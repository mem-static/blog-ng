{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/algorithm/rotational-symmetry/","result":{"data":{"markdownRemark":{"html":"<p>五边形数生成函数即欧拉函数：</p>\n<p>$$\n\\varphi(x) = \\prod_{n=1}^\\infty (1 - x^n)\n$$</p>\n<!--more-->\n<h2>推导</h2>\n<p>五边形数定理用来描述欧拉函数展开式的特性：</p>\n<p>$$\n\\varphi(x) = \\sum_{k=-\\infty}^{\\infty} (-1)^k x^{\\frac {k(3k+1)} 2} = \\sum_{k=0}^{\\infty} (-1)^k x^{\\frac {k(3k \\pm 1)} 2}\n$$</p>\n<p>欧拉函数的倒数是划分数的生成函数：</p>\n<p>$$\n\\frac 1 {\\varphi(x)} = \\sum_{i=0}^\\infty p(i) x^i = \\prod_{i=0}^\\infty \\sum_{j=0}^\\infty x^{ij} = \\prod_{i=0}^\\infty \\frac 1 {1 - x^i}\n$$</p>\n<!--more-->\n<p>由定义我们可以得到：</p>\n<p>$$\n\\varphi(x) \\times \\frac 1 {\\varphi(x)} = 1 \\Leftrightarrow\n\\left( \\sum_{k=0}^{\\infty} (-1)^k x^{\\frac {k(3k \\pm 1)} 2} \\right) \\left( \\sum_{i=0}^\\infty p(i) x^i \\right) = 1\n$$</p>\n<p>通过这个我们可以得到划分数的递推式。</p>\n<p>同时发现五边形数生成函数的项数是 $O(\\sqrt n)$ 级别的，故我们可以在 $O(n \\sqrt n)$ 的时间复杂度内求出划分数前 $n$ 项。</p>\n<p>我们也可以通过这种方法求有限制时的划分数：现在限制划分的每个数的大小小于 $k$，则有</p>\n<p>$$\nF(x) = \\prod_{i=0}^\\infty \\sum_{j=0}^{k-1} x^{ij} = \\prod_{i=1}^\\infty \\frac {1-x^{ik}} {1 - x^i} = \\frac {\\varphi(x^k)} {\\varphi(x)}\n$$</p>\n<p>则</p>\n<p>$$\nF(x) = \\varphi(x^k) \\times P(x)\n$$</p>\n<p>在先求出划分数的生成函数之后，我们同样可以在 $O(\\sqrt n)$ 的时间复杂度内求出 $F(x)$ 的单项。</p>\n<h2>例题</h2>\n<h4>HDU4651</h4>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\nconst int N=1e5+10,mod=1e9+7;\nint T,n,m,f[N],g[N];\nint main(){\n\tf[0]=1;\n\tfor(int i=1;i*(3*i-1)/2&#x3C;=100000;i++)g[m++]=i*(3*i-1)/2,g[m++]=i*(3*i+1)/2;\n\tfor(int n=1;n&#x3C;=100000;n++)for(int j=0;j&#x3C;m&#x26;&#x26;g[j]&#x3C;=n;j++)f[n]=(f[n]+(((j>>1)&#x26;1)?mod-1ll:1ll)*f[n-g[j]])%mod;\n\tfor(scanf(\"%d\",&#x26;T);T--;)scanf(\"%d\",&#x26;n),printf(\"%d\\n\",f[n]);\n}\n</code></pre>\n<h4>HDU4658</h4>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\nconst int N=5e5+10,mod=1e9+7;\nint T,n,m,k,res,f[N],g[N];\nint main(){\n\tf[0]=1;\n\tfor(int k=1;k*(3*k-1)/2&#x3C;=100000;k++)g[m++]=k*(3*k-1)/2,g[m++]=k*(3*k+1)/2;\n\tfor(int i=1;i&#x3C;=100000;i++)for(int j=0;j&#x3C;m&#x26;&#x26;g[j]&#x3C;=i;j++)f[i]=(f[i]+f[i-g[j]]*((j>>1)&#x26;1?mod-1ll:1ll))%mod;\n\tfor(scanf(\"%d\",&#x26;T);T--;){\n\t\tscanf(\"%d%d\",&#x26;n,&#x26;k),res=f[n];\n\t\tfor(int i=0;i&#x3C;m&#x26;&#x26;g[i]*k&#x3C;=n;i++)res=(res+f[n-g[i]*k]*((i>>1)&#x26;1?1ll:mod-1ll))%mod;\n\t\tprintf(\"%d\\n\",res);\n\t}\n}\n</code></pre>\n<h4>证明</h4>\n<p>欧拉函数展开式的证明：<a href=\"https://blog.csdn.net/visit_world/article/details/52734860\">https://blog.csdn.net/visit_world/article/details/52734860</a></p>","frontmatter":{"date":"December 26, 2019","title":"五边形数定理学习笔记","cover":"/cover/59.jpg"}}},"pageContext":{"id":"46ab16e1-0b50-5e75-901f-7c9937579524","slug":"blog/algorithm/rotational-symmetry"}},"staticQueryHashes":[],"slicesMap":{}}