{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/algorithm/sqrt-structures-review/","result":{"data":{"markdownRemark":{"html":"<p>分块，可以看做一个度数为 $\\sqrt n$，只有三层的树。</p>\n<p><img src=\"https://static.memset0.cn/img/v4/2021/09/23/sxC2OuHu.png\" alt=\"\"></p>\n<p>所以如果在分治结构上很难快速合并某些信息，我们就可以利用分块来做。</p>\n<!--more-->\n<style>\nb, strong, .mark { background: yellow; }\n</style>\n<h2>动态分块</h2>\n<h4>0x01 经典问题</h4>\n<p>维护一个序列，支持：1.区间加；2.查询区间小于 $x$ 的数个数。</p>\n<blockquote>\n<p>块大小为 $\\sqrt {n \\log n}$ 分块，可以做到 $O(m \\sqrt {n \\log n})$ 的复杂度。</p>\n</blockquote>\n<h4>0x02 [Ynoi2017]舌尖上的由乃</h4>\n<p>维护一个序列，支持：1.区间加；2.查询区间第 $k$ 小。</p>\n<blockquote>\n<p>显然需要二分。块大小设置为 $\\sqrt n \\log n$，<strong>二分开始前把两个零散块拼起来</strong>。时间复杂度 $O(m \\sqrt n \\log n)$</p>\n</blockquote>\n<h2>用根号平衡来优化数据结构复杂度</h2>\n<h4>0x01</h4>\n<p>维护一个序列，支持：1. $O(1)$ 单点修改；2. $O(\\sqrt n)$ 区间和。</p>\n<blockquote>\n<p>修改</p>\n<p><img src=\"https://i.loli.net/2020/02/24/rhquwRZe5MzmdLc.png\" alt=\"\"></p>\n<p>查询</p>\n<p><img src=\"https://i.loli.net/2020/02/24/aqGeOLtBkwfiCDc.png\" alt=\"\"></p>\n</blockquote>\n<h4>0x02</h4>\n<p>维护一个序列，支持：1. $O(\\sqrt n)$ 单点修改；2. $O(1)$ 区间和。</p>\n<blockquote>\n<p>维护前缀和。</p>\n<p>修改</p>\n<p><img src=\"https://i.loli.net/2020/02/24/hKDtvngWPi7lJsA.png\" alt=\"\"></p>\n<p>查询</p>\n<p><img src=\"https://i.loli.net/2020/02/24/M9I1jlKe5DNqE7o.png\" alt=\"\"></p>\n</blockquote>\n<h4>0x03</h4>\n<p>维护一个序列，支持：1. $O(\\sqrt n)$ 区间加；2. $O(1)$ 查单点。</p>\n<blockquote>\n<p>修改</p>\n<p><img src=\"https://i.loli.net/2020/02/24/YiVCJ6aS2A8X9te.png\" alt=\"\"></p>\n<p>查询</p>\n<p><img src=\"https://i.loli.net/2020/02/24/M9I1jlKe5DNqE7o.png\" alt=\"\"></p>\n</blockquote>\n<h4>0x04</h4>\n<p>维护一个序列，支持：1. $O(1)$ 区间加；2. $O(\\sqrt n)$ 查单点。</p>\n<blockquote>\n<p>差分。</p>\n<p>修改</p>\n<p><img src=\"https://i.loli.net/2020/02/24/JBAcSzR8wQ4teoW.png\" alt=\"\"></p>\n<p>查询</p>\n<p><img src=\"https://i.loli.net/2020/02/24/kQnRVMio3LDJ861.png\" alt=\"\"></p>\n</blockquote>\n<h4>0x05</h4>\n<p>维护一个集合，支持：1. $O(1)$ 插入一个数；2. $O(\\sqrt n)$ 查询第 $k$ 小。值域与 $n$ 同阶。</p>\n<blockquote>\n<p>修改</p>\n<p><img src=\"https://i.loli.net/2020/02/24/JBAcSzR8wQ4teoW.png\" alt=\"\"></p>\n<p>查询：最多跨过 $\\sqrt n$ 个整块和 $\\sqrt n$ 个零散的数。</p>\n<p><img src=\"https://i.loli.net/2020/02/24/kQnRVMio3LDJ861.png\" alt=\"\"></p>\n</blockquote>\n<h4>0x06</h4>\n<p>维护一个集合，支持：1. $O(\\sqrt n)$ 插入一个数；2. $O(1)$ 查询第 $k$ 小。值域与 $n$ 同阶。</p>\n<blockquote>\n<p>直接维护一下整个队列，把整个队列分块。</p>\n<p>插入一个数的时候重构一下对应的队列，如果队列超了就把最后的数丟到下一个块。</p>\n<p>修改</p>\n<p><img src=\"https://i.loli.net/2020/02/24/GiYwCe9F8tDnLH6.png\" alt=\"\"></p>\n<p>查询</p>\n<p><img src=\"https://i.loli.net/2020/02/24/vjLlfaRdEGDXOeF.png\" alt=\"\"></p>\n</blockquote>\n<h4>0x07 CodeChef Chef and Churu</h4>\n<p>给 $n$ 个数，给定 $m$ 函数，每个函数为序列中第 $l_i$ 到第 $r_i$ 个数的和。有 $q$ 个两种类型的操作：</p>\n<ol>\n<li><code>1 x y</code> 把序列中第 $x$ 个数改成 $y$</li>\n<li><code>2 x y</code> 求第 $x$ 个函数到第 $y$ 个函数的和</li>\n</ol>\n<blockquote>\n<p>把 $m$ 个函数分块。整块的可以直接维护，零散块用一个 $O(\\sqrt n)$ 修改，$O(1)$ 查询的分块维护。</p>\n</blockquote>\n<h2>简单莫队算法</h2>\n<h4>常见优化</h4>\n<ul>\n<li><strong>奇偶块排序</strong>，可以快一倍左右。</li>\n<li>调整块大小 $\\left( n / \\sqrt { 2m / 3 } \\right)$ 可以快 $10%$ 左右。</li>\n</ul>\n<h4>0x01 [AHOI2013]作业</h4>\n<p>给定序列，支持查询区间 $[l,r]$ 中值在 $[a,b]$ 内的不同数个数。</p>\n<p>$n \\leq 10^5,\\ m \\leq 10^6$。</p>\n<blockquote>\n<p>序列离散化，跑一个莫队。拉一个 $O(1)$ 插入，$O(\\sqrt n)$ 求和的分块即可。时间复杂度 $O(m \\sqrt n)$。</p>\n<p>另外显然有 polylog 做法（话说我第一反应也是 polylog（（（</p>\n</blockquote>\n<h4>0x02 [Ynoi2016]这是我自己的发明</h4>\n<p>给一个树，有点权，初始根是 $1$。支持：</p>\n<ul>\n<li><code>1 x</code>：将树根换为 $x$</li>\n<li><code>2 x y</code>：从 $x$ 的子树中选每一个点，$y$ 的子树中选每一个点，如果两个点点权相等则<code>ans++</code>，求 $ans$。</li>\n</ul>\n<blockquote>\n<p>考虑把树上换根问子树转化到序列上。每次询问有四个参数不好维护，可以<strong>差分成四个询问每次两个参数</strong>：</p>\n<p>$$\nF(l_1,r_1,l_2,r_2)=F(1,r_1,1,r_2)-F(1,l_1-1,1,r_2)-F(1,r_1,1,l2-1)+F(1,l_1-1,1,l2-1)\n$$</p>\n<p>注意这里询问次数可能会比较多，可以<strong>考虑基数排序询问</strong>。时间复杂度 $O(n \\sqrt m + m)$。</p>\n</blockquote>\n<h4>0x03 BZOJ3920 Yunna的礼物</h4>\n<p>给定序列，支持查询区间中出现次数 $k_1$ 小的数里面的 $k_2$ 小的数。卡空间。</p>\n<blockquote>\n<p>考虑一种高维离散化技巧，以出现次数为第一关键字，数值为第二关键字排序，仍是 $O(n)$ 项的。</p>\n<p>然后一边跑一个莫队，用一个 $O(1)$ 修改，$O(\\sqrt n)$ 查询值域分块来维护就好。</p>\n<p>时间复杂度 $O(m \\sqrt n)$。</p>\n</blockquote>\n<h4>0x04 BZOJ4241 历史研究</h4>\n<p>给定序列，定义 $\\operatorname{Chtholly}(l,r,x)$ 为 $x$ 在区间 $[l,r]$ 中出现次数，支持查询一个区间中最大的 $x \\times \\operatorname{Chtholly}(l,r,x)$。</p>\n<blockquote>\n<p>用上一题的方法离散化后莫队维护即可。时间复杂度 $O(m \\sqrt n)$。</p>\n</blockquote>\n<h4>0x04 [Ynoi2015]纵使日薄西山</h4>\n<p>给定序列，定义区间 $[l,r]$ 的贡献为其每一个子序列贡献和；定义子序列 $\\alpha$ 的贡献为 $\\alpha$ 内的元素去重后的和。支持查询区间贡献。</p>\n<blockquote>\n<p>考虑数 $x$ 在长度为 $l$ 的区间中出现了 $y$ 次，贡献为：</p>\n<p>$$\nx \\times 2^{l - y} \\times (2^{y} - 1) = x (2 ^ l - 2 ^ {l - y})\n$$</p>\n<p>可以分成两部分计算。第一部分是好维护的，第二部分可以把 $y$ 相同的放在一起计算。<strong>其中 $y$ 不同的至多只有 $O(\\sqrt l)$ 个</strong>。</p>\n<p><strong>为了 $O(1)$ 算出快速幂，我们可以预处理出 $2^{1}, 2^2 , ... , 2^{\\sqrt n}$ 和 $2^{\\sqrt n} , 2^{2 \\sqrt n} , ... , 2^{\\sqrt n \\sqrt n}$。（类似分块打表的思想）</strong></p>\n</blockquote>\n<h4>0x05 [HNOI2016]大数</h4>\n<p>给定一个数字串和质数 $p$，支持查询这个数字串的一个子串里有多少个子串是 $p$ 的倍数。</p>\n<blockquote>\n<p>首先处理掉 $p=2$ 或 $p=5$ 的情况。然后考虑子串 $[l,r]$ 是 $p$ 的倍数当且仅当 $s_{l-1} \\equiv s_{r} \\pmod p$。</p>\n<p>离散化后等价于小 Z 的袜子。</p>\n</blockquote>\n<h4>0x06 区间逆序对</h4>\n<p>给定序列，支持查询区间逆序对个数。</p>\n<blockquote>\n<p><em>Solution 1</em></p>\n<p><strong>把值域分块的结构可持久化（lxl 称为可持久化块状树）</strong>，插入+可持久化的复杂度 $O(\\sqrt n)$，查询的复杂度 $O(1)$。</p>\n<p>结合经典的莫队做法可以做到 $O(n \\sqrt m)$ 的时间复杂度和 $O(n \\sqrt n)$ 的空间复杂度。</p>\n<p><em>Solution 2</em></p>\n<p><strong>莫队二次离线：</strong><br>\n<strong>将莫队当做是 $O( n \\sqrt m )$ 次查询区间中满足特定特征的性质的数的某个信息。</strong><br>\n<strong>如果这个信息具有可减性，可以差分。</strong><br>\n<strong>考虑差分后变成 $O( n \\sqrt m )$ 次查询前缀中满足特定特征的性质的数的某个信息。</strong></p>\n<p>一个暴力的维护方式是：</p>\n<p>每次我们从 $[l,r]$ 转移到 $[l,r-1]$ 或 $[l,r+1]$ 或 $[l-1,r]$ 或 $[l+1,r]$ 的时候，假设要求的是区间小于 $z$ 的数的个数。<br>\n那么就差分一下，在 $l-1$ 处打上标记 $(x,-z)$，在 $r$ 处打上标记 $(x,z)$。</p>\n<p>然后扫一遍，用值域分块维护就可以 $O(1)$ 知道每次转移的贡献了。</p>\n<p>时间复杂度 $O(n \\sqrt m)$，空间复杂度 $O(\\sqrt m)$（自带两倍常数）。</p>\n<p>由于空间常数巨大，寻址不连续，这是一个空间和时间都消耗巨大的算法。我们考虑从空间入手优化。</p>\n</blockquote>\n<h2>致谢</h2>\n<p>nzhtl1477 的讲课。</p>","frontmatter":{"date":"February 24, 2020","title":"根号数据结构复习","cover":"/cover/60.jpg"}}},"pageContext":{"id":"571ed137-4ea4-56cd-bb89-a95e584e8ac9","slug":"blog/algorithm/sqrt-structures-review"}},"staticQueryHashes":[],"slicesMap":{}}