{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/contest/20200429c/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>给定 $p,A,B,C,D$，求 $x,y$ 满足 $C^x \\equiv D^y \\pmod x$，并最小化 $Ax + By$。</p>\n<p>$6000$ 组询问，$0 \\leq A,B,C,D,p \\leq 10^9$，保证 $p$ 是质数。</p>\n</blockquote>\n<!--more-->\n<h2>题解（个人做法）</h2>\n<p>因为 $p$ 是质数，我们求出其原根 $g$，故</p>\n<p>$$\nC^x \\equiv D^y (\\bmod\\ p) \\Leftrightarrow{} g^{cx} \\equiv g^{dy} (\\bmod\\ p) \\Leftrightarrow{} cx \\equiv dy (\\bmod\\ \\varphi(p))\n$$</p>\n<p>假设</p>\n<p>$$\nf(x,p,A,B) = \\min { A(ix \\bmod p) + Bi \\mid i }\n$$</p>\n<p>我们转化为了一个稍微好计算一点的问题：$f(d \\cdot c^{-1}, p-1, A, B)$。</p>\n<p>当然，可能存在 $c$ 模 $\\varphi(p) = p-1$ 没有逆元的情况，我们需要做一点处理：</p>\n<pre><code class=\"language-py\"># c x \\equiv d y \\pmod p\ng = gcd(c, d, p)\nc /= g; d /= g; p /= g\ncg = gcd(c, p); c /= cg; b *= cg\ndg = gcd(d, p); d /= dg; a *= dg\np /= cg * dg\n</code></pre>\n<p>考虑如何计算 $f$，采用类似欧几里得的思想。</p>\n<p>$$\nf(x,p,A,B) = \\begin{cases}\n\\small\\text{直接 }O(1)\\small\\text{ 计算} &#x26; (x = 0) \\\nf(x / \\gcd(x,p), p / \\gcd(x,p), A \\gcd(x,p), B) &#x26; (x \\not\\perp p) \\\nf(x \\bmod p, p, A, B) &#x26; (x \\geq p) \\\nf(q, x, \\frac {Ap} x, \\frac {Ax + B} x) &#x26; \\text{otherwise} \\\n\\end{cases}\n$$</p>\n<p>假设 $i = \\tfrac {kp + b} x$，其中 $x \\mid kp + b$。由于 $x \\perp p$，故确定 $b$ 后就能唯一确定 $k$。</p>\n<p>实际上 $k$ 满足：</p>\n<p>$$\n\\begin{aligned}\nkp + b &#x26;\\equiv 0 &#x26; \\pmod x \\\nk &#x26;\\equiv b \\cdot (-p^{-1}) &#x26; \\pmod x \\\n\\end{aligned}\n$$</p>\n<p>令 $q \\equiv -p^{-1} \\pmod x$，那么原式可以化为：</p>\n<p>$$\n\\begin{aligned}\nf(x,p,A,B)\n&#x26;= \\min{ A(ix \\bmod p) + Bi \\mid i } \\\n&#x26;= \\min{ A((kp + b) \\bmod p) + B \\cdot \\tfrac {kp + b} x \\mid i } \\\n&#x26;= \\min{ Ab + B \\cdot \\tfrac {(pq \\bmod p) \\cdot p + b} {x} \\mid i } \\\n&#x26;= f(q, x, \\tfrac {Bp} {x}, \\tfrac {Ax + B} {x}) \\\n\\end{aligned}\n$$</p>\n<p>感性理解了一下逆元的分布应该是比较随机的，感觉复杂度应该是 $O(\\log n)$。</p>\n<h2>题解（标答做法）</h2>\n<p>类欧几里得推导，设：</p>\n<p>$$\ng(a,b,c,d,e,f) = \\min_i \\left( a + b i + c \\left\\lfloor \\frac {di + e} {f} \\right\\rfloor \\right)\n$$</p>\n<p>若 $d \\geq f$，假设 $d = gf + h$，则</p>\n<p>$$\n\\begin{aligned}\ng(a,b,c,d,e,f)\n&#x26;= \\min_i \\left( a + bi + c \\left\\lfloor \\frac {(gf + h) i + e} {f} \\right\\rfloor \\right) \\\n&#x26;= \\min_i \\left( a + (b+cg) i + c \\left\\lfloor \\frac {hi + e} {f} \\right\\rfloor \\right) \\\n&#x26;= g(a, b + cg, c, h, e, f) \\\n&#x26;= g(a, b + c \\lfloor d/f \\rfloor, c, d \\bmod f, e, f) \\\n\\end{aligned}\n$$</p>\n<p>若 $d &#x3C; f$，则</p>\n<p>$$\n\\begin{aligned}\ng(a,b,c,d,e,f)\n&#x26;= \\min_j \\min_i \\left( a + bi + c j \\left[ \\left\\lfloor \\frac {di + e} {f} \\right\\rfloor  \\geq j\\right] \\right) \\\n\\end{aligned}\n$$</p>\n<p>其中</p>\n<p>$$\n\\begin{aligned}\n\\left[ \\left\\lfloor \\frac {di + e} {f} \\right\\rfloor \\geq j\\right]\n&#x26;= \\left[ \\frac {di + e} {f} \\geq j \\right] \\\n&#x26;= \\left[ i \\geq \\frac {jf - e} {d} \\right] \\\n&#x26;= \\left[ i > \\frac {jf - e - 1} {d} \\right] \\\n&#x26;= \\left[ i > \\left\\lfloor \\frac {jf - e - 1} {d} \\right\\rfloor \\right] \\\n\\end{aligned}\n$$</p>\n<p>因为我们要求最小化，不妨直接令 $\\displaystyle i = \\left\\lfloor \\frac {jf - e - 1} {d} \\right\\rfloor +1$</p>\n<p>故</p>\n<p>$$\n\\begin{aligned}\ng(a,b,c,d,e,f)\n&#x26;= \\min_j \\left( a + b \\left( \\left\\lfloor \\frac {jf - e - 1} {d} \\right\\rfloor +1 \\right) + cj \\right) \\\n&#x26;= g(a+b,c,b,f,-e-1,d) \\\n\\end{aligned}\n$$</p>\n<p>其实 $c$ 是不需要存的，但是式子都推好了就懒得改了。</p>\n<p>另外还要存一下枚举的上下界，一层递归是 $7$ 个参数。</p>\n<h2>细节</h2>\n<h4>0x01</h4>\n<p>特判 $p = 2$ 的情况。</p>\n<h4>0x02</h4>\n<p>$$\nka \\equiv kb \\pmod p\n$$</p>\n<p>两边能同时除以 $k$ 当且仅当</p>\n<ol>\n<li>$k \\perp p$，转化为 $a \\equiv b \\pmod p$</li>\n<li>$k \\mid p$，转化为 $a \\equiv b \\pmod {(p/k)}$</li>\n</ol>","frontmatter":{"date":"April 29, 2020","title":"「校内模拟20200429C」游戏达人","cover":"/cover/26.webp"}}},"pageContext":{"id":"f093c275-4502-58aa-9672-e0b3c09b99bf","slug":"blog/contest/20200429c"}},"staticQueryHashes":[],"slicesMap":{}}