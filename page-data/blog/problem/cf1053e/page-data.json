{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/cf1053e/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>给定一棵树的欧拉序，其中被若干位被删除。你可以在被删除的位置填数，要求构造任何一个合法的欧拉序。</p>\n<p>$n \\leq 5 \\times 10^5, |S| = 2n - 1$。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<h3>主体思路</h3>\n<p>我们可以分治，$\\operatorname{solve}(l, r)$ 表示解决 $l$ 到 $r$ 这段区间其中 $a_l = a_r$。</p>\n<p>首先如果 $a_{(l + 1) \\cdots (r - 1)}$ 中有何 $a_l$ 相等的数，那么可以继续分治，否则的话中间没有和 $a_l$ 相等的数。</p>\n<p>对于所有满足 $l &#x3C; p &#x3C; q &#x3C; r \\text{ and } a_p = a_q$，也可以递归，递归完后删除掉除了这段区间的根节点的点。这样的话 $a_{(l + 1) \\cdots (r - 1)}$ 除 $0$ 外互不相同。</p>\n<p>接下来考虑对于所有 $x, y, 0$ 或 $0, y, x$ 的，可以直接把空格处填成 $x$，然后缩掉。这样的话只会剩下连续的 $0$。</p>\n<p>对于连续的 $0$，依次补过去，每补上一个，如果存在 $x, y, 0$ 或 $0, y, x$ 就继续缩掉。</p>\n<p>最后只剩下一个点，也就完成了递归。</p>\n<h3>对无解的判断</h3>\n<ol>\n<li>没有足够的点用来放</li>\n<li>$a_1 \\neq a_n$</li>\n<li>对于 $\\operatorname{solve}(l, r)$，$r - l + 1$ 是 $2$ 的倍数</li>\n<li>对于 $\\operatorname{solve}(l, r)$，递归完后 $0$ 的个数小于非 $0$ 个数 $-1$</li>\n<li>存在 $p &#x3C; q &#x3C; r &#x3C; s$ 满足 $a_p = a_r \\text{ and } a_q = a_s \\text{ and } a_p \\neq a_q \\text{ and } a_r \\neq a_s$</li>\n</ol>\n<h3>对于 $a_1, a_{2n - 1}$ 的特殊处理</h3>\n<ol>\n<li>如果 $a_1 \\neq 0 \\text{ and } a_{2n-1} \\neq 0 \\text{ and } a_1 \\neq a_{2n-1}$，那么无解</li>\n<li>如果 $(a_1 = 0 \\text{ and } a_{2n-1} \\neq 0) \\text{ or } (a_1 \\neq 0 \\text{ and } a_{2n-1} = 0)$，那么 $a_1 = a_{2n-1} = \\max(a_1, a_{2n-1})$ 即可</li>\n<li>如果 $a_1 = a_{2n-1} = 0$ 那么需要给 $a_1, a_{2n-1}$ 分配一个标号。先枚举检查有没有可以从中间选出的可能，如果没有，就新分配一个点</li>\n</ol>\n<h3>对于递归的复杂度保证</h3>\n<p>直接实现的可能会超时，我把相同值的下标存到一起，然后根据「CTSC2018 青蕈领主」的方式建树，先把区间内与根节点不同色的递归处理掉，再来处理根节点同色的。</p>\n<h3>对于扫描形如 $x, y, 0$ 和 $y, x, 0$ 的复杂度保证</h3>\n<p>可以开一个栈暴力扫过去，用类似括号匹配的方式处理，这里不多讲。</p>\n<p>需要注意的是，我的实现是先把已有的 $x, y, 0$ 和 $y, x, 0$ 填掉，不然有可能不是最优方案。</p>\n<p>然后两端同时扫描，如果没有可以直接填的，但给两端中的 $0$ 的点分配标号可以配对的话，就分配掉。如果都没有，随便一端填个数即可。</p>\n<h3>复杂度证明</h3>\n<p>一个数只会在某一层被处理掉，对那一层的复杂度贡献是 $\\mathcal O(1)$ 的，所以这一部分的时间复杂度为 $\\mathcal O(n)$。</p>\n<p>由于需要判断无解等等情况，可以写一个支持区间查询最大值 / 最小值的线段树 / ST 表，时间复杂度 $\\mathcal O(n \\log n)$，其中 ST 表的空间复杂度为 $\\mathcal O(n \\log n)$，可能会导致 $\\text{MLE}$。</p>\n<p>综上，时间复杂度 $\\mathcal O(n \\log n)$，空间复杂度 $\\mathcal O(n)$，可以通过本题。</p>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">// =================================\n//   author: memset0\n//   date: 2019.05.08 21:39:49\n//   website: https://memset0.cn/\n// =================================\n#include &#x3C;bits/stdc++.h>\n#define ll long long\n#define debug(...) ((void)0)\n#ifndef debug\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#endif\nnamespace ringo {\ntemplate &#x3C;class T> inline void read(T &#x26;x) {\n\tx = 0; register char c = getchar(); register bool f = 0;\n\twhile (!isdigit(c)) f ^= c == '-', c = getchar();\n\twhile (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n\tif (f) x = -x;\n}\ntemplate &#x3C;class T> inline void print(T x) {\n\tif (x &#x3C; 0) putchar('-'), x = -x;\n\tif (x > 9) print(x / 10);\n\tputchar('0' + x % 10);\n}\ntemplate &#x3C;class T> inline void print(T x, char c) { print(x), putchar(c); }\ntemplate &#x3C;class T> inline void print(T a, int l, int r, std::string s = \"\") {\n\tif (s != \"\") std::cout &#x3C;&#x3C; s &#x3C;&#x3C; \": \";\n\tfor (int i = l; i &#x3C;= r; i++) print(a[i], \" \\n\"[i == r]);\n}\n\nconst int N = 1e6 + 10, L = 21;\nint n, m;\nint a[N], del[N], use[N], log[N];\nstd::vector&#x3C;int> v[N], G[N];\n\nstruct info {\n\tint val, id;\n\tinline info() {}\n\tinline info(int k) { val = a[k], id = k; }\n\tinline info(int a, int b) { val = a, id = b; }\n};\nstd::vector&#x3C;info> s, h, t, bkt[N];\nstd::priority_queue&#x3C;int, std::vector&#x3C;int>, std::greater&#x3C;int>> q;\n\nvoid noSolution() { puts(\"no\"), exit(0); }\n\nstruct minimax {\n\tint min, max;\n\tinline minimax operator^(const minimax &#x26;other) const {\n\t\treturn {std::min(min, other.min), std::max(max, other.max)};\n\t}\n};\n\nnamespace seg {\n\tminimax b[N];\n\tstruct node {\n\t\tint l, r, mid;\n\t\tminimax x;\n\t} p[N &#x3C;&#x3C; 2];\n\tvoid build(int u, int l, int r) {\n\t\tp[u].l = l, p[u].r = r, p[u].mid = (l + r) >> 1;\n\t\tif (l == r) { p[u].x = b[l]; return; }\n\t\tbuild(u &#x3C;&#x3C; 1, l, p[u].mid);\n\t\tbuild(u &#x3C;&#x3C; 1 | 1, p[u].mid + 1, r);\n\t\tp[u].x = p[u &#x3C;&#x3C; 1].x ^ p[u &#x3C;&#x3C; 1 | 1].x;\n\t}\n\tminimax query(int u, int l, int r) {\n\t\tif (p[u].l == l &#x26;&#x26; p[u].r == r) return p[u].x;\n\t\tif (r &#x3C;= p[u].mid) return query(u &#x3C;&#x3C; 1, l, r);\n\t\telse if (l > p[u].mid) return query(u &#x3C;&#x3C; 1 | 1, l, r);\n\t\telse return query(u &#x3C;&#x3C; 1, l, p[u].mid) ^ query(u &#x3C;&#x3C; 1 | 1, p[u].mid + 1, r);\n\t}\n\tvoid init() {\n\t\tstatic int tmp[N];\n\t\tmemset(tmp, 0, sizeof tmp);\n\t\tfor (int i = 1; i &#x3C;= m; i++) if (a[i]) {\n\t\t\tif (!tmp[a[i]]) tmp[a[i]] = i;\n\t\t\tb[i].min = tmp[a[i]];\n\t\t} else {\n\t\t\tb[i].min = i;\n\t\t}\n\t\tmemset(tmp, 0, sizeof tmp);\n\t\tfor (int i = m; i >= 1; i--) if (a[i]) {\n\t\t\tif (!tmp[a[i]]) tmp[a[i]] = i;\n\t\t\tb[i].max = tmp[a[i]];\n\t\t} else {\n\t\t\tb[i].max = i;\n\t\t}\n\t\tbuild(1, 1, m);\n\t}\n\tminimax query(int l, int r) { return query(1, l, r); }\n}\nusing namespace seg;\n\ninline bool possible(int l, int r) {\n\tif (!((r - l + 1) &#x26; 1)) return false;\n\tif (l + 1 > r - 1) return true;\n\tauto it = query(l + 1, r - 1);\n\treturn it.max &#x3C;= r &#x26;&#x26; it.min >= l;\n}\n\ninline int newNode() {\n\tstatic int cur = 1;\n\twhile (use[cur]) cur++;\n\tif (cur > n) std::cerr &#x3C;&#x3C; \"[No enougth nodes] No solution.\\n\", noSolution();\n\treturn use[cur] = 1, cur;\n}\n\nvoid solve(int x) {\n\tstd::vector&#x3C;std::pair&#x3C;int, int>> jump;\n\tfor (auto y : G[x]) {\n\t\tsolve(y);\n\t\tjump.push_back(std::make_pair(*v[y].begin(), *--v[y].end()));\n\t}\n\tstd::reverse(jump.begin(), jump.end());\n\tfor (int i = 0, L, R, at = 0; i + 1 &#x3C; v[x].size(); i++) {\n\t\tL = v[x][i], R = v[x][i + 1];\n\t\tif (!((R - L + 1) &#x26; 1)) noSolution(); // 要求每个这样的区间为奇数\n\t\ts.clear(), s.push_back(info(L));\n\t\tfor (int i = L + 1; i &#x3C;= R - 1; i++) {\n\t\t\ts.push_back(info(i));\n\t\t\tif (at &#x3C; jump.size() &#x26;&#x26; i == jump[at].first) i = jump[at++].second;\n\t\t}\n\t\ts.push_back(info(R));\n\n\t\tint c0 = 0, c1 = 0;\n\t\tfor (int i = 1; i + 1 &#x3C; s.size(); i++)\n\t\t\ts[i].val ? ++c1 : ++c0;\n\t\tif (c0 &#x3C; c1 - 1) noSolution();\n\n\t\tint tl = 0, tr = s.size() - 1;\n\t\twhile (tl &#x3C; s.size() &#x26;&#x26; s[tl].val) tl++;\n\t\twhile (tr >= 0 &#x26;&#x26; s[tr].val) tr--;\n\t\tif (tl == s.size()) continue;\n\t\tfor (int i = tl; i &#x3C;= tr; i++)\n\t\t\tif (s[i].val) {\n\t\t\t\tif (t.size() >= 2 &#x26;&#x26; (--t.end())->val &#x26;&#x26; !(----t.end())->val) {\n\t\t\t\t\ta[(----t.end())->id] = s[i].val;\n\t\t\t\t\tdel[(----t.end())->id] = del[(--t.end())->id] = 1;\n\t\t\t\t\tt.pop_back(), t.pop_back(), t.push_back(s[i]);\n\t\t\t\t} else {\n\t\t\t\t\tt.push_back(s[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (t.size() >= 2 &#x26;&#x26; (--t.end())->val &#x26;&#x26; (----t.end())->val) {\n\t\t\t\t\ta[s[i].id] = (----t.end())->val;\n\t\t\t\t\tdel[s[i].id] = del[(--t.end())->id] = 1;\n\t\t\t\t\tt.pop_back();\n\t\t\t\t} else {\n\t\t\t\t\tt.push_back(s[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\tt.clear(), std::swap(t, s);\n\t\tfor (int i = 0; i &#x3C; t.size(); i++)\n\t\t\tif (del[t[i].id]) del[t[i].id] = false;\n\t\t\telse s.push_back(t[i]);\n\t\tt.clear();\n\n\t\tfor (int i = 0, j = s.size() - 1; i &#x3C;= j; ) {\n\t\t\tif (s[i].val) {\n\t\t\t\th.push_back(s[i++]);\n\t\t\t} else if (s[j].val) {\n\t\t\t\tt.push_back(s[j--]);\n\t\t\t} else {\n\t\t\t\tif (h.size() >= 2) {\n\t\t\t\t\ta[s[i].id] = s[i].val = (----h.end())->val;\n\t\t\t\t\th.pop_back(), i++;\n\t\t\t\t} else if (t.size() >= 2) {\n\t\t\t\t\ta[s[j].id] = s[j].val = (----t.end())->val;\n\t\t\t\t\tt.pop_back(), j--;\n\t\t\t\t} else {\n\t\t\t\t\ta[s[i].id] = s[i].val = newNode();\n\t\t\t\t\th.push_back(s[i++]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\th.clear(), t.clear(), s.clear();\n\t}\n}\n\nvoid main() {\n\tread(n), m = (n &#x3C;&#x3C; 1) - 1, log[0] = -1;\n\tfor (int i = 1; i &#x3C;= m; i++) log[i] = log[i >> 1] + 1;\n\tfor (int i = 1; i &#x3C;= m; i++) {\n\t\tread(a[i]);\n\t\tif (a[i]) use[a[i]] = 1;\n\t}\n\tif (a[1] &#x26;&#x26; a[m] &#x26;&#x26; a[1] != a[m]) noSolution();\n\telse if (!a[1] &#x26;&#x26; !a[m]) {\n\t\tinit();\n\t\tint any = 0;\n\t\tfor (int i = 3; i &#x3C;= m - 2; i++) {\n\t\t\tif (a[i] &#x26;&#x26; a[i] != a[2] &#x26;&#x26; a[i] != a[m - 1] &#x26;&#x26; possible(1, i) &#x26;&#x26; possible(i, m))\n\t\t\t\tany = std::max(any, a[i]);\n\t\t}\n\t\tstd::cerr &#x3C;&#x3C; \"any = \" &#x3C;&#x3C; any &#x3C;&#x3C; std::endl;\n\t\ta[1] = a[m] = any ? any : newNode();\n\t} else a[1] = a[m] = a[1] | a[m];\n\tinit();\n\tfor (int i = 1; i &#x3C;= m; i++) if (a[i]) v[a[i]].push_back(i);\n\tfor (int i = 1; i &#x3C;= n; i++) if (v[i].size() > 1) {\n\t\tfor (int j = 0; j + 1 &#x3C; v[i].size(); j++)\n\t\t\tif (!possible(v[i][j], v[i][j + 1])) {\n\t\t\t\tstd::cerr &#x3C;&#x3C; \"[Impossible section] \" &#x3C;&#x3C; v[i][j] &#x3C;&#x3C; \" \" &#x3C;&#x3C; v[i][j + 1] &#x3C;&#x3C; std::endl;\n\t\t\t\tnoSolution();\n\t\t\t}\n\t\tbkt[*--v[i].end()].push_back({*v[i].begin(), i});\n\t}\n\tfor (int i = 1; i &#x3C;= m; i++) {\n\t\tfor (auto it : bkt[i]) {\n\t\t\twhile (s.size() &#x26;&#x26; (--s.end())->val >= it.val) {\n\t\t\t\tG[it.id].push_back((--s.end())->id);\n\t\t\t\ts.pop_back();\n\t\t\t}\n\t\t\ts.push_back(it);\n\t\t}\n\t}\n\ts.clear();\n\tsolve(a[1]);\n\tputs(\"yes\");\n\tprint(a, 1, m);\n}\n\n} signed main() {\n#ifdef memset0\n\tfreopen(\"1.in\", \"r\", stdin);\n#endif\n\treturn ringo::main(), 0;\n}\n</code></pre>","frontmatter":{"date":"May 09, 2019","title":"「CF1053E」Euler tour","cover":"/cover/10.png"}}},"pageContext":{"id":"bb86a756-1ecc-537f-9652-e040dc8e2ab7","slug":"blog/problem/cf1053e"}},"staticQueryHashes":[],"slicesMap":{}}