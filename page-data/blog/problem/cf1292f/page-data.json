{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/cf1292f/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>一个大小为 $n$ 的集合 ${a_i}_{i=1}^n$，每次可以选择 $(i,j,k)$，若 $a_i \\mid a_j$ 且 $a_i \\mid a_k$，可以将 $a_k$ 删去。</p>\n<p>求能删除最多数的删除序列数，删除序列定义为对于一个三元组 $(i,j,k)$，每次删数把 $a_k$ 加入到删除序列中。</p>\n<p>$1 \\leq a_i, n \\leq 60$，保证 $a_i$ 两两不同。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p>考虑如果 $a_i \\mid a_j$，就从 $i$ 到 $j$ 连一条边，这样形成的图是一个偏序集。不妨只考虑第一层的点，称为 $A$ 类点，其余的点称为 $B$ 类点。每次删除操作可以转化为，找到一个 $A$ 类点，存在 $\\geq 2$ 的出度，就可以删掉其中任意一条出边指向的点。</p>\n<p>对于任意一个由 $A$、$B$ 类点组成的非平凡弱联通块，一定存在一种删除方式使得是剩下其中的 $A$ 类点和某一个 $B$ 类点。这就是删除最多数的方案。</p>\n<p>那么怎么统计方案数呢，我们枚举最后剩下的点，然后把删除操作倒过来做，变成加入操作。那么我们可以状压一个状态，是一个 $A$ 类点的集合，此时这些 $A$ 类点有至少 $1$ 的出度。那么每次被反向「删除」回来的点一定和状态中的某一个 $A$ 类点有边，且会产生两种影响，即：要么增加后状态不变，要么增加后使得更多的 $A$ 类点变成「可用」。</p>\n<p>我们不妨在每次导致第二种影响的时候统计方案，就不会统计重复，这样的话可以得到一个 $O(2^{r} n^2)$ 的暴力 DP，其中 $r$ 是 $A$ 类点的个数。</p>\n<p>如果我们删除没有出度的点，容易证明 $r \\leq 15$（$[16,30] \\cup [46,60]$），可以通过本题。实际上如果特判出度为 $1$，能让 $r$ 做到更小。</p>\n<h2>代码</h2>\n<!--more-->\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\nusing namespace std;\nconst int N=65,mod=1e9+7;\nint n,m,tot,sum,ans,in[N],out[N],anc[N],val[N],tag[N],fac[N],ifac[N],S[1&#x3C;&#x3C;15],dp[N][1&#x3C;&#x3C;15];\nlong long T[1&#x3C;&#x3C;15];\nint find(int x){return anc[x]==x?x:anc[x]=find(anc[x]);}\ninline int C(int n,int m){return n&#x3C;m?0:(long long)fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nint main(){\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n#endif\n  fac[0]=ifac[0]=ifac[1]=1;\n  for(int i=2;i&#x3C;N;i++)ifac[i]=(long long)(mod-mod/i)*ifac[mod%i]%mod;\n  for(int i=1;i&#x3C;N;i++)fac[i]=(long long)fac[i-1]*i%mod,ifac[i]=(long long)ifac[i-1]*ifac[i]%mod;\n  cin>>n;\n  for(int i=1;i&#x3C;=n;i++)cin>>val[i],tag[val[i]]=true;\n  m=*std::max_element(val+1,val+n+1);\n  for(int i=1;i&#x3C;=m;i++)if(tag[i])anc[i]=i;\n  for(int i=1;i&#x3C;=m;i++)if(tag[i])\n    for(int j=(i&#x3C;&#x3C;1);j&#x3C;=m;j+=i)if(tag[j]){\n      out[i]++,in[j]++;\n      anc[find(i)]=find(j);\n    }\n  ans=1;\n  // for(int i=1;i&#x3C;=m;i++)printf(\"%d%c\",tag[i]?find(i):-1,\" \\n\"[i==m]);\n  for(int c=1;c&#x3C;=m;c++)if(tag[c]&#x26;&#x26;find(c)==c){\n    std::vector&#x3C;int> a,b;\n    std::vector&#x3C;long long> A,B;\n    for(int i=1;i&#x3C;=m;i++)if(tag[i]&#x26;&#x26;find(i)==c){\n      if(!in[i]){\n        if(!out[i])continue;\n        a.push_back(i);\n      }else{\n        b.push_back(i);\n      }\n    }\n    if(!b.size())continue;\n    A.resize(a.size());\n    B.resize(b.size());\n    for(int i=0;i&#x3C;a.size();i++)\n      for(int j=0;j&#x3C;b.size();j++)\n        if(b[j]%a[i]==0){\n          A[i]|=1ll&#x3C;&#x3C;j;\n          B[j]|=1ll&#x3C;&#x3C;i;\n        }\n    for(int x=0;x&#x3C;(1&#x3C;&#x3C;a.size());x++){\n      long long s=0,t=0;\n      for(int i=0;i&#x3C;a.size();i++)if((x>>i)&#x26;1)t|=A[i];\n      for(int j=0;j&#x3C;b.size();j++)if(((t>>j)&#x26;1)&#x26;&#x26;(x&#x26;B[j])==B[j])s|=1ll&#x3C;&#x3C;j;\n      S[x]=__builtin_popcountll(s),T[x]=t;\n    }\n    sum=0;\n    for(int i=0;i&#x3C;b.size();i++){\n      for(int i=0;i&#x3C;=b.size();i++)memset(dp[i],0,(1&#x3C;&#x3C;a.size())&#x3C;&#x3C;2);\n      dp[1][B[i]]=fac[S[B[i]]-1];\n      for(int x=B[i],y;x&#x3C;(1&#x3C;&#x3C;a.size());x++)\n        for(int t=0;t&#x3C;b.size();t++)if(((T[x]>>t)&#x26;1)&#x26;&#x26;(y=x|B[t])!=x)\n          for(int i=1;i&#x3C;b.size();i++)if(dp[i][x])\n            for(int j=i+1;j&#x3C;=b.size();j++){\n              // printf(\"%d %d %d[%d] : %d(%d) -> %d(%d)\\n\",i,j,t,b[t],x,S[x],y,S[y]);\n              dp[j][y]=(dp[j][y]+(long long)dp[i][x]*C(S[y]-j,S[y]-S[x]-1)%mod*fac[S[y]-S[x]-1])%mod;\n            }\n      for(int i=0;i&#x3C;=b.size();i++)sum=(sum+dp[i][(1&#x3C;&#x3C;a.size())-1])%mod;\n      // printf(\"%d[%d] %d\\n\",i,b[i],sum);\n    }\n    // for(int i=0;i&#x3C;a.size();i++)printf(\"%d,%lld%c\",a[i],A[i],\" \\n\"[i+1==a.size()]);\n    // for(int i=0;i&#x3C;b.size();i++)printf(\"%d,%lld%c\",b[i],B[i],\" \\n\"[i+1==b.size()]);\n    tot+=b.size()-1;\n    ans=(long long)ans*sum%mod*C(tot,b.size()-1)%mod;\n    // printf(\">> %d %d\\n\",(int)b.size(),sum);\n  }\n  cout&#x3C;&#x3C;ans&#x3C;&#x3C;endl;\n}\n</code></pre>","frontmatter":{"date":"September 15, 2020","title":"「CF1292F」Nora's Toy Boxes","cover":"/cover/27.webp"}}},"pageContext":{"id":"945ca2cd-63af-5647-9206-025630936ceb","slug":"blog/problem/cf1292f"}},"staticQueryHashes":[],"slicesMap":{}}