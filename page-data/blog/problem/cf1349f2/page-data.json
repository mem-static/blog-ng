{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/cf1349f2/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>定义一个排列 $p$ 是好的当且仅当对于每个 $k &#x3C; \\max{p}$，存在 $1 \\leq i &#x3C; j \\leq n$ 使得 $a_i = k-1$ 且 $a_j = k$。</p>\n<p>定义 $f_a(k)$ 为序列 $a$ 中数值 $k$ 的出现次数，假设所有合法序列集合为 $S$，对于每个 $k \\in [1;n]$，求</p>\n<p>$$\n\\left( \\sum_{a \\in S} f_a(k) \\right) \\bmod 998244353\n$$</p>\n<p>$n \\leq 10^5$。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p>考虑由排列 $p$ 生成序列，在 $p_i$ 和 $p_{i+1}$ 之间填入大于或小于号，则 $a_{p_i}$ 的值为 $p_{1...i}$ 中的小于号个数 $+1$，不难验证合法序列集合和排列集合构成双射。</p>\n<p>注意到这是个欧拉数的形式，考虑容斥维护：</p>\n<p>$$\n\\newcommand{\\strling}[2]{\\left{\\begin{matrix}#1\\#2\\end{matrix}\\right}}\n\\begin{aligned}\nans_i\n&#x26;= \\sum_{m=0}^n \\frac {n!} {m!} \\sum_{j \\ge i} (m-j)! (-1)^{j-i}\\binom j i \\strling m {m-j} \\\n&#x26;= \\sum_{j \\ge i} n! (-1)^{j-i} \\binom j i \\sum_{m=j+1}^n \\strling m {m-j} \\frac {(m-j)!} {m!}\n\\end{aligned}\n$$</p>\n<blockquote>\n<p>第二类斯特林数的生成函数</p>\n<p>$$\\newcommand{\\strling}[2]{\\left{\\begin{matrix}#1\\#2\\end{matrix}\\right}} \\strling n k = n! [z^n] \\frac {(e^z-1)^k} {k!}$$</p>\n</blockquote>\n<p>设 $h$，先带上 $m=i$ 的情况计算，最后再令 $h_0$ 减 $1$。</p>\n<p>$$\n\\newcommand{\\strling}[2]{\\left{\\begin{matrix}#1\\#2\\end{matrix}\\right}}\n\\begin{aligned}\nh_i\n&#x26;= \\sum_{m=i}^n \\strling m {m-i} \\frac{(m-i)!} {m!} \\\n&#x26;= \\sum_{m=i}^n [z^m] (e^z-1)^{m-i}\\\n&#x26;= \\sum_{j=0}^{n-i} [z^{j+i}] (e^z-1)^j \\\n&#x26;= [z^i] \\sum_{j=0}^{n-i} \\left( \\frac{e^z-1} {z} \\right)^j \\\n\\end{aligned}\n$$</p>\n<p>令 $F(z) = (e^z-1)/z$，有</p>\n<p>$$\n\\begin{aligned}\nh_i\n&#x26;= [z^i] \\sum_{j=0}^{n-i} F^j(z) \\\n&#x26;= [z^i] \\frac{F^{n-i+1}(z)-1} {F(z)-1} \\\n&#x26;= [z^i] \\left( \\frac{-1}{F(z)-1} + \\frac{F^{n-i+1}(z)}{F(z)-1} \\right) \\\n\\end{aligned}\n$$</p>\n<p>前半部分容易直接多项式求逆处理，现在考虑后半部分</p>\n<p>$$\n[z^i] \\frac{F^{n-i+1}(z)}{F(z)-1} = [z^{n+1}] \\frac{(z F(z))^{n-i+1}}{F(z)-1}\n$$</p>\n<p>（开始在这里卡住了，不求甚解的从题解那里拉了个式子，第二天冷静了一下，为了行文连贯，把补充理解附在后面）</p>\n<p>设 $\\omega(z) = zF(z)$，$\\varphi(z)$ 满足 $\\dfrac{\\omega(z)}{\\varphi(\\omega(z))}=z$，则 $\\dfrac{zF(z)}{\\varphi(\\omega(z))}=z$，即 $F=\\varphi(\\omega)$</p>\n<blockquote>\n<p>拓展拉格朗日反演</p>\n<p>$f,g,h$ 是 $F[[x]]$ 上的多项式，已知 $f(g(x)) = g(f(x)) = x$，则</p>\n<p>$$[x^n] h(f(x)) = \\frac 1 n [x^{n-1}] h'(x) \\left( \\frac {x} {g(x)} \\right)^n$$</p>\n</blockquote>\n<p>考虑</p>\n<p>$$\n\\begin{aligned}\nf(x) &#x26;= \\omega(x) \\\ng(x) &#x26;= \\frac x {\\varphi(x)} \\\nh(x) &#x26;= \\frac 1 {(1-\\varphi(x)) (1 - ux)} \\\n\\end{aligned}\n$$</p>\n<p>则</p>\n<p>$$\n\\begin{aligned}\n&#x26; [u^{n-i+1} z^{n+1}] \\frac 1 {1-\\varphi (\\omega(z))} \\frac 1 {1-uw(z)} \\\n=&#x26; [u^{n-i+1}] \\frac 1 {n+1} [z^n] \\left(\\left(\\frac 1 {1-\\varphi(z)} \\frac 1 {1-uz}\\right)'\\cdot \\varphi(z)^{n+1}\\right) \\\n\\end{aligned}\n$$</p>\n<blockquote>\n<p>$\\displaystyle \\frac 1 {(1-x)^k} = \\sum_{i=0}^{\\infty} \\binom {i+k-1} {k-1} x^i$</p>\n<p>直接考虑系数组合意义就可以证明。</p>\n</blockquote>\n<p>其中</p>\n<p>$$\n\\begin{aligned}\n&#x26; \\left(\\frac 1 {1-\\varphi(z)} \\frac 1 {1-uz}\\right)' \\\n=&#x26; \\frac {\\varphi'(z)} {(1-uz) (1-\\varphi(z))^2} + \\frac {u} {(1-\\varphi(z))(1-uz)^2} \\\n=&#x26; \\frac {\\varphi'(z)} {(1-\\varphi(z))^2} \\sum_{i=0}^\\infty u^i z^i + \\frac {1} {1 - \\varphi(z)} \\sum_{i=0}^\\infty (i+1) u^{i+1} z^i \\\n\\end{aligned}\n$$</p>\n<p>代入到原式中有</p>\n<p>$$\n\\begin{aligned}\n&#x26; \\frac {[z^n] \\varphi^{n+1}(z)} {n+1} \\left( \\frac {z^{n-i+1} \\varphi'(z)} {(1-\\varphi(z))^2} + \\frac {(n-i+1) z^{n-i}} {1 - \\varphi(z)} \\right) \\\n=&#x26; [z^{i-1}] \\frac {\\varphi^{n+1}(z) \\varphi'(z)} {(n+1) (1-\\varphi(z))^2} + [z^i] \\frac {\\varphi^{n+1}(z) (n-i+1)} {(n+1) (1-\\varphi(z))} \\\n\\end{aligned}\n$$</p>\n<p>唯一的问题就是 $\\varphi(x)$ 怎么求了，注意到 $\\omega(x) = e^x-1$，构造得 $\\dfrac z {\\ln (1+z)}$。</p>\n<h2>坑</h2>\n<ol>\n<li>$\\varphi(z) = \\dfrac {z} {\\ln(1+z)}$，注意到 $\\ln(1+z)$ 的常数项是 $0$，不能直接求逆；</li>\n<li>$1-\\varphi(z)$ 常数项也是 $0$，同样不能直接求逆，只能求出 $(1-\\varphi(z))/z$，上面的式子大概变成\n$$\n[z^{i+1}] \\frac {\\varphi^{n+1}(z) \\varphi'(z)} {(n+1) ((1-\\varphi(z))/z)^2} + [z^{i+1}] \\frac {\\varphi^{n+1}(z) (n-i+1)} {(n+1) ((1-\\varphi(z)/z))}\n$$</li>\n<li>上面两种情况的处理可能带来更多的多项式长度要求。</li>\n<li>$h_0$ 减 $1$。</li>\n</ol>\n<h2>补充理解</h2>\n<p>现在我们需要对 $i \\in [0;n]$，求出</p>\n<p>$$\n[z^{n+1}] \\frac{(z F(z))^{n-i+1}}{F(z)-1}\n$$</p>\n<p>考虑用二元生成函数表示</p>\n<p>$$\n\\begin{aligned}\n&#x26; [z^{n+1} u^{n-i+1}] \\frac 1 {F(z)-1} \\sum_{k=0}^\\infty (z u F(z))^{k} \\\n=&#x26; [z^{n+1} u^{n-i+1}] \\frac 1 {(F(z)-1) (1-zuF(z))} \\\n\\end{aligned}\n$$</p>\n<p>如果直接对着这个式子做，是没有办法拉格朗日反演的，因为本质上我们有两个关于 $z$ 的多项式：$F(z)$ 和 $zF(z)$。我们设法构造一个关于 $F$ 的多项式使其满足 $\\varphi(F(z)) = z F(z)$。</p>\n<p>形式化的，我们想要构造多项式 $\\varphi(z)$ 使得</p>\n<p>$$\n\\varphi(F(z)) = z F(z)\n$$</p>\n<p>同时，由该式我们也可以直接得到 $F$ 的复合逆形式：</p>\n<p>$$\n\\frac {\\varphi(F(z))} {F(z)} = z\n$$</p>\n<p>说回到 $\\varphi(x)$ 的构造，我们只能利用 $F(z)$ 本身的性质设法构造出 $z$：我们有</p>\n<p>$$\nF(z) = \\frac {e^{z} - 1} {z}\n$$</p>\n<p>相当于有</p>\n<p>$$\n\\ln(1 + zF(z)) = z\n$$</p>\n<p>不幸的是，这个式子本身还和 $z$ 有关，但启发我们改变方向，设 $\\omega(z) = z F(z)$，构造多项式 $\\varphi(z)$ 使得</p>\n<p>$$\n\\begin{cases}\n\\omega(z) = z F(z) \\\n\\varphi(\\omega(z)) = F(z) \\\n\\end{cases}\n$$</p>\n<p>有 $\\varphi(z) = \\dfrac {z} {\\ln(1 + z)}$，$\\dfrac {\\omega(z)} {\\varphi(\\omega(z))} = z$。即把原式转化为了：</p>\n<p>$$\n\\frac 1 {(1 - u \\omega(z)) \\left(\\dfrac {\\omega(z)} {\\ln(1 + \\omega(z))}-1\\right)}\n$$</p>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\nchar obuf[1&#x3C;&#x3C;21],*oS=obuf,*oT=oS+(1&#x3C;&#x3C;21)-1;\n#define flush() (fwrite(obuf,1,oS-obuf,stdout),oS=obuf,void())\n#define getchar() (iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,S,stdin),(iS==iT?EOF:*iS++)):*iS++)\n#define putchar(x) (*oS++=(x),oS==oT?flush():void())\nstruct Flusher_{~Flusher_(){flush();}}flusher_;\ntemplate&#x3C;class T> inline void print(T x){\n  if(x&#x3C;0)putchar('-'),x=-x;\n  if(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate&#x3C;class T> inline void print(T x,char c){print(x),putchar(c);}\n#define love %\nconst int N=1e5+10,wyp=998244353;\nint n,len;\nstruct z {\n  int32_t x;\n  z(int32_t x=0):x(x){}\n  friend inline z operator*(z a,z b){return (int64_t)a.x*b.x love wyp;}\n  friend inline z operator-(z a,z b){return (a.x-=b.x)&#x3C;0?a.x+wyp:a.x;}\n  friend inline z operator+(z a,z b){return (a.x+=b.x)>=wyp?a.x-wyp:a.x;}\n}h[N],ans[N],inv[N],fac[N],ifac[N];\ninline z fpow(z a,int b){z s=1;for(;b;b>>=1,a=a*a)if(b&#x26;1)s=s*a;return s;}\nvoid init(int n){\n  fac[0]=ifac[0]=inv[0]=inv[1]=1;\n  for(int i=2;i&#x3C;n;i++)inv[i]=(wyp-wyp/i)*inv[/*!!!*/wyp love i/*!!!*/];\n  for(int i=1;i&#x3C;n;i++)fac[i]=fac[i-1]*i,ifac[i]=ifac[i-1]*inv[i];\n}\nnamespace poly{\n  int len=1,rev[N&#x3C;&#x3C;2]; z w[N&#x3C;&#x3C;2];\n  struct vec:std::vector&#x3C;z>{\n    using std::vector&#x3C;z>::vector;\n    inline void input(){for(size_t i=0;i&#x3C;size();i++)scanf(\"%d\",&#x26;((int&#x26;)this->operator[](i)));}\n    inline void output(){for(size_t i=0;i&#x3C;size();i++)printf(\"%d%c\",this->operator[](i).x,\" \\n\"[i+1==size()]);}\n    inline vec divx(){vec res=*this; return res.erase(res.begin()),res;}\n    inline vec setl(size_t len){vec res=*this; return res.resize(len),res;}\n    inline vec fun1(){vec res(this->begin()+1,this->end()); for(int i=0;i&#x3C;res.size();i++)res[i].x=wyp-res[i].x; return res;}\n  };\n  int init(int n){\n    int lim=1,k=0; while(lim&#x3C;n)lim&#x3C;&#x3C;=1,++k;\n    for(int i=0;i&#x3C;lim;i++)rev[i]=(rev[i>>1]>>1)|((i&#x26;1)&#x3C;&#x3C;(k-1));\n    for(;len&#x3C;lim;len&#x3C;&#x3C;=1){\n      z wn=fpow(3,(wyp-1)/(len&#x3C;&#x3C;1)); w[len]=1;\n      for(int i=1;i&#x3C;len;i++)w[i+len]=w[i+len-1]*wn;\n    }return lim;\n  }\n  void dft(vec &#x26;a,int lim){\n    a.resize(lim);\n    for(int i=0;i&#x3C;lim;i++)if(i&#x3C;rev[i])std::swap(a[i],a[rev[i]]);\n    for(int i=0;i&#x3C;lim;i+=2){z x=a[i],y=a[i+1]*w[1];a[i]=x+y,a[i+1]=x-y;}\n    for(int len=2;len&#x3C;lim;len&#x3C;&#x3C;=1)\n      for(int i=0;i&#x3C;lim;i+=(len&#x3C;&#x3C;1))\n        for(int j=0;j&#x3C;len;j++){\n          z x=a[i+j],y=a[i+j+len]*w[j+len];\n          a[i+j]=x+y,a[i+j+len]=x-y;\n        }\n  }\n  void idft(vec &#x26;a,int lim){\n    z inv=fpow(lim,wyp-2); dft(a,lim),std::reverse(&#x26;a[1],&#x26;a[lim]);\n    for(int i=0;i&#x3C;lim;i++)a[i]=a[i]*inv;\n  }\n  vec operator+(vec a,const vec &#x26;b){\n    a.resize(std::max(a.size(),b.size()));\n    for(int i=0;i&#x3C;b.size();i++)a[i]=a[i]+b[i]; return a;\n  }\n  vec operator-(vec a,const vec &#x26;b){\n    a.resize(std::max(a.size(),b.size()));\n    for(int i=0;i&#x3C;b.size();i++)a[i]=a[i]-b[i]; return a;\n  }\n  vec operator*(vec a,vec b){\n    if(a.size()&#x3C;20||b.size()&#x3C;20||(uint64_t)a.size()+b.size()&#x3C;400){\n      vec c(a.size()+b.size()-1);\n      for(int i=0;i&#x3C;a.size();i++)\n        for(int j=0;j&#x3C;b.size();j++)\n          c[i+j]=c[i+j]+a[i]*b[j];\n      return c;\n    }\n    int len=a.size()+b.size()-1,lim=init(len);\n    dft(a,lim),dft(b,lim);\n    for(int i=0;i&#x3C;lim;i++)a[i]=a[i]*b[i];\n    return idft(a,lim),a.resize(len),a;\n  }\n  vec inv(const vec &#x26;f,int len=-1){\n    if((len=~len?len:f.size())==1)return vec{fpow(f[0],wyp-2)};\n    vec a=inv(f,(len+1)>>1),b(&#x26;f[0],&#x26;f[len]); int lim=init((len&#x3C;&#x3C;1)-1);\n    dft(a,lim),dft(b,lim);\n    for(int i=0;i&#x3C;lim;i++)a[i]=a[i]*(2-a[i]*b[i]);\n    return idft(a,lim),a.resize(len),a;\n  }\n  vec inte(vec a){for(int i=a.size()-1;i;i--)a[i]=a[i-1]*::inv[i];return *a.begin()=0,a;}\n  vec deri(vec a){for(int i=0;i&#x3C;a.size()-1;i++)a[i]=a[i+1]*(i+1);return *a.rbegin()=0,a;}\n  vec ln(const vec &#x26;f){return inte((deri(f)*inv(f)).setl(f.size()));}\n  vec exp(const vec &#x26;f,int len=-1){\n    if((len=~len?len:f.size())==1)return vec{1};\n    vec a=exp(f,(len+1)>>1),b=a;b.resize(len),b=ln(b);\n    for(int i=0;i&#x3C;len;i++)b[i]=0-b[i]; b[0]=b[0]+1;\n    for(int i=0;i&#x3C;len;i++)b[i]=b[i]+f[i]; return (a*b).setl(len);\n  }\n  vec pow(vec a,int b){a=ln(a); for(int i=0;i&#x3C;a.size();i++)a[i]=a[i]*b; return exp(a);}\n}\nusing poly::vec;\nint main(){\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n#endif\n  std::cin>>n;\n  init(n+10),len=n+5;\n  vec Finv=poly::inv(vec(ifac+1,ifac+len+1).fun1());\n  for(int i=0;i&#x3C;=n;i++)h[i]=Finv[i+1]; h[0]=h[0]-1;\n  vec P(len); for(int i=0;i&#x3C;len;i++)P[i]=(i&#x26;1?wyp-1:1)*inv[i+1]; P=poly::inv(P);\n  vec Ppow=poly::pow(P,n+1);\n  vec Pinv=poly::inv(P.fun1());\n  vec lpart=(Ppow*Pinv).setl(len);\n  vec rpart=((poly::deri(P)*Pinv).setl(len)*lpart).setl(len);\n  z tmp=fpow(n+1,wyp-2);\n  for(int i=0;i&#x3C;=n;i++)h[i]=h[i]-tmp*(lpart[i+1]*(n-i+1)+rpart[i+1]);\n  vec f(n+1),g(n+1);\n  for(int i=0;i&#x3C;=n;i++)f[i]=((n-i)&#x26;1?wyp-1:1)*ifac[n-i];\n  for(int i=0;i&#x3C;=n;i++)g[i]=fac[i]*h[i];\n  f=f*g;\n  for(int i=0;i&#x3C;n;i++)ans[i]=f[i+n]*fac[n]*ifac[i];\n  for(int i=0;i&#x3C;n;i++)print(ans[i].x,\" \\n\"[i+1==n]);\n}\n</code></pre>","frontmatter":{"date":"May 14, 2020","title":"「CF1349F2」Slime and Sequences (Hard Version)","cover":"/cover/24.webp"}}},"pageContext":{"id":"f102da1b-10e9-5911-b64e-fe66f3b17e5c","slug":"blog/problem/cf1349f2"}},"staticQueryHashes":[],"slicesMap":{}}