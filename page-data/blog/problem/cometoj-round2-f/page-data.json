{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/cometoj-round2-f/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>有 $n$ 种操作，第 $i$ 种操作使用后有 $p_i$ 的概率升级，$(1-p_i)$ 的概率不升级。</p>\n<p>进行若干次操作后，如果主人公的等级为 $i$，就能产生 $a_i$ 的贡献。</p>\n<p>对于每个 $i \\in [1;n]$ 求出，使用 $j \\neq i$ 的所有操作 $j$，主人公产生等级贡献的期望。</p>\n<p>$n \\leq 10^5$。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p>设 $C_i(x) = (1 - p_i + p_i x)$，$C(x) = \\prod_{i=0}^{n-1} C_i(x)$</p>\n<p>$$\nans_m = \\sum_{i=0}^{n-1} a_i [x^i] \\prod_{j \\neq m} C_j(x)\n$$</p>\n<p>这是一个线性算法，其转移矩阵为 $D_{m,i} = [x^i] \\prod_{j \\neq m} C_j(x)$</p>\n<p>考虑其转置 $D^T_{m,i} = [x^m] \\prod_{j \\neq i} C_j(x)$</p>\n<p>我们有做法</p>\n<p>$$\nans_m = \\prod_{i=0}^{n-1} a_i [x^m] \\prod_{j \\neq i} C_j(x)\n$$</p>\n<p>$$\nANS(x) = \\prod_{i=0}^n a_i \\prod_{j \\neq i} C_j(x)\n$$</p>\n<p>有类似 $k$ 次幂和的 $O(n \\log^2 n)$ 做法，可以改写成其转置。</p>\n<p>具体的，我们令 $A(x) = \\sum_{i \\ge 0} a_i x^i$，为线段树根节点，$\\operatorname{mul}^T$ 到叶子节点即可。</p>\n<p>一般做法可以参见 zsy 博客：<a href=\"https://www.cnblogs.com/zhoushuyu/p/10777808.html\">https://www.cnblogs.com/zhoushuyu/p/10777808.html</a></p>\n<p>大概是利用多项式点乘的性质把贡献拆开然后多点求值（</p>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\ntemplate&#x3C;class T> inline void read(T &#x26;x){\n  x=0; register char c=getchar(); register bool f=0;\n  while(!isdigit(c))f^=c=='-',c=getchar();\n  while(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\ntemplate&#x3C;class T> inline void print(T x){\n  if(x&#x3C;0)putchar('-'),x=-x;\n  if(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate&#x3C;class T> inline void print(T x,char c){print(x),putchar(c);}\nconst int N=1e5+10,mod=998244353;\nint n,m;\nstruct z {\n  int x;\n  z(int x=0):x(x){}\n  friend inline z operator*(z a,z b){return (long long)a.x*b.x%mod;}\n  friend inline z operator-(z a,z b){return (a.x-=b.x)&#x3C;0?a.x+mod:a.x;}\n  friend inline z operator+(z a,z b){return (a.x+=b.x)>=mod?a.x-mod:a.x;}\n}a[N],p[N],ans[N],fac[N],ifac[N],inv[N];\ninline z fpow(z a,int b){z s=1;for(;b;b>>=1,a=a*a)if(b&#x26;1)s=s*a;return s;}\nvoid init(int n){\n  n+=5,inv[0]=inv[1]=fac[0]=ifac[0]=1;\n  for(int i=2;i&#x3C;n;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n  for(int i=1;i&#x3C;n;i++)fac[i]=fac[i-1]*i,ifac[i]=ifac[i-1]*inv[i];\n}\nnamespace poly{//polynomial\n  int len=1,rev[N&#x3C;&#x3C;2]; z w[N&#x3C;&#x3C;2];\n  struct vec:std::vector&#x3C;z>{\n    using std::vector&#x3C;z>::vector;\n    inline void input(int n){resize(n);for(int i=0;i&#x3C;n;i++)read(this->operator[](i).x);}\n    inline void output(){for(int i=0;i&#x3C;size();i++)print(this->operator[](i).x,\" \\n\"[i+1==size()]);}\n  };\n  int init(int n){\n    int lim=1,k=0; while(lim&#x3C;n)lim&#x3C;&#x3C;=1,++k;\n    for(int i=0;i&#x3C;lim;i++)rev[i]=(rev[i>>1]>>1)|((i&#x26;1)&#x3C;&#x3C;(k-1));\n    for(;len&#x3C;lim;len&#x3C;&#x3C;=1){\n      z wn=fpow(3,(mod-1)/(len&#x3C;&#x3C;1)); w[len]=1;\n      for(int i=1;i&#x3C;len;i++)w[i+len]=w[i+len-1]*wn;\n    }return lim;\n  }\n  void dft(vec &#x26;a,int lim){\n    a.resize(lim);\n    for(int i=0;i&#x3C;lim;i++)if(i&#x3C;rev[i])std::swap(a[i],a[rev[i]]);\n    for(int len=1;len&#x3C;lim;len&#x3C;&#x3C;=1)\n      for(int i=0;i&#x3C;lim;i+=(len&#x3C;&#x3C;1))\n        for(int j=0;j&#x3C;len;j++){\n          z x=a[i+j],y=a[i+j+len]*w[j+len];\n          a[i+j]=x+y,a[i+j+len]=x-y;\n        }\n  }\n  void idft(vec &#x26;a,int lim){\n    dft(a,lim),std::reverse(&#x26;a[1],&#x26;a[lim]); z inv=fpow(lim,mod-2);\n    for(int i=0;i&#x3C;lim;i++)a[i]=a[i]*inv;\n  }\n  inline vec mul(vec a,vec b,int l=-1){\n    int len=~l?l:a.size()+b.size()-1,lim=init(a.size()+b.size()-1);\n    dft(a,lim),dft(b,lim);\n    for(int i=0;i&#x3C;lim;i++)a[i]=a[i]*b[i];\n    return idft(a,lim),a.resize(len),a;\n  }\n  namespace extra{\n    using namespace poly;\n    vec mulT(vec a,vec b){\n      int al=a.size(),bl=b.size(),lim=init(al);\n      dft(a,lim),std::reverse(b.begin(),b.end()),dft(b,lim);\n      for(int i=0;i&#x3C;lim;i++)a[i]=a[i]*b[i];\n      return idft(a,lim),vec(&#x26;a[bl-1],&#x26;a[al]);\n    }\n  }\n}\npoly::vec F[N&#x3C;&#x3C;2],G[N&#x3C;&#x3C;2];\nvoid dfs1(int u,int l,int r){\n  if(l==r){F[u]={1-p[l],p[l]}; return;}\n  dfs1(u&#x3C;&#x3C;1,l,(l+r)>>1),dfs1(u&#x3C;&#x3C;1|1,((l+r)>>1)+1,r);\n  F[u]=poly::mul(F[u&#x3C;&#x3C;1],F[u&#x3C;&#x3C;1|1]);\n}\nvoid dfs2(int u,int l,int r){\n  if(l==r){ans[l]=G[u][0]; return;}\n  G[u&#x3C;&#x3C;1]=poly::extra::mulT(G[u],F[u&#x3C;&#x3C;1|1]);\n  G[u&#x3C;&#x3C;1|1]=poly::extra::mulT(G[u],F[u&#x3C;&#x3C;1]);\n  dfs2(u&#x3C;&#x3C;1,l,(l+r)>>1),dfs2(u&#x3C;&#x3C;1|1,((l+r)>>1)+1,r);\n}\nint main(){\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n#endif\n  read(n);\n  for(int i=0;i&#x3C;n;i++)read((int&#x26;)a[i]);\n  for(int i=0,x,y;i&#x3C;n;i++)read(x),read(y),p[i]=x*fpow(y,mod-2);\n  dfs1(1,0,n-1),G[1]=poly::vec(a,a+n),dfs2(1,0,n-1);\n  for(int i=0;i&#x3C;n;i++)print(ans[i].x,\" \\n\"[i==n]);\n}\n</code></pre>","frontmatter":{"date":"May 20, 2020","title":"「CometOJ Round #2 F」真实无妄她们的人生之路","cover":"/cover/36.webp"}}},"pageContext":{"id":"442b365a-6dee-5418-bd9d-518716e2a0ec","slug":"blog/problem/cometoj-round2-f"}},"staticQueryHashes":[],"slicesMap":{}}