{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/cometoj-round7-f/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>维护序列 $a_{1\\ldots n}$，支持以下操作 $m$ 次：</p>\n<ol>\n<li>给 $x,y$，将 $x$ 位置的值修改为 $y$；</li>\n<li>给 $l,r,x$，查询区间$[l,r]$中有多少子区间的最大值小于或等于 $x$。</li>\n</ol>\n<p>$n,m \\leq 3 \\times 10^5$。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p>对于询问 ${l,r,x}$，相当于转化为这样一个问题：</p>\n<p>序列 $b$ 满足 $b_i = [a_i \\leq x]$，然后询问 $b$ 的区间 $[l,r]$ 内，有多少子区间的均为 $1$。</p>\n<p>考虑一个分块，维护块内外的信息是平凡的，瓶颈在于如何优化离散化的复杂度。</p>\n<p>然后此处用到一个叫分散层叠的 trick，开一个每一个块作为叶子节点的线段树，叶子节点维护每个数的权值及排名，</p>\n<p>考虑 <code>maintain</code> 操作，每次只保留下标是 $3$ 的倍数的位置。</p>\n<ul>\n<li>对于修改操作，暴力 <code>maintain</code> 上去，时间复杂度 $O(\\sqrt n + \\frac 2 3 \\sqrt n + \\frac 4 9 \\sqrt n + \\cdots) = O(\\sqrt n)$。</li>\n<li>对于查询操作，DFS 遍历整棵树，递归到下一层的时候指针只会右移至多 $2$ 次，是常数级别的，故时间复杂度为总节点数，即 $O(\\sqrt n)$。</li>\n</ul>\n<h2>卡常</h2>\n<p>实现上由于分散层叠的常数有点大，还是需要一些卡常技巧的。</p>\n<ol>\n<li>内存连续，而且注意到直接开的话内存空余会很大，可以手动分配内存。</li>\n<li>关于往后扫四次的这个操作，可以写成这样 <code>k+=arr[k+2]&#x3C;=x?2:0,k+=arr[k+1]&#x3C;=x</code>，然后在 <code>arr</code> 里多丢两个 $+\\infty$。</li>\n</ol>\n<h2>代码</h2>\n<p><strong>二分查找（$O(n \\sqrt {n\\log n})$）</strong></p>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\n\nnamespace mem{ //v2.1.2 => size: 14.19KiB\n  #define MEM_IO\n  #define MEM_MATH\n  #define MEM_UTILS\n  #define MEM_MODINT\n  #define MEM_RANDOM\n  #define MEM_STDVAL\n  #define MEM_LOGGER\n  #define MEM_CONTAINER\n  #ifdef memset0\n  #else\n    #define MEM_FASTIO\n  #endif\n\n  #ifdef __SIZEOF_INT128__\n    #define MEM_INT128\n  #endif\n\n  #define __integer_mapper(func)       \\\n        func(int)                      \\\n        func(unsigned int)             \\\n        func(long long int)            \\\n        func(unsigned long long int)\n  #define __float_mapper(func)         \\\n        func(float)                    \\\n        func(double)                   \\\n        func(long double)\n    \n    namespace stdval{\n  #ifdef MEM_STDVAL\n      using i32=int;\n      using i64=long long int;\n      using u32=unsigned int;\n      using u64=unsigned long long int;\n      using f32=float;\n      using f64=double;\n      using f96=long double;\n    #ifdef MEM_INT128\n      using i128=__int128_t;\n      using u128=__uint128_t;\n    #endif\n  #endif\n    }\n    \n    namespace utils{\n  #ifdef MEM_UTILS\n      using std::cin;\n      using std::tie;\n      using std::cout;\n      using std::cerr;\n      using std::endl;\n      using std::swap;\n      using std::sort;\n      using std::unique;\n      using std::reverse;\n      using std::shuffle;\n      using std::function;\n      using std::make_pair;\n      using std::make_tuple;\n      using std::accumulate;\n      using std::lower_bound;\n      using std::upper_bound;\n      using std::max_element;\n      using std::min_element;\n  #endif\n    }\n    \n    namespace random{\n  #ifdef MEM_RANDOM\n      const int LuckyNumber=20040726; // Kanbe Kotori's Birthday\n      std::mt19937 rng(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n      std::mt19937_64 rng64(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n      \n      template&#x3C;class T> inline T rand(T l,T r){return std::uniform_int_distribution&#x3C;T>(l,r)(rng);}\n      template&#x3C;class T> inline T rand64(T l,T r){return std::uniform_int_distribution&#x3C;T>(l,r)(rng);}\n  #endif\n    }\n    \n    namespace modint{\n  #ifdef MEM_MODINT\n      template&#x3C;const int mod> struct Z{\n        int x;\n        inline Z(){x=0;}\n        inline Z(int t){x=t;}\n        \n        inline void operator-=(Z a){(x-=a.x)&#x3C;0&#x26;&#x26;(x+=mod);}\n        inline void operator+=(Z a){(x+=a.x)>=mod&#x26;&#x26;(x-=mod);}\n        inline void operator*=(Z a){x=(long long)x*a.x%mod;}\n        \n        friend inline Z operator*(Z a,Z b){return (long long)a.x*b.x%mod;}\n        friend inline Z operator-(Z a,Z b){return ((a.x-=b.x)&#x3C;0&#x26;&#x26;(a.x+=mod)),a;}\n        friend inline Z operator+(Z a,Z b){return ((a.x+=b.x)>=mod&#x26;&#x26;(a.x-=mod)),a;}\n      };\n      \n      template&#x3C;const int mod> inline Z&#x3C;mod> finv(Z&#x3C;mod> x){\n        if(x.x&#x3C;2)return x;\n        return (mod-mod/x.x)*finv(mod%x.x);\n      }\n      template&#x3C;const int mod> inline Z&#x3C;mod> fpow(Z&#x3C;mod> a,int b){\n        Z &#x3C;mod> s=1;\n        for(;b;b>>=1,a=a*a)\n          if(b&#x26;1)s=s*a;\n        return s;\n      }\n      \n      template&#x3C;const int mod> inline void init_inverse(int n,Z&#x3C;mod> *inv){\n        inv[0]=inv[1]=1;\n        for(int i=2;i&#x3C;n;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n      }\n      template&#x3C;const int mod> inline void init_factorial(int n,Z&#x3C;mod> *fac,Z&#x3C;mod> *ifac){\n        fac[0]=1,init_inverse(n,ifac);\n        for(int i=1;i&#x3C;n;i++)fac[i]=fac[i-1]*i,ifac[i]=ifac[i-1]*ifac[i];\n      }\n    }\n    \n    namespace io{\n      template&#x3C;const int mod> inline void read(modint::Z&#x3C;mod> &#x26;x){read(x.x);}\n      template&#x3C;const int mod> inline void print(modint::Z&#x3C;mod> x){print(x.x);}\n  #endif\n    }\n    \n    namespace math{\n  #ifdef MEM_MATH\n      using std::max;\n      using std::min;\n      template&#x3C;class T> inline T abs(T x){return x&#x3C;0?-x:x;}\n      template&#x3C;class T> inline T gcd(T n,T m){return m?gcd(m,n%m):n;}\n      template&#x3C;class T> inline T lcm(T n,T m){return n/gcd(n,m)*m;}\n      \n      template&#x3C;const stdval::u64 p> struct FastDiv{\n        stdval::u64 t,i;\n        inline FastDiv():t(stdval::u64(-1)/p),i(mul_inv(p)){}\n        \n        inline bool divide(stdval::u64 n){return n*i&#x3C;=t;}\n        inline bool divide(stdval::i64 n){return stdval::u64(n&#x3C;0?-n:n)*i&#x3C;=t;}\n        inline stdval::u64 mul_inv(stdval::u64 n){\n          stdval::u64 x=n;\n          for(int i=0;i&#x3C;5;++i)x*=2-n*x;\n          return x;\n        }\n      };\n    \n    #ifdef MEM_INT128\n      template&#x3C;const stdval::u64 b> struct FastMod{\n        stdval::u64 m;\n        inline FastMod():m(stdval::u64((stdval::u128(1)&#x3C;&#x3C;64)/b)){}\n        \n        inline stdval::u64 reduce(stdval::u64 a){\n          stdval::u64 q=(stdval::u64)((stdval::u128(m)*a)>>64);\n          stdval::u64 r=a-q*b;\n          return r>=b?r-b:r;\n        }\n      };\n    #endif\n  #endif\n    }\n    \n    namespace container{\n  #ifdef MEM_CONTAINER\n      using std::pair;\n      using std::tuple;\n      using std::set;\n      using std::unordered_set;\n      using std::map;\n      using std::unordered_map;\n      \n      using std::tie;\n      using std::make_pair;\n      using std::make_tuple;\n      \n      template&#x3C;class T> struct vector:std::vector&#x3C;T>{\n        using std::vector&#x3C;T>::vector;\n        vector():std::vector&#x3C;T>(){}\n        vector(const std::vector&#x3C;T> &#x26;plain):std::vector&#x3C;T>(plain){}\n        \n        inline void sort(){std::sort(this->begin(),this->end());}\n        inline void concat(const vector &#x26;rhs){this->insert(this->end(),rhs.begin(),rhs.end());}\n        inline bool includes(const T &#x26;x) const{return std::find(this->begin(),this->end(),x)!=this->end();}\n        template&#x3C;class Function> inline void forEach(Function func){for(const auto &#x26;it:*this)func(it);}\n        \n        inline vector slice(int l,int r) const{\n          if(l>r)return {};\n          if(r&#x3C;this->size())return vector(this->begin()+l,this->begin()+r);\n          vector&#x3C;int> rsp=(this->begin()+l,this->end());\n          return rsp.resize(r-l),rsp;\n        }\n        \n        inline void from(const std::set&#x3C;T> &#x26;src){\n          this->resize(src.size());\n          auto it=this->begin();\n          for(const T e:src)*it++=e;\n        }\n        \n        template&#x3C;class R,class Function> inline vector&#x3C;R> _map(Function func) const{\n          vector &#x3C;R> res(this->size());\n          for(size_t i=0;i&#x3C;this->size();i++)\n            res[i]=func(this->operator[](i));\n          return res;\n        }\n        template&#x3C;class R> inline vector&#x3C;R> map(R func(T)) const{return this->_map&#x3C;R>(func);}\n        template&#x3C;class R> inline vector&#x3C;R> map(const std::function&#x3C;R(T)> &#x26;func) const{return this->_map&#x3C;R>(func);}\n      };\n      \n      struct string:std::string{\n        using std::string::string;\n        string():std::string(\"\"){}\n        string(const std::string &#x26;plain):std::string(plain){}\n        \n        template&#x3C;class T> inline string join(const vector&#x3C;T> &#x26;vet) const;\n        \n        vector&#x3C;string> split(const string &#x26;dim) const{\n          if(this->empty())return {};\n          char *src=new char[this->length()+1];\n          strcpy(src,this->c_str());\n          char *tar=new char[dim.length()+1];\n          strcpy(tar,dim.c_str());\n          vector &#x3C;string> rsp;\n          for(char *pos=strtok(src,tar);pos;pos=strtok(nullptr,tar))\n            rsp.push_back(string(pos));\n          delete[] src;\n          delete[] tar;\n          return rsp;\n        }\n        \n        template&#x3C;class... Args> static inline string format(const char *fm,Args... args){\n          int len=snprintf(nullptr,0,fm,args...);\n          char *buf=new char[len+1];\n          snprintf(buf,len+1,fm,args...);\n          string str(buf);\n          delete[] buf;\n          return str;\n        }\n        template&#x3C;class... Args> static inline string format(const string &#x26;fm,Args... args){\n          return format(fm.c_str(),args...);\n        }\n      };\n    \n    #define __to_string(T)                 \\\n      inline string to_string(const T &#x26;x){ \\\n        return std::to_string(x);          \\\n      }\n      __float_mapper(__to_string)\n      __integer_mapper(__to_string)\n    #undef __to_string\n      \n      inline string to_string(const string &#x26;s){return s;}\n      inline string to_string(const char *s){return string(s);}\n      inline string to_string(const std::string &#x26;s){return string(s);}\n      \n      template&#x3C;const int mod> inline string to_string(const mem::modint::Z&#x3C;mod> &#x26;v){return std::to_string(v.x);}\n      \n      template&#x3C;class T> inline string to_string(const vector&#x3C;T> &#x26;ctn){return \"[\"+string(\",\").join(ctn)+\"]\";}\n      template&#x3C;class T> inline string to_string(const set&#x3C;T> &#x26;ctn){\n        string result=\"{\";\n        bool flag=false;\n        for(const auto &#x26;it:ctn){\n          if(flag)result+=\",\";\n          flag=true;\n          result+=to_string(it);\n        }\n        return result+\"}\";\n      }\n      template&#x3C;class T1,class T2> inline string to_string(const map&#x3C;T1,T2> &#x26;ctn){\n        string result=\"{\";\n        bool flag=false;\n        for(const auto &#x26;it:ctn){\n          if(flag)result+=\",\";\n          flag=true;\n          result+=to_string(it.first)+\":\"+to_string(it.second);\n        }\n        return result+\"}\";\n      }\n      \n      template&#x3C;class T> inline string string::join(const vector&#x3C;T> &#x26;vet) const{\n        if(!vet.size())return \"\";\n        string res=to_string(vet[0]);\n        for(size_t i=1;i&#x3C;vet.size();i++){\n          res+=*this;\n          res+=to_string(vet[i]);\n        }\n        return res;\n      }\n      \n      inline string operator \"\" _s(const char *s){return string(s);}\n      inline string operator \"\" _s(const char *s,size_t len){return string(s,len);}\n      inline string operator \"\" _s(long double x){return to_string(x);}\n      inline string operator \"\" _s(unsigned long long int x){return to_string(x);}\n  #endif\n    }\n    \n    namespace io{\n  #ifdef MEM_IO\n    #ifdef MEM_FASTIO\n      namespace fastio{\n        const int BUFFER=1&#x3C;&#x3C;18;\n        char ibuf[BUFFER],*iS,*iT;\n        inline int getc(){\n          if(iS==iT){\n            iT=(iS=ibuf)+fread(ibuf,1,BUFFER,stdin);\n            return iS==iT?EOF:*iS++;\n          }else{\n            return *iS++;\n          }\n        }\n        char obuf[BUFFER],*oS=obuf,*oT=oS+BUFFER-1;\n        inline void flush(){\n          fwrite(obuf,1,oS-obuf,stdout);\n          oS=obuf;\n        }\n        inline void putc(int x){\n          *oS++=x;\n          if(oS==oT)flush();\n        }\n        struct Flusher{~Flusher(){flush();}}flusher;\n      }\n      using fastio::getc;\n      using fastio::putc;\n    #else\n      inline int getc(){return getchar();}\n      inline void putc(int c){putchar(c);}\n    #endif\n      \n      template&#x3C;class T> inline void readDigit(T &#x26;x){\n        x=getc();\n        while(!isdigit(x))x=getc();\n      }\n      inline int readDigit(){\n        int x;\n        readDigit(x);\n        return x;\n      }\n      template&#x3C;class T> inline void readAlpha(T &#x26;x){\n        x=getc();\n        while(!isalpha(x))x=getc();\n      }\n      inline int readAlpha(){\n        int x;\n        readAlpha(x);\n        return x;\n      }\n    \n    #define __read(T)                             \\\n        inline void read(T &#x26;x) {                  \\\n          x=0; bool f=0; char c=getc();           \\\n          while(!isdigit(c))f^=c=='-',c=getc();   \\\n          while(isdigit(c))x=x*10+c-'0',c=getc(); \\\n          if(f)x=-x;                              \\\n        }\n      __integer_mapper(__read)\n    #undef __read\n      \n      inline void read(char &#x26;x){x=getc();}\n      inline void read(char *s){\n        char c=getc();\n        while(~c&#x26;&#x26;!isspace(c))*s++=c,c=getc();\n        *s++='\\0';\n      }\n      inline void read(container::string &#x26;s){\n        char c=getc();\n        s=\"\";\n        while(~c&#x26;&#x26;!isspace(c))s+=c,c=getc();\n      }\n      \n      template&#x3C;class T=int> inline T read(){\n        T x;\n        read(x);\n        return x;\n      }\n      template&#x3C;class T,class... Args> inline void read(T &#x26;x,Args &#x26;... args){\n        read(x),read(args...);\n      }\n    \n    #define __print(T)           \\\n        inline void print(T x){  \\\n          if(x&#x3C;0)putc('-'),x=-x; \\\n          if(x>9)print(x/10);    \\\n          putc('0'+x%10);        \\\n        }\n      __integer_mapper(__print)\n    #undef __print\n      \n      inline void print(char x){putc(x);}\n      inline void print(const char *s){\n        int len=strlen(s);\n        for(int i=0;i&#x3C;len;i++)putc(s[i]);\n      }\n      inline void print(const container::string &#x26;s){\n        for(int i=0;i&#x3C;s.length();i++)putc(s[i]);\n      }\n      \n      template&#x3C;class T,class... Args> inline void print(const T &#x26;x,Args... args){\n        print(x),print(args...);\n      }\n      template&#x3C;class... Args> inline void println(Args... args){\n        print(args...),putc('\\n');\n      }\n      \n      template&#x3C;class... Args> inline void printfm(const char *formatter,Args... arguments){\n        print(container::string().format(formatter,arguments...));\n      }\n      template&#x3C;class... Args> inline void printfm(const container::string &#x26;formatter,Args... arguments){\n        print(container::string().format(formatter,arguments...));\n      }\n  #endif\n    }\n    \n    namespace logger{\n  #ifdef MEM_LOGGER\n      enum ConsoleColor{\n        NOPE=-1,BLACK,RED,GREEN,YELLOW,BLUE,PURPLE,DEEPBLUE\n      };\n      template&#x3C;const ConsoleColor color=NOPE,class... Args> inline void log(const char *formatter,Args... args){\n        if(~color){\n          fprintf(stderr,\"\\033[%dm\",30+color);\n          fprintf(stderr,formatter,args...);\n          fprintf(stderr,\"\\033[0m\");\n        }else{\n          fprintf(stderr,formatter,args...);\n        }\n      }\n      template&#x3C;const ConsoleColor color=NOPE,class... Args> inline void logln(const char *formatter,Args... args){\n        if(~color){\n          fprintf(stderr,\"\\033[%dm\",30+color);\n          fprintf(stderr,formatter,args...);\n          fprintf(stderr,\"\\033[0m\\n\");\n        }else{\n          fprintf(stderr,formatter,args...);\n          fprintf(stderr,\"\\n\");\n        }\n      }\n      template&#x3C;class T> inline void logs(const T &#x26;x){\n        fprintf(stderr,container::to_string(x).c_str());\n      }\n      template&#x3C;class T,class... Args> inline void logs(const T &#x26;x,Args... args){\n        logs(x),logs(args...);\n      }\n      template&#x3C;class... Args> inline void logsln(Args... args){\n        logs(args...);\n        fprintf(stderr,\"\\n\");\n      }\n  #endif\n    }\n\n  #undef __integer_mapper\n  #undef __float_mapper\n  #undef __string_mapper\n  #undef __string_join_mapper\n    \n    using namespace io;\n    using namespace math;\n    using namespace utils;\n    using namespace modint;\n    using namespace random;\n    using namespace stdval;\n    using namespace logger;\n    using namespace container;\n} // namespace mem\n\nusing namespace mem::io;\nusing namespace mem::math;\nusing namespace mem::utils;\n\nconst int N=3e5+10,sqn=502,S=sqn+10;\nint n,m,a[N],bln[N];\n\nstruct atom{\n  int l,r,c;\n  long long s;\n};\ninline atom operator+(const atom &#x26;a,const atom &#x26;b){\n  if(a.l==a.c&#x26;&#x26;b.l==b.c){\n    return {a.l+b.l,a.r+b.r,a.c+b.c,a.s+b.s+a.c*b.c};\n  }else if(a.l==a.c){\n    return {a.l+b.l,b.r,a.c+b.c,a.s+b.s+a.c*b.l};\n  }else if(b.l==b.c){\n    return {a.l,a.r+b.r,a.c+b.c,a.s+b.s+a.r*b.c};\n  }else{\n    return {a.l,b.r,a.c+b.c,a.s+b.s+a.r*b.l};\n  }\n}\ninline atom calc(int l,int r,int x){\n  atom res{0,0,r-l+1,0};\n  while(res.l&#x3C;res.c&#x26;&#x26;a[l+res.l]&#x3C;=x)res.l++;\n  while(res.r&#x3C;res.c&#x26;&#x26;a[r-res.r]&#x3C;=x)res.r++;\n  int pre=0;\n  for(int i=l;i&#x3C;=r;i++)if(a[i]&#x3C;=x)res.s+=++pre; else pre=0;\n  return res;\n}\nconst atom c[2]={{0,0,1,0},{1,1,1,1}};\n\nint anc[S],siz[S],tag[S];\nint find(int x){return anc[x]==x?x:anc[x]=find(anc[x]);}\ninline void merge(int a,int b,long long &#x26;s){\n  a=find(a),b=find(b),s+=siz[a]*siz[b];\n  if(siz[a]>siz[b])swap(a,b);\n  anc[a]=b,siz[b]+=siz[a];\n}\nstruct block{\n  int l,r,n,val[S],pos[S];\n  atom pre[S];\n  inline int loc(int x){return upper_bound(val+1,val+n+1,x)-val-1;}\n  inline void init(){\n    n=r-l+1;\n    pre[0]={0,0,n,0};\n    pre[n]={n,n,n,(long long)n*(n-1)/2};\n    for(int i=1;i&#x3C;n;i++)pre[i].c=n;\n    std::vector&#x3C;std::pair&#x3C;int,int>> t(n);\n    for(int i=0;i&#x3C;n;i++)t[i]={a[i+l],i};\n    sort(t.begin(),t.end());\n    for(int i=1;i&#x3C;=n;i++)val[i]=t[i-1].first,pos[i]=t[i-1].second;\n  }\n  inline void modify(int k){\n    for(int i=1;i&#x3C;=n;i++)if(pos[i]==k){\n      val[i]=a[k+l];\n      while(i>1&#x26;&#x26;val[i]&#x3C;val[i-1])swap(val[i],val[i-1]),swap(pos[i],pos[i-1]),i--;\n      while(i&#x3C;n&#x26;&#x26;val[i]>val[i+1])swap(val[i],val[i+1]),swap(pos[i],pos[i+1]),i++;\n      return;\n    }\n  }\n  inline void build(){\n    for(int i=n-1;i>=1;i--){\n      pre[i].l=min(pre[i+1].l,pos[i+1]);\n      pre[i].r=min(pre[i+1].r,n-pos[i+1]-1);\n    }\n    for(int i=0;i&#x3C;n;i++)anc[i]=i,siz[i]=1,tag[i]=0;\n    for(int i=1;i&#x3C;=n;i++){\n      pre[i].s=i?pre[i-1].s+1:1;\n      tag[pos[i]]=1;\n      if(pos[i]&#x26;&#x26;tag[pos[i]-1])merge(pos[i]-1,pos[i],pre[i].s);\n      if(pos[i]&#x3C;n-1&#x26;&#x26;tag[pos[i]+1])merge(pos[i]+1,pos[i],pre[i].s);\n    }\n  }\n}s[N/sqn+5];\n\nint main(){\n#ifdef memset0 \n  freopen(\"1.in\",\"r\",stdin);\n  freopen(\"1.out\",\"w\",stdout);\n#endif\n  read(n,m);\n  for(int i=1;i&#x3C;=n;i++)read(a[i]);\n  for(int i=1;i&#x3C;=n;i++)bln[i]=(i-1)/sqn+1;\n  for(int i=1;i&#x3C;=n;i++)s[bln[i]].r=i;\n  for(int i=n;i>=1;i--)s[bln[i]].l=i;\n  for(int i=1;i&#x3C;=bln[n];i++)s[i].init(),s[i].build();\n  for(int o,l,r,x,y,i=1;i&#x3C;=m;i++){\n    read(o);\n    if(o==1){\n      read(x,y);\n      a[x]=y;\n      s[bln[x]].modify(x-s[bln[x]].l);\n      s[bln[x]].build();\n    }else{\n      read(l,r,x);\n      atom ans;\n      if(bln[l]==bln[r]){\n        ans=calc(l,r,x);\n      }else{\n        ans=calc(l,s[bln[l]].r,x);\n        for(int i=bln[l]+1;i&#x3C;=bln[r]-1;i++)ans=ans+s[i].pre[s[i].loc(x)];\n        ans=ans+calc(s[bln[r]].l,r,x);\n      }\n      print(ans.s,'\\n');\n    }\n  }\n  fprintf(stderr,\"clocks: %.4lf\\n\",clock()/(double)CLOCKS_PER_SEC);\n}\n</code></pre>\n<p><strong>分散层叠（$O(n \\sqrt n)$）</strong></p>\n<pre><code class=\"language-cpp\">#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,fma,tune=native\") \n#include&#x3C;bits/stdc++.h>\n\nnamespace mem{ //v2.1.2 => size: 14.19KiB\n  #define MEM_IO\n  #define MEM_MATH\n  #define MEM_UTILS\n  #define MEM_MODINT\n  #define MEM_RANDOM\n  #define MEM_STDVAL\n  #define MEM_LOGGER\n  #define MEM_CONTAINER\n  #ifdef memset0\n  #else\n    #define MEM_FASTIO\n  #endif\n\n  #ifdef __SIZEOF_INT128__\n    #define MEM_INT128\n  #endif\n\n  #define __integer_mapper(func)       \\\n        func(int)                      \\\n        func(unsigned int)             \\\n        func(long long int)            \\\n        func(unsigned long long int)\n  #define __float_mapper(func)         \\\n        func(float)                    \\\n        func(double)                   \\\n        func(long double)\n    \n    namespace stdval{\n  #ifdef MEM_STDVAL\n      using i32=int;\n      using i64=long long int;\n      using u32=unsigned int;\n      using u64=unsigned long long int;\n      using f32=float;\n      using f64=double;\n      using f96=long double;\n    #ifdef MEM_INT128\n      using i128=__int128_t;\n      using u128=__uint128_t;\n    #endif\n  #endif\n    }\n    \n    namespace utils{\n  #ifdef MEM_UTILS\n      using std::cin;\n      using std::tie;\n      using std::cout;\n      using std::cerr;\n      using std::endl;\n      using std::swap;\n      using std::sort;\n      using std::unique;\n      using std::reverse;\n      using std::shuffle;\n      using std::function;\n      using std::make_pair;\n      using std::make_tuple;\n      using std::accumulate;\n      using std::lower_bound;\n      using std::upper_bound;\n      using std::max_element;\n      using std::min_element;\n  #endif\n    }\n    \n    namespace random{\n  #ifdef MEM_RANDOM\n      const int LuckyNumber=20040726; // Kanbe Kotori's Birthday\n      std::mt19937 rng(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n      std::mt19937_64 rng64(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n      \n      template&#x3C;class T> inline T rand(T l,T r){return std::uniform_int_distribution&#x3C;T>(l,r)(rng);}\n      template&#x3C;class T> inline T rand64(T l,T r){return std::uniform_int_distribution&#x3C;T>(l,r)(rng);}\n  #endif\n    }\n    \n    namespace modint{\n  #ifdef MEM_MODINT\n      template&#x3C;const int mod> struct Z{\n        int x;\n        inline Z(){x=0;}\n        inline Z(int t){x=t;}\n        \n        inline void operator-=(Z a){(x-=a.x)&#x3C;0&#x26;&#x26;(x+=mod);}\n        inline void operator+=(Z a){(x+=a.x)>=mod&#x26;&#x26;(x-=mod);}\n        inline void operator*=(Z a){x=(long long)x*a.x%mod;}\n        \n        friend inline Z operator*(Z a,Z b){return (long long)a.x*b.x%mod;}\n        friend inline Z operator-(Z a,Z b){return ((a.x-=b.x)&#x3C;0&#x26;&#x26;(a.x+=mod)),a;}\n        friend inline Z operator+(Z a,Z b){return ((a.x+=b.x)>=mod&#x26;&#x26;(a.x-=mod)),a;}\n      };\n      \n      template&#x3C;const int mod> inline Z&#x3C;mod> finv(Z&#x3C;mod> x){\n        if(x.x&#x3C;2)return x;\n        return (mod-mod/x.x)*finv(mod%x.x);\n      }\n      template&#x3C;const int mod> inline Z&#x3C;mod> fpow(Z&#x3C;mod> a,int b){\n        Z &#x3C;mod> s=1;\n        for(;b;b>>=1,a=a*a)\n          if(b&#x26;1)s=s*a;\n        return s;\n      }\n      \n      template&#x3C;const int mod> inline void init_inverse(int n,Z&#x3C;mod> *inv){\n        inv[0]=inv[1]=1;\n        for(int i=2;i&#x3C;n;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n      }\n      template&#x3C;const int mod> inline void init_factorial(int n,Z&#x3C;mod> *fac,Z&#x3C;mod> *ifac){\n        fac[0]=1,init_inverse(n,ifac);\n        for(int i=1;i&#x3C;n;i++)fac[i]=fac[i-1]*i,ifac[i]=ifac[i-1]*ifac[i];\n      }\n    }\n    \n    namespace io{\n      template&#x3C;const int mod> inline void read(modint::Z&#x3C;mod> &#x26;x){read(x.x);}\n      template&#x3C;const int mod> inline void print(modint::Z&#x3C;mod> x){print(x.x);}\n  #endif\n    }\n    \n    namespace math{\n  #ifdef MEM_MATH\n      using std::max;\n      using std::min;\n      template&#x3C;class T> inline T abs(T x){return x&#x3C;0?-x:x;}\n      template&#x3C;class T> inline T gcd(T n,T m){return m?gcd(m,n%m):n;}\n      template&#x3C;class T> inline T lcm(T n,T m){return n/gcd(n,m)*m;}\n      \n      template&#x3C;const stdval::u64 p> struct FastDiv{\n        stdval::u64 t,i;\n        inline FastDiv():t(stdval::u64(-1)/p),i(mul_inv(p)){}\n        \n        inline bool divide(stdval::u64 n){return n*i&#x3C;=t;}\n        inline bool divide(stdval::i64 n){return stdval::u64(n&#x3C;0?-n:n)*i&#x3C;=t;}\n        inline stdval::u64 mul_inv(stdval::u64 n){\n          stdval::u64 x=n;\n          for(int i=0;i&#x3C;5;++i)x*=2-n*x;\n          return x;\n        }\n      };\n    \n    #ifdef MEM_INT128\n      template&#x3C;const stdval::u64 b> struct FastMod{\n        stdval::u64 m;\n        inline FastMod():m(stdval::u64((stdval::u128(1)&#x3C;&#x3C;64)/b)){}\n        \n        inline stdval::u64 reduce(stdval::u64 a){\n          stdval::u64 q=(stdval::u64)((stdval::u128(m)*a)>>64);\n          stdval::u64 r=a-q*b;\n          return r>=b?r-b:r;\n        }\n      };\n    #endif\n  #endif\n    }\n    \n    namespace container{\n  #ifdef MEM_CONTAINER\n      using std::pair;\n      using std::tuple;\n      using std::set;\n      using std::unordered_set;\n      using std::map;\n      using std::unordered_map;\n      \n      using std::tie;\n      using std::make_pair;\n      using std::make_tuple;\n      \n      template&#x3C;class T> struct vector:std::vector&#x3C;T>{\n        using std::vector&#x3C;T>::vector;\n        vector():std::vector&#x3C;T>(){}\n        vector(const std::vector&#x3C;T> &#x26;plain):std::vector&#x3C;T>(plain){}\n        \n        inline void sort(){std::sort(this->begin(),this->end());}\n        inline void concat(const vector &#x26;rhs){this->insert(this->end(),rhs.begin(),rhs.end());}\n        inline bool includes(const T &#x26;x) const{return std::find(this->begin(),this->end(),x)!=this->end();}\n        template&#x3C;class Function> inline void forEach(Function func){for(const auto &#x26;it:*this)func(it);}\n        \n        inline vector slice(int l,int r) const{\n          if(l>r)return {};\n          if(r&#x3C;this->size())return vector(this->begin()+l,this->begin()+r);\n          vector&#x3C;int> rsp=(this->begin()+l,this->end());\n          return rsp.resize(r-l),rsp;\n        }\n        \n        inline void from(const std::set&#x3C;T> &#x26;src){\n          this->resize(src.size());\n          auto it=this->begin();\n          for(const T e:src)*it++=e;\n        }\n        \n        template&#x3C;class R,class Function> inline vector&#x3C;R> _map(Function func) const{\n          vector &#x3C;R> res(this->size());\n          for(size_t i=0;i&#x3C;this->size();i++)\n            res[i]=func(this->operator[](i));\n          return res;\n        }\n        template&#x3C;class R> inline vector&#x3C;R> map(R func(T)) const{return this->_map&#x3C;R>(func);}\n        template&#x3C;class R> inline vector&#x3C;R> map(const std::function&#x3C;R(T)> &#x26;func) const{return this->_map&#x3C;R>(func);}\n      };\n      \n      struct string:std::string{\n        using std::string::string;\n        string():std::string(\"\"){}\n        string(const std::string &#x26;plain):std::string(plain){}\n        \n        template&#x3C;class T> inline string join(const vector&#x3C;T> &#x26;vet) const;\n        \n        vector&#x3C;string> split(const string &#x26;dim) const{\n          if(this->empty())return {};\n          char *src=new char[this->length()+1];\n          strcpy(src,this->c_str());\n          char *tar=new char[dim.length()+1];\n          strcpy(tar,dim.c_str());\n          vector &#x3C;string> rsp;\n          for(char *pos=strtok(src,tar);pos;pos=strtok(nullptr,tar))\n            rsp.push_back(string(pos));\n          delete[] src;\n          delete[] tar;\n          return rsp;\n        }\n        \n        template&#x3C;class... Args> static inline string format(const char *fm,Args... args){\n          int len=snprintf(nullptr,0,fm,args...);\n          char *buf=new char[len+1];\n          snprintf(buf,len+1,fm,args...);\n          string str(buf);\n          delete[] buf;\n          return str;\n        }\n        template&#x3C;class... Args> static inline string format(const string &#x26;fm,Args... args){\n          return format(fm.c_str(),args...);\n        }\n      };\n    \n    #define __to_string(T)                 \\\n      inline string to_string(const T &#x26;x){ \\\n        return std::to_string(x);          \\\n      }\n      __float_mapper(__to_string)\n      __integer_mapper(__to_string)\n    #undef __to_string\n      \n      inline string to_string(const string &#x26;s){return s;}\n      inline string to_string(const char *s){return string(s);}\n      inline string to_string(const std::string &#x26;s){return string(s);}\n      \n      template&#x3C;const int mod> inline string to_string(const mem::modint::Z&#x3C;mod> &#x26;v){return std::to_string(v.x);}\n      \n      template&#x3C;class T> inline string to_string(const vector&#x3C;T> &#x26;ctn){return \"[\"+string(\",\").join(ctn)+\"]\";}\n      template&#x3C;class T> inline string to_string(const set&#x3C;T> &#x26;ctn){\n        string result=\"{\";\n        bool flag=false;\n        for(const auto &#x26;it:ctn){\n          if(flag)result+=\",\";\n          flag=true;\n          result+=to_string(it);\n        }\n        return result+\"}\";\n      }\n      template&#x3C;class T1,class T2> inline string to_string(const map&#x3C;T1,T2> &#x26;ctn){\n        string result=\"{\";\n        bool flag=false;\n        for(const auto &#x26;it:ctn){\n          if(flag)result+=\",\";\n          flag=true;\n          result+=to_string(it.first)+\":\"+to_string(it.second);\n        }\n        return result+\"}\";\n      }\n      \n      template&#x3C;class T> inline string string::join(const vector&#x3C;T> &#x26;vet) const{\n        if(!vet.size())return \"\";\n        string res=to_string(vet[0]);\n        for(size_t i=1;i&#x3C;vet.size();i++){\n          res+=*this;\n          res+=to_string(vet[i]);\n        }\n        return res;\n      }\n      \n      inline string operator \"\" _s(const char *s){return string(s);}\n      inline string operator \"\" _s(const char *s,size_t len){return string(s,len);}\n      inline string operator \"\" _s(long double x){return to_string(x);}\n      inline string operator \"\" _s(unsigned long long int x){return to_string(x);}\n  #endif\n    }\n    \n    namespace io{\n  #ifdef MEM_IO\n    #ifdef MEM_FASTIO\n      namespace fastio{\n        const int BUFFER=1&#x3C;&#x3C;18;\n        char ibuf[BUFFER],*iS,*iT;\n        inline int getc(){\n          if(iS==iT){\n            iT=(iS=ibuf)+fread(ibuf,1,BUFFER,stdin);\n            return iS==iT?EOF:*iS++;\n          }else{\n            return *iS++;\n          }\n        }\n        char obuf[BUFFER],*oS=obuf,*oT=oS+BUFFER-1;\n        inline void flush(){\n          fwrite(obuf,1,oS-obuf,stdout);\n          oS=obuf;\n        }\n        inline void putc(int x){\n          *oS++=x;\n          if(oS==oT)flush();\n        }\n        struct Flusher{~Flusher(){flush();}}flusher;\n      }\n      using fastio::getc;\n      using fastio::putc;\n    #else\n      inline int getc(){return getchar();}\n      inline void putc(int c){putchar(c);}\n    #endif\n      \n      template&#x3C;class T> inline void readDigit(T &#x26;x){\n        x=getc();\n        while(!isdigit(x))x=getc();\n      }\n      inline int readDigit(){\n        int x;\n        readDigit(x);\n        return x;\n      }\n      template&#x3C;class T> inline void readAlpha(T &#x26;x){\n        x=getc();\n        while(!isalpha(x))x=getc();\n      }\n      inline int readAlpha(){\n        int x;\n        readAlpha(x);\n        return x;\n      }\n    \n    #define __read(T)                             \\\n        inline void read(T &#x26;x) {                  \\\n          x=0; bool f=0; char c=getc();           \\\n          while(!isdigit(c))f^=c=='-',c=getc();   \\\n          while(isdigit(c))x=x*10+c-'0',c=getc(); \\\n          if(f)x=-x;                              \\\n        }\n      __integer_mapper(__read)\n    #undef __read\n      \n      inline void read(char &#x26;x){x=getc();}\n      inline void read(char *s){\n        char c=getc();\n        while(~c&#x26;&#x26;!isspace(c))*s++=c,c=getc();\n        *s++='\\0';\n      }\n      inline void read(container::string &#x26;s){\n        char c=getc();\n        s=\"\";\n        while(~c&#x26;&#x26;!isspace(c))s+=c,c=getc();\n      }\n      \n      template&#x3C;class T=int> inline T read(){\n        T x;\n        read(x);\n        return x;\n      }\n      template&#x3C;class T,class... Args> inline void read(T &#x26;x,Args &#x26;... args){\n        read(x),read(args...);\n      }\n    \n    #define __print(T)           \\\n        inline void print(T x){  \\\n          if(x&#x3C;0)putc('-'),x=-x; \\\n          if(x>9)print(x/10);    \\\n          putc('0'+x%10);        \\\n        }\n      __integer_mapper(__print)\n    #undef __print\n      \n      inline void print(char x){putc(x);}\n      inline void print(const char *s){\n        int len=strlen(s);\n        for(int i=0;i&#x3C;len;i++)putc(s[i]);\n      }\n      inline void print(const container::string &#x26;s){\n        for(int i=0;i&#x3C;s.length();i++)putc(s[i]);\n      }\n      \n      template&#x3C;class T,class... Args> inline void print(const T &#x26;x,Args... args){\n        print(x),print(args...);\n      }\n      template&#x3C;class... Args> inline void println(Args... args){\n        print(args...),putc('\\n');\n      }\n      \n      template&#x3C;class... Args> inline void printfm(const char *formatter,Args... arguments){\n        print(container::string().format(formatter,arguments...));\n      }\n      template&#x3C;class... Args> inline void printfm(const container::string &#x26;formatter,Args... arguments){\n        print(container::string().format(formatter,arguments...));\n      }\n  #endif\n    }\n    \n    namespace logger{\n  #ifdef MEM_LOGGER\n      enum ConsoleColor{\n        NOPE=-1,BLACK,RED,GREEN,YELLOW,BLUE,PURPLE,DEEPBLUE\n      };\n      template&#x3C;const ConsoleColor color=NOPE,class... Args> inline void log(const char *formatter,Args... args){\n        if(~color){\n          fprintf(stderr,\"\\033[%dm\",30+color);\n          fprintf(stderr,formatter,args...);\n          fprintf(stderr,\"\\033[0m\");\n        }else{\n          fprintf(stderr,formatter,args...);\n        }\n      }\n      template&#x3C;const ConsoleColor color=NOPE,class... Args> inline void logln(const char *formatter,Args... args){\n        if(~color){\n          fprintf(stderr,\"\\033[%dm\",30+color);\n          fprintf(stderr,formatter,args...);\n          fprintf(stderr,\"\\033[0m\\n\");\n        }else{\n          fprintf(stderr,formatter,args...);\n          fprintf(stderr,\"\\n\");\n        }\n      }\n      template&#x3C;class T> inline void logs(const T &#x26;x){\n        fprintf(stderr,container::to_string(x).c_str());\n      }\n      template&#x3C;class T,class... Args> inline void logs(const T &#x26;x,Args... args){\n        logs(x),logs(args...);\n      }\n      template&#x3C;class... Args> inline void logsln(Args... args){\n        logs(args...);\n        fprintf(stderr,\"\\n\");\n      }\n  #endif\n    }\n\n  #undef __integer_mapper\n  #undef __float_mapper\n  #undef __string_mapper\n  #undef __string_join_mapper\n    \n    using namespace io;\n    using namespace math;\n    using namespace utils;\n    using namespace modint;\n    using namespace random;\n    using namespace stdval;\n    using namespace logger;\n    using namespace container;\n} // namespace mem\n\nusing namespace mem::io;\nusing namespace mem::math;\nusing namespace mem::utils;\nusing namespace mem::logger;\n\nconst int N=3e5+10,sqn=600,S=sqn+10;\nint n,m,bn,a[N],bln[N];\n\nstruct atom{\n  int l,r,c;\n  long long s;\n};\ninline atom operator+(const atom &#x26;a,const atom &#x26;b){\n  if(a.l==a.c&#x26;&#x26;b.l==b.c){\n    return {a.l+b.l,a.r+b.r,a.c+b.c,a.s+b.s+a.c*b.c};\n  }else if(a.l==a.c){\n    return {a.l+b.l,b.r,a.c+b.c,a.s+b.s+a.c*b.l};\n  }else if(b.l==b.c){\n    return {a.l,a.r+b.r,a.c+b.c,a.s+b.s+a.r*b.c};\n  }else{\n    return {a.l,b.r,a.c+b.c,a.s+b.s+a.r*b.l};\n  }\n}\ninline atom calc(int l,int r,int x){\n  atom res{0,0,r-l+1,0};\n  while(res.l&#x3C;res.c&#x26;&#x26;a[l+res.l]&#x3C;=x)res.l++;\n  while(res.r&#x3C;res.c&#x26;&#x26;a[r-res.r]&#x3C;=x)res.r++;\n  int pre=0;\n  for(int i=l;i&#x3C;=r;i++)if(a[i]&#x3C;=x)res.s+=++pre; else pre=0;\n  return res;\n}\nconst atom c[2]={{0,0,1,0},{1,1,1,1}};\n\nint anc[S],siz[S],tag[S];\nint find(int x){return anc[x]==x?x:anc[x]=find(anc[x]);}\ninline void merge(int a,int b,long long &#x26;s){\n  a=find(a),b=find(b),s+=siz[a]*siz[b];\n  if(siz[a]>siz[b])swap(a,b);\n  anc[a]=b,siz[b]+=siz[a];\n}\nstruct block{\n  int l,r,n,val[S],pos[S];\n  atom pre[S];\n  inline int loc(int x){return upper_bound(val+1,val+n+1,x)-val-1;}\n  inline void init(){\n    n=r-l+1;\n    pre[0]={0,0,n,0};\n    pre[n]={n,n,n,(long long)n*(n-1)/2};\n    for(int i=1;i&#x3C;n;i++)pre[i].c=n;\n    std::vector&#x3C;std::pair&#x3C;int,int>> t(n);\n    for(int i=0;i&#x3C;n;i++)t[i]={a[i+l],i};\n    sort(t.begin(),t.end());\n    for(int i=1;i&#x3C;=n;i++)val[i]=t[i-1].first,pos[i]=t[i-1].second;\n  }\n  inline void modify(int k){\n    for(int i=1;i&#x3C;=n;i++)if(pos[i]==k){\n      val[i]=a[k+l];\n      while(i>1&#x26;&#x26;val[i]&#x3C;val[i-1])swap(val[i],val[i-1]),swap(pos[i],pos[i-1]),i--;\n      while(i&#x3C;n&#x26;&#x26;val[i]>val[i+1])swap(val[i],val[i+1]),swap(pos[i],pos[i+1]),i++;\n      return;\n    }\n  }\n  inline void build(){\n    for(int i=n-1;i>=1;i--){\n      pre[i].l=min(pre[i+1].l,pos[i+1]);\n      pre[i].r=min(pre[i+1].r,n-pos[i+1]-1);\n    }\n    for(int i=0;i&#x3C;n;i++)anc[i]=i,siz[i]=1,tag[i]=0;\n    for(int i=1;i&#x3C;=n;i++){\n      pre[i].s=i?pre[i-1].s+1:1;\n      tag[pos[i]]=1;\n      if(pos[i]&#x26;&#x26;tag[pos[i]-1])merge(pos[i]-1,pos[i],pre[i].s);\n      if(pos[i]&#x3C;n-1&#x26;&#x26;tag[pos[i]+1])merge(pos[i]+1,pos[i],pre[i].s);\n    }\n  }\n}s[N/sqn+5];\n\nint bas,_mem[N*12],*_p=_mem;\nstruct FC{\n  int n,*arr,*l,*r;\n  inline void source(int i){memcpy(arr+1,s[i].val+1,n&#x3C;&#x3C;2);}\n  inline void land(int n){if(n)this->n=n,arr=_p,_p+=n+3,l=_p,_p+=n+1,r=_p,_p+=n+1,arr[n+1]=arr[n+2]=1e9;}\n  inline void merge(const FC &#x26;a,const FC &#x26;b){\n    #define PushI {if(!c)arr[++n]=a.arr[i++],l[n]=i-1,r[n]=j-1; else ++i; c=(c+1)&#x26;3;}\n    #define PushJ {if(!c)arr[++n]=b.arr[j++],l[n]=i-1,r[n]=j-1; else ++j; c=(c+1)&#x26;3;}\n    int i=1,j=1,c=0;n=0;\n    while(i&#x3C;=a.n&#x26;&#x26;j&#x3C;=b.n)if(a.arr[i]&#x3C;b.arr[j])PushI else PushJ;\n    while(i&#x3C;=a.n)PushI;\n    while(j&#x3C;=b.n)PushJ;\n  }\n  inline void out(){\n    log(\"n=%d\\n\",n);\n    for(int i=1;i&#x3C;=n;i++)log&#x3C;RED>(\"%d%c\",arr[i],\" \\n\"[i==n]);\n    for(int i=1;i&#x3C;=n;i++)log&#x3C;BLUE>(\"%d%c\",l[i],\" \\n\"[i==n]);\n    for(int i=1;i&#x3C;=n;i++)log&#x3C;GREEN>(\"%d%c\",r[i],\" \\n\"[i==n]);\n  }\n}tr[S&#x3C;&#x3C;1];\nint res[S&#x3C;&#x3C;1];\nbool use[S&#x3C;&#x3C;1];\nvoid locate(int x,int l,int r){\n  #define Loc res[i]+=tr[i].arr[res[i]+2]&#x3C;=x?2:0,res[i]+=tr[i].arr[res[i]+1]&#x3C;=x\n  for(int i=1;i&#x3C;=bn;i++)use[bas+i]=l&#x3C;=i&#x26;&#x26;i&#x3C;=r;\n  for(int i=bas;i>=1;i--)use[i]=use[i&#x3C;&#x3C;1]||use[i&#x3C;&#x3C;1|1];\n  res[1]=0;\n  for(int i=1;i&#x3C;=bas;i++)if(use[i]){\n    Loc;\n    res[i&#x3C;&#x3C;1]=tr[i].l[res[i]];\n    res[i&#x3C;&#x3C;1|1]=tr[i].r[res[i]];\n  }\n  for(int i=l+bas;i&#x3C;=r+bas;i++)Loc;\n  // for(int i=l;i&#x3C;=r;i++)log(\"%d%c\",tr[i+bas].k,\" \\n\"[i==r]);\n}\n\nint main(){\n#ifdef memset0 \n  freopen(\"1.in\",\"r\",stdin);\n  freopen(\"1.out\",\"w\",stdout);\n#endif\n  read(n,m);\n  for(int i=1;i&#x3C;=n;i++)read(a[i]);\n  for(int i=1;i&#x3C;=n;i++)bln[i]=(i-1)/sqn+1;\n  bn=bln[n];\n  for(int i=1;i&#x3C;=n;i++)s[bln[i]].r=i;\n  for(int i=n;i>=1;i--)s[bln[i]].l=i;\n  for(int i=1;i&#x3C;=bn;i++)s[i].init(),s[i].build();\n  log&#x3C;RED>(\"block=%d\\n\",bn);\n  for(bas=1;bas&#x3C;=bn;bas&#x3C;&#x3C;=1);--bas;\n  for(int i=1;i&#x3C;=bn;i++)tr[bas+i].land(s[i].n);\n  for(int i=bas;i>=1;i--)tr[i].land((tr[i&#x3C;&#x3C;1].n+tr[i&#x3C;&#x3C;1|1].n+3)>>2);\n  for(int i=1;i&#x3C;=bn;i++)tr[bas+i].source(i);\n  for(int i=bas;i>=1;i--)tr[i].merge(tr[i&#x3C;&#x3C;1],tr[i&#x3C;&#x3C;1|1]);\n  // for(int i=1;i&#x3C;=bas+n;i++)tr[i].out();\n  for(int o,l,r,x,y,i=1;i&#x3C;=m;i++){\n    read(o);\n    if(o==1){\n      read(x,y);\n      a[x]=y;\n      s[bln[x]].modify(x-s[bln[x]].l);\n      s[bln[x]].build();\n      tr[bas+bln[x]].source(bln[x]);\n      for(int i=(bas+bln[x])>>1;i>=1;i>>=1)tr[i].merge(tr[i&#x3C;&#x3C;1],tr[i&#x3C;&#x3C;1|1]);\n    }else{\n      read(l,r,x);\n      atom ans;\n      if(bln[l]==bln[r]){\n        ans=calc(l,r,x);\n      }else{\n        ans=calc(l,s[bln[l]].r,x);\n        if(bln[l]+1&#x3C;=bln[r]-1)locate(x,bln[l]+1,bln[r]-1);\n        for(int i=bln[l]+1;i&#x3C;=bln[r]-1;i++)ans=ans+s[i].pre[res[i+bas]];\n        ans=ans+calc(s[bln[r]].l,r,x);\n      }\n      print(ans.s,'\\n');\n    }\n    // if(i%10000==0)fprintf(stderr,\"clocks: %.4lf\\n\",clock()/(double)CLOCKS_PER_SEC);\n  }\n  fprintf(stderr,\"clocks: %.4lf\\n\",clock()/(double)CLOCKS_PER_SEC);\n}\n</code></pre>","frontmatter":{"date":"October 10, 2020","title":"「CometOJ Round #7 F」最简单的题","cover":"/cover/25.webp"}}},"pageContext":{"id":"20a95f3b-de1d-5bf4-8d83-5f8029a6d614","slug":"blog/problem/cometoj-round7-f"}},"staticQueryHashes":[],"slicesMap":{}}