{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/icpcwf2018-g/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>给定一个 $n$ 个点的简单多边形（不保证是凸的），你需要确定一个半径 $r$，然后在每个端点画一个半径为 $r$ 的圆，要求能覆盖简单多边形的全部面积。</p>\n<p><img src=\"https://static.memset0.cn/img/v2/20201018160521.png\" alt=\"center\"></p>\n<p>你需要确定这个 $r$ 最小是多少，精度要求 $10^{-6}$。</p>\n<p>$3 \\leq n \\leq 2000,\\ -10^4 \\leq x_i,y_i \\leq 10^4$。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p>考虑求出端点的 Voronoi 图，答案一定是 Voronoi 图的端点，或者是 Voronoi 图和多边形的交点贡献的。</p>\n<p>由于这题数据范围较小，我们可以跑暴力半平面交。</p>\n<h2>坑</h2>\n<p>这题我计算点对答案的贡献的时候是暴力 $O(n)$ 的，其实这样的话理论复杂度高达 $O(n^3)$（然而照样卡不掉）。</p>\n<p>因为 Voronoi 图本质就是按照最近关键点来划分平面，故我们可以直接 $O(1)$ 来计算。</p>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\nusing namespace std;\nconst int N=2e3+10;\nconst double inf=2e4,eps=0;\nnamespace geometry{\n  const double mathPI=acos(-1);\n  template&#x3C;class T> inline T abs(const T &#x26;x){return x&#x3C;0?-x:x;}\n  struct point{\n    double x,y;\n    inline bool operator&#x3C;(const point &#x26;rhs)const{\n      return (abs(x-rhs.x)&#x3C;=eps)?(y-rhs.y&#x3C;-eps):(x-rhs.x&#x3C;-eps);\n    }\n    inline bool operator==(const point &#x26;rhs)const{\n      return abs(x-rhs.x)&#x3C;=eps&#x26;&#x26;abs(y-rhs.y)&#x3C;=eps;\n    }\n  };\n  struct line{\n    point a,b;\n    inline bool operator&#x3C;(const line &#x26;rhs)const{\n      return a==rhs.a?b&#x3C;rhs.b:a&#x3C;rhs.a;\n    }\n  };\n  inline double squaredDistance(const point &#x26;a,const point &#x26;b){\n    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n  }\n  inline double distance(const point &#x26;a,const point &#x26;b){\n    return sqrt(squaredDistance(a,b));\n  }\n  inline double cross(const point &#x26;u,const point &#x26;a,const point &#x26;b){\n    return (a.x-u.x)*(b.y-u.y)-(b.x-u.x)*(a.y-u.y);\n  }\n  inline point intersect(const line &#x26;a,const line &#x26;b){\n    double u=((a.a.y-b.a.y)*(b.a.x-b.b.x)-(a.a.x-b.a.x)*(b.a.y-b.b.y))/\n      ((a.a.x-a.b.x)*(b.a.y-b.b.y)-(a.a.y-a.b.y)*(b.a.x-b.b.x));\n    return {u*(a.a.x-a.b.x)+a.a.x,u*(a.a.y-a.b.y)+a.a.y};\n  }\n  inline bool checkSegmentCrossed(const line &#x26;a,const line &#x26;b){\n    return ((cross(a.a,a.b,b.a)&#x3C;eps)^(cross(a.a,a.b,b.b)&#x3C;eps))&#x26;&#x26;((cross(b.a,b.b,a.a)&#x3C;eps)^(cross(b.a,b.b,a.b)&#x3C;eps));\n  }\n  inline bool insideConvex(const point &#x26;x,const vector&#x3C;point> &#x26;a){\n    bool target=cross(a[0],a[1],x)&#x3C;eps;\n    for(int i=1;i&#x3C;a.size();i++)\n      if(target!=(cross(a[i],a[(i+1)%a.size()],x)&#x3C;eps))\n        return false;\n    return true;\n  }\n  inline bool insidePolygon(const point &#x26;x,const vector&#x3C;point> &#x26;a){\n    vector&#x3C;double> deg(a.size());\n    for(int i=0;i&#x3C;a.size();i++){\n      deg[i]=atan2(a[i].y-x.y,a[i].x-x.x);\n    }\n    double sum=0;\n    for(int i=0;i&#x3C;a.size();i++){\n      double cur=deg[i]-deg[(i+1)%a.size()];\n      if(cur>=mathPI)cur-=mathPI;\n      if(cur&#x3C;=-mathPI)cur+=mathPI;\n      sum+=cur;\n    }\n    return abs(sum)>.5*mathPI;\n  }\n  deque&#x3C;point> halfPlane(const vector&#x3C;line> &#x26;source){\n    vector&#x3C;pair&#x3C;line,double>> plane(source.size());\n    for(int i=0;i&#x3C;plane.size();i++){\n      plane[i]={source[i],atan2(source[i].b.y-source[i].a.y,source[i].b.x-source[i].a.x)};\n    }\n    sort(plane.begin(),plane.end(),[&#x26;](const pair&#x3C;line,double> &#x26;a,const pair&#x3C;line,double> &#x26;b){\n      return abs(a.second-b.second)>eps?a.second&#x3C;b.second:cross(a.first.a,b.first.a,b.first.b)>eps;\n    });\n    deque&#x3C;point> q;\n    deque&#x3C;line> ql;\n    for(int i=0;i&#x3C;plane.size();i++){\n      if(i&#x26;&#x26;abs(plane[i].second-plane[i-1].second)&#x3C;=eps)continue;\n      line cur=plane[i].first;\n      while(q.size()&#x26;&#x26;cross(cur.a,cur.b,q.back())&#x3C;-eps)q.pop_back(),ql.pop_back();\n      while(q.size()&#x26;&#x26;cross(cur.a,cur.b,q.front())&#x3C;-eps)q.pop_front(),ql.pop_front();\n      if(ql.size())q.push_back(intersect(ql.back(),cur));\n      ql.push_back(cur);\n    }\n    while(q.size()>1&#x26;&#x26;cross(ql.front().a,ql.front().b,q.back())&#x3C;-eps)q.pop_back(),ql.pop_back();\n    return q;\n  }\n}\nusing namespace geometry;\nint n,satisifyCounter;\nvector&#x3C;point> a;\ndouble ans;\nset&#x3C;point> voronoiNode;\nset&#x3C;line> voronoiEdge;\nvoid satisifyNode(const point &#x26;x){\n  if(isnan(x.x)||isnan(x.y))return;\n  double cur=numeric_limits&#x3C;double>::infinity();\n  for(int i=0;i&#x3C;n;i++){\n    cur=min(cur,squaredDistance(x,a[i]));\n  }\n  ++satisifyCounter;\n  // cerr&#x3C;&#x3C;\"check \"&#x3C;&#x3C;x.x&#x3C;&#x3C;\" \"&#x3C;&#x3C;x.y&#x3C;&#x3C;\" \"&#x3C;&#x3C;cur&#x3C;&#x3C;endl;\n  ans=max(ans,cur);\n}\nint main(){\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n#endif\n  ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n  // cerr&#x3C;&#x3C;fixed&#x3C;&#x3C;setprecision(4);\n  cin>>n;\n  a.resize(n);\n  for(int i=0;i&#x3C;n;i++){\n    cin>>a[i].x>>a[i].y;\n  }\n  for(int i=0;i&#x3C;n;i++){\n    satisifyNode({(a[i].x+a[(i+1)%n].x)/2,(a[i].y+a[(i+1)%n].y)/2});\n    // cerr&#x3C;&#x3C;\"Segment \"&#x3C;&#x3C;a[i].x&#x3C;&#x3C;\" \"&#x3C;&#x3C;a[i].y&#x3C;&#x3C;\" \"&#x3C;&#x3C;a[(i+1)%n].x&#x3C;&#x3C;\" \"&#x3C;&#x3C;a[(i+1)%n].y&#x3C;&#x3C;endl;\n  }\n  // cerr&#x3C;&#x3C;endl;\n  for(int i=0;i&#x3C;n;i++){\n    vector&#x3C;line> plane={\n      {{inf,inf},{-inf,inf}},\n      {{inf,-inf},{inf,inf}},\n      {{-inf,inf},{-inf,-inf}},\n      {{-inf,-inf},{inf,-inf}},\n    };\n    // cerr&#x3C;&#x3C;\"Circle \"&#x3C;&#x3C;a[i].x&#x3C;&#x3C;\" \"&#x3C;&#x3C;a[i].y&#x3C;&#x3C;\" 5\"&#x3C;&#x3C;endl;\n    for(int j=0;j&#x3C;n;j++)if(i!=j){\n      point mid{(a[i].x+a[j].x)/2,(a[i].y+a[j].y)/2};\n      point delta{a[i].x-mid.x,a[i].y-mid.y};\n      plane.push_back({{mid.x-delta.y,mid.y+delta.x},{mid.x+delta.y,mid.y-delta.x}});\n    }\n    auto convex=halfPlane(plane);\n    for(int i=0;i&#x3C;convex.size();i++){\n      // cerr&#x3C;&#x3C;convex[i].x&#x3C;&#x3C;\" \"&#x3C;&#x3C;convex[i].y&#x3C;&#x3C;endl;\n      voronoiNode.insert(convex[i]);\n      line e={convex[i],convex[(i+1)%convex.size()]};\n      if(e.a.x&#x3C;e.b.x)swap(e.a,e.b);\n      voronoiEdge.insert(e);\n    }\n    // cerr&#x3C;&#x3C;endl;\n  }\n  for(const point &#x26;x:voronoiNode){\n    // cerr&#x3C;&#x3C;x.x&#x3C;&#x3C;\" \"&#x3C;&#x3C;x.y&#x3C;&#x3C;\" \"&#x3C;&#x3C;insidePolygon(x,a)&#x3C;&#x3C;endl;\n    if(insidePolygon(x,a)){\n      satisifyNode(x);\n    }\n  }\n  // cerr&#x3C;&#x3C;endl;\n  for(const line &#x26;e:voronoiEdge){\n    for(int i=0;i&#x3C;a.size();i++){\n      line target{a[i],a[(i+1)%a.size()]};\n      if(checkSegmentCrossed(e,target)){\n        satisifyNode(intersect(e,target));\n      }\n    }\n  }\n  cout&#x3C;&#x3C;fixed&#x3C;&#x3C;setprecision(12)&#x3C;&#x3C;sqrt(ans)&#x3C;&#x3C;endl;\n  cerr&#x3C;&#x3C;\"satisifyCounter: \"&#x3C;&#x3C;satisifyCounter&#x3C;&#x3C;endl;\n}\n</code></pre>\n<h2>Hack</h2>\n<blockquote>\n<p>内容偏娱乐向，本来打算发布的，结果发现时限过大 + 精度要求低，卡都卡不掉。</p>\n</blockquote>\n<p>此题貌似是一个 Voronoi 图板题，我们需要找出由原多边形端点得到的 Voronoi 图，然后答案的贡献只可能从 Voronoi 图的端点，或者 Voronoi 图和线段的交点中产生</p>\n<p>正常做法中，我们知道 Voronoi 图实际上是把二维平面按照距离最近的关键点划分为若干部分，所以贡献答案的计算是容易的。</p>\n<p>此处我们点开一位幸运选手 memset0 的代码：<a href=\"https://loj.ac/submission/959701\">959701</a>，注意到这个人好像不清楚  Voronoi 图的性质，而是大力猜想 Voronoi 图和原多边形的交点个数是 $O(n)$ 级别的，然后暴力跑贡献答案。看起来好像非常对，而且实际上跑的还很快。</p>\n<p>但这个猜想嘛，肯定是假的，怎么卡呢？我们考虑交点个数计数：假设我们把简单多边形的边提出来染色，边上的一个区间和端点 $i$ 距离最近，就染成染色 $i$。那么总交点个数即等于每条边的颜色段数和。</p>\n<h2>Hack 程序</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\nusing namespace std;\nint main(){\n  ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n  const int lx=-10000,rx=-9000,ly=-10000,ry=10000,m=250;\n  vector&#x3C;pair&#x3C;int,int>> node;\n  for(int i=1;i&#x3C;=m;i++){\n    node.push_back({rx,i*2-1});\n    node.push_back({lx,i*2-1});\n    node.push_back({lx,i*2});\n    node.push_back({rx,i*2});\n  }\n  for(int i=1;i&#x3C;=m;i++){\n    node.push_back({rx+i*2-1,ry});\n    node.push_back({rx+i*2-1,ly});\n    if(i!=m){\n      node.push_back({rx+i*2,ly});\n      node.push_back({rx+i*2,ry});\n    }else{\n      node.push_back({rx+m*2,ly-1});\n      node.push_back({rx,ly-1});\n    }\n  }\n// test data mode\n  cout&#x3C;&#x3C;node.size()&#x3C;&#x3C;endl;\n  for(auto x:node)cout&#x3C;&#x3C;x.first&#x3C;&#x3C;\" \"&#x3C;&#x3C;x.second&#x3C;&#x3C;endl;\n  cout&#x3C;&#x3C;endl;\n// geometry widget mode\n  // for(int i=0;i&#x3C;node.size();i++){\n  //   cout&#x3C;&#x3C;\"Segment \"&#x3C;&#x3C;node[i].first&#x3C;&#x3C;\" \"&#x3C;&#x3C;node[i].second;\n  //   cout&#x3C;&#x3C;\" \"&#x3C;&#x3C;node[(i+1)%node.size()].first&#x3C;&#x3C;\" \"&#x3C;&#x3C;node[(i+1)%node.size()].second&#x3C;&#x3C;endl;\n  // }\n}\n</code></pre>","frontmatter":{"date":"October 18, 2020","title":"「ICPC World Finals 2018」熊猫保护区","cover":"/cover/19.webp"}}},"pageContext":{"id":"51b2c027-0e92-5d1a-9416-c40a1794e1e2","slug":"blog/problem/icpcwf2018-g"}},"staticQueryHashes":[],"slicesMap":{}}