{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/loj3397/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>一个长度为 $n$ 的排列是正确的，当且仅当他不存在非平凡的连续子序列，使得他的值也是连续的。 对于 $k\\in[1,n]$ 求出，有多少长度为 $k$ 的正确的排列。</p>\n<p>$n\\le 10^5$。</p>\n</blockquote>\n<!--more-->\n<h2>题解 Part 1</h2>\n<p>定义 $F(x)=\\sum_{i\\ge 4}f_ix^i,\\ G(x)=\\sum_{i\\ge 2}g_ix^i,\\ H(x)=\\sum_{i\\ge 2}i!x^i$。</p>\n<p>其中 $f_i$ 表示有 $i$ 个叶子节点，根节点为析点且树高为 $2$ 的析合树数量，$g_i$ 表示有 $n$ 个叶子节点，根节点为合点，且孩子排列的相对大小关系是单调上升的析合树个数。注意到 $g_i$ 也同时表示孩子排列相对大小单调下降的析合树个数。</p>\n<p>考虑一个析合树是合法的，其本身节点的限制：</p>\n<ul>\n<li>如果一个点是析点，他的所有儿子都是析点。</li>\n<li>如果一个点是合点，且他的一个儿子也是合点，那么这两个点的单调性一定恰好相反。</li>\n</ul>\n<p>根据这两条我们可以得到关于上述生成函数的若干等式：</p>\n<p>$$\n\\begin{aligned}\n&#x26;G(x)=\\sum_{k\\ge 2}(H(x)-G(x))^k &#x26; (1)\\\n&#x26;F(H(x))=H(x)-2G(x)-x &#x26; (2)\\\n\\end{aligned}\n$$</p>\n<p>根据 $(1)$ 式我们可以解得 $G(x)=\\dfrac{H^2(x)}{H(x)+1}$。</p>\n<p>在 $(2)$ 式中带入 $H(x)$ 的复合逆 $I(x)$，有</p>\n<p>$$\n\\begin{aligned}\n&#x26;F(H(I(x)))=H(I(x))-2G(I(x))-I(x)\\\n\\Rightarrow\\ &#x26;F(x)=x-\\dfrac{2x^2}{x+1}-I(x)\n\\end{aligned}\n$$</p>\n<p>$x-\\dfrac{2x^2}{x+1}$ 部分对答案的贡献是容易计算的，故我们的瓶颈在于求出 $H(x)$ 的复合逆 $I(x)$。</p>\n<h2>题解 Part 2</h2>\n<p>现问题转化为，对于某函数 $\\displaystyle F(x)=\\sum_{i=1}^\\infty i!x^i$，计算其复合逆。</p>\n<p>考虑 $F(x)$ 满足如下微分方程（可以通过其递推式得到）</p>\n<p>$$\nF(x)=F'(x)\\cdot x^2+F(x)\\cdot x+x\n$$</p>\n<p>带入其复合逆 $G(x)$ 得到</p>\n<p>$$\n\\begin{aligned}\n&#x26;x=F'(G(x))\\cdot G^2(x)+ x\\cdot G(x)+G(x) \\\n\\Rightarrow\\ &#x26;x=\\frac{1}{G'(x)} G^2(x)+ x\\cdot G(x)+G(x) \\\n\\Rightarrow\\ &#x26;G^2(x)-G'(x)\\cdot x+(x+1)G(x)G'(x)=0\\\n\\end{aligned}\n$$</p>\n<p>考虑其中每一项都等于 $0$，得到递推式：</p>\n<p>$$\ng_n=\\begin{cases}\n0&#x26;(n=0)\\\n1&#x26;(n=1)\\\n-\\sum_{i=1}^{n-1}(i+1)g_ig_{n-i}-\\sum_{i=2}^{n-1}ig_ig_{n-i+1}&#x26;(n\\ge 2)\n\\end{cases}\n$$</p>\n<p>可以分治 NTT 或者半在线卷积。</p>\n<h2>反思</h2>\n<p>通过观察阶乘的递推公式，我们得到了关于其生成函数的一个一阶常微分方程，并用以解决多项式复合逆问题，从而提供了一种不同于拉格朗日反演的推导方式。</p>\n<p>想起之前做的“简单的普及组计数”，自己在这方面的水平仍需训练加强。</p>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\nnamespace mem{ //v2.10.1 => size: 15.80KiB\n  #ifdef memset0\n  #else\n    #define MEM_FASTIO\n  #endif\n\n  #ifdef __SIZEOF_INT128__\n    #define MEM_INT128\n  #endif\n\n  #define __integer_mapper(func)    \\\n      func(int)                     \\\n      func(unsigned int)            \\\n      func(long long int)           \\\n      func(unsigned long long int)\n  #define __float_mapper(func)        \\\n      func(float)                     \\\n      func(double)                    \\\n      func(long double)\n  \n  namespace stdval{\n    using i32=int;\n    using i64=long long;\n    using u32=unsigned;\n    using u64=unsigned long long;\n    using f32=float;\n    using f64=double;\n    using f96=long double;\n  #ifdef MEM_INT128\n    using i128=__int128_t;\n    using u128=__uint128_t;\n  #endif\n  }\n  \n  namespace utils{\n    using std::cin;\n    using std::tie;\n    using std::get;\n    using std::cout;\n    using std::cerr;\n    using std::endl;\n    using std::swap;\n    using std::sort;\n    using std::find;\n    using std::copy;\n    using std::fill;\n    using std::unique;\n    using std::reverse;\n    using std::shuffle;\n    using std::function;\n    using std::make_pair;\n    using std::make_tuple;\n    using std::accumulate;\n    using std::lower_bound;\n    using std::upper_bound;\n    using std::max_element;\n    using std::min_element;\n    using std::next_permutation;\n  }\n  \n  namespace random{\n    const int LuckyNumber=0726; // Kanbe Kotori's Birthday\n    std::mt19937 rng(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n    std::mt19937_64 rng64(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n    \n    template&#x3C;class T> inline T rand(T l,T r){return std::uniform_int_distribution&#x3C;T>(l,r)(rng);}\n    template&#x3C;class T> inline T rand64(T l,T r){return std::uniform_int_distribution&#x3C;T>(l,r)(rng);}\n  }\n  \n  namespace modint{\n    template&#x3C;const int mod> struct Z{\n      int x;\n      inline Z(){x=0;}\n      inline Z(int t){x=t;}\n      inline Z(long long t){x=t%mod,x&#x3C;0&#x26;&#x26;(x+=mod);}\n      \n      inline void operator-=(Z a){(x-=a.x)&#x3C;0&#x26;&#x26;(x+=mod);}\n      inline void operator+=(Z a){(x+=a.x)>=mod&#x26;&#x26;(x-=mod);}\n      inline void operator*=(Z a){x=(long long)x*a.x%mod;}\n      \n      friend inline Z operator*(Z a,Z b){return (long long)a.x*b.x%mod;}\n      friend inline Z operator-(Z a,Z b){return ((a.x-=b.x)&#x3C;0&#x26;&#x26;(a.x+=mod)),a;}\n      friend inline Z operator+(Z a,Z b){return ((a.x+=b.x)>=mod&#x26;&#x26;(a.x-=mod)),a;}\n    };\n    \n    template&#x3C;const int mod> inline Z&#x3C;mod> finv(Z&#x3C;mod> x){\n      if(x.x&#x3C;2)return x;\n      return (mod-mod/x.x)*finv(mod%x.x);\n    }\n    template&#x3C;const int mod> inline Z&#x3C;mod> fpow(Z&#x3C;mod> a,int b){\n      Z&#x3C;mod> s=1;\n      for(;b;b>>=1,a=a*a)\n        if(b&#x26;1)s=s*a;\n      return s;\n    }\n    \n    template&#x3C;const int mod> inline void init_inverse(int n,Z&#x3C;mod> *inv){\n      inv[0]=inv[1]=1;\n      for(int i=2;i&#x3C;n;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n    }\n    template&#x3C;const int mod> inline void init_factorial(int n,Z&#x3C;mod> *fac,Z&#x3C;mod> *ifac){\n      fac[0]=1,init_inverse(n,ifac);\n      for(int i=1;i&#x3C;n;i++)fac[i]=fac[i-1]*i,ifac[i]=ifac[i-1]*ifac[i];\n    }\n  }\n  \n  namespace math{\n    using namespace stdval;\n    using std::max;\n    using std::min;\n    template&#x3C;class T> inline T abs(T x){return x&#x3C;0?-x:x;}\n    template&#x3C;class T> inline T gcd(T n,T m){return m?gcd(m,n%m):n;}\n    template&#x3C;class T> inline T lcm(T n,T m){return n/gcd(n,m)*m;}\n    \n    struct FastDiv{\n      u64 t,i;\n      inline FastDiv(u64 p):t(u64(-1)/p),i(mul_inv(p)){}\n      \n      inline bool divide(u64 n){return n*i&#x3C;=t;}\n      inline bool divide(i64 n){return u64(n&#x3C;0?-n:n)*i&#x3C;=t;}\n      inline u64 mul_inv(u64 n){\n        u64 x=n;\n        for(int i=0;i&#x3C;5;++i)x*=2-n*x;\n        return x;\n      }\n    };\n  \n  #ifdef MEM_INT128\n    struct FastMod{\n      u64 m,b;\n      inline FastMod(u64 b):m(u64((u128(1)&#x3C;&#x3C;64)/b)),b(b){}\n      \n      inline u64 reduce(u64 a){\n        u64 q=(u64)((u128(m)*a)>>64);\n        u64 r=a-q*b;\n        return r>=b?r-b:r;\n      }\n    };\n  #endif\n  }\n  \n  namespace container{\n    using std::pair;\n    using std::tuple;\n    using std::set;\n    using std::multiset;\n    using std::unordered_set;\n    using std::unordered_multiset;\n    using std::map;\n    using std::multimap;\n    using std::unordered_map;\n    using std::unordered_multimap;\n    using std::queue;\n    using std::stack;\n    using std::priority_queue;\n    using std::deque;\n    using std::bitset;\n    \n    using std::tie;\n    using std::get;\n    using std::make_pair;\n    using std::make_tuple;\n    \n    template&#x3C;class T> struct vector:std::vector&#x3C;T>{\n      using std::vector&#x3C;T>::vector;\n      using iterator=typename std::vector&#x3C;T>::iterator;\n      using const_iterator=typename std::vector&#x3C;T>::const_iterator;\n      vector():std::vector&#x3C;T>(){}\n      explicit vector(const std::vector&#x3C;T> &#x26;plain):std::vector&#x3C;T>(plain){}\n      \n      inline void reverse(){std::reverse(this->begin(),this->end());}\n      inline void unique(){this->erase(std::unique(this->begin(),this->end()),this->end());}\n      inline void concat(const vector &#x26;rhs){this->insert(this->end(),rhs.begin(),rhs.end());}\n      inline bool includes(const T &#x26;x) const{return std::find(this->begin(),this->end(),x)!=this->end();}\n      template&#x3C;class Function> inline void forEach(Function func){for(const auto &#x26;it:*this)func(it);}\n      \n      inline iterator find(const T &#x26;x){return std::find(this->begin(),this->end(),x);}\n      inline iterator lower_bound(const T &#x26;x){return std::lower_bound(this->begin(),this->end(),x);}\n      inline iterator upper_bound(const T &#x26;x){return std::upper_bound(this->begin(),this->end(),x);}\n      inline const_iterator find(const T &#x26;x)const{return std::find(this->begin(),this->end(),x);}\n      inline const_iterator lower_bound(const T &#x26;x)const{return std::lower_bound(this->begin(),this->end(),x);}\n      inline const_iterator upper_bound(const T &#x26;x)const{return std::upper_bound(this->begin(),this->end(),x);}\n\n      inline void sort(){std::sort(this->begin(),this->end());}\n      template&#x3C;class Function> inline void sort(Function func){std::sort(this->begin(),this->end(),func);}\n      \n      inline vector slice(int l,int r) const{\n        if(l>r)return {};\n        if(r&#x3C;this->size())return vector(this->begin()+l,this->begin()+r);\n        vector rsp(this->begin()+l,this->end());\n        return rsp.resize(r-l),rsp;\n      }\n\n      inline void from(const std::set&#x3C;T> &#x26;src){\n        this->resize(src.size());\n        auto it=this->begin();\n        for(const T e:src)*it++=e;\n      }\n\n      template&#x3C;class R,class Function> inline vector&#x3C;R> _map(Function func) const{\n        vector&#x3C;R> res(this->size());\n        for(size_t i=0;i&#x3C;this->size();i++)\n          res[i]=func(this->operator[](i));\n        return res;\n      }\n      template&#x3C;class R> inline vector&#x3C;R> map(R func(T)) const{return this->_map&#x3C;R>(func);}\n      template&#x3C;class R> inline vector&#x3C;R> map(const std::function&#x3C;R(T)> &#x26;func) const{return this->_map&#x3C;R>(func);}\n    };\n    \n    struct string:std::string{\n      using std::string::string;\n      string():std::string(\"\"){}\n      string(const std::string &#x26;plain):std::string(plain){}\n      \n      template&#x3C;class T> inline string join(const vector&#x3C;T> &#x26;vet) const;\n            \n      inline string slice(int l,int r) const{\n        if(l>r)return {};\n        if(r&#x3C;this->size())return string(this->begin()+l,this->begin()+r);\n        string rsp(this->begin()+l,this->end());\n        return rsp.resize(r-l),rsp;\n      }\n      \n      vector&#x3C;string> split(const string &#x26;dim) const{\n        if(this->empty())return {};\n        char *src=new char[this->length()+1];\n        strcpy(src,this->c_str());\n        char *tar=new char[dim.length()+1];\n        strcpy(tar,dim.c_str());\n        vector&#x3C;string> rsp;\n        for(char *pos=strtok(src,tar);pos;pos=strtok(nullptr,tar))\n          rsp.push_back(string(pos));\n        delete[] src;\n        delete[] tar;\n        return rsp;\n      }\n      \n      template&#x3C;class... Args> static inline string format(const char *fm,Args... args){\n        int len=snprintf(nullptr,0,fm,args...);\n        char *buf=new char[len+1];\n        snprintf(buf,len+1,fm,args...);\n        string str(buf);\n        delete[] buf;\n        return str;\n      }\n      template&#x3C;class... Args> static inline string format(const string &#x26;fm,Args... args){\n        return format(fm.c_str(),args...);\n      }\n    };\n  \n  #define __to_string(T)                   \\\n      inline string to_string(const T &#x26;x){ \\\n        return std::to_string(x);          \\\n      }\n    __float_mapper(__to_string)\n    __integer_mapper(__to_string)\n  #undef __to_string\n    \n    inline string to_string(const string &#x26;s){return s;}\n    inline string to_string(const char *s){return string(s);}\n    inline string to_string(const std::string &#x26;s){return string(s);}\n    template&#x3C;const int mod> inline string to_string(const modint::Z&#x3C;mod> &#x26;v){return std::to_string(v.x);}\n    \n    template&#x3C;class T> inline string to_string(const vector&#x3C;T> &#x26;ctn){return \"[\"+string(\",\").join(ctn)+\"]\";}\n    template&#x3C;class T> inline string to_string(const set&#x3C;T> &#x26;ctn){\n      string result=\"{\";\n      bool flag=false;\n      for(const auto &#x26;it:ctn){\n        if(flag)result+=\",\";\n        flag=true;\n        result+=to_string(it);\n      }\n      return result+\"}\";\n    }\n    template&#x3C;class T1,class T2> inline string to_string(const map&#x3C;T1,T2> &#x26;ctn){\n      string result=\"{\";\n      bool flag=false;\n      for(const auto &#x26;it:ctn){\n        if(flag)result+=\",\";\n        flag=true;\n        result+=to_string(it.first)+\":\"+to_string(it.second);\n      }\n      return result+\"}\";\n    }\n    \n    template&#x3C;class T> inline string string::join(const vector&#x3C;T> &#x26;vet) const{\n      if(!vet.size())return \"\";\n      string res=to_string(vet[0]);\n      for(size_t i=1;i&#x3C;vet.size();i++){\n        res+=*this;\n        res+=to_string(vet[i]);\n      }\n      return res;\n    }\n    \n    inline string operator \"\" _s(const char *s){return string(s);}\n    inline string operator \"\" _s(const char *s,size_t len){return string(s,len);}\n    inline string operator \"\" _s(long double x){return to_string(x);}\n    inline string operator \"\" _s(unsigned long long int x){return to_string(x);}\n  }\n  \n  namespace io{\n  #ifdef MEM_FASTIO\n    namespace fastio{\n      const int BUFFER=1&#x3C;&#x3C;18;\n      char ibuf[BUFFER],*iS,*iT;\n      inline int getc(){\n        if(iS==iT){\n          iT=(iS=ibuf)+fread(ibuf,1,BUFFER,stdin);\n          return iS==iT?EOF:*iS++;\n        }else{\n          return *iS++;\n        }\n      }\n      char obuf[BUFFER],*oS=obuf,*oT=oS+BUFFER-1;\n      inline void flush(){\n        fwrite(obuf,1,oS-obuf,stdout);\n        oS=obuf;\n      }\n      inline void putc(int x){\n        *oS++=x;\n        if(oS==oT)flush();\n      }\n      struct Flusher{~Flusher(){flush();}}flusher;\n    }\n    using fastio::getc;\n    using fastio::putc;\n    inline void flush(){fastio::flush(),fflush(stdout);}\n  #else\n    inline int getc(){return getchar();}\n    inline void putc(int c){putchar(c);}\n    inline void flush(){fflush(stdout);}\n  #endif\n    \n    template&#x3C;class T> inline void read_digit(T &#x26;x){x=getc(); while(!isdigit(x))x=getc();}\n    template&#x3C;class T> inline void read_alpha(T &#x26;x){x=getc(); while(!isalpha(x))x=getc();}\n    template&#x3C;class T> inline void read_lower(T &#x26;x){x=getc(); while(!islower(x))x=getc();}\n    template&#x3C;class T> inline void read_upper(T &#x26;x){x=getc(); while(!isupper(x))x=getc();}\n    inline int read_digit(){int x; read_digit(x); return x;}\n    inline int read_alpha(){int x; read_alpha(x); return x;}\n    inline int read_lower(){int x; read_lower(x); return x;}\n    inline int read_upper(){int x; read_upper(x); return x;}\n  \n  #define __read(T)                             \\\n      inline void read(T &#x26;x) {                  \\\n        x=0; bool f=0; char c=getc();           \\\n        while(!isdigit(c))f^=c=='-',c=getc();   \\\n        while(isdigit(c))x=x*10+c-'0',c=getc(); \\\n        if(f)x=-x;                              \\\n      }\n    __integer_mapper(__read)\n    #ifdef MEM_INT128\n      __read(__int128_t)\n      __read(__uint128_t)\n    #endif\n  #undef __read\n    \n    inline void read(char &#x26;x){x=getc();}\n    inline void read(char *s){\n      char c=getc();\n      while(~c&#x26;&#x26;!isspace(c))*s++=c,c=getc();\n      *s++='\\0';\n    }\n    inline void read(container::string &#x26;s){\n      char c=getc();\n      s=\"\";\n      while(~c&#x26;&#x26;!isspace(c))s+=c,c=getc();\n    }\n    template&#x3C;const int mod> inline void read(const modint::Z&#x3C;mod> &#x26;x){read(x.x);}\n    \n    template&#x3C;class T=int> inline T read(){T x; read(x); return x;}\n    template&#x3C;class T,class... Args> inline void read(T &#x26;x,Args &#x26;... args){\n      read(x),read(args...);\n    }\n  \n  #define __print(T)           \\\n      inline void print(T x){  \\\n        if(x&#x3C;0)putc('-'),x=-x; \\\n        if(x>9)print(x/10);    \\\n        putc('0'+x%10);        \\\n      }\n    __integer_mapper(__print)\n    #ifdef MEM_INT128\n      __print(__int128_t)\n      __print(__uint128_t)\n    #endif\n  #undef __print\n    \n    inline void print(char x){putc(x);}\n    inline void print(const char *s){\n      size_t len=strlen(s);\n      for(size_t i=0;i&#x3C;len;i++)putc(s[i]);\n    }\n    inline void print(const container::string &#x26;s){\n      for(size_t i=0;i&#x3C;s.length();i++)putc(s[i]);\n    }\n    template&#x3C;const int mod> inline void print(const modint::Z&#x3C;mod> &#x26;x){print(x.x);}\n    \n    template&#x3C;class T,class... Args> inline void print(const T &#x26;x,Args... args){\n      print(x),print(args...);\n    }\n    template&#x3C;class... Args> inline void println(Args... args){\n      print(args...),putc('\\n');\n    }\n    \n    template&#x3C;class... Args> inline void printfm(const char *formatter,Args... arguments){\n      print(container::string().format(formatter,arguments...));\n    }\n    template&#x3C;class... Args> inline void printfm(const container::string &#x26;formatter,Args... arguments){\n      print(container::string().format(formatter,arguments...));\n    }\n  }\n  \n  namespace logger{\n    enum ConsoleColor{\n      NOPE=-1,BLACK,RED,GREEN,YELLOW,BLUE,PURPLE,DEEPBLUE\n    };\n    template&#x3C;const ConsoleColor color=NOPE,class... Args> inline void log(const char *formatter,Args... args){\n  #ifdef memset0\n      if(~color){\n        fprintf(stderr,\"\\033[%dm\",30+color);\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,\"\\033[0m\");\n      }else{\n        fprintf(stderr,formatter,args...);\n      }\n  #endif\n    }\n    template&#x3C;const ConsoleColor color=NOPE,class... Args> inline void logln(const char *formatter,Args... args){\n  #ifdef memset0\n      if(~color){\n        fprintf(stderr,\"\\033[%dm\",30+color);\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,\"\\033[0m\\n\");\n      }else{\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,\"\\n\");\n      }\n  #endif\n    }\n    template&#x3C;class T> inline void logs(const T &#x26;x){\n  #ifdef memset0\n      fprintf(stderr,container::to_string(x).c_str());\n  #endif\n    }\n    template&#x3C;class T,class... Args> inline void logs(const T &#x26;x,Args... args){\n      logs(x),logs(args...);\n    }\n    template&#x3C;class... Args> inline void logsln(Args... args){\n      logs(args...);\n  #ifdef memset0\n      fprintf(stderr,\"\\n\");\n  #endif\n    }\n  }\n  \n  namespace fileio{\n    inline void file_input(const char *dir){freopen(dir,\"r\",stdin);}\n    inline void file_output(const char *dir){freopen(dir,\"w\",stdout);}\n    inline void file_input(const std::string &#x26;dir){file_input(dir.c_str());}\n    inline void file_output(const std::string &#x26;dir){file_output(dir.c_str());}\n    inline void file_input(const container::string &#x26;dir){file_input(dir.c_str());}\n    inline void file_output(const container::string &#x26;dir){file_output(dir.c_str());}\n\n    template&#x3C;class T> inline void file_io(const T name){\n      using namespace container;\n      file_input(name+\".in\"_s);\n      file_output(name+\".out\"_s);\n    }\n\n    inline void fast_cpp_io(){\n      std::ios::sync_with_stdio(0);\n      std::cin.tie(0);\n      std::cout.tie(0);\n    }\n  }\n\n  #undef __integer_mapper\n  #undef __float_mapper\n  #undef __string_mapper\n  #undef __string_join_mapper\n\n  using namespace io;\n  using namespace math;\n  using namespace utils;\n  using namespace modint;\n  using namespace random;\n  using namespace stdval;\n  using namespace fileio;\n  using namespace logger;\n  using namespace container;\n} // namespace mem\n\nconst int N=1&#x3C;&#x3C;19,mod=998244353;\n\nnamespace polynomial{\n  namespace full{\n    using u32=unsigned;\n    using u64=unsigned long long;\n    using z=mem::modint::Z&#x3C;mod>;\n\n    const u32 mod=::mod;\n    z fac[N],ifac[N];\n    \n    inline z fpow(z a,int b){z s=1;for(;b;b>>=1,a=a*a)if(b&#x26;1)s=s*a;return s;}\n\n    struct poly:mem::container::vector&#x3C;z>{\n      using mem::container::vector&#x3C;z>::vector;\n      inline void input(){\n        for(int i=0;i&#x3C;this->size();i++){\n          mem::io::read(this->operator[](i).x);\n        }\n      }\n      inline void output()const{\n        for(int i=0;i&#x3C;this->size();i++){\n          mem::io::print(this->operator[](i).x);\n          if(i+1!=this->size())mem::io::putc(' ');\n        }\n        mem::io::putc('\\n');\n      }\n    };\n\n    namespace SimpleNTT{\n      u32 lim,shift,rev[N],w[N];\n      u64 a[N];\n      void dft_base_init(int N){\n        for(int wn,len=1;len&#x3C;N;len&#x3C;&#x3C;=1){\n          wn=fpow(3,(mod-1)/(len&#x3C;&#x3C;1)).x,w[len]=1;\n          for(int i=1;i&#x3C;len;i++)w[i+len]=((u64)w[i+len-1]*wn)%mod;\n        }\n      }\n      void dft_init(int len){\n        lim=1,shift=0;\n        while(lim&#x3C;len)lim&#x3C;&#x3C;=1,++shift;\n        for(int i=0;i&#x3C;lim;i++)rev[i]=(rev[i>>1]>>1)|((i&#x26;1)&#x3C;&#x3C;(shift-1));\n      }\n      void dft(u32 *f){\n        for(int i=0;i&#x3C;lim;i++)a[rev[i]]=f[i];\n        for(int len=1;len&#x3C;lim;len&#x3C;&#x3C;=1){\n          for(int i=0;i&#x3C;lim;i+=(len&#x3C;&#x3C;1))\n            for(int j=0;j&#x3C;len;j++){\n              u64 x=a[i+j],y=a[i+j+len]*w[j+len]%mod;\n              a[i+j]=x+y,a[i+j+len]=x+mod-y;\n            }\n          if(len==131072)for(int i=0;i&#x3C;lim;i++)a[i]%=mod;\n        }\n        for(int i=0;i&#x3C;lim;i++)f[i]=(u32)(a[i]%mod);\n      }\n      void idft(u32 *f){\n        dft(f);\n        std::reverse(f+1,f+lim);\n        u32 inv_lim=fpow((int)lim,mod-2).x;\n        for(int i=0;i&#x3C;lim;i++)f[i]=(u64)f[i]*inv_lim%mod;\n      }\n    }\n\n    namespace FastNTT{ // source: skip2004, https://uoj.ac/submission/415571\n      const u32 mod2=mod&#x3C;&#x3C;1;\n      u32 lim,shift;\n      struct multi_integer{\n        u32 val,ival;\n        inline multi_integer(){}\n        inline explicit multi_integer(u32 v){val=v,ival=((u64)v&#x3C;&#x3C;32)/mod;}\n        inline u32 operator*(u32 x)const{return val*x-u32((u64)x*ival>>32)*mod;}\n      }wn[N|1],iwn[N|1];\n\n      inline u32 get(u32 x){return ((u64)x&#x3C;&#x3C;32)/mod;}\n      inline u32 norm1(u32 x){return x>=mod?x-mod:x;}\n      inline u32 norm2(u32 x){return x>=mod2?x-mod2:x;}\n      inline u32 pow(u32 a,u32 b,u32 ans=1){for(;b;b>>=1,a=(u64)a*a%mod)if(b&#x26;1)ans=(u64)ans*a%mod;return ans;}\n      inline u32 multi(u32 w,u32 idx){return wn[idx]*w;}\n      inline u32 div_lim(u32 x){return (x+(u64)(-x&#x26;lim-1)*mod)>>shift;}\n      inline void fold(u32 *a){for(int i=0;i&#x3C;lim;i++)if(a[i]>=mod)a[i]-=mod;}\n\n      inline void dft_base_init(u32 len){\n        u32 N=1; for(;N&#x3C;len;)N&#x3C;&#x3C;=1;\n        const u32 mid=N>>1,w=pow(3,mod/N),iw=pow((mod+1)/3,mod/N);\n        wn[mid]=iwn[mid]=multi_integer(1);\n        for(u32 i=1;i&#x3C;mid;++i){\n          wn[mid+i]=multi_integer((u64)wn[mid+i-1].val*w%mod);\n          iwn[mid+i]=multi_integer((u64)iwn[mid+i-1].val*iw%mod);\n        }\n        for(u32 i=mid-1;(int)i>=0;--i)wn[i]=wn[i&#x3C;&#x3C;1],iwn[i]=iwn[i&#x3C;&#x3C;1];\n      }\n      inline void dft_init(u32 len){lim=1,shift=0;for(;lim&#x3C;len;)lim&#x3C;&#x3C;=1,++shift;}\n\n      inline void dft(u32 *a){\n      #define trans(a,b,idx) { \\\n          const u32 A=norm2(a+b); \\\n          b=wn[idx]*(a+mod2-b),a=A; \\\n        }\n      #define trans2(a,b) { \\\n          const u32 A=norm2(a+b); \\\n          b=norm2(a+mod2-b),a=A; \\\n        }\n        if(lim==1)return;\n        if(lim==2){trans(a[0],a[1],1);return fold(a);}\n        if(lim==4){trans2(a[0],a[2])trans(a[1],a[3],3)trans(a[0],a[1],1)trans(a[2],a[3],1);return fold(a);}\n        for(int mid=lim>>1;mid>2;mid>>=1)\n          for(int j=0;j&#x3C;lim;j+=mid+mid)\n            for(int k=0;k&#x3C;mid;k+=4){\n              trans(a[j+k+0],a[mid+j+k+0],mid+k+0);\n              trans(a[j+k+1],a[mid+j+k+1],mid+k+1);\n              trans(a[j+k+2],a[mid+j+k+2],mid+k+2);\n              trans(a[j+k+3],a[mid+j+k+3],mid+k+3);\n            }\n        for(int j=0;j&#x3C;lim;j+=8){\n          trans2(a[j+0],a[j+2])trans(a[j+1],a[j+3],3);\n          trans2(a[j+4],a[j+6])trans(a[j+5],a[j+7],3);\n        }\n        for(int j=0;j&#x3C;lim;j+=8){\n          trans2(a[j+0],a[j+1])trans2(a[j+2],a[j+3]);\n          trans2(a[j+4],a[j+5])trans2(a[j+6],a[j+7]);\n        }\n        for(int i=0;i&#x3C;lim;i++)if(a[i]>=mod)a[i]-=mod;\n        fold(a);\n      #undef trans\n      #undef trans2\n      }\n\n      inline void idft(u32 *a){\n      #define trans(a,b,idx) { \\\n          u32 _a=a,_b=b,A=norm2(_a),B=iwn[idx]*_b; \\\n          a=A+B,b=A+mod2-B; \\\n        }\n      #define trans2(a,b) { \\\n          const u32 A=norm2(a),B=norm2(b); \\\n          a=A+B,b=A+mod2-B; \\\n        }\n        if(lim==1)return;\n        if(lim==2){\n          const u32 A=a[0],B=a[1];\n          a[0]=div_lim(A+B),a[1]=div_lim(A+mod2-B);\n          return fold(a);\n        }\n        if(lim==4){\n          trans(a[0],a[1],1)trans(a[2],a[3],1)trans2(a[0],a[2])trans(a[1],a[3],3);\n          a[0]=div_lim(a[0]),a[1]=div_lim(a[1]),a[2]=div_lim(a[2]),a[3]=div_lim(a[3]);\n          return fold(a);\n        }\n        for(int j=0;j&#x3C;lim;j+=8){\n          trans2(a[j+0],a[j+1])trans2(a[j+2],a[j+3]);\n          trans2(a[j+4],a[j+5])trans2(a[j+6],a[j+7]);\n        }\n        for(int j=0;j&#x3C;lim;j+=8){\n          trans2(a[j+0],a[j+2])trans(a[j+1],a[j+3],3);\n          trans2(a[j+4],a[j+6])trans(a[j+5],a[j+7],3);\n        }\n        for(int mid=4;mid&#x3C;lim;mid&#x3C;&#x3C;=1)\n          for(int j=0;j&#x3C;lim;j+=mid+mid)\n            for(int k=0;k&#x3C;mid;k+=4){\n              trans(a[j+k+0],a[mid+j+k+0],mid+k+0);\n              trans(a[j+k+1],a[mid+j+k+1],mid+k+1);\n              trans(a[j+k+2],a[mid+j+k+2],mid+k+2);\n              trans(a[j+k+3],a[mid+j+k+3],mid+k+3);\n            }\n        for(int i=0;i&#x3C;lim;++i)a[i]=div_lim(a[i]);\n        fold(a);\n      #undef trans\n      #undef trans2\n      }\n    }\n\n    using namespace FastNTT;\n    inline void dft(z *a){dft((u32*)a);}\n    inline void idft(z *a){idft((u32*)a);}\n    inline void dft(poly &#x26;a){a.resize(lim),dft((u32*)&#x26;a[0]);}\n    inline void idft(poly &#x26;a){a.resize(lim),idft((u32*)&#x26;a[0]);}\n\n    inline poly mul(poly a,poly b,int len=-1){\n      if(!~len)len=(int)a.size()+(int)b.size()-1;\n      dft_init((int)a.size()+(int)b.size()-1);\n      dft(a),dft(b);\n      for(int i=0;i&#x3C;lim;i++)a[i]*=b[i];\n      idft(a);\n      return a.resize(len),a;\n    }\n\n    inline poly operator+(poly a,const poly &#x26;b){\n      if(b.size()>a.size())a.resize(b.size());\n      for(int i=0;i&#x3C;b.size();i++)a[i]+=b[i];\n      return a;\n    }\n    inline poly operator-(poly a,const poly &#x26;b){\n      if(b.size()>a.size())a.resize(b.size());\n      for(int i=0;i&#x3C;b.size();i++)a[i]-=b[i];\n      return a;\n    }\n    inline poly operator*(const poly &#x26;a,const poly &#x26;b){\n      return mul(a,b,(int)a.size()+(int)b.size()-1);\n    }\n\n    struct PolynomialInit{PolynomialInit(){dft_base_init(N);}}_polynomial_initer;\n  }\n  using full::z;\n  using full::poly;\n  using full::dft_init;\n  using full::dft;\n  using full::idft;\n  using full::mul;\n}\n\nusing namespace mem;\nusing namespace polynomial;\n\nint type,n;\nz a[N],b[N],c[N],d[N],e[N],f[N],g[N];\n\nvoid solve(int l,int r){\n  if(l+1==r){\n    if(l==1)g[l]=1;\n//\t\tfor(int j=1;j&#x3C;=l-1;j++)g[l]-=(j+1)*g[j]*g[l-j];\n//\t\tfor(int j=2;j&#x3C;=l-1;j++)g[l]-=j*g[j]*g[l-j+1];\n    return;\n  }\n  int m=(l+r)>>1,n=(r-l)>>1;\n  solve(l,m);\n  using polynomial::full::lim;\n  if(l==0){\n    dft_init((n&#x3C;&#x3C;1)-1);\n    for(int i=0;i&#x3C;n;i++)b[i]=g[i]*i;\n    memset(b+n,0,(lim-n)&#x3C;&#x3C;2),dft(b);\n    for(int i=0;i&#x3C;n;i++)c[i]=g[i];\n    memset(c+n,0,(lim-n)&#x3C;&#x3C;2),dft(c);\n    for(int i=0;i&#x3C;lim;i++)a[i]=b[i]+c[i];\n    for(int i=0;i&#x3C;lim;i++)a[i]*=c[i],b[i]*=c[i];\n    idft(a);\n    idft(b);\n    for(int i=0;i&#x3C;n;i++)g[m+i]-=a[n+i];\n    for(int i=0;i&#x3C;n-1;i++)g[m+i]-=b[n+i+1];\n  }else{\n    dft_init(n*3);\n    for(int i=0;i&#x3C;n;i++)b[i]=g[i+l]*(i+l);\n    memset(b+n,0,(lim-n)&#x3C;&#x3C;2),dft(b);\n    for(int i=0;i&#x3C;n;i++)c[i]=g[i+l];\n    memset(c+n,0,(lim-n)&#x3C;&#x3C;2),dft(c);\n    for(int i=0;i&#x3C;lim;i++)a[i]=b[i]+c[i];\n    for(int i=0;i&#x3C;=(n&#x3C;&#x3C;1);i++)e[i]=g[i]*i;\n    memset(e+(n&#x3C;&#x3C;1)+1,0,(lim-(n&#x3C;&#x3C;1)-1)&#x3C;&#x3C;2),dft(e);\n    for(int i=0;i&#x3C;=(n&#x3C;&#x3C;1);i++)f[i]=g[i];\n    memset(f+(n&#x3C;&#x3C;1)+1,0,(lim-(n&#x3C;&#x3C;1)-1)&#x3C;&#x3C;2),dft(f);\n    for(int i=0;i&#x3C;lim;i++)d[i]=e[i]+f[i];\n    for(int i=0;i&#x3C;lim;i++)a[i]*=f[i],b[i]*=f[i];\n    idft(a);\n    idft(b);\n    for(int i=0;i&#x3C;lim;i++)d[i]*=c[i],e[i]*=c[i];\n    idft(d);\n    idft(e);\n    for(int i=0;i&#x3C;n;i++)g[m+i]-=a[n+i]+d[n+i];\n    for(int i=0;i&#x3C;n;i++)g[m+i]-=b[n+i+1]+e[n+i+1];\n    if((n&#x3C;&#x3C;1)==l)g[(l&#x3C;&#x3C;1)-1]+=g[l]*g[l]*l;\n  }\n//\tlog(\"solve(%d,%d)=>%d\\n\",l,r,g[5].x);\n  solve(m,r);\n}\n\nint main(){\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n#endif\n  read(type,n);\n  int lim=1;\n  while(lim&#x3C;=n)lim&#x3C;&#x3C;=1;\n  solve(0,lim);\n//\tfor(int i=1;i&#x3C;=n;i++)println(g[i]);\n  for(int i=1;i&#x3C;=n;i++)f[i]=(i&#x26;1?2:mod-2)-g[i];\n  f[2]=2;\n  for(int i=1;i&#x3C;=n;i++)if(type||i==n)println(f[i]);\n}\n</code></pre>","frontmatter":{"date":"December 16, 2020","title":"「集训队作业2020」春天，在积雪下结一成形，抽枝发芽","cover":"/cover/12.png"}}},"pageContext":{"id":"8c1fe0e7-b94f-557b-bfd9-8841afbd40d7","slug":"blog/problem/loj3397"}},"staticQueryHashes":[],"slicesMap":{}}