{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/loj3401/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>给一个长度为 $n$ 的序列 $a_i$，和 $q$ 组询问 $(l,r,x)$，表示求 $\\displaystyle\\prod_{i=l}^r\\left(1-\\frac{a_i}{x}\\right)$ 的值。实数输出，精度要求 $10^{-6}$。</p>\n<p>$n,q\\le6\\times10^5,\\ 1\\leq a_i &#x3C; x\\leq 10^9$。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p>按照 EI 的话说，这是一个误差分析题。</p>\n<p>首先需要注意到这个式子可以泰勒展开：</p>\n<p>$$\n\\begin{aligned}\n&#x26;\\exp\\left(\\ln\\left(\\prod_{i=l}^r\\left(1-\\frac{a_i}{x}\\right)\\right)\\right) \\\n=&#x26;\\exp\\left(\\sum_{i=l}^r\\ln\\left(1-\\frac{a_i}{x}\\right)\\right) \\\n=&#x26;\\exp\\left(-\\sum_{i=l}^r\\sum_{k=1}^{L}\\frac{a_i^k}{k\\cdot x^k}\\right) \\\n\\end{aligned}\n$$</p>\n<p>然而，如果直接泰勒展开，需要的 $L$ 是数十万级别的，无益于我们解决问题。</p>\n<p>考虑到导致泰勒展开精度损失的主要原因，是因为当 $a_i/x$ 较大时，我们对 $\\ln(1-a_i/x)$ 的精度要求很高。然而，$a_i/x$ 较大时，很容易导致答案小于我们要求的精度范围。</p>\n<p>故我们不妨设定一个阈值 $R=0.5$，当 $a_i/x\\le R$ 时，考虑线段树维护泰勒展开；否则，当 $a_i/x>R$ 时，优先找出这些位置并暴力计算。当答案小于精度要求时就退出。暴力计算的次数显然不会超过 $\\log_2 10^6$ 次。</p>\n<p>这样就得到了一个 $O(n\\log^2L)$ 的做法，实践得 $L$ 取 $20$ 左右即可。</p>\n<p>可以通过本题，但时间较大。实际上，线段树的部分可以直接换为前缀和。为什么精度还在接受范围内呢？注意到 $x>a_i$ 对于任意 $x$ 和任意 $i$ 都成立。如果前缀和的部分因为 $a_i$ 太小被省略，他本身对泰勒展开的影响也是被省略的级别。换句话说，对于泰勒展开的值，前缀和能保证的精度范围，恰为 <code>double</code> 本身的精度范围。</p>\n<p>所以，直接将上述做法中的线段树替换为前缀和就能在 $O(n\\log nL)$ 的时间复杂度内解决本题。<del>三个 log 年轻人不讲武德。</del></p>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\nusing namespace std;\nconst int N=6e5+10,K=20;\nconst double eps=1e-10;\nint n,m,x,a[N],lg[N],st[20][N];\ndouble sum,ans;\nmt19937 rng(20040725);\ninline int better(int i,int j){return a[i]&#x3C;a[j]?j:i;}\ninline int query(int l,int r){\n  if(l==r)return l;\n  int k=lg[r-l];\n  return better(st[k][l],st[k][r-(1&#x3C;&#x3C;k)]);\n}\nstruct segment{\n  int l,r,mid;\n  double s[K];\n}p[N&#x3C;&#x3C;2];\nvoid build(int u,int l,int r){\n  p[u].l=l,p[u].r=r,p[u].mid=(l+r)>>1;\n  if(l==r){\n    p[u].s[0]=a[l];\n    for(int i=1;i&#x3C;K;i++)p[u].s[i]=p[u].s[i-1]*a[l];\n    return;\n  }\n  build(u&#x3C;&#x3C;1,l,p[u].mid);\n  build(u&#x3C;&#x3C;1|1,p[u].mid+1,r);\n  for(int i=0;i&#x3C;K;i++){\n    p[u].s[i]=p[u&#x3C;&#x3C;1].s[i]+p[u&#x3C;&#x3C;1|1].s[i];\n  }\n}\ndouble query(int u,int l,int r){\n  if(p[u].l==l&#x26;&#x26;p[u].r==r){\n    double sum=0;\n    for(int i=K-1;i>=0;i--){\n      sum=(sum+p[u].s[i]/(i+1))/x;\n    }\n    return sum;\n  }\n  if(r&#x3C;=p[u].mid)return query(u&#x3C;&#x3C;1,l,r);\n  if(l>p[u].mid)return query(u&#x3C;&#x3C;1|1,l,r);\n  return query(u&#x3C;&#x3C;1,l,p[u].mid)+query(u&#x3C;&#x3C;1|1,p[u].mid+1,r);\n}\nvoid solve(int l,int r){\n  if(l>r||ans&#x3C;eps){\n    return;\n  }\n  int pos=query(l,r);\n  if(a[pos]&#x3C;(x>>1)){\n    ans*=exp(-query(1,l,r));\n    return;\n  }\n  ans*=1-a[pos]/(double)x;\n  if(rng()&#x26;1){\n    solve(l,pos-1);\n    solve(pos+1,r);\n  }else{\n    solve(pos+1,r);\n    solve(l,pos-1);\n  }\n}\nint main(){\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n//    freopen(\"ex_gjx3.in\",\"r\",stdin);\n#endif\n  ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n  cout&#x3C;&#x3C;fixed&#x3C;&#x3C;setprecision(12);\n  lg[0]=-1;\n  for(int i=1;i&#x3C;N;i++)lg[i]=lg[i>>1]+1;\n  cin>>n>>m;\n  for(int i=1;i&#x3C;=n;i++)cin>>a[i];\n  for(int i=1;i&#x3C;n;i++){\n    st[0][i]=better(i,i+1);\n  }\n  for(int i=1;i&#x3C;20;i++)\n    for(int j=1;j+(1&#x3C;&#x3C;i)&#x3C;=n;j++){\n      st[i][j]=better(st[i-1][j],st[i-1][j+(1&#x3C;&#x3C;(i-1))]);\n    }\n  build(1,1,n);\n  for(int l,r,i=1;i&#x3C;=m;i++){\n    cin>>l>>r>>x;\n    ans=1;\n    solve(l,r);\n    cout&#x3C;&#x3C;1-ans&#x3C;&#x3C;endl;\n  }\n}\n</code></pre>","frontmatter":{"date":"December 17, 2020","title":"「集训队作业2020」Old Problem","cover":"/cover/13.png"}}},"pageContext":{"id":"1ca12269-9a71-563b-a47e-042c2c9536b9","slug":"blog/problem/loj3401"}},"staticQueryHashes":[],"slicesMap":{}}