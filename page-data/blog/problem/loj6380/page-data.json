{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/loj6380/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>定义区间树为线段树的拓展，即每次断开的位置可以不是线段的中心。</p>\n<p>给定一个 $[1, n]$ 的区间树和 $q$ 次询问，每次询问包含一个正整数 $k$, 你需要求出有多少区间的时间复杂度恰好等于 $k$。</p>\n<p>$n, q\\le 10^5,\\ k\\le 10^9$。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p>在线回答询问无意义，考虑利用生成函数处理出所有询问的答案。</p>\n<p>询问 $[l;r]$ 选中的线段（$ql=l \\land qr=r$ 的线段，而非经过的线段），LCA 往两侧深度单调减（且中间平的一段的长度至多为 $2$）。</p>\n<p>求出往两侧单调的生成函数合并，类似：</p>\n<p>$$\nL_u(x) = x (1 + L_l(x) + x (L_r(x) - x)) = x L_l(x) + x^2 L_r(x) + x - x^3 \\\nR_u(x) = x (1 + R_r(x) + x (R_l(x) - x)) = x R_r(x) + x^2 R_l(x) + x - x^3 \\\n$$</p>\n<p>其中 $L,R$ 分别表示左/右端点和当前线段的左/右端点相同的线段（不包括完全相同的情况）的生成函数，$u$ 是当前节点，$l$ 是左儿子，$r$ 是右儿子。</p>\n<p>处理一些平凡情况，在断点计算贡献：</p>\n<p>$$\nS_u(x) = x^{dep_u} (R_l(x) L_r(x) - x^2 + 1)\n$$</p>\n<p>就能做到 $\\text{polylog} \\times \\sum \\small{\\text{线段长度}}$ 复杂度。</p>\n<p>进一步优化复杂度，考虑边分治：假设当前处理子树 $u$，边分的子树 $v$。递归处理出 $u \\leftrightarrow v$ 的路径上的 $S,L,R$。下面考虑 $L_v,R_v$ 对路径上点的 $S$ 和 $u$ 的 $L,R$ 的贡献。</p>\n<p>前者可以分别考虑 $L_v,R_v$ 的贡献，通过两次卷积得到。后者则是路径上的 $L,R$ 通过一定位移得到。</p>\n<p>至于处理可以分别在两侧继续边分。复杂度 $O(n \\log^2 n)$。</p>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\ntemplate&#x3C;class T> inline void read(T &#x26;x){\n  x=0; register char c=getchar(); register bool f=0;\n  while(!isdigit(c))f^=c=='-',c=getchar();\n  while(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\ntemplate&#x3C;class T> inline void print(T x){\n  if(x&#x3C;0)putchar('-'),x=-x;\n  if(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate&#x3C;class T> inline void print(T x,char c){print(x),putchar(c);}\nconst int N=2e5+10,mod=998244353;\nint _,n,m,cnt,siz[N],vis[N],mid[N],ch[N][2],fa[N],l[N],r[N],dep[N],rev[N&#x3C;&#x3C;2];\nstruct z {\n  int x;\n  z(int x=0):x(x){}\n  friend inline z operator*(z a,z b){return (long long)a.x*b.x%mod;}\n  friend inline z operator-(z a,z b){return (a.x-=b.x)&#x3C;0?a.x+mod:a.x;}\n  friend inline z operator+(z a,z b){return (a.x+=b.x)>=mod?a.x-mod:a.x;}\n}w[N&#x3C;&#x3C;2];\nstd::vector&#x3C;z> ans;\ninline z fpow(z a,int b){z s=1;for(;b;b>>=1,a=a*a)if(b&#x26;1)s=s*a;return s;}\ninline void print(const std::vector&#x3C;z> &#x26;a){for(int i=0;i&#x3C;a.size();i++)printf(\"%d \",a[i].x); printf(\"\\n\");}\nvoid dft(std::vector&#x3C;z> &#x26;a,int lim){\n  a.resize(lim);\n  for(int i=0;i&#x3C;lim;i++)if(i&#x3C;rev[i])std::swap(a[i],a[rev[i]]);\n  for(int len=1;len&#x3C;lim;len&#x3C;&#x3C;=1)\n    for(int i=0;i&#x3C;lim;i+=(len&#x3C;&#x3C;1))\n      for(int j=0;j&#x3C;len;j++){\n        z x=a[i+j],y=a[i+j+len]*w[j+len];\n        a[i+j]=x+y,a[i+j+len]=x-y;\n      }\n}\nstd::vector&#x3C;z> operator+(std::vector&#x3C;z> a,const std::vector&#x3C;z> &#x26;b){\n  a.resize(std::max(a.size(),b.size()));\n  for(int i=0;i&#x3C;b.size();i++)a[i]=a[i]+b[i]; return a;\n}\nstd::vector&#x3C;z> operator-(std::vector&#x3C;z> a,const std::vector&#x3C;z> &#x26;b){\n  a.resize(std::max(a.size(),b.size()));\n  for(int i=0;i&#x3C;b.size();i++)a[i]=a[i]-b[i]; return a;\n}\nstd::vector&#x3C;z> operator*(std::vector&#x3C;z> a,std::vector&#x3C;z> b){\n  int len=a.size()+b.size()-1,lim=1,k=0;\n  while(lim&#x3C;len)lim&#x3C;&#x3C;=1,++k;\n  for(int i=0;i&#x3C;lim;i++)rev[i]=rev[i>>1]>>1|((i&#x26;1)&#x3C;&#x3C;(k-1));\n  dft(a,lim),dft(b,lim);\n  for(int i=0;i&#x3C;lim;i++)a[i]=a[i]*b[i];\n  dft(a,lim),std::reverse(&#x26;a[1],&#x26;a[lim]);\n  z inv=fpow(lim,mod-2);\n  for(int i=0;i&#x3C;lim;i++)a[i]=a[i]*inv;\n  return a.resize(len),a;\n}\nvoid shift(z x,std::vector&#x3C;z> &#x26;dst,size_t dta){\n  dst.resize(std::max(dst.size(),dta+1));\n  dst[dta]=dst[dta]+x;\n}\nvoid shift(const std::vector&#x3C;z> &#x26;src,std::vector&#x3C;z> &#x26;dst,size_t dta){\n  dst.resize(std::max(dst.size(),src.size()+dta));\n  for(int i=0;i&#x3C;src.size();i++)dst[i+dta]=dst[i+dta]+src[i];\n}\nvoid dfsInit(int &#x26;u,int l,int r,int dep){\n  if(l==r){\n    u=n-1+l;\n  }else{\n    u=++cnt;\n    dfsInit(ch[u][0],l,mid[u],dep+1),fa[ch[u][0]]=u;\n    dfsInit(ch[u][1],mid[u]+1,r,dep+1),fa[ch[u][1]]=u;\n  }\n  ::l[u]=l,::r[u]=r,::dep[u]=dep;\n}\nint calcSize(int u){\n  if(!u||vis[u])return 0;\n  return siz[u]=1+calcSize(ch[u][0])+calcSize(ch[u][1]);\n}\nstd::pair&#x3C;int,int> findSubTree(int u,int lim){\n  if(!u||vis[u])return {-1,-1};\n  if(siz[u]&#x3C;lim)return {u,siz[u]};\n  std::pair&#x3C;int,int> x=ch[u][0]?findSubTree(ch[u][0],lim):std::make_pair(-1,-1);\n  std::pair&#x3C;int,int> y=ch[u][1]?findSubTree(ch[u][1],lim):std::make_pair(-1,-1);\n  return x.second>y.second?x:y;\n}\nvoid calc(bool fl,int u,int mov,std::vector&#x3C;z> &#x26;f){\n  if(vis[u]||l[u]==r[u])return shift(1,f,mov+1);\n  shift(1,f,mov+1);\n  shift(mod-1,f,mov+3);\n  calc(fl,ch[u][0],mov+(fl?2:1),f);\n  calc(fl,ch[u][1],mov+(fl?1:2),f);\n}\nstd::pair&#x3C;std::vector&#x3C;z>,std::vector&#x3C;z>> fuck(int u){\n  if(vis[u]||l[u]==r[u])return {{0,1},{0,1}};\n  std::vector&#x3C;z> Ll,Lr,Rl,Rr,Lu,Ru;\n  Lu=Ru=std::vector&#x3C;z>{0,1,0,mod-1};\n  std::tie(Ll,Rl)=fuck(ch[u][0]);\n  std::tie(Lr,Rr)=fuck(ch[u][1]);\n  shift(Ll,Lu,1),shift(Lr,Lu,2);\n  shift(Rr,Ru,1),shift(Rl,Ru,2);\n  shift(Rl*Lr,ans,dep[u]);\n  return {Lu,Ru};\n}\nstd::pair&#x3C;std::vector&#x3C;z>,std::vector&#x3C;z>> solve(int u){\n  if(vis[u]||l[u]==r[u])return {{0,1},{0,1}};\n  int siz=calcSize(u);\n  int v=findSubTree(u,(siz*2)/4).first;\n  if(v==-1)return fuck(u);\n  std::vector&#x3C;z> Lu,Ru,Lv,Rv,Lt,Rt,T;\n  std::tie(Lv,Rv)=solve(v);\n  vis[v]=1;\n  std::tie(Lu,Ru)=solve(u);\n  vis[v]=0;\n  int lmov=0,rmov=0;\n  for(int p=v;p!=u;lmov+=ch[fa[p]][0]==p?1:2,rmov+=ch[fa[p]][0]==p?2:1,p=fa[p]){\n    int f=fa[p],q=ch[f][0]==p?ch[f][1]:ch[f][0];\n    if(ch[f][0]==p){\n      T.clear(),calc(0,q,0,T),shift(T,Lt,rmov+dep[f]-dep[u]);\n    }else{\n      T.clear(),calc(1,q,0,T),shift(T,Rt,lmov+dep[f]-dep[u]);\n    }\n  }\n  shift(mod-1,Lv,1);\n  shift(mod-1,Rv,1);\n  shift(Lv*Rt,ans,dep[u]);\n  shift(Rv*Lt,ans,dep[u]);\n  shift(Lv,Lu,lmov);\n  shift(Rv,Ru,rmov);\n  return {Lu,Ru};\n}\nvoid solution(){\n  for(int i=1;i&#x3C;n;i++)read(mid[i]);\n  dfsInit(_,1,n,1);\n  solve(1);\n  for(int i=1;i&#x3C;(n&#x3C;&#x3C;1);i++)shift(1,ans,dep[i]);\n  for(int i=1;i&#x3C;n;i++)shift(mod-1,ans,dep[i]+2);\n  for(int i=1,q;i&#x3C;=m;i++){\n    read(q);\n    print(q&#x3C;ans.size()?ans[q].x:0,'\\n');\n  }\n}\nvoid recycle(){\n  cnt=0;\n  ans.clear();\n  memset(ch,0,sizeof(ch));\n  memset(fa,0,sizeof(fa));\n}\nint main(){\n  for(int len=1;len&#x3C;(N&#x3C;&#x3C;1);len&#x3C;&#x3C;=1){\n    z wn=fpow(3,(mod-1)/(len&#x3C;&#x3C;1)); w[len]=1;\n    for(int i=1;i&#x3C;len;i++)w[i+len]=w[i+len-1]*wn;\n  }\n  while(~scanf(\"%d%d\",&#x26;n,&#x26;m))solution(),recycle();\n}\n</code></pre>","frontmatter":{"date":"June 02, 2020","title":"「是男人就过8题——Pony.ai」IntervalTree","cover":"/cover/9.png"}}},"pageContext":{"id":"cb15de9b-ce12-5680-a040-cde2e3ff54e4","slug":"blog/problem/loj6380"}},"staticQueryHashes":[],"slicesMap":{}}