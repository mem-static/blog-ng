{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/luogu4156/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>给定一个字符串 $s$，假设其 border 集合为 $S$，则每次你可以在 $s$ 后面接上一个长度为 $|s| - x$ 的字符串，其中 $x \\in S$。问在总长度 $\\leq w$ 的情况下有多少种可能的本质不同的长度。</p>\n<p>$n \\leq 5 \\times 10^5,\\ w \\leq 10^{18}$。</p>\n</blockquote>\n<!--more-->\n<h4>题解</h4>\n<p>做法和哥哥们的好像不大一样，不过本质应该差不多，但还是厚颜无耻的来水一篇。</p>\n<p>border 的贡献是若干端等差数列，不妨设其中一段为 $kx + b$，其中 $x \\in [0,l]$，考虑其产生的贡献整理后可以理解为三种：</p>\n<ul>\n<li>长度为 $b$ 的贡献，可以选择 $\\inf$ 次；</li>\n<li>长度为 $lk + b$ 的贡献，可以选择 $\\inf$ 次；</li>\n<li>长度为 $(0...l)k + b$ 的贡献，可以选择 $1$ 次。</li>\n</ul>\n<p>考虑前两种贡献，就是朴素的同余最短路问题。考虑先计算出他们的 dis 数组，再转移上第三类贡献。</p>\n<p>对于每一种等差数列分开处理，分模 $k$ 的余数讨论，容易发现可以直接用单调队列维护下转移。</p>\n<p>同余最短路跑 spfa 是线性的，可以直接用（。</p>\n<p>时间复杂度 $O(n \\log w)$。</p>\n<h4>代码</h4>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\ntemplate&#x3C;class T> inline void read(T &#x26;x){\n\tx=0; register char c=getchar(); register bool f=0;\n\twhile(!isdigit(c))f^=c=='-',c=getchar();\n\twhile(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\nconst int N=5e5+10;\nint T,n,fl,mod;\nchar s[N];\nlong long w,ans,t[N],dis[2][N];\nstd::vector&#x3C;int> key;\nstruct atom{\n\tint b,k,l;\n};\nstd::vector&#x3C;atom> res;\nnamespace priority_queue{\n\tint nod;\n\tstruct node{\n\t\tint pre,nxt,i;\n\t\tlong long x;\n\t}e[N&#x3C;&#x3C;1];\n\tinline void init(){\n\t\tnod=0;\n\t}\n\tstruct set{\n\t\tint lim,hed,til;\n\t\tinline void reset(int l){\n\t\t\thed=til=0,lim=l;\n\t\t}\n\t\tinline void pop_front(){\n\t\t\tif(hed==til)hed=til=0;\n\t\t\telse{\n\t\t\t\te[e[til].pre].nxt=0;\n\t\t\t\ttil=e[til].pre;\n\t\t\t}\n\t\t}\n\t\tinline void pop_back(){\n\t\t\tif(hed==til)hed=til=0;\n\t\t\telse{\n\t\t\t\te[e[hed].nxt].pre=0;\n\t\t\t\thed=e[hed].nxt;\n\t\t\t}\n\t\t}\n\t\tinline void push_back(int i,long long x){\n\t\t\te[++nod].i=i,e[nod].x=x;\n\t\t\tif(!hed){\n\t\t\t\thed=til=nod;\n\t\t\t\te[nod].pre=e[nod].nxt=0;\n\t\t\t}else{\n\t\t\t\te[nod].nxt=hed,e[hed].pre=nod;\n\t\t\t\thed=nod;\n\t\t\t}\n\t\t}\n\t\tinline void insert(int i,long long x){\n\t\t\twhile(hed&#x26;&#x26;e[hed].x>x)pop_back();\n\t\t\tpush_back(i,x);\n\t\t\twhile(e[til].i&#x3C;i-lim)pop_front();\n\t\t}\n\t\tinline long long query(){return e[til].x;}\n\t};\n}\npriority_queue::set set[N];\nnamespace border_finder{\n\tconst int b=131131,p1=998244353,p2=1e9+7;\n\tint f[N],g[N],pf[N],pg[N];\n\tstd::vector&#x3C;int> vet;\n\tinline int query(int l,int r,int *a,int *pa,int p){\n\t\tint res=(a[r]-(long long)a[l-1]*pa[r-l+1])%p;\n\t\treturn res&#x3C;0?res+p:res;\n\t}\n\tvoid solve(int n){\n\t\tpf[0]=pg[0]=1,vet.clear(),res.clear();\n\t\tfor(int i=1;i&#x3C;=n;i++){\n\t\t\tpf[i]=(long long)pf[i-1]*b%p1;\n\t\t\tpg[i]=(long long)pg[i-1]*b%p2;\n\t\t\tf[i]=((long long)f[i-1]*b+s[i]-'a')%p1;\n\t\t\tg[i]=((long long)g[i-1]*b+s[i]-'a')%p2;\n\t\t}\n\t\tfor(int i=n-1;i>=1;i--)\n\t\t\tif(query(1,i,f,pf,p1)==query(n-i+1,n,f,pf,p1)&#x26;&#x26;query(1,i,g,pg,p2)==query(n-i+1,n,g,pg,p2))\n\t\t\t\tvet.push_back(n-i);\n\t\tvet.push_back(n);\n\t\tint first=vet[0],delta=0,cnt=0;\n\t\tfor(int i=1;i&#x3C;vet.size();i++)if(!delta){\n\t\t\tdelta=vet[i]-vet[i-1],cnt=1;\n\t\t}else{\n\t\t\tif(vet[i]-vet[i-1]==delta)++cnt;\n\t\t\telse{\n\t\t\t\tres.push_back((atom){first,delta,cnt});\n\t\t\t\tfirst=vet[i],delta=0,cnt=0;\n\t\t\t}\n\t\t}\n\t\tres.push_back((atom){first,delta,cnt});\n\t}\n}\nvoid spfa(std::vector&#x3C;int> &#x26;key,long long *dis){\n\tstatic int l,r,q[N&#x3C;&#x3C;3]; static bool inq[N];\n\tmod=*std::max_element(key.begin(),key.end());\n\tmemset(dis,63,mod&#x3C;&#x3C;3);\n\tq[l=r=1]=dis[0]=0;\n\twhile(l&#x3C;=r){\n\t\tint u=q[l++]; inq[u]=0;\n\t\tfor(int w:key){\n\t\t\tint c=(u+w)/mod; int v=u+w-c*mod;\n\t\t\tif(dis[u]+c&#x3C;dis[v]){\n\t\t\t\tdis[v]=dis[u]+c;\n\t\t\t\tif(!inq[v])inq[v]=1,q[++r]=v;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid trans(long long *f,long long *g,const atom &#x26;it){\n\tif(!it.l){\n\t\tfor(int i=0;i&#x3C;mod;i++){\n\t\t\tg[i]=std::min(f[i],f[(i-it.b+mod)%mod]);\n\t\t}\n\t\treturn;\n\t}\n\tmemset(t,63,mod&#x3C;&#x3C;3),priority_queue::init();\n\tfor(int i=0;i&#x3C;it.k;i++)set[i].reset(it.l);\n\tfor(int i=-mod;i&#x3C;mod;i++){\n\t\tauto &#x26;set=::set[(i+mod)%it.k];\n\t\tset.insert((i+mod)/it.k,i&#x3C;0?f[i+mod]+1:f[i]);\n\t\tif(i>=0)t[i]=set.query();\n\t}\n\tfor(int i=0;i&#x3C;mod;i++){\n\t\tg[i]=std::min(f[i],i&#x3C;it.b?t[i-it.b+mod]+1:t[i-it.b]);\n\t}\n}\nint main(){\n\tfor(read(T);T--;ans=0,key.clear()){\n\t\tscanf(\"%d%lld%s\",&#x26;n,&#x26;w,s+1);\n\t\tif(w&#x3C;n){puts(\"0\"); continue;}\n\t\tborder_finder::solve(n);\n\t\tfor(auto x:res){\n\t\t\tkey.push_back(x.b);\n\t\t\tif(x.l)key.push_back(x.b+x.k*x.l);\n\t\t}\n\t\tspfa(key,dis[fl]);\n\t\tfor(auto x:res){\n\t\t\ttrans(dis[fl],dis[fl^1],x);\n\t\t\tfl^=1;\n\t\t}\n\t\tfor(int i=0;i&#x3C;mod;i++)if(dis[fl][i]!=4557430888798830399){\n\t\t\tans+=std::max(0ll,(w-n-i)/mod+1-dis[fl][i]);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n</code></pre>","frontmatter":{"date":"April 26, 2020","title":"「WC2016」论战捆竹竿","cover":"/cover/6.png"}}},"pageContext":{"id":"118e4583-0966-5572-98a3-dba2c9049cec","slug":"blog/problem/luogu4156"}},"staticQueryHashes":[],"slicesMap":{}}