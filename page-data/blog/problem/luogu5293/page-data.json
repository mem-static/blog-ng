{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/luogu5293/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>有一张顶点数为 $(L+1)\\times n$ 的有向图。这张图的每个顶点由一个二元组$(u,v)$表示$(0\\le u\\le L,1\\le v\\le n)$。\n这张图不是简单图，对于任意两个顶点 $(u_1,v_1)(u_2,v_2)$，如果 $u_1&#x3C;u_2$，则从 $(u_1,v_1)$ 到 $(u_2,v_2)$ 一共有 $w[v_1][v_2]$ 条不同的边，如果 $u_1\\ge u_2$ 则没有边。</p>\n<p>白兔将在这张图上上演一支舞曲。白兔初始时位于该有向图的顶点 $(0,x)$。</p>\n<p>白兔将会跳若干步。每一步，白兔会从当前顶点沿任意一条出边跳到下一个顶点。白兔可以在任意时候停止跳舞（也可以没有跳就直接结束）。当到达第一维为 $L$ 的顶点就不得不停止，因为该顶点没有出边。</p>\n<p>假设白兔停止时，跳了 $m$ 步，白兔会把这只舞曲给记录下来成为一个序列。序列的第 $i$ 个元素为它第 $i$ 步经过的边。</p>\n<p>问题来了：给定正整数 $k$ 和 $y$（$1\\le y\\le n$），对于每个 $t$（$0\\le t&#x3C;k$），求有多少种舞曲（假设其长度为 $m$）满足 $m \\bmod k=t$，且白兔最后停在了坐标第二维为 $y$ 的顶点？</p>\n<p>两支舞曲不同定义为它们的长度（$m$）不同或者存在某一步它们所走的边不同。</p>\n<p>输出的结果对 $p$ 取模。保证 $p$ 是质数，$10^8 \\leq p \\leq 2^{30}$。</p>\n<p>$1 \\leq n \\leq 3,\\ 1 \\leq k \\leq 65536$。</p>\n</blockquote>\n<p>对于 $n=1$ 的情况，考虑令 $a = w_{1, 1}$ ，用 $f_i$ 表示跳了 $i$ 步的答案，则 $f_i = a^i \\binom n i$ 。</p>\n<p>考虑</p>\n<p>$$\n\\begin{aligned}\nans\n&#x26;= \\sum_{i \\bmod k=m} f_i = \\sum_{i \\bmod k=m} a^i \\binom ni \\\n&#x26;= \\sum_{i=0}^n [k|i-m] a^i \\binom ni \\\n&#x26;= \\sum_{i=0}^n \\frac 1k \\sum_{j=0}^{k-1} \\omega_k^{j(i-m)} a^i \\binom ni \\\n&#x26;= \\frac 1k \\sum_{j=0}^{k-1} \\omega^{-mj}<em>k \\sum</em>{i=0}^n \\binom ni (\\omega^{j}<em>k a)^i 1^{n-i} \\\n&#x26;= \\frac 1k \\sum</em>{i=0}^{k-1} \\omega^{-mi}_k \\left(\\omega^i_k a + 1\\right)^n\n\\end{aligned}\n$$</p>\n<p>考虑后面的 $\\displaystyle{\\left(\\omega^i_k a + 1\\right)^n}$ 对于固定的 $i$ 是相同的，可以与先处理出 $i \\in [0, k)$ 的值，设为 $c(i)$。</p>\n<p>一个暴力是多项式多点求值出多项式 $\\displaystyle{\\frac 1k \\sum_{i=0}^{k-1} x^i c(i)}$ 在 $\\omega_k^0, \\omega_k^{-1}, \\omega_k^{-2} ... \\omega_k^{-k+1}$ 的值，复杂度 $O(k \\log^2 k)$，有学长写了一发，貌似被针对了过不去 ...</p>\n<p>考虑是否有更优秀的做法来处理 $\\omega^{-mj}$？毛爷爷论文中提到把 $ij$ 拆成 $\\frac {(i+j)^2} 2 - \\frac {i^2} 2 - \\frac {j^2} 2$ ，然而可能存在单位根没有二次剩余的情况。考虑把 $ij$ 拆成 $\\binom {i+j} 2 - \\binom i2 - \\binom j2$ ，那么原式可以化为</p>\n<p>$$\n\\begin{aligned}\nans\n&#x26;= \\frac 1k \\sum_{i=0}^{k-1} \\omega^{-mi}<em>k c(i) \\\n&#x26;= \\frac 1k \\sum</em>{i=0}^{k-1} \\omega^{\\binom {i-m} 2 - \\binom i2 - \\binom {-m}2} <em>k c(i) \\\n&#x26;= \\frac {\\omega^{- \\binom {-m}2}} k \\sum</em>{i=0}^{k-1} \\omega^{\\binom {i-m} 2}_k \\left( \\omega^{- \\binom i2}_k  c(i)\\right)  \\\n\\end{aligned}\n$$</p>\n<p>是一个卷积的形式，复杂度 $O(k \\log k)$。</p>\n<p>考虑 $n \\le 3$ 的情况，原来的转移会变成矩阵，类似于 BZOJ3328 PYXFIB，可以发现 $c(i)$ 仍然是一个常数，同理卷积即可。</p>\n<!--more-->\n<p>代码：</p>\n<pre><code class=\"language-cpp\">// =================================\n//   author: memset0\n//   date: 2019.04.08 17:56:11\n//   website: https://memset0.cn/\n// =================================\n#include &#x3C;bits/stdc++.h>\n#define ll long long\n#define debug(...) ((void)0)\n#ifndef debug\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#endif\nnamespace ringo {\ntemplate &#x3C;class T> inline void read(T &#x26;x) {\n\tx = 0; register char c = getchar(); register bool f = 0;\n\twhile (!isdigit(c)) f ^= c == '-', c = getchar();\n\twhile (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n\tif (f) x = -x;\n}\ntemplate &#x3C;class T> inline void print(T x) {\n\tif (x &#x3C; 0) putchar('-'), x = -x;\n\tif (x > 9) print(x / 10);\n\tputchar('0' + x % 10);\n}\ntemplate &#x3C;class T> inline void print(T x, char c) { print(x), putchar(c); }\n\nconst int N = 7e4 + 10;\nint n, k, L, x, y, mod;\nint c[N], w[N], ans[N];\n\ninline int dec(int a, int b) { a -= b; return a &#x3C; 0 ? a + mod : a; }\ninline int sub(int a, int b) { a += b; return a >= mod ? a - mod : a; }\ninline int mul(int a, int b) { return (ll)a * b - (ll)a * b / mod * mod; }\ninline int inv(int x) { return x &#x3C; 2 ? 1 : mul(mod - mod / x, inv(mod % x)); }\ntemplate &#x3C;class T> inline int get_omega(T x) { x = x % k; return w[x &#x3C; 0 ? x + k : x]; }\ninline int fpow(int a, int b) { int s = 1; for (; b; b >>= 1, a = mul(a, a)) if (b &#x26; 1) s = mul(s, a); return s; }\n\nint get_root(int p) {\n\tint phi = 1, tmp = p;\n\tfor (int i = 2; i * i &#x3C;= tmp; i++)\n\t\tif (tmp % i == 0) {\n\t\t\tphi *= i - 1, tmp /= i;\n\t\t\twhile (tmp % i == 0) phi *= i, tmp /= i;\n\t\t}\n\tif (tmp != 1) phi *= tmp - 1;\n\tstd::vector &#x3C;int> e(1, 1);\n\tfor (int i = 2; i * i &#x3C;= phi; i++)\n\t\tif (phi % i == 0) {\n\t\t\te.push_back(i);\n\t\t\tif (i * i != phi) e.push_back(phi / i);\n\t\t}\n\tfor (int w = 2; ; w++) {\n\t\tbool flag = true;\n\t\tfor (std::vector &#x3C;int> ::iterator it = e.begin(); it != e.end(); it++)\n\t\t\tif (fpow(w, *it) == 1) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (flag) return w;\n\t}\n}\n\nstruct matrix {\n\tint a[3][3];\n\tinline void out() const {\n\t\tfor (register int i = 0; i &#x3C; 3; i++)\n\t\t\tfor (register int j = 0; j &#x3C; 3; j++)\n\t\t\t\tprint(a[i][j], \" \\n\"[j == 2]);\n\t\tputs(\"\");\n\t}\n\tfriend inline matrix operator + (matrix a, const matrix &#x26;b) {\n\t\tfor (register int i = 0; i &#x3C; 3; i++)\n\t\t\tfor (register int j = 0; j &#x3C; 3; j++)\n\t\t\t\ta.a[i][j] = sub(a.a[i][j], b.a[i][j]);\n\t\treturn a;\n\t}\n\tfriend inline matrix operator * (matrix a, int b) {\n\t\tfor (register int i = 0; i &#x3C; 3; i++)\n\t\t\tfor (register int j = 0; j &#x3C; 3; j++)\n\t\t\t\ta.a[i][j] = mul(a.a[i][j], b);\n\t\treturn a;\n\t}\n\tfriend inline matrix operator * (const matrix &#x26;a, const matrix &#x26;b) {\n\t\tmatrix c; memset(c.a, 0, sizeof(c.a));\n\t\tfor (register int i = 0; i &#x3C; 3; i++)\n\t\t\tfor (register int j = 0; j &#x3C; 3; j++)\n\t\t\t\tfor (register int k = 0; k &#x3C; 3; k++)\n\t\t\t\t\tc.a[i][j] = (c.a[i][j] + (ll)a.a[i][k] * b.a[k][j]) % mod;\n\t\treturn c;\n\t}\n\tfriend inline matrix fpow(matrix a, int b) {\n\t\tmatrix s; memset(s.a, 0, sizeof(s.a)), s.a[0][0] = s.a[1][1] = s.a[2][2] = 1;\n\t\tfor (; b; b >>= 1, a = a * a)\n\t\t\tif (b &#x26; 1) s = s * a;\n\t\treturn s;\n\t}\n} I, S, A;\n\nstruct poly : std::vector &#x3C;int> {\n\tusing std::vector &#x3C;int> ::vector;\n} f, g;\n\nnamespace MTT {\n\tconst int M = N &#x3C;&#x3C; 2;\n  const double pi = acos(-1);\n  ll p30 = 1ll &#x3C;&#x3C; 30, p15 = 1ll &#x3C;&#x3C; 15;\n  struct complex {\n    double a, b;\n    inline complex() {}\n    inline complex(double x) { a = x, b = 0; }\n    inline complex(double x, double y) { a = x, b = y; }\n    inline complex operator + (const complex &#x26;other) const { return complex(a + other.a, b + other.b); }\n    inline complex operator - (const complex &#x26;other) const { return complex(a - other.a, b - other.b); }\n    inline complex operator * (const complex &#x26;other) const { return complex(a * other.a - b * other.b, a * other.b + b * other.a); }\n  } w[M], iw[M], a[M], b[M], c[M], d[M], e[M], f[M], g[M], h[M];\n  int lim, rev[M];\n  inline int init(int len) {\n    int lim = 1, k = 0; while (lim &#x3C; len) lim &#x3C;&#x3C;= 1, ++k;\n    for (int i = 0; i &#x3C; lim; i++) rev[i] = (rev[i >> 1] >> 1) | ((i &#x26; 1) &#x3C;&#x3C; (k - 1));\n    len = lim >> 1;\n    for (int i = 0; i &#x3C; len; i++) w[i + len] = complex(cos(pi * i / len), sin(pi * i / len));\n    for (int i = 0; i &#x3C; len; i++) iw[i + len] = complex(cos(pi * i / len), -sin(pi * i / len));\n    for (int i = len - 1; i >= 0; i--) w[i] = w[i &#x3C;&#x3C; 1], iw[i] = iw[i &#x3C;&#x3C; 1];\n    return lim;\n  }\n  inline void fft(complex *a) {\n    for (int i = 0; i &#x3C; lim; i++) if (i &#x3C; rev[i]) std::swap(a[i], a[rev[i]]);\n    for (int len = 1; len &#x3C; lim; len &#x3C;&#x3C;= 1)\n      for (int i = 0; i &#x3C; lim; i += (len &#x3C;&#x3C; 1))\n        for (int j = 0; j &#x3C; len; j++) {\n          complex x = a[i + j], y = a[i + j + len] * w[j + len];\n          a[i + j] = x + y, a[i + j + len] = x - y;\n        }\n  }\n  inline void ifft(complex *a) {\n    for (int i = 0; i &#x3C; lim; i++) if (i &#x3C; rev[i]) std::swap(a[i], a[rev[i]]);\n    for (int len = 1; len &#x3C; lim; len &#x3C;&#x3C;= 1)\n      for (int i = 0; i &#x3C; lim; i += (len &#x3C;&#x3C; 1))\n        for (int j = 0; j &#x3C; len; j++) {\n          complex x = a[i + j], y = a[i + j + len] * iw[j + len];\n          a[i + j] = x + y, a[i + j + len] = x - y;\n        }\n    for (int i = 0; i &#x3C; lim; i++) a[i].a /= lim;\n  }\n  inline poly operator * (const poly &#x26;F, const poly &#x26;G) {\n    poly H(F.size() + G.size() - 1); lim = init(H.size());\n    for (int i = 0; i &#x3C; F.size(); i++) a[i] = F[i] >> 15, b[i] = F[i] &#x26; 32767;\n    for (int i = 0; i &#x3C; G.size(); i++) c[i] = G[i] >> 15, d[i] = G[i] &#x26; 32767;\n    for (int i = F.size(); i &#x3C; lim; i++) a[i] = b[i] = 0;\n    for (int i = G.size(); i &#x3C; lim; i++) c[i] = d[i] = 0;\n    fft(a), fft(b), fft(c), fft(d);\n    for (int i = 0; i &#x3C; lim; i++)\n      e[i] = a[i] * c[i], f[i] = a[i] * d[i], g[i] = b[i] * c[i], h[i] = b[i] * d[i];\n    ifft(e), ifft(f), ifft(g), ifft(h);\n    p30 %= mod, p15 %= mod;\n    for (int i = 0; i &#x3C; H.size(); i++)\n      H[i] = ((ll)(e[i].a + 0.5) % mod * p30 % mod + (ll)(f[i].a + 0.5) % mod * p15 % mod + (ll)(g[i].a + 0.5) % mod * p15 % mod + (ll)(h[i].a + 0.5)) % mod;\n    return H;\n  }\n}\nusing MTT::operator *;\n\nvoid main() {\n\tread(n), read(k), read(L), read(x), read(y), read(mod), --x, --y;\n\tfor (int i = 0; i &#x3C; n; i++) for (int j = 0; j &#x3C; n; j++) read(A.a[i][j]);\n\tw[0] = 1, w[1] = fpow(get_root(mod), (mod - 1) / k);\n\tfor (int i = 2; i &#x3C; k; i++) w[i] = mul(w[i - 1], w[1]);\n\tI.a[0][0] = I.a[1][1] = I.a[2][2] = 1, S.a[0][x] = 1;\n\tfor (int i = 0; i &#x3C; k; i++) c[i] = (S * fpow(A * w[i] + I, L)).a[0][y];\n\tf.resize((k &#x3C;&#x3C; 1) + 1), g.resize(k + 1);\n\tfor (int i = 0; i &#x3C; f.size(); i++) f[i] = get_omega(-((ll)i * (i - 1) >> 1));\n\tfor (int i = 0; i &#x3C; g.size(); i++) g[i] = mul(c[i], get_omega(((ll)i * (i - 1) >> 1)));\n\t// printf(\"w: \"); for (int i = 0; i &#x3C; k; i++) print(w[i], \" \\n\"[i == k - 1]);\n\t// printf(\"c: \"); for (int i = 0; i &#x3C; k; i++) print(c[i], \" \\n\"[i == k - 1]);\n\t// printf(\"f: \"); for (int i = 0; i &#x3C; f.size(); i++) print(f[i], \" \\n\"[i == f.size() - 1]);\n\t// printf(\"g: \"); for (int i = 0; i &#x3C; g.size(); i++) print(g[i], \" \\n\"[i == g.size() - 1]);\n\tstd::reverse(g.begin(), g.end());\n\tf = f * g;\tint inv_k = inv(k);\n\tfor (int i = 0; i &#x3C; k; i++) ans[i] = mul(f[k + i], mul(get_omega(((ll)i * (i - 1) >> 1)), inv_k));\n\tfor (int i = 0; i &#x3C; k; i++) print(ans[i], '\\n');\n}\n\n} signed main() {\n#ifdef MEMSET0_LOCAL_ENVIRONMENT\n\tfreopen(\"1.in\", \"r\", stdin);\n#endif\n\treturn ringo::main(), 0;\n}\n</code></pre>","frontmatter":{"date":"April 08, 2019","title":"「HNOI2019」白兔之舞","cover":"/cover/8.png"}}},"pageContext":{"id":"3b9d0d39-beed-52bf-a969-f91852c5eb8f","slug":"blog/problem/luogu5293"}},"staticQueryHashes":[],"slicesMap":{}}