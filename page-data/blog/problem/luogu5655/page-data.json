{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/luogu5655/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>给定一个长度为 $n$ 的数组 ${a_i}<em>{i=1}^n$，$Q$ 次询问，每次给定 $l$ 和 $r$ 查询 $\\operatorname{lcm}({a_i}</em>{i=l}^r)$，答案对 $10^9+7$ 取模。</p>\n<p><strong>多组数据</strong>，$T,n,Q \\leq 300,\\ a_i \\leq 10^{18}$。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p>把 $&#x3C; 10^{4.5}$ 的质数分开来处理，这样剩余每个数至多剩余 $3$ 个不同的质因子。考虑我们不需把每个数分解质因数，只需要能够构造一个等价的质数集合即可。构造方法如下：</p>\n<p>对于所有 $1 \\leq i &#x3C; j \\leq n$，将 $\\gcd(a_i, a_j), a_i / \\gcd(a_i, a_j), a_j / \\gcd(a_i, a_j)$ 加入到集合 $S$ 中。将其中存在 $S$ 中的数作为因数的数删掉，剩下的集合就是一个合法的质数集合。</p>\n<p>接下来的一个朴素做法是莫队，需要一些精妙的实现使得那个 $\\log$ 是加上去的而不是乘上去的。</p>\n<ol>\n<li>会用到质数的快速幂，这个可以预处理</li>\n<li>相当于对于每个质数维护一个出现次数集合，支持加减和查询最大的出现次数。首先维护一个桶来去重，然后开一个 long long，并每次查询最高的 $1$ 出现的位置。</li>\n</ol>\n<p>时间复杂度近似于 $O(n^3 \\log n)$，需要一些精细的实现。</p>\n<h2>代码</h2>\n<p>一度 TLE，后来被 zx2003 哥哥卡了半天卡进去了。</p>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define pair std::pair&#x3C;int,int>\nconst int N=310,M=32000,L=5000,mod=1e9+7;\nnamespace io {\n\tconst int SIZE = (1 &#x3C;&#x3C; 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\tinline char gch(){\n\t\tchar c=gc();for(;isspace(c);c=gc());\n\t\treturn c;\n\t}\n\tinline void gs(char*c){\n\t\tchar x=gc();for(;isspace(x);x=gc());\n\t\tfor(;!isspace(x);x=gc())*c++=x;*c=0;\n\t}\n\ttemplate &#x3C;class I>\n\tinline void gi (I &#x26;x) {\n\t\tfor (f = 1, c = gc(); c &#x3C; '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c &#x3C;= '9' &#x26;&#x26; c >= '0'; c = gc()) x = x * 10 + (c &#x26; 15); x *= f;\n\t}\n\t// print a signed integer\n\ttemplate &#x3C;class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x &#x3C; 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nstruct ExactDiv {\n  ExactDiv() {}\n  ExactDiv(ull n){\n  \tfor(z=0;!(n&#x26;1);++z,n>>=1);\n  \tt=((ull)-1) / n;\n\ti=mul_inv(n);\n  }\n  ull mul_inv(ull n) {\n    ull x = n;\n    for (int i = 0; i &#x3C; 6; ++i) x *= 2 - n * x;\n    return x;\n  }\n  inline bool divide(const ull&#x26;n) { return ((n>>z&#x3C;&#x3C;z)==n) &#x26;&#x26; (n>>z)*this->i&#x3C;=this->t; }\n  inline bool ck(const ll&#x26;n){\n  \treturn n>=0 &#x26;&#x26; divide(n);\n  }\n  ull t, i,z;\n}ediv[M],el[L];\nint T,n,m,l,tl,pc,sqn,p[L],ans[N],vis[M],bln[N],pri[M];ll a[N],ls[L],pw[L][65],ipw[L][65];\nstd::vector&#x3C;ll> fac;\nstd::vector&#x3C;pair> v[N];\nconst int Z=1005;\nint gg[Z][Z];\nint C;\ntemplate&#x3C;class T> inline T gcd(T x,T y){++C;return x&#x3C;Z &#x26;&#x26; y&#x3C;Z?gg[x][y]:(y?gcd(y,x%y):x);}\nstruct query{\n\tint l,r,id;\n\tinline bool operator&#x3C;(const query &#x26;other)const{\n\t\treturn bln[l]==bln[other.l]?(r&#x3C;other.r)==(bln[l]&#x26;1):l&#x3C;other.l;\n//\t\treturn bln[l]==bln[other.l]?r&#x3C;other.r:l&#x3C;other.l;\n\t}\n}q[N];\ninline int fpow(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(ll)a*a%mod)if(b&#x26;1)s=(ll)s*a%mod;\n\treturn s;\n}\nint buc[L][65],mx[L];\nint tot=1,zcnt;\ninline void add(const std::vector&#x3C;pair> &#x26;vet){\n\tfor(auto it:vet){\n\t\tif(mx[it.first]){\t\n\t\t\tif(ls[it.first])tot=tot*ipw[it.first][mx[it.first]]%mod;\n\t\t\t\telse --zcnt;\n\t\t}\n\t\t++buc[it.first][it.second];\n\t\tmx[it.first]=std::max(mx[it.first],it.second);\n\t\tif(mx[it.first]){\t\n\t\t\tif(ls[it.first])tot=tot*pw[it.first][mx[it.first]]%mod;\n\t\t\t\telse ++zcnt;\n\t\t}\n\t}\n}\ninline void del(const std::vector&#x3C;pair> &#x26;vet){\n\tfor(auto it:vet){\n\t\tif(mx[it.first]){\t\n\t\t\tif(ls[it.first])tot=tot*ipw[it.first][mx[it.first]]%mod;\n\t\t\t\telse --zcnt;\n\t\t}\n\t\t--buc[it.first][it.second];\n\t\tfor(mx[it.first]=p[it.first];mx[it.first] &#x26;&#x26; !buc[it.first][mx[it.first]];--mx[it.first]);\n\t\tif(mx[it.first]){\t\n\t\t\tif(ls[it.first])tot=tot*pw[it.first][mx[it.first]]%mod;\n\t\t\t\telse ++zcnt;\n\t\t}\n\t}\n}\ninline ll fpow2(ll x,ll y,ll mo){\n\tll ans=1;\n\tfor(;y;y>>=1,x=(__int128)x*x%mo)if(y&#x26;1)ans=(__int128)x*x%mo;\n\treturn ans;\n}\ninline bool ck(ll x){\n\tfor(int i=1;pri[i]&#x3C;=10;++i)if(fpow2(pri[i],x-1,x)!=1)return 0;\n\treturn 1;\n}\nstruct hmp{\nstatic const int mo=1999;\nint h[mo],nxt[mo],xb;ll v[mo];\ninline void insert(ll x){\n\tif(x==1)return;\n\tint z=x%mo,i=h[z];\n\tfor(;i &#x26;&#x26; v[i]!=x;i=nxt[i]);\n\tif(!i)nxt[++xb]=h[z],h[z]=xb,v[xb]=x;\n}\n}ss;\nint main(){\n\tfor(int i=2;i&#x3C;M;i++){\n\t\tif(!vis[i])pri[++pc]=i;\n\t\tfor(int j=1;j&#x3C;=pc&#x26;&#x26;i*pri[j]&#x3C;M;j++){\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i&#x3C;=pc;++i)ediv[i]=pri[i];\n\tfor(int i=0;i&#x3C;Z;++i)for(int j=0;j&#x3C;Z;++j)gg[i][j]=!i || !j?i+j:(i>j?gg[i-j][j]:gg[i][j-i]);\n\tfor(io::gi(T);T--;){\n\t\tio::gi(n),io::gi(m),sqn=sqrt(n),l=0,fac.clear();\n\t\tfor(int i=1;i&#x3C;=n;i++)io::gi(a[i]),bln[i]=i/sqn,v[i].clear();\n\t\tfor(int i=1;i&#x3C;=m;i++)io::gi(q[i].l),io::gi(q[i].r),q[i].id=i,ans[i]=1;\n\t\tstatic int id[M];memset(id+1,0,pc&#x3C;&#x3C;2);\n\t\tfor(int i=1;i&#x3C;=n;i++)\n\t\t\tfor(int j=1,cnt;j&#x3C;=pc;j++)if(ediv[j].divide(a[i])){\n\t\t\t\tcnt=0;while(a[i]%pri[j]==0)++cnt,a[i]/=pri[j];\n\t\t\t\tif(!id[j])ls[id[j]=++l]=pri[j],el[l]=ls[l],p[l]=0;\n\t\t\t\tv[i].push_back(std::make_pair(id[j],cnt)),p[id[j]]=std::max(p[id[j]],cnt);\n\t\t\t}\n\t\tss.xb=0;memset(ss.h,0,sizeof ss.h);\n\t\tint step=8;\n\t\tstatic ll aa[N];int nn=0;\n\t\tfor(int i=1;i&#x3C;=n;++i)if(a[i]>1)aa[++nn]=a[i];\n\t\tfor(int i=1;i&#x3C;=nn;++i)ss.insert(aa[i]);\n\t\tfor(int i=1;i&#x3C;=nn;i++){\n\t\t\tfor(int j=i+1;j&#x3C;=nn;j+=step){\n\t\t\t\tll pi=1;\n\t\t\t\tfor(int k=0;k&#x3C;step &#x26;&#x26; j+k&#x3C;=nn;++k)pi=(__int128)pi*aa[j+k]%aa[i];\n\t\t\t\tif(gcd(pi,aa[i])!=1)for(int k=0;k&#x3C;step &#x26;&#x26; j+k&#x3C;=nn;++k){\n\t\t\t\t\tll x=gcd(aa[i],aa[j+k]);\n\t\t\t\t\tss.insert(x);ss.insert(aa[i]/x);ss.insert(aa[j+k]/x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfac=std::vector&#x3C;ll>(ss.v+1,ss.v+ss.xb+1);\n\t\tstd::sort(fac.begin(),fac.end()),fac.erase(std::unique(fac.begin(),fac.end()),fac.end());\n\t\ttl=l;\n\t\tif(!fac.empty())for(int i=fac[0]==1?1:0,fl;fl=0,i&#x3C;fac.size();i++){\n\t\t\tfl=1;\n\t\t\tif(fl)ls[++l]=fac[i],p[l]=0,el[l]=ls[l];\n\t\t}\n\t\tfor(int i=1;i&#x3C;=n;i++){\n\t\t\tfor(int j=tl+1,cnt;j&#x3C;=l;j++)if(el[j].divide(a[i])){\n\t\t\t\tcnt=0;while(a[i]%ls[j]==0)++cnt,a[i]/=ls[j];\n\t\t\t\tv[i].push_back(std::make_pair(j,cnt)),p[j]=std::max(p[j],cnt);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i&#x3C;=l;i++)for(int j=0;j&#x3C;=p[i];j++)ipw[i][j]=fpow(pw[i][j]=fpow(ls[i]%mod,j),mod-2);\n\t\tstd::stable_sort(q+1,q+m+1);\n\t\tint ul=1,ur=0;\n\t\tfor(int i=1;i&#x3C;=m;i++){\n\t\t\twhile(ul>q[i].l)add(v[--ul]);while(ur&#x3C;q[i].r)add(v[++ur]);\n\t\t\twhile(ul&#x3C;q[i].l)del(v[ul++]);while(ur>q[i].r)del(v[ur--]);\n\t\t\tans[q[i].id]=tot;\n\t\t}\n\t\twhile(ul&#x3C;=ur)del(v[ur--]);\n\t\tfor(int i=1;i&#x3C;=m;i++)io::print(ans[i]),io::putc('\\n');\n\t}\n\treturn 0;\n}\n</code></pre>","frontmatter":{"date":"November 21, 2019","title":"「洛谷5655」基础数论函数练习题","cover":"/cover/4.png"}}},"pageContext":{"id":"0656fa9b-3a8c-52da-88bb-27eca69f48f9","slug":"blog/problem/luogu5655"}},"staticQueryHashes":[],"slicesMap":{}}