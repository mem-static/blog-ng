{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/luogu6579/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>给数组 $A$ 和 $n$ 个节点的树，每个点有一个 $1$ 到 $x$ 颜色。</p>\n<p>$m$ 次查询，每次查询树上只保留 $[l,r]$ 内的所有节点，设一个极大连通块中出现奇数次数的颜色个数为 $t$，则其对答案的贡献为 $A_t$ ，即答案是所有连通块贡献的和，询问相互独立。</p>\n<p>$1\\leq n,m\\leq 10^5$，$1\\leq x,A_i \\leq 10^4$。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p><del>退役选手被lxl抓过来写题解</del></p>\n<p>考虑用单增莫队维护，想了想容易发现复杂度不对。</p>\n<p>莫队的端点移动需要启发式合并维护信息，而启发式合并的复杂度基于我们可以把势能均摊，如果我们在分块时基于势能呢？</p>\n<p>单增莫队的复杂度主要产生于以下两个部分（假设把询问分为 $S$ 块）：</p>\n<ul>\n<li>左端点左移：对于每个端点都会贡献 $O(S)$，故这一部分的总势能是 $O(S n \\sqrt n)$ 的</li>\n<li>右端点右移：每个块内的询问会对每个块内的端点贡献 $O(1)$ 次，可以通过构造询问分布，卡满这部分的势能和。</li>\n<li>回滚后缀的右端点右移操作：回滚操作于增加操作复杂度相同。</li>\n</ul>\n<p>~~有没有救呢？当然是有的。~~注意左端点的移动势能是只和块数相关的。瓶颈在于右端点的移动：对于一个区间 $[l,r]$，端点 $i$ 在右端点移动时贡献的势能为 $A_i$，则一次经过该区间的询问产生的势能至多为 $\\sum_{i=l+1}^r A_i$。</p>\n<p>理清思路后题解就很显然了，我们先处理出每个端点的势能 $B_i$（在 $1 \\ldots (i-1)$ 后插入 $i$ 贡献的势能，上文提到的势能 $A_i$ 是一定有 $A_i \\leq B_i$ 的）。然后从右到左对势能分块。</p>\n<p>如果加入当前端点后当前栈内端点的势能和大于 $\\sqrt {n} \\log n$ 就将栈内元素分为一块。由于所有被分配到这个块的询问都是经过块的不会贡献势能的左端点，而其余端点贡献的势能和是一定小于 $\\sqrt n \\log n$ 的。</p>\n<p>总时间复杂度 $O((n+Q)\\sqrt n \\log n)$。</p>\n<h2>卡常技巧</h2>\n<p>本题卡常的一比，毒瘤 lxl（（</p>\n<ol>\n<li>手动调整块大小</li>\n<li>作栈/队列功能的 <code>std::vector&#x3C;T></code> 换成手写（不知道为什么我做到这这步就过了）</li>\n<li>手写 bitset（我鸽了）</li>\n<li>手写可合并的 vector（然而我手写了一个还打不过 <code>std::vector&#x3C;T></code>，我已经报警了）</li>\n</ol>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\n#pragma GCC target(\"avx\")\n#pragma GCC target(\"popcnt\")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#define log(...) (void(0))\n// #define log(...) fprintf(stderr,__VA_ARGS__)\n#define debug log(\"\\33[2mPassing [%s] in LINE %d\\33[0m\\n\",__FUNCTION__,__LINE__);\nconst int S=1&#x3C;&#x3C;21; char ibuf[S],*iS,*iT,obuf[S],*oS=obuf,*oT=oS+S-1;\n#define flush() (fwrite(obuf,1,oS-obuf,stdout),oS=obuf,void())\n#define getchar() (iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,S,stdin),(iS==iT?EOF:*iS++)):*iS++)\n#define putchar(x) (*oS++=(x),oS==oT?flush():void())\nstruct Flusher_{~Flusher_(){flush();}}flusher_;\ntemplate&#x3C;class T> inline void read(T &#x26;x){\n  x=0; register char c=getchar(); register bool f=0;\n  while(!isdigit(c))f^=c=='-',c=getchar();\n  while(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\ntemplate&#x3C;class T> inline void print(T x){\n  if(x&#x3C;0)putchar('-'),x=-x;\n  if(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate&#x3C;class T> inline void print(T x,char c){print(x),putchar(c);}\nconst int N=1e5+10,M=1e4+10,S1=256,S2=4;\nunsigned int clockSum;\nint n,m,x,blocks,a[N],c[N],bln[N],anc[N],pre[N],siz[N],ans[N];\nstd::vector&#x3C;int> G[N];\ntemplate&#x3C;class T,int N> struct static_vector{\n  T a[N];\n  size_t top;\n  inline T&#x26; operator[](size_t k){return a[k];}\n  inline T operator[](size_t k)const{return a[k];}\n  inline T&#x26; back(){return a[top-1];}\n  inline T back()const{return a[top-1];}\n  inline void clear(){top=0;}\n  inline void pop_back(){top--;}\n  inline void push_back(const T &#x26;e){a[top++]=e;}\n  inline size_t size(){return top;}\n};\nstruct query{\n  int l,r,id;\n};\nstd::vector&#x3C;query> q;\nnamespace tree{\n  int ans,delta,anc[N];\n  bool roll,mrk[N];\n  std::bitset&#x3C;M> mem[N/S2+5];\n  static_vector&#x3C;size_t,(N/S2+5)> rub;\n  static_vector&#x3C;std::tuple&#x3C;int,int,int>,(N&#x3C;&#x3C;1)> history;\n  struct unicom_block{\n    int id,cnt,bitset,key[S2];\n    std::vector&#x3C;int> vec;\n    inline unicom_block(){bitset=-1,memset(key,-1,sizeof(key));}\n    inline void clear(){\n      if(~bitset)mem[bitset].reset(),rub.push_back(bitset),bitset=-1;\n      cnt=0,vec.clear(),memset(key,-1,sizeof(key));\n    }\n    inline void pushup(int k){\n      ans-=a[cnt];\n      if(~bitset){\n        if(mem[bitset][k]){\n          mem[bitset][k]=0,--cnt;\n        }else{\n          mem[bitset][k]=1,++cnt;\n        }\n      }else{\n        for(int i=0;i&#x3C;S2;i++)if(key[i]==k){key[i]=-1,--cnt; goto out;}\n        for(int i=0;i&#x3C;S2;i++)if(key[i]==-1){key[i]=k,++cnt; goto out;}\n        bitset=rub.back(),rub.pop_back();\n        mem[bitset][k]=1,++cnt;\n        for(int i=0;i&#x3C;S2;i++)mem[bitset][key[i]]=1;\n      }\n      out:ans+=a[cnt];\n    }\n  }uni[N];\n  inline void merge(unicom_block &#x26;u,unicom_block &#x26;v){\n    for(int i:u.vec)v.pushup(i);\n  }\n  int find(int x){return x==anc[x]?x:find(anc[x]);}\n  void reset(){\n    log(\"\\e[2mreset\\e[0m\\n\");\n    ans=roll=0;\n    for(int i=1;i&#x3C;=n;i++){\n      anc[i]=i;\n      if(mrk[i])uni[i].clear(),mrk[i]=0;\n    }\n  }\n  void add(int x){\n    log(\"\\e[2madd %d\\e[0m\\n\",x);\n    ans+=a[0]; if(roll)delta+=a[0];\n    if(roll)history.push_back({0,x,0});\n    mrk[x]=1;\n    uni[x].vec.push_back(c[x]),uni[x].pushup(c[x]);\n    for(int i=0;i&#x3C;G[x].size();i++)if(mrk[G[x][i]]){\n      int y=G[x][i],u=find(x),v=find(y);\n      if(uni[u].vec.size()>uni[v].vec.size())std::swap(u,v);\n      // log(\"merge %d[%d %lu] %d[%d %lu]\\n\",x,u,uni[u].vec.size(),y,v,uni[v].vec.size());\n      if(roll)history.push_back({u,v,anc[u]});\n      merge(uni[u],uni[v]);\n      uni[v].vec.insert(uni[v].vec.end(),uni[u].vec.begin(),uni[u].vec.end()),anc[u]=v;\n      ans-=a[uni[u].cnt]; if(roll)delta-=a[uni[u].cnt];\n    }\n  }\n  int query(){return ans;}\n  void rollback(){\n    log(\"\\e[2mrollback\\e[0m\\n\");\n    ans-=delta,delta=0;\n    for(int u,v,t,i=(int)history.size()-1;i>=0;i--){\n      std::tie(u,v,t)=history[i];\n      if(u){\n        anc[u]=t;\n        for(int i:uni[u].vec)uni[v].vec.pop_back();\n        merge(uni[u],uni[v]);\n      }else{\n        mrk[v]=0,uni[v].pushup(c[v]),uni[v].clear();\n      }\n    }\n    history.clear();\n  }\n}\nstruct block{\n  int id,l,r;\n  std::vector&#x3C;query> q;\n  void init(){\n    for(int i=l;i&#x3C;=r;i++)bln[i]=id;\n  }\n  void solve(){\n    std::sort(q.begin(),q.end(),[](const query &#x26;a,const query &#x26;b){return a.l>b.l;});\n    tree::reset();\n    int cur=l,i;\n    for(const auto &#x26;it:q){\n      // log(\"\\e[34mquery {%d %d}\\e[0m block[%d]={%d %d}\\n\",it.l,it.r,id,l,r);\n      while(it.l&#x3C;=cur)tree::add(cur--);\n      for(tree::roll^=1,i=l+1;i&#x3C;=it.r;i++)tree::add(i);\n      ans[it.id]=tree::query();\n      tree::roll^=1,tree::rollback();\n    }\n  }\n}block[S1&#x3C;&#x3C;1];\nvoid build(){\n  std::function&#x3C;int(int)> find=[&#x26;](int x){return anc[x]==x?x:anc[x]=find(anc[x]);};\n  for(int i=1;i&#x3C;=n;i++)anc[i]=i,siz[i]=1;\n  for(int u=1;u&#x3C;=n;u++){\n    for(int v:G[u])if(v&#x3C;u){\n      int fu=find(u),fv=find(v); if(fu==fv)continue;\n      if(siz[fu]>siz[fv])std::swap(fu,fv);\n      pre[u]+=siz[fu],anc[fu]=fv,siz[fv]+=siz[fu];\n    }\n    pre[u]+=G[u].size();\n  }\n  int S=std::accumulate(pre+1,pre+n+1,0)/S1+1;\n  fprintf(stderr,\"> block limit = %d\\n\",S);\n  std::vector&#x3C;std::tuple&#x3C;int,int,int>> seq={{n+1,n,0}};\n  for(int i=n;i>=1;i--){\n    std::get&#x3C;0>(seq.back())--,std::get&#x3C;2>(seq.back())+=pre[i];\n    if(i==1||std::get&#x3C;2>(seq.back())+pre[i]>S)seq.push_back({i,i-1,0});\n  }\n  seq.pop_back(),std::reverse(seq.begin(),seq.end()),blocks=seq.size();\n  for(int _,i=0;i&#x3C;blocks;i++){\n    std::tie(block[i].l,block[i].r,_)=seq[i];\n    // log(\"%d [%d %d] %d\\n\",i,block[i].l,block[i].r,std::accumulate(pre+block[i].l,pre+block[i].r+1,0));\n    block[i].id=i,block[i].init();\n  }\n}\nvoid solve(){\n  for(int i=1;i&#x3C;=n;i++)tree::uni[i].id=i;\n  for(const auto &#x26;it:q)if(bln[it.l]==bln[it.r]){\n    // log(\"\\e[34mquery {%d %d}\\e[0m all belong to %d\\n\",it.l,it.r,bln[it.l]);\n    tree::reset();\n    for(int i=it.l;i&#x3C;=it.r;i++)tree::add(i);\n    ans[it.id]=tree::query();\n  }else{\n    block[bln[it.r]].q.push_back(it);\n  }\n  for(int i=0;i&#x3C;blocks;i++)block[i].solve();\n}\nint main(){\n  for(int i=0;i&#x3C;N/S2+5;i++)tree::rub.push_back(i);\n#ifdef memset0\n  freopen(\"2.in\",\"r\",stdin);\n  freopen(\"2.out\",\"w\",stdout);\n#endif\n  read(n),read(m),read(x);\n  for(int i=1;i&#x3C;=n;i++)read(c[i]),--c[i];\n  for(int u,v,i=1;i&#x3C;n;i++){\n    read(u),read(v);\n    G[u].push_back(v),G[v].push_back(u);\n  }\n  for(int i=0;i&#x3C;=x;i++)read(a[i]);\n  build();\n  // log(\"\\e[31mpre\\e[0m = \"); for(int i=1;i&#x3C;=n;i++)log(\"%d%c\",pre[i],\" \\n\"[i==n]);\n  // log(\"\\e[31mbln\\e[0m = \"); for(int i=1;i&#x3C;=n;i++)log(\"%d%c\",bln[i],\" \\n\"[i==n]);\n  for(int l,r,i=1;i&#x3C;=m;i++){\n    read(l),read(r);\n    q.push_back({l,r,i});\n  }\n  solve();\n  for(int i=1;i&#x3C;=m;i++)print(ans[i],'\\n');\n  fprintf(stderr,\"clocks: %.4lf\\n\",clockSum/(double)CLOCKS_PER_SEC);\n  fprintf(stderr,\"clocks: %.4lf\\n\",clock()/(double)CLOCKS_PER_SEC);\n}\n</code></pre>\n<h2>手写 vector 且没通过的代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\n#pragma GCC target(\"avx\")\n#pragma GCC target(\"popcnt,tune=native\")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#define log(...) (void(0))\n// #define log(...) fprintf(stderr,__VA_ARGS__)\nconst int S=1&#x3C;&#x3C;21; char ibuf[S],*iS,*iT,obuf[S],*oS=obuf,*oT=oS+S-1;\n#define flush() (fwrite(obuf,1,oS-obuf,stdout),oS=obuf,void())\n#define getchar() (iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,S,stdin),(iS==iT?EOF:*iS++)):*iS++)\n#define putchar(x) (*oS++=(x),oS==oT?flush():void())\nstruct Flusher_{~Flusher_(){flush();}}flusher_;\ntemplate&#x3C;class T> inline void read(T &#x26;x){\n  x=0; register char c=getchar(); register bool f=0;\n  while(!isdigit(c))f^=c=='-',c=getchar();\n  while(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\ntemplate&#x3C;class T> inline void print(T x){\n  if(x&#x3C;0)putchar('-'),x=-x;\n  if(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate&#x3C;class T> inline void print(T x,char c){print(x),putchar(c);}\nconst int N=1e5+10,M=1e4+10,S1=256,S2=4;\nint n,m,x,blocks,a[N],c[N],bln[N],anc[N],pre[N],siz[N],ans[N];\nstd::vector&#x3C;int> G[N];\nstruct query{\n  int l,r,id;\n};\nstd::vector&#x3C;query> q;\ntemplate&#x3C;class T,int N> struct static_vector{\n  T a[N];\n  size_t top;\n  inline T&#x26; operator[](size_t k){return a[k];}\n  inline T operator[](size_t k)const{return a[k];}\n  inline T&#x26; back(){return a[top-1];}\n  inline T back()const{return a[top-1];}\n  inline void clear(){top=0;}\n  inline void pop_back(){top--;}\n  inline void push_back(const T &#x26;e){a[top++]=e;}\n  inline size_t size(){return top;}\n};\nint mempool[N&#x3C;&#x3C;5],*mempointer=mempool;\nint* memselect(int n){\n  int *res=mempointer;\n  log(\"\\e[32mmem select [%d] => %d\\e[0m\\n\",n,res);\n  mempointer+=n;\n  return res;\n}\nstruct combinable_vector{\n  int lim;\n  int *l,*r;\n  inline size_t size()const{return r-l;}\n  inline void clear(){r=l;}\n  inline void assign(){l=r=memselect(lim=8);}\n  inline void re_assign(){\n    int *tl=l,*tr=r;\n    lim&#x3C;&#x3C;=3,l=memselect(lim),r=l+(tr-tl);\n    memcpy(l,tl,size()&#x3C;&#x3C;2);\n  }\n  inline void push_back(int x){if(size()==lim)re_assign(); *(r++)=x;}\n  inline void pop_back(){r--;}\n  inline void concat(const combinable_vector &#x26;rhs){\n    if(size()+rhs.size()>lim)re_assign();\n    memcpy(r,rhs.l,rhs.size()&#x3C;&#x3C;2),r+=rhs.size();\n  }\n  inline void concat_reverse(const combinable_vector &#x26;rhs){r-=rhs.size();}\n};\nnamespace tree{\n  int ans,delta,anc[N];\n  bool roll,mrk[N];\n  std::bitset&#x3C;M> mem[N/S2+5];\n  static_vector&#x3C;size_t,(N/S2+5)> rub;\n  static_vector&#x3C;std::tuple&#x3C;int,int,int>,(N&#x3C;&#x3C;1)> history;\n  struct unicom_block{\n    int id,cnt,bitset,key[S2];\n    combinable_vector vec;\n    inline unicom_block(){bitset=-1,memset(key,-1,sizeof(key)),vec.assign();}\n    inline void clear(){\n      if(~bitset)mem[bitset].reset(),rub.push_back(bitset),bitset=-1;\n      cnt=0,vec.clear(),memset(key,-1,sizeof(key));\n    }\n    inline void pushup(int k){\n      ans-=a[cnt];\n      if(~bitset){\n        if(mem[bitset][k]){\n          mem[bitset][k]=0,--cnt;\n        }else{\n          mem[bitset][k]=1,++cnt;\n        }\n      }else{\n        for(int i=0;i&#x3C;S2;i++)if(key[i]==k){key[i]=-1,--cnt; goto out;}\n        for(int i=0;i&#x3C;S2;i++)if(key[i]==-1){key[i]=k,++cnt; goto out;}\n        bitset=rub.back(),rub.pop_back();\n        mem[bitset][k]=1,++cnt;\n        for(int i=0;i&#x3C;S2;i++)mem[bitset][key[i]]=1;\n      }\n      out:ans+=a[cnt];\n    }\n  }uni[N];\n  inline void merge(unicom_block &#x26;u,unicom_block &#x26;v){\n    log(\"\\e[31mmerge %d %d\\e[0m\\n\",(int)u.vec.size(),(int)v.vec.size());\n    for(int *it=u.vec.l;it!=u.vec.r;it++)v.pushup(*it);\n  }\n  int find(int x){return x==anc[x]?x:find(anc[x]);}\n  void reset(){\n    log(\"\\e[2mreset\\e[0m\\n\");\n    ans=roll=0;\n    for(int i=1;i&#x3C;=n;i++){\n      anc[i]=i;\n      if(mrk[i])uni[i].clear(),mrk[i]=0;\n    }\n    mempointer=mempool;\n    for(int i=1;i&#x3C;=n;i++)uni[i].vec.assign();\n  }\n  void add(int x){\n    log(\"\\e[2madd %d\\e[0m\\n\",x);\n    ans+=a[0]; if(roll)delta+=a[0];\n    if(roll)history.push_back({0,x,0});\n    mrk[x]=1,uni[x].pushup(c[x]);\n    uni[x].vec.push_back(c[x]);\n    for(int i=0;i&#x3C;G[x].size();i++)if(mrk[G[x][i]]){\n      int y=G[x][i],u=find(x),v=find(y);\n      if(uni[u].vec.size()>uni[v].vec.size())std::swap(u,v);\n      log(\"merge %d[%d] %d[%d]\\n\",x,u,y,v);\n      if(roll)history.push_back({u,v,anc[u]});\n      merge(uni[u],uni[v]);\n      anc[u]=v;\n      uni[v].vec.concat(uni[u].vec);\n      ans-=a[uni[u].cnt]; if(roll)delta-=a[uni[u].cnt];\n    }\n  }\n  int query(){return ans;}\n  void rollback(){\n    log(\"\\e[2mrollback\\e[0m\\n\");\n    ans-=delta,delta=0;\n    for(int u,v,t,i=(int)history.size()-1;i>=0;i--){\n      std::tie(u,v,t)=history[i];\n      if(u){\n        anc[u]=t;\n        merge(uni[u],uni[v]);\n        uni[v].vec.concat_reverse(uni[u].vec);\n      }else{\n        mrk[v]=0,uni[v].pushup(c[v]),uni[v].clear();\n      }\n    }\n    history.clear();\n  }\n}\nstruct block{\n  int id,l,r;\n  std::vector&#x3C;query> q;\n  void init(){\n    for(int i=l;i&#x3C;=r;i++)bln[i]=id;\n  }\n  void solve(){\n    std::sort(q.begin(),q.end(),[](const query &#x26;a,const query &#x26;b){return a.l>b.l;});\n    tree::reset();\n    int cur=l,i;\n    for(const auto &#x26;it:q){\n      while(it.l&#x3C;=cur)tree::add(cur--);\n      for(tree::roll^=1,i=l+1;i&#x3C;=it.r;i++)tree::add(i);\n      ans[it.id]=tree::query();\n      tree::roll^=1,tree::rollback();\n    }\n  }\n}block[S1&#x3C;&#x3C;1];\nvoid build(){\n  std::function&#x3C;int(int)> find=[&#x26;](int x){return anc[x]==x?x:anc[x]=find(anc[x]);};\n  for(int i=1;i&#x3C;=n;i++)anc[i]=i,siz[i]=1;\n  for(int u=1;u&#x3C;=n;u++){\n    for(int v:G[u])if(v&#x3C;u){\n      int fu=find(u),fv=find(v); if(fu==fv)continue;\n      if(siz[fu]>siz[fv])std::swap(fu,fv);\n      pre[u]+=siz[fu],anc[fu]=fv,siz[fv]+=siz[fu];\n    }\n    pre[u]+=G[u].size();\n  }\n  int S=std::accumulate(pre+1,pre+n+1,0)/S1+1;\n  fprintf(stderr,\"> block limit = %d\\n\",S);\n  std::vector&#x3C;std::tuple&#x3C;int,int,int>> seq={{n+1,n,0}};\n  for(int i=n;i>=1;i--){\n    std::get&#x3C;0>(seq.back())--,std::get&#x3C;2>(seq.back())+=pre[i];\n    if(i==1||std::get&#x3C;2>(seq.back())+pre[i]>S)seq.push_back({i,i-1,0});\n  }\n  seq.pop_back(),std::reverse(seq.begin(),seq.end()),blocks=seq.size();\n  for(int _,i=0;i&#x3C;blocks;i++){\n    std::tie(block[i].l,block[i].r,_)=seq[i];\n    block[i].id=i,block[i].init();\n  }\n}\nvoid solve(){\n  for(int i=1;i&#x3C;=n;i++)tree::uni[i].id=i;\n  for(const auto &#x26;it:q)if(bln[it.l]==bln[it.r]){\n    tree::reset();\n    for(int i=it.l;i&#x3C;=it.r;i++)tree::add(i);\n    ans[it.id]=tree::query();\n  }else{\n    block[bln[it.r]].q.push_back(it);\n  }\n  for(int i=0;i&#x3C;blocks;i++)block[i].solve();\n}\nint main(){\n  for(int i=0;i&#x3C;N/S2+5;i++)tree::rub.push_back(i);\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n  freopen(\"1.out\",\"w\",stdout);\n#endif\n  read(n),read(m),read(x);\n  for(int i=1;i&#x3C;=n;i++)read(c[i]),--c[i];\n  for(int u,v,i=1;i&#x3C;n;i++){\n    read(u),read(v);\n    G[u].push_back(v),G[v].push_back(u);\n  }\n  for(int i=0;i&#x3C;=x;i++)read(a[i]);\n  build();\n  for(int l,r,i=1;i&#x3C;=m;i++){\n    read(l),read(r);\n    q.push_back({l,r,i});\n  }\n  solve();\n  for(int i=1;i&#x3C;=m;i++)print(ans[i],'\\n');\n  fprintf(stderr,\"clocks: %.4lf\\n\",clock()/(double)CLOCKS_PER_SEC);\n}\n</code></pre>","frontmatter":{"date":"June 26, 2020","title":"「Ynoi2019」美好的每一天~ 不连续的存在","cover":"/cover/17.webp"}}},"pageContext":{"id":"221e60aa-e8a0-5622-bc39-67eaebb2f622","slug":"blog/problem/luogu6579"}},"staticQueryHashes":[],"slicesMap":{}}