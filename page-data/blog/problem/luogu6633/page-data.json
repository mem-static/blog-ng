{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/luogu6633/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>有 $m$ 张带编号卡牌，每次你可以随机抽取一张。抽中每张的概率均为 $\\frac 1 m$。当编号连续的 $k$ 张牌都被抽取过时，游戏结束。</p>\n<p>问游戏结束的期望步数。</p>\n<p>$1 \\leq k \\leq m \\leq 2 \\times 10^5$。</p>\n</blockquote>\n<!--more-->\n<h2>题解 Part1</h2>\n<p>我们可以直接对每张牌第一次被抽中的操作序列计数。</p>\n<p>把牌的每一段编号连续区间分开考虑，每一段处理出选中连续区间长度不超过 $k$ 的方案数（同时容易得到超过的方案数），然后分治 + NTT 合并，这是平凡的。</p>\n<p>这个做法的时间复杂度是 $O(n^2＋n \\log^2 n)$ 的，瓶颈在于前半部分即处理出分成把 $n$ 个 $m=1...n$ 段满足每一段长度都不超过 $k$ 的方案数，更进一步的可以表示为：\n$$\nB(u) = [x^{n+1}] \\frac 1 {1 - u \\frac {x - x^{k+1}} {1 - x}}\n$$\n我们需要求出多项式 $B$。</p>\n<h2>题解 Part2</h2>\n<p>注意到这是一个拓展拉格朗日反演的形式，我们需要求出 $F(x) = \\frac{x - x^{k+1}} {1 - x}$ 的复合逆。\n相当于我们要求 $G(x)$ 满足 $F(G(x)) = x$，根据多项式牛顿迭代，有\n$$\nT(G(x))\n= F(G(x)) - x\n= \\frac {G(x) - G^{k+1}(x)}{1 - G(x)} - x \\\n\\begin{aligned}\nT'(G(x))\n&#x26;= \\frac {(1 - (k+1)G^k(x))(1 - G(x)) + (G(x) - G^{k+1}(x))}{(1 - G(x))^2} \\\n&#x26;= \\frac {1 - (k+1)G^k(x) + kG^{k+1}(x)} {1 - 2G(x) + G^2(x)} \\\n\\end{aligned}\n$$\n由多项式牛顿迭代，我们可以倍增得到 $G(x)$。</p>\n<h2>题解 Part3</h2>\n<p>代入拓展拉格朗日反演的式子，令 $H(x) = \\frac 1 {1 - ux}$ 我们可以得到\n$$\nS\n= [x^{n+1}] H(F(x))\n= \\frac 1 {n+1} [x^n] H'(x) \\left(\\frac x {G(x)}\\right)^{n+1}\n$$\n设 $T(x) = \\frac 1{n+1} \\left(\\frac x {G(x)}\\right)^{n+1}$，则有\n$$\n\\begin{aligned}\nS\n&#x26;= [x^n] H'(x) T(x) = [x^n] T(x) \\frac {u} {(1-ux)^2} \\\n&#x26;= [x^n] T(x) u \\sum_{i=0}^\\infty (i+1) (ux)^i\n\\end{aligned}\n$$\n即可直接得到 $S(u)$。</p>\n<p>问题解决，总时间复杂度 $O(n\\log^2 n)$。</p>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\n#define log(...) fprintf(stderr,__VA_ARGS__)\ntemplate&#x3C;class T> inline void read(T &#x26;x){\n\tx=0; register char c=getchar(); register bool f=0;\n\twhile(!isdigit(c))f^=c=='-',c=getchar();\n\twhile(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\ntemplate&#x3C;class T> inline void print(T x){\n\tif(x&#x3C;0)putchar('-'),x=-x;\n\tif(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate&#x3C;class T> inline void print(T x,char c){print(x),putchar(c);}\nconst int N=2e5+10,mod=998244353;\nint n,m,k,a[N],b[N],rev[N&#x3C;&#x3C;2];\nstruct z{\n\tint x;\n\tinline z():x(0){}\n\tinline z(int x):x(x){}\n\tfriend inline z operator*(z a,z b){return (long long)a.x*b.x%mod;}\n\tfriend inline z operator-(z a,z b){return (a.x-=b.x)&#x3C;0?a.x+mod:a.x;}\n\tfriend inline z operator+(z a,z b){return (a.x+=b.x)>=mod?a.x-mod:a.x;}\n}ans,len[N],fac[N],ifac[N],w[N&#x3C;&#x3C;2],S[N];\ninline z C(int n,int m){return n&#x3C;m?0:fac[n]*ifac[m]*ifac[n-m];}\ninline z fpow(z a,int b){z s=1;for(;b;b>>=1,a=a*a)if(b&#x26;1)s=s*a;return s;}\nstruct vec:std::vector&#x3C;z>{\n\tusing std::vector&#x3C;z>::vector;\n\tinline void print(){for(int i=0;i&#x3C;size();i++)::print(at(i).x,' ');putchar('\\n');}\n};\ninline vec resize(vec a,int n){a.resize(n); return a;}\nvoid initfac(int n){\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i&#x3C;=n;i++)fac[i]=fac[i-1]*i;\n\tfor(int i=2;i&#x3C;=n;i++)ifac[i]=(mod-mod/i)*ifac[mod%i];\n\tfor(int i=2;i&#x3C;=n;i++)ifac[i]=ifac[i-1]*ifac[i];\n}\nint init(int n){\n\tint lim=1,k=0; while(lim&#x3C;n)lim&#x3C;&#x3C;=1,++k;\n\tfor(int i=0;i&#x3C;lim;i++)rev[i]=(rev[i>>1]>>1)|((i&#x26;1)&#x3C;&#x3C;(k-1));\n\tstatic int len=1;for(;len&#x3C;lim;len&#x3C;&#x3C;=1){\n\t\tz wn=fpow(3,(mod-1)/(len&#x3C;&#x3C;1)); w[len]=1;\n\t\tfor(int i=1;i&#x3C;len;i++)w[i+len]=w[i+len-1]*wn;\n\t}return lim;\n}\nvoid dft(vec &#x26;a,int lim){\n\ta.resize(lim);\n\tfor(int i=0;i&#x3C;lim;i++)if(i&#x3C;rev[i])std::swap(a[i],a[rev[i]]);\n\tfor(int len=1;len&#x3C;lim;len&#x3C;&#x3C;=1)\n\t\tfor(int i=0;i&#x3C;lim;i+=(len&#x3C;&#x3C;1))\n\t\t\tfor(int j=0;j&#x3C;len;j++){\n\t\t\t\tz x=a[i+j],y=a[i+j+len]*w[j+len];\n\t\t\t\ta[i+j]=x+y,a[i+j+len]=x-y;\n\t\t\t}\n}\nvoid idft(vec &#x26;a,int lim){\n\tdft(a,lim),std::reverse(&#x26;a[1],&#x26;a[lim]); z inv=fpow(lim,mod-2);\n\tfor(int i=0;i&#x3C;lim;i++)a[i]=a[i]*inv;\n}\ninline vec mul(vec a,vec b,int l){\n\tif(a.size()&#x3C;10||b.size()&#x3C;10){\n\t\tvec c(a.size()+b.size()-1);\n\t\tfor(int i=0;i&#x3C;a.size();i++)\n\t\t\tfor(int j=0;j&#x3C;b.size();j++)\n\t\t\t\tc[i+j]=c[i+j]+a[i]*b[j];\n\t\treturn c.resize(l),c;\n\t}\n\tint len=a.size()+b.size()-1,lim=init(len);\n\tdft(a,lim),dft(b,lim);\n\tfor(int i=0;i&#x3C;lim;i++)a[i]=a[i]*b[i];\n\treturn idft(a,lim),a.resize(l),a;\n}\ninline vec operator*(const vec &#x26;a,const vec &#x26;b){return mul(a,b,a.size()+b.size()-1);}\ninline vec operator+(vec a,const vec &#x26;b){\n\ta.resize(std::max(a.size(),b.size()));\n\tfor(int i=0;i&#x3C;b.size();i++)a[i]=a[i]+b[i]; return a;\n}\ninline vec operator-(vec a,const vec &#x26;b){\n\ta.resize(std::max(a.size(),b.size()));\n\tfor(int i=0;i&#x3C;b.size();i++)a[i]=a[i]-b[i]; return a;\n}\nvec inv(const vec &#x26;f,int len=-1){\n\tif((len=~len?len:f.size())==1)return {fpow(f[0],mod-2)};\n\tvec a(&#x26;f[0],&#x26;f[len]),b=inv(f,(len+1)>>1);\n\tint lim=init((len&#x3C;&#x3C;1)-1);\n\tdft(a,lim),dft(b,lim);\n\tfor(int i=0;i&#x3C;lim;i++)a[i]=b[i]*(2-a[i]*b[i]);\n\treturn idft(a,lim),a.resize(len),a;\n}\nvec deri(vec f){for(int i=0;i&#x3C;=(int)f.size()-2;i++)f[i]=f[i+1]*(i+1); return f.back()=0,f;}\nvec inte(vec f){for(int i=(int)f.size()-1;i>=1;i--)f[i]=f[i-1]*fpow(i,mod-2); return f.front()=0,f;}\nvec ln(const vec &#x26;f){return inte(mul(inv(f),deri(f),f.size()));}\nvec exp(const vec &#x26;f,int len=-1){\n\tif((len=~len?len:f.size())==1)return {1};\n\tvec a(&#x26;f[0],&#x26;f[len]),b=exp(f,(len+1)>>1);\n\treturn b.resize(len),mul(b,a+vec{1}-ln(b),len);\n}\nvec fpow(vec a,int b){\n\tint n=a.size(); vec s;\n\tfor(int c=0;c&#x3C;n;c++)if(a[c].x){\n\t\tint l=n-c*b;\n\t\tif(l&#x3C;=0)return s.resize(n),s;\n\t\tfor(int i=0;i&#x3C;l;i++)a[i]=a[i+c];\n\t\ta.resize(l);\n\t\ta=ln(a);\n\t\tfor(int i=0;i&#x3C;l;i++)a[i]=a[i]*b;\n\t\ta=exp(a),s.resize(c*b);\n\t\ts.insert(s.end(),a.begin(),a.end());\n\t\treturn s;\n\t}\n\treturn a;\n}\nvec complex(const vec &#x26;g){ //F(G(x))\n\tvec s,c={1};\n\tfor(int i=1;i&#x3C;=k;i++)c=mul(c,g,g.size()),s=s+c;\n\treturn s;\n}\nvec complex_inv(int len){ //G^{-1}(F(x))\n\tif(len==1)return {0};\n\tvec g=resize(complex_inv((len+1)>>1),len),gk=fpow(g,k),gk1=mul(gk,g,len);\n\tvec res=g-mul(mul(g-gk1-vec{0,1}*(vec{1}-g),vec{1}-g,len),inv(vec{1}-vec{k+1}*gk+vec{k}*gk1),len);\n\treturn res;\n}\ninline vec sol(int n){ //\tn+1个球，分m组，每组1~k个。\n\tvec g=complex_inv(n+1),res(n+1);\n\tg.erase(g.begin());\n\tg=fpow(inv(g),n+1)*vec{fpow(n+1,mod-2)};\n\tfor(int i=1;i&#x3C;=n;i++)res[i-1]=(i+1)*g[n-i];\n\tstd::reverse(&#x26;res[0],&#x26;res[n]),res[n]=n+1&#x3C;=k;\n\treturn res;\n}\nstd::pair&#x3C;vec,vec> solve(int l,int r){\n\tif(l==r){\n\t\tint n=b[l];\n\t\tvec F(n+1),G=sol(n);\n\t\tfor(int i=0;i&#x3C;=n;i++){\n\t\t\tF[i]=fac[n]*ifac[n-i]-G[i]*fac[i]-(i?S[i-1]:0)*ifac[n-i];\n\t\t\tS[i]=(i?S[i-1]:0)+F[i]*fac[n-i];\n\t\t}\n\t\tfor(int i=0;i&#x3C;n;i++)F[i]=F[i+1]*ifac[i];\n\t\treturn F.pop_back(),std::pair&#x3C;vec,vec>{F,G};\n\t}\n\tint mid=(l+r)>>1;\n\tauto L=solve(l,(l+r)>>1),R=solve(((l+r)>>1)+1,r);\n\treturn {L.first*R.second+L.second*R.first,L.second*R.second};\n}\nint main(){\n#ifdef memset0\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tread(n),read(k),initfac(n+5);\n\tfor(int i=1;i&#x3C;=n;i++)read(a[i]);\n\tstd::sort(a+1,a+n+1);\n\tfor(int i=1,j;i&#x3C;=n;i=j+1){\n\t\tfor(j=i;j&#x3C;n&#x26;&#x26;a[j+1]==a[i]+j-i+1;j++);\n\t\tb[++m]=j-i+1;\n\t}\n\tauto res=solve(1,m);\n\tfor(int i=1;i&#x3C;=n;i++){\n\t\tlen[i]=len[i-1]+n*fpow(n-i+1,mod-2);\n\t\tans=ans+res.first[i-1]*fac[i-1]*fac[n-i]*len[i];\n\t}\n\tprint((ans*ifac[n]).x,'\\n');\n\tfprintf(stderr,\"clock = %.2lf\\n\",clock()/double(CLOCKS_PER_SEC));\n}\n</code></pre>","frontmatter":{"date":"June 28, 2020","title":"「ZJOI2020」抽卡","cover":"/cover/29.webp"}}},"pageContext":{"id":"a7023ae2-6848-51fc-b5a7-fafd5050db01","slug":"blog/problem/luogu6633"}},"staticQueryHashes":[],"slicesMap":{}}