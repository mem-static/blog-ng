{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/opencup2020-gomel-h/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>给出 $n$ 个区间 $[l_i, r_i]$ ，你需要放下<strong>至多</strong> $n$ 个点，使得每个区间里至少包含一个点。并且区间里点个数的最大值要尽可能小。</p>\n<p>$1 \\le n \\le 10^5, 10^9 \\le l_i &#x3C; r_i \\le 10^9$ 。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p>先按照如下方法贪心：维护一个集合表示当前没有放点的区间，每次选出一个右端点最小的区间，在这个右端点放下一个区间。</p>\n<p>若此时的最大值为 $t$ ，则答案要么为 $t$ 要么为 $t-1$ 。</p>\n<p>证明：考虑一个被放了 $t$ 个点的区间，只有可能把第一个点的移到区间外，其余的点必定在区间内移动。</p>\n<p>怎么判断答案是否为 $t-1$ 呢，定义一个点 $x$ 是合法的当且仅当只考虑 $x$ 和所有被放在 $x$ 右侧的点所有右端点 $r_i\\geq x$ 的区间都能至多放 $t-1$ 个。</p>\n<p>从右往左扫描线，定义 $next_x$ 为在 $x$ 右侧，能找到的最远合法点，且区间 $(x, next_x)$ 内不严格包含任意一个区间。令 $y=next^{t-1}_x$ ，如果不存在一个区间同时包含 $x, y$ ，那么 $x$ 就是合法的。</p>\n<p>求出所有合法点后，若 $min_{i=1}^n (l_i)$ 是合法的，答案为 $t-1$ ，否则答案为 $t$ 。</p>\n<p><img src=\"https://static.memset0.cn/img/v1/20200731225233.png\" alt=\"\"></p>\n<p>（附图：考虑我们是要让每个形如 $x_1$ 的贡献都丢到外面去，但是 $x'_1$ 能取的范围只能在 $[x'_l; x'_r]$ ，否则就不能完整覆盖内部线段）</p>\n<h2>坑</h2>\n<p>一开始调了半天就是离散化的问题。</p>\n<p>实际上区间间留白的部分是有影响的（考虑是否完全包含的时候），把这部分也丢进去离散化就过了，哭哭。</p>\n<p>不过别的部分能一遍写对还是挺开心的。</p>\n<h2>zimpha 的题解</h2>\n<p>考虑每个区间至少放一个点的贪心做法。维护一个集合表示当前没有放点的区间，每次选出一个右端点最小的区间，在这个右端点放下一个区间。</p>\n<p>如果在上述方案下，最大值为 $t$ ，那么可以证明最优值要么是 $t$ ，要么是 $t-1$ 。</p>\n<p>考虑上述方案下，包含点数最多的那个区间 $[l, r]$ 。假设这 $t$ 个点从左往右依次为 $x_1, x_2, \\dots, x_t$ 。那么在最优方案下，这个区间里的点个数肯定要 $\\le t$ 。考虑 $l$ 左边的第一个点为 $x^\\prime_1$ ，那么接下来那个点 $x^\\prime_2$ 一定要不超过 $x_2$ 。因为我们需要用 $x^\\prime_2$ 来覆盖被 $x_1$ 覆盖的区间，如果超过 $x_2$ ，肯定会有区间没有被覆盖。类似的， $x^\\prime_3$ 一定不能超过 $x_3$ 。依次类推， $x^\\prime_t$ 一定不能超过 $x_t$ 。也就是少区间 $[l, r]$ 里至少要有 $t-1$ 个点。</p>\n<p>那么接下来只需要判定 $t-1$ 是否可行即可。我们从左往右考虑数轴上每个点 $x$ ，定义 $x$ 是合法的当且仅当如果我们的方案包含了点 $x$ 后，仅考虑加入其它 $\\ge x$ 的点，所有右端点 $r_i \\ge x$ 的区间里面最多只有 $t-1$ 个点。令 $next(x)$ 是 $x$ 右边最远的合法的点，使得没有区间 $[l_i, r_i]$ 严格在区间 $[x, next_x]$ 里。考虑 $y=next^{t-1}(x)$ ，如果存在一个 $[l_i, r_i]$ 同时包含了端点 $x$ 和 $y$ ，那么 $x$ 显然是不合法的，否则 $x$ 是合法的。</p>\n<p>最后如果所有点 $\\min(l_i)-1$ 是合法的，那么就存在一个 $t-1$ 的解。</p>\n<p>复杂度 $O(n \\log n)$ 。</p>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\n// #define log(...) (void(0))\n#define log(...) fprintf(stderr,__VA_ARGS__)\ntemplate&#x3C;class T> inline void read(T &#x26;x){\n  x=0; register char c=getchar(); register bool f=0;\n  while(!isdigit(c))f^=c=='-',c=getchar();\n  while(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\ntemplate&#x3C;class T> inline void print(T x){\n  if(x&#x3C;0)putchar('-'),x=-x;\n  if(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate&#x3C;class T> inline void print(T x,char c){print(x),putchar(c);}\nconst int N=6e5+10,M=21;\nint T,n,t,tn,ta[N],maxl[N],maxr[N],mrk[N],nxt[N][M];\nstd::vector&#x3C;int> pos,ans;\nstruct node{\n  int l,r;\n}a[N];\ninline bool inside(int l,int r){return l&#x3C;=r&#x26;&#x26;maxl[r]>=l;}\ninline bool outside(int l,int r){return l>r||maxr[l]>=r;}\nnamespace seg{\n  struct node{\n    int l,r,mid,s;\n  }p[N&#x3C;&#x3C;2];\n  void build(int u,int l,int r){\n    p[u].l=l,p[u].r=r,p[u].mid=(l+r)>>1,p[u].s=0;\n    if(l==r)return;\n    build(u&#x3C;&#x3C;1,l,p[u].mid);\n    build(u&#x3C;&#x3C;1|1,p[u].mid+1,r);\n  }\n  void modify(int u,int k,int x){\n    if(p[u].l==p[u].r){p[u].s+=x; return;}\n    modify(k&#x3C;=p[u].mid?u&#x3C;&#x3C;1:u&#x3C;&#x3C;1|1,k,x);\n    p[u].s=p[u&#x3C;&#x3C;1].s+p[u&#x3C;&#x3C;1|1].s;\n  }\n  int query(int u,int l,int r){\n    if(p[u].l==l&#x26;&#x26;p[u].r==r)return p[u].s;\n    if(r&#x3C;=p[u].mid)return query(u&#x3C;&#x3C;1,l,r);\n    if(l>p[u].mid)return query(u&#x3C;&#x3C;1|1,l,r);\n    return query(u&#x3C;&#x3C;1,l,p[u].mid)+query(u&#x3C;&#x3C;1|1,p[u].mid+1,r);\n  }\n}\nint main(){\n#ifdef local\n  freopen(\"1.in\",\"r\",stdin);\n#endif\n  for(read(T);T--;){\n    t=tn=0,ans.clear(),pos.clear();\n    read(n);\n    ta[++tn]=1e9+10,ta[++tn]=-1e9-10;\n    for(int i=1;i&#x3C;=n;i++){\n      read(a[i].l),ta[++tn]=a[i].l;\n      read(a[i].r),ta[++tn]=a[i].r;\n      ta[++tn]=a[i].l-1,ta[++tn]=a[i].l+1;\n      ta[++tn]=a[i].r-1,ta[++tn]=a[i].r+1;\n    }\n    std::sort(ta+1,ta+tn+1);\n    tn=std::unique(ta+1,ta+tn+1)-ta-1;\n    for(int i=1;i&#x3C;=n;i++){\n      a[i].l=std::lower_bound(ta+1,ta+tn+1,a[i].l)-ta;\n      a[i].r=std::lower_bound(ta+1,ta+tn+1,a[i].r)-ta;\n    }\n    memset(maxl+1,0,tn&#x3C;&#x3C;2);\n    memset(maxr+1,0,tn&#x3C;&#x3C;2);\n    for(int i=1;i&#x3C;=n;i++){\n      maxl[a[i].r]=std::max(maxl[a[i].r],a[i].l);\n      maxr[a[i].l]=std::max(maxr[a[i].l],a[i].r);\n    }\n    for(int i=1;i&#x3C;=tn;i++){\n      maxl[i]=std::max(maxl[i-1],maxl[i]);\n      maxr[i]=std::max(maxr[i-1],maxr[i]);\n    }\n    std::sort(a+1,a+n+1,[](const node &#x26;a,const node &#x26;b){\n      return a.r==b.r?a.l&#x3C;b.l:a.r&#x3C;b.r;\n    });\n    seg::build(1,1,tn);\n    for(int i=1;i&#x3C;=n;i++)\n      if(!seg::query(1,a[i].l,a[i].r)){\n        seg::modify(1,a[i].r,1);\n        ans.push_back(a[i].r);\n      }\n    for(int i=1;i&#x3C;=n;i++){\n      t=std::max(t,seg::query(1,a[i].l,a[i].r));\n    }\n    if(t>1){\n      // log(\">> %d\\n\",n);\n      // for(int i=1;i&#x3C;=n;i++)log(\"(%d %d)%c\",a[i].l,a[i].r,\" \\n\"[i==n]);\n      memset(mrk+1,0,tn);\n      pos.push_back(tn),mrk[tn]=1;\n      for(int i=0;i&#x3C;M;i++)nxt[tn][i]=tn;\n      for(int i=tn-1,j,l,r,mid,s,k;i>=1;i--){\n        l=0,r=pos.size()-1,nxt[i][0]=-1;\n        while(l&#x3C;=r){\n          mid=(l+r)>>1;\n          if(!inside(i+1,pos[mid]-1)){\n            nxt[i][0]=pos[mid];\n            r=mid-1;\n          }else{\n            l=mid+1;\n          }\n        }\n        if(!~nxt[i][0])continue;\n        for(j=nxt[i][0],k=M-1,s=t-2;k>=0;k--){\n          if((s>>k)&#x26;1)j=nxt[j][k];\n        }\n        // log(\"i=%d nxt_i=%d nxt^t-1_i=%d\\n\",i,nxt[i][0],j);\n        if(outside(i,j))continue;\n        pos.push_back(i),mrk[i]=1;\n        for(int j=1;j&#x3C;M;j++){\n          nxt[i][j]=nxt[nxt[i][j-1]][j-1];\n        }\n      }\n      // for(int i=1;i&#x3C;=tn;i++)log(\"%d%c\",mrk[i],\" \\n\"[i==tn]);\n      int minl=tn;\n      for(int i=1;i&#x3C;=n;i++)minl=std::min(minl,a[i].l);\n      // log(\"minl=%d\\n\",minl);\n      if(mrk[minl-1]){\n        --t,ans.clear();\n        int u=minl-1;\n        while(u!=tn)ans.push_back(u),u=nxt[u][0];\n        if(ans.front()==1)ans.erase(ans.begin());\n      }\n    }\n    print(t,' ');\n    print(ans.size(),' ');\n    for(int i=0;i&#x3C;ans.size();i++){\n      print(ta[ans[i]],\" \\n\"[i+1==ans.size()]);\n    }\n    // printf(\"%d\\n\",t);\n  }\n}\n</code></pre>","frontmatter":{"date":"July 31, 2020","title":"「XX Open Cup. GP of Gomel」Hit","cover":"/cover/21.webp"}}},"pageContext":{"id":"a91d74a5-1d6e-5c64-bc13-7d73565c0d94","slug":"blog/problem/opencup2020-gomel-h"}},"staticQueryHashes":[],"slicesMap":{}}