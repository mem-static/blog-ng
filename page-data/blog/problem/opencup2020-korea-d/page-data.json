{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/opencup2020-korea-d/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>给定两个长度 $n$ 的序列 $s,t$，每一位是 $1$ 或者 $2$。每一次你可以翻转长度 $\\leq 3$ 的区间，代价为区间和加上常数 $c$。问从 $s$ 变换到 $t$ 的最小代价。</p>\n<p>$n \\leq 500$。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p>非常巧妙的一个题。</p>\n<p>我们转化为格路问题，$1$ 表示向右走，$2$ 表示向上走。则 $s$ 和 $t$ 对应的两条路线，被他们的交点分割为若干段。</p>\n<p>相当于我们需要用 $1 \\times 1, 1 \\times 2, 2 \\times 1$ 三种长方形填充到两条路线包围住的区间里。不妨先设初始解为全用 $1 \\times 1$ 的网格填充，黑白染色后相当于在得到的二分图跑最小费用最大流。</p>\n<p>注意到放一个 $2 \\times 1$ 的长方形对应的边权是 $2+c$，$1 \\times 2$ 的长方形对应的边权是 $1+c$。一开始我们可以贪心的填 $2 \\times 1$ 的长方形，这样剩下未被覆盖的格子只有 $O(n)$ 个。在这个残量网络上跑增广，容易证明至多增广 $O(n)$ 次。</p>\n<p>求方案可能还需要跑个拓扑排序。</p>\n<p>时间复杂度 $O(n^3 \\log n)$，然而听说有牛逼的 $O(n^2)$ DP 做法。</p>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\nconst int N=510,M=1&#x3C;&#x3C;21;\nint n,c,s,t,l,r,ans,cnt,nod,ind[N*N],q[M],pre[M],dis[M],minA[N],minB[N],id[N][N],num[N][N];\nint tot=2,hed[M],nxt[M],to[M],val[M],cst[M];\nbool map[N][N],inq[M];\nchar a[N],b[N];\nstd::vector&#x3C;int> G[N*N];\nstd::vector&#x3C;std::pair&#x3C;int,int>> seq(1),loc(1);\ninline void add(int u,int v,int w){\n  // printf(\"add %d %d %d\\n\",u,v,w);\n  nxt[tot]=hed[u],to[tot]=v,val[tot]=1,cst[tot]= w,hed[u]=tot++;\n  nxt[tot]=hed[v],to[tot]=u,val[tot]=0,cst[tot]=-w,hed[v]=tot++;\n}\nvoid way(char *a,int *min){\n  int x=1,y=1;\n  for(int i=1;i&#x3C;=n;i++)\n    if(a[i]=='1'){\n      min[x]=y;\n      for(int i=y;i&#x3C;N;i++)map[x][i]^=1;\n      ++x;\n    }else{\n      ++y;\n    }\n}\nbool spfa(){\n  memset(pre+1,0,nod&#x3C;&#x3C;2);\n  memset(dis+1,-63,nod&#x3C;&#x3C;2);\n  dis[s]=pre[s]=0;\n  q[l=r=1]=s,inq[s]=true;\n  while(l&#x3C;=r){\n    int u=q[(l++)%M];\n    inq[u]=false;\n    for(int i=hed[u];i;i=nxt[i])\n      if(val[i]&#x26;&#x26;dis[to[i]]&#x3C;dis[u]+cst[i]){\n        pre[to[i]]=i;\n        dis[to[i]]=dis[u]+cst[i];\n        if(!inq[to[i]])q[(++r)%M]=to[i],inq[to[i]]=1;\n      }\n  }\n  // for(int i=1;i&#x3C;=n;i++)printf(\"%d%c\",dis[i],\" \\n\"[i==n]);\n  return pre[t]&#x26;&#x26;dis[t]>0;\n}\nint main(){\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n#endif\n  scanf(\"%d%d%s%s\",&#x26;n,&#x26;c,a+1,b+1);\n  way(a,minA);\n  way(b,minB);\n  for(int i=0;i&#x3C;N;i++)\n    for(int j=0;j&#x3C;N;j++)\n      if(map[i][j]){\n        id[i][j]=++nod;\n        loc.push_back({i,j});\n        ans+=3+c;\n        // printf(\"(%d,%d)\\n\",i,j);\n      }\n  fprintf(stderr,\"ans=%d\\n\",ans);\n  s=++nod,t=++nod;\n  for(int i=0;i&#x3C;N;i++)\n    for(int j=0;j&#x3C;N;j++)\n      if(map[i][j]){\n        if((i+j)&#x26;1){\n          add(s,id[i][j],0);\n          for(int d=-1;d&#x3C;=1;d+=2){\n            if(map[i+d][j])add(id[i][j],id[i+d][j],2+c);\n            if(map[i][j+d])add(id[i][j],id[i][j+d],1+c);\n          }\n        }else{\n          add(id[i][j],t,0);\n        }\n      }\n  for(int i=0;i&#x3C;N;i++)\n    for(int j=0;j&#x3C;N;j++)\n      if(map[i][j]&#x26;&#x26;map[i+1][j]){\n        auto connect=[&#x26;](int i,int j){\n          int u=id[i][j];\n          for(int i=hed[u];i;i=nxt[i]){\n            if(to[i]==s)return val[i];\n            if(to[i]==t)return val[i^1];\n          }\n          assert(0);\n        };\n        auto play=[&#x26;](int u,int v,int k){\n          for(int i=hed[u];i;i=nxt[i])\n            if(to[i]==v){\n              ans-=k*cst[i];\n              val[i]-=k,val[i^1]+=k;\n            }\n        };\n        if(!connect(i,j)&#x26;&#x26;!connect(i+1,j)){\n          int u=id[i][j],v=id[i+1][j];\n          if(!((i+j)&#x26;1))std::swap(u,v);\n          play(u,s,-1);\n          play(u,v,1);\n          play(v,t,1);\n        }\n      }\n  fprintf(stderr,\"ans=%d\\n\",ans);\n  while(spfa()){\n    int sum=0;\n    for(int i=pre[t];i;i=pre[to[i^1]]){\n      sum+=cst[i];\n      val[i]--,val[i^1]++;\n    }\n    ans-=sum;\n    // printf(\"flow -> %d\\n\",sum);\n  }\n  // for(int i=2;i&#x3C;tot;i++)printf(\"%d -> %d : %d %d\\n\",to[i^1],to[i],val[i],cst[i]);\n  fprintf(stderr,\"ans=%d\\n\",ans);\n  for(int i=0;i&#x3C;N;i++)\n    for(int j=0;j&#x3C;N;j++)\n      if(map[i][j]&#x26;&#x26;((i+j)&#x26;1)){\n        int ii=0,jj=0;\n        for(int k=hed[id[i][j]];k;k=nxt[k])\n          if(to[k]!=s&#x26;&#x26;val[k^1]){\n            ii=loc[to[k]].first;\n            jj=loc[to[k]].second;\n          }\n        if(ii&#x26;&#x26;jj){\n          // printf(\"paired (%d,%d) (%d,%d)\\n\",i,j,ii,jj);\n          int k=std::min(i+j,ii+jj)-1;\n          num[i][j]=num[ii][jj]=++cnt;\n          seq.push_back({k,k+2});\n        }\n      }\n  for(int i=0;i&#x3C;N;i++)\n    for(int j=0;j&#x3C;N;j++)\n      if(map[i][j]&#x26;&#x26;!num[i][j]){\n        int k=i+j-1;\n        num[i][j]=++cnt;\n        seq.push_back({k,k+1});\n      }\n  // for(int i=1;i&#x3C;=cnt;i++)printf(\"seq[%d] = {%d, %d}\\n\",i,seq[i].first,seq[i].second);\n  for(int i=0;i&#x3C;N;i++)\n    for(int j=0;j&#x3C;N;j++)\n      if(map[i][j]){\n        if(minA[i]&#x3C;minB[i]){\n          if(map[i+1][j]&#x26;&#x26;num[i][j]!=num[i+1][j]){\n            G[num[i+1][j]].push_back(num[i][j]);\n            ++ind[num[i][j]];\n          }\n          if(map[i][j-1]&#x26;&#x26;num[i][j]!=num[i][j-1]){\n            G[num[i][j-1]].push_back(num[i][j]);\n            ++ind[num[i][j]];\n          }\n        }else{\n          if(map[i-1][j]&#x26;&#x26;num[i][j]!=num[i-1][j]){\n            G[num[i-1][j]].push_back(num[i][j]);\n            ++ind[num[i][j]];\n          }\n          if(map[i][j+1]&#x26;&#x26;num[i][j]!=num[i][j+1]){\n            G[num[i][j+1]].push_back(num[i][j]);\n            ++ind[num[i][j]];\n          }\n        }\n      }\n  printf(\"%d\\n\",cnt);\n  l=1,r=0;\n  for(int i=1;i&#x3C;=cnt;i++)if(!ind[i])q[++r]=i;\n  while(l&#x3C;=r){\n    int u=q[l++];\n    printf(\"%d %d\\n\",seq[u].first,seq[u].second);\n    for(int v:G[u]){\n      if(!--ind[v])q[++r]=v;\n    }\n  }\n}\n</code></pre>","frontmatter":{"date":"August 02, 2020","title":"「XX Open Cup. GP of Korea」Container","cover":"/cover/22.webp"}}},"pageContext":{"id":"28e5099a-033f-5471-8994-fa0a3e72dae0","slug":"blog/problem/opencup2020-korea-d"}},"staticQueryHashes":[],"slicesMap":{}}