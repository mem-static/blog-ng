{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/petrozavodsk2020-summer-day5-c/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>定义一个排列 $P$ 上的操作 $(t,S)$ 为：</p>\n<ol>\n<li>有两个空序列 $A$ 和 $B$</li>\n<li>枚举 $i$ 从 $1$ 到 $n$\n<ul>\n<li>如果 $S_i=0$，不进行操作</li>\n<li>如果 $S_i=1$，如果 $P_i$ 是偶数，则放到 $A$ 的末尾，否则放到 $B$ 的末尾</li>\n</ul>\n</li>\n<li>如果 $t=0$，$C=\\overline{AB}$；否则 $C=\\overline{BA}$。</li>\n<li>枚举 $i$ 从 $1$ 到 $n$\n<ul>\n<li>如果 $S_i=0$，不进行操作</li>\n<li>如果 $S_i=1$，将 $P_i$ 设为 $C$ 的开头元素，删去 $C$ 的开头元素</li>\n</ul>\n</li>\n</ol>\n<p>现给出一个排列 $P$，你需要使用至多 $30$ 次如上操作，使 $P$ 从小到大排序，注意你并不需要最小化操作次数。</p>\n<p>$1\\le n\\le 15000$。</p>\n</blockquote>\n<!--more-->\n<h2>题意补充</h2>\n<p>对于 $P={0,4,2,3,6,5,1}$ 上的操作 $(1,\\texttt{1101101})$，有示意图如下</p>\n<img src=\"https://static.memset0.cn/img/v4/2021/09/20/0rrCPC9T.png\" width:400px margin:auto>\n<h2>题解</h2>\n<p>由于 $30=2\\left(\\left\\lfloor\\log n\\right\\rfloor\\right)+1$，我们考虑 $t=0$ 和 $t=1$ 的操作交错执行。</p>\n<p>首先可以确定最后一次操作前，每个数的位置，如 $n=13$ 的时候，最后一次操作前的 $p$ 应为：</p>\n<pre><code class=\"language-plain\">0 8 2 10 4 12 6 7 1 9 3 11 5\n</code></pre>\n<p>故对于每个数，我们求出此时期望的位置 $rk$，也就是说，现在我们要把每个 $p_i$，移动到 $rk_{p_i}$ 的位置上。</p>\n<p>考虑从低位到高位，每次把这一位是 $1$ 的数不改变相对顺序地丢到最后面，$\\log$ 次后即可完成排序。</p>\n<p>先进行一次 $(0,\\texttt{111\\ldots1})$ 操作后，所有偶数都在奇数前面，我们可以认为是两个序列；把偶数中需要放后面的数和奇数中需要放前面的数执行 $t=1$ 操作即可。但 $n$ 时可能两侧的数字个数不同，这时候给偶数序列中多丢一个 $0$ 就好了。</p>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\nusing namespace std;\n\nconst int N=150009;\nint n,m,t,p[N],rk[N];\nstring s;\nvector&#x3C;int> a,b,c;\nvector&#x3C;pair&#x3C;bool,string>> ans;\n\nvoid apply(bool t,const string &#x26;s){\n  a.clear(),b.clear();\n  for(int i=0;i&#x3C;n;i++)if(s[i]=='1')(p[i]&#x26;1?b:a).push_back(p[i]);\n  if(t)swap(a,b);\n  c=a,c.insert(c.end(),b.begin(),b.end());\n  reverse(c.begin(),c.end());\n  for(int i=0;i&#x3C;n;i++)if(s[i]=='1')p[i]=c.back(),c.pop_back();\n  ans.push_back(make_pair(t,s));\n}\n\nvoid solve(){\n  int s00=((n+1)/2+1)/2,s01=(n+1)/4,s10=s01,s11=n/2-s10;\n  assert(s00+s01+s10+s11==n);\n  for(int i=0;i&#x3C;s00;i++)rk[i&#x3C;&#x3C;1]=i&#x3C;&#x3C;1;\n  for(int i=0;i&#x3C;s10;i++)rk[(i+s00)&#x3C;&#x3C;1]=i&#x3C;&#x3C;1|1;\n  for(int i=0;i&#x3C;s01;i++)rk[i&#x3C;&#x3C;1|1]=(i+s00)&#x3C;&#x3C;1;\n  for(int i=0;i&#x3C;s11;i++)rk[(i+s10)&#x3C;&#x3C;1|1]=(i+s10)&#x3C;&#x3C;1|1;\n  for(int i=1;i&#x3C;n;i+=2)rk[i]=n-1-rk[i]+(n&#x26;1);\n  // for(int i=0;i&#x3C;n;i++)fprintf(stderr,\"%d%c\",rk[i],\" \\n\"[i+1==n]);\n  for(int k=0;k&#x3C;14;k++){\n    apply(0,string(n,'1'));\n    s=string(n,'0');\n    // for(int i=0;i&#x3C;n;i++)cerr&#x3C;&#x3C;p[i]&#x3C;&#x3C;\" \\n\"[i+1==n];\n    int t=0;\n    for(int i=0;i&#x3C;n;i++)if(p[i]%2==0&#x26;&#x26;(rk[p[i]]>>k)%2==1)s[i]='1';\n    for(int i=0;i&#x3C;n;i++)if(p[i]%2==1&#x26;&#x26;(rk[p[i]]>>k)%2==1)s[i]='1';\n    // cerr&#x3C;&#x3C;s&#x3C;&#x3C;endl;\n    // for(int i=0;i&#x3C;n;i++)cerr&#x3C;&#x3C;rk[p[i]]&#x3C;&#x3C;\" \\n\"[i+1==n];\n    apply(1,s);\n  }\n  apply(0,string(n,'1'));\n  s=string(n,'0');\n  for(int i=0;i&#x3C;n;i++)if(p[i]!=i)s[i]='1';\n  apply(1,s);\n  // for(int i=0;i&#x3C;n;i++)cerr&#x3C;&#x3C;p[i]&#x3C;&#x3C;\" \\n\"[i+1==n];\n  for(int i=0;i&#x3C;n;i++)assert(p[i]==i);\n}\n\nint main(){\n#ifdef memset0\n  // freopen(\"1.in\",\"r\",stdin);\n  freopen(\"2.in\",\"r\",stdin);\n#endif\n  ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n  cin>>n;\n  for(int i=0;i&#x3C;n;i++)cin>>p[i];\n  solve();\n  cout&#x3C;&#x3C;ans.size()&#x3C;&#x3C;endl;\n  for(const auto &#x26;it:ans)cout&#x3C;&#x3C;(it.first?1:0)&#x3C;&#x3C;\" \"&#x3C;&#x3C;it.second&#x3C;&#x3C;endl;\n}\n</code></pre>","frontmatter":{"date":"January 21, 2021","title":"「Petrozavodsk Summer 2020」Parity Sort","cover":"/cover/14.png"}}},"pageContext":{"id":"f536b5c8-62c0-5844-adaf-ce81f3934a35","slug":"blog/problem/petrozavodsk2020-summer-day5-c"}},"staticQueryHashes":[],"slicesMap":{}}