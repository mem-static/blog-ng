{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/uoj120/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>给定 $n$ 和 $c_{0\\ldots n}$，表示限制形如对于 $0 \\leq i \\leq n$ 都满足 $1 \\leq f(i) \\leq c_i$。</p>\n<p>其中 $f(x) = \\sum_{i=0}^{n} a_i x^i$，其中 $a_{0 \\ldots n}$ 都是整数，即 $f(x)$ 是一个不超过 $n$ 次的整系数多项式。</p>\n<p>问满足限制的 $f(x)$ 有多少个，答案对 $998244353$ 取模。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p>考虑把 $1 \\leq f(i) \\leq c_i$ 的限制转换为 $0 \\leq f(i) &#x3C; c_i$，且将 $f(x)$ 转化为下降幂多项式。注意到这些转化不会影响到答案。</p>\n<p>我们令 $a_i = x_i (n-i)! + y_i$，考虑枚举 $y_i$ 后怎么计算答案。</p>\n<p>我们提出其中一项式子：</p>\n<p>$$\n0 \\leq a_0 + k a_1 + k^{\\underline 2}a_2 + k^{\\underline 3} a_3 + \\cdots + k! a_k &#x3C; c_k\n$$</p>\n<p>把前半部分设为 $d_k$，则有：</p>\n<p>$$\n0 \\leq d_k + k!a_k &#x3C; c_k\n$$</p>\n<p>代入 $a_k = x_k (n-k)! + y_k$ 得：</p>\n<p>$$\n0 \\leq d_k + k!(x_k (n-k)! + y_k) &#x3C; c_k\n$$</p>\n<p>其中 $y_k$ 是我们已经枚举的整数，故只需要考虑对 $x_k$ 计数即可。</p>\n<p>$$\n-d_k - k! y_k \\leq k!(n-k)! x_k &#x3C; c_k - d_k - k! y_k\n$$</p>\n<p>答案显然是在 $\\frac {c_k} {k!(n-k)!}$ 的级别，但是会有 $\\pm 1$ 的偏差，取决于不等式两边在模意义下的大小，具体地（令 $C=d_k+ k!y_k ,\\ M = k!(n-k)!$）：</p>\n<p>$$\n\\operatorname{count}(x_k)= \\begin{cases}\n\\lfloor \\frac {c_k} {M} \\rfloor &#x26; (C \\bmod M \\leq c_k + C \\bmod M) \\\n\\lfloor \\frac {c_k} {M} \\rfloor +1 &#x26; (C \\bmod M > c_k + C \\bmod M) \\\n\\end{cases}\n$$</p>\n<p>我们现在考察 $C\\bmod M$ 的关系，$k!y_k$ 的贡献是已知常数，考虑：</p>\n<p>$$\nd_k\n= \\sum_{i=0}^{k-1} a_i k^{\\underline i}\n= \\sum_{i=0}^{k-1} (x_i(n-i)! + y_i) k^{\\underline i}\n$$</p>\n<p>注意到 $(n-i)!k^{\\underline i}$ 是 $M$ 的倍数，故 $C \\bmod M$ 只和 $y_{0 \\ldots k}$ 有关。</p>\n<p>可以通过枚举 $y_{0 \\ldots n}$ 后计算，时间复杂度 $O(n \\times n! \\times (n-1)! \\times \\cdots \\times 1!)$。</p>\n<p>虽然理论上来说是不能过的但是可以通过巨大多常数优化草过去，实际表现还是跑的挺快的。（竟然比以小常数著名的 zx2003 学长快！）</p>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,fma,tune=native\") \n#include&#x3C;bits/stdc++.h>\n\nnamespace mem{ //v1.8.5 => size: 13.21KiB\n  #define MEM_IO\n  #define MEM_STR\n  #define MEM_MATH\n  #define MEM_UTILS\n  #define MEM_MODINT\n  #define MEM_RANDOM\n  #define MEM_STDVAL\n  #define MEM_CONTAINER\n  #ifdef memset0\n  #else\n    #define MEM_FASTIO\n  #endif\n\n  #ifdef __SIZEOF_INT128__\n    #define MEM_INT128\n  #endif\n\n  #define __integer_mapper(func)     \\\n      func(int)                      \\\n      func(unsigned int)             \\\n      func(long long)                \\\n      func(unsigned long long)\n  #define __float_mapper(func)       \\\n      func(float)                    \\\n      func(double)\n  #define __string_mapper(func) \\\n      func(char *)              \\\n      func(string &#x26;)            \\\n      func(std::string &#x26;)\n  #define __string_join_mapper(func)                                              \\\n      func(vector&#x3C;string>,string)                                                 \\\n      func(std::vector&#x3C;string>,string)                                            \\\n      template&#x3C;class T> func(vector&#x3C;T>,to_string)                                 \\\n      template&#x3C;class T> func(std::vector&#x3C;T>,to_string)\n\n  #ifdef MEM_STDVAL\n    namespace stdval{\n      using i32=int;\n      using i64=long long;\n      using u32=unsigned int;\n      using u64=unsigned long long;\n      using f32=float;\n      using f64=double;\n  #ifdef MEM_INT128\n      using i128=__int128_t;\n      using u128=__uint128_t;\n  #endif\n    }\n  #endif\n\n  #ifdef MEM_UTILS\n    namespace utils{\n      using std::cin;\n      using std::tie;\n      using std::cout;\n      using std::cerr;\n      using std::endl;\n      using std::swap;\n      using std::sort;\n      using std::unique;\n      using std::reverse;\n      using std::shuffle;\n      using std::function;\n      using std::make_pair;\n      using std::make_tuple;\n      using std::lower_bound;\n      using std::upper_bound;\n      using std::max_element;\n      using std::min_element;\n    }\n  #endif\n\n  #ifdef MEM_IO\n    namespace io{\n  #ifdef MEM_FASTIO\n      namespace fastio{\n        const int BUFFER=1&#x3C;&#x3C;21;\n        char ibuf[BUFFER],*iS,*iT;\n        inline int getc(){\n          if(iS==iT){\n            iT=(iS=ibuf)+fread(ibuf,1,BUFFER,stdin);\n            return iS==iT?EOF:*iS++;\n          }else{\n            return *iS++;\n          }\n        }\n        char obuf[BUFFER],*oS=obuf,*oT=oS+BUFFER-1;\n        inline void flush(){\n          fwrite(obuf,1,oS-obuf,stdout);\n          oS=obuf;\n        }\n        inline void putc(int x){\n          *oS++=x;\n          if(oS==oT)flush();\n        }\n        struct Flusher{~Flusher(){flush();}}flusher;\n      }\n      using fastio::getc;\n      using fastio::putc;\n  #else\n      inline int getc(){return getchar();}\n      inline void putc(int c){putchar(c);}\n  #endif\n      \n      template&#x3C;class T> inline void readDigit(T &#x26;x){\n        x=getc();\n        while(!isdigit(x))x=getc();\n      }\n      inline int readDigit(){\n        int x;\n        readDigit(x);\n        return x;\n      }\n      template&#x3C;class T> inline void readAlpha(T &#x26;x){\n        x=getc();\n        while(!isalpha(x))x=getc();\n      }\n      inline int readAlpha(){\n        int x;\n        readAlpha(x);\n        return x;\n      }\n      template&#x3C;class T> inline void readInt(T &#x26;x){\n        x=0;\n        bool f=0;\n        char c=getc();\n        while(!isdigit(c))f^=c=='-',c=getc();\n        while(isdigit(c))x=x*10+c-'0',c=getc();\n        if(f)x=-x;\n      }\n\n  #define __read(T)                             \\\n      inline void read(T &#x26;x) {                  \\\n        x=0; bool f=0; char c=getc();           \\\n        while(!isdigit(c))f^=c=='-',c=getc();   \\\n        while(isdigit(c))x=x*10+c-'0',c=getc(); \\\n        if(f)x=-x;                              \\\n      }\n      __integer_mapper(__read)\n  #undef __read\n      \n      inline void read(char &#x26;x){x=getc();}\n      template&#x3C;class T=int> inline T read(){\n        T x;\n        read(x);\n        return x;\n      }\n      template&#x3C;class T,class... Args> inline void read(T &#x26;x,Args &#x26;... args){\n        read(x),read(args...);\n      }\n\n  #define __print(T)           \\\n      inline void print(T x){  \\\n        if(x&#x3C;0)putc('-'),x=-x; \\\n        if(x>9)print(x/10);    \\\n        putc('0'+x%10);        \\\n      }\n      __integer_mapper(__print)\n  #undef __print\n      \n      inline void print(char x){putc(x);}\n      inline void print(const char *s){\n        int len=strlen(s);\n        for(int i=0;i&#x3C;len;i++)putc(s[i]);\n      }\n      inline void print(const std::string &#x26;s){\n        for(int i=0;i&#x3C;s.length();i++)putc(s[i]);\n      }\n      \n      template&#x3C;class T,class... Args> inline void print(const T &#x26;x,Args... args){\n        print(x),print(args...);\n      }\n      template&#x3C;class... Args> inline void println(Args... args){\n        print(args...),putc('\\n');\n      }\n    }\n  #endif\n\n  #ifdef MEM_RANDOM\n    namespace random{\n      const int LuckyNumber=20040725;\n      std::mt19937 rng(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n      std::mt19937_64 rng64(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n      \n      template&#x3C;class T> inline T rand(T l,T r){return std::uniform_int_distribution&#x3C;T>(l,r)(rng);}\n      template&#x3C;class T> inline T rand64(T l,T r){return std::uniform_int_distribution&#x3C;T>(l,r)(rng);}\n    }\n  #endif\n\n  #ifdef MEM_MODINT\n    namespace modint{\n      template&#x3C;const int mod> struct Z{\n        int x;\n        inline Z(){x=0;}\n        inline Z(int t){x=t;}\n        \n        inline void operator-=(Z a){(x-=a.x)&#x3C;0&#x26;&#x26;(x+=mod);}\n        inline void operator+=(Z a){(x+=a.x)>=mod&#x26;&#x26;(x-=mod);}\n        inline void operator*=(Z a){x=(long long)x*a.x%mod;}\n        \n        friend inline Z operator*(Z a,Z b){return (long long)a.x*b.x%mod;}\n        friend inline Z operator-(Z a,Z b){return ((a.x-=b.x)&#x3C;0&#x26;&#x26;(a.x+=mod)),a;}\n        friend inline Z operator+(Z a,Z b){return ((a.x+=b.x)>=mod&#x26;&#x26;(a.x-=mod)),a;}\n      };\n      \n      template&#x3C;const int mod> inline Z&#x3C;mod> finv(Z&#x3C;mod> x){\n        if(x.x&#x3C;2)return x;\n        return (mod-mod/x.x)*finv(mod%x.x);\n      }\n      template&#x3C;const int mod> inline Z&#x3C;mod> fpow(Z&#x3C;mod> a,int b){\n        Z &#x3C;mod> s=1;\n        for(;b;b>>=1,a=a*a)\n          if(b&#x26;1)s=s*a;\n        return s;\n      }\n      \n      template&#x3C;const int mod> inline void init_inverse(int n,Z&#x3C;mod> *inv){\n        inv[0]=inv[1]=1;\n        for(int i=2;i&#x3C;n;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n      }\n      template&#x3C;const int mod> inline void init_factorial(int n,Z&#x3C;mod> *fac,Z&#x3C;mod> *ifac){\n        fac[0]=1,init_inverse(n,ifac);\n        for(int i=1;i&#x3C;n;i++)fac[i]=fac[i-1]*i,ifac[i]=ifac[i-1]*ifac[i];\n      }\n    }\n  #endif\n\n  #ifdef MEM_MATH\n    namespace math{\n      using std::max;\n      using std::min;\n      template&#x3C;class T> inline T abs(T x){return x&#x3C;0?-x:x;}\n      template&#x3C;class T> inline T gcd(T n,T m){return m?gcd(m,n%m):n;}\n      template&#x3C;class T> inline T lcm(T n,T m){return n/gcd(n,m)*m;}\n      \n      template&#x3C;const stdval::u64 p> struct FastDiv{\n        stdval::u64 t,i;\n        inline FastDiv():t(stdval::u64(-1)/p),i(mul_inv(p)){}\n        \n        inline bool divide(stdval::u64 n){return n*i&#x3C;=t;}\n        inline bool divide(stdval::i64 n){return stdval::u64(n&#x3C;0?-n:n)*i&#x3C;=t;}\n        inline stdval::u64 mul_inv(stdval::u64 n){\n          stdval::u64 x=n;\n          for(int i=0;i&#x3C;5;++i)x*=2-n*x;\n          return x;\n        }\n      };\n\n  #ifdef MEM_INT128\n      template&#x3C;const stdval::u64 b> struct FastMod{\n        stdval::u64 m;\n        inline FastMod():m(stdval::u64((stdval::u128(1)&#x3C;&#x3C;64)/b)){}\n        \n        inline stdval::u64 reduce(stdval::u64 a){\n          stdval::u64 q=(stdval::u64)((stdval::u128(m)*a)>>64);\n          stdval::u64 r=a-q*b;\n          return r>=b?r-b:r;\n        }\n      };\n  #endif\n    }\n  #endif\n\n  #ifdef MEM_CONTAINER\n    namespace container{\n      using std::pair;\n      using std::tuple;\n      using std::set;\n      using std::unordered_set;\n      using std::map;\n      using std::unordered_map;\n\n      using std::tie;\n      using std::make_pair;\n      using std::make_tuple;\n\n      template&#x3C;class T> struct vector:std::vector&#x3C;T>{\n        using std::vector&#x3C;T>::vector;\n        vector():std::vector&#x3C;T>(){}\n        vector(const std::vector&#x3C;T> &#x26;plain):std::vector&#x3C;T>(plain){}\n        \n        inline void read(int s=-1){\n          if(~s)this->resize(s);\n          for(size_t i=0;i&#x3C;this->size();i++){\n            io::read(this->operator[](i));\n          }\n        }\n        inline void print(char pt0=' ',char pt1='\\n'){\n          for(size_t i=0;i&#x3C;this->size();i++){\n            io::print(this->operator[](i));\n            if(i+1&#x3C;this->size())io::putc(pt0);\n          }\n          io::putc(pt1);\n        }\n        \n        inline void sort(){std::sort(this->begin(),this->end());}\n        inline void concat(const vector &#x26;rhs){this->insert(this->end(),rhs.begin(),rhs.end());}\n        inline bool includes(const T &#x26;x) const{return std::find(this->begin(),this->end(),x)!=this->end();}\n        \n        inline vector slice(int l,int r) const{\n          if(l>r)return {};\n          if(r&#x3C;this->size())return vector(this->begin()+l,this->begin()+r);\n          vector&#x3C;int> rsp=(this->begin()+l,this->end());\n          return rsp.resize(r-l),rsp;\n        }\n        \n        inline void from(const std::set&#x3C;T> &#x26;src){\n          this->resize(src.size());\n          auto it=this->begin();\n          for(const T e:src)*it++=e;\n        }\n        \n        template&#x3C;class Function> inline void forEach(Function func){for(const auto &#x26;it:*this)func(it);}\n        \n        template&#x3C;class R,class Function> inline vector&#x3C;R> _map(Function func) const{\n          vector &#x3C;R> res(this->size());\n          for(size_t i=0;i&#x3C;this->size();i++)\n            res[i]=func(this->operator[](i));\n          return res;\n        }\n        template&#x3C;class R> inline vector&#x3C;R> map(R func(T)) const{return this->_map&#x3C;R>(func);}\n        template&#x3C;class R> inline vector&#x3C;R> map(const std::function&#x3C;R(T)> &#x26;func) const{return this->_map&#x3C;R>(func);}\n      };\n    }\n  #endif\n\n  #ifdef MEM_STR\n    namespace str {\n      using namespace mem::container;\n\n      struct string:std::string{\n        using std::string::string;\n        string():std::string(\"\"){}\n        string(const std::string &#x26;plain):std::string(plain){}\n\n  #define __join_declaration(Vector,_)            \\\n        inline string join(const Vector &#x26;) const;\n        __string_join_mapper(__join_declaration)\n  #undef __join_declaration\n        \n        vector&#x3C;string> split(const string &#x26;delim)const{\n          if(this->empty())return {};\n          char *src=new char[this->length()+1];\n          strcpy(src,this->c_str());\n          char *tar=new char[delim.length()+1];\n          strcpy(tar,delim.c_str());\n          vector&#x3C;string> rsp;\n          for(char *pos=strtok(src,tar);pos;pos=strtok(nullptr,tar))\n            rsp.push_back(string(pos));\n          delete[] src;\n          delete[] tar;\n          return rsp;\n        }\n        \n        template&#x3C;class... Args> static inline string format(const char *fm,Args... args){\n          int len=snprintf(nullptr,0,fm,args...);\n          char *buf=new char[len+1];\n          snprintf(buf,len+1,fm,args...);\n          string str(buf);\n          delete[] buf;\n          return str;\n        }\n        template&#x3C;class... Args> static inline string format(const string &#x26;fm,Args... args){\n          return format(fm.c_str(),args...);\n        }\n      };\n\n  #define __to_string(T)                   \\\n      inline string to_string(const T &#x26;x){ \\\n        return std::to_string(x);          \\\n      }\n      __float_mapper(__to_string)\n      __integer_mapper(__to_string)\n  #undef __to_string\n      template&#x3C;class T> inline string to_string(const vector&#x3C;T> &#x26;vet){return \"{\"+string(\",\").join(vet)+\"}\";}\n      template&#x3C;class T> inline string to_string(const std::vector&#x3C;T> &#x26;vet){return to_string(vector&#x3C;T>(vet.begin(),vet.end()));}\n      template&#x3C;const int mod> inline string to_string(const mem::modint::Z&#x3C;mod> &#x26;zval){return std::to_string(zval.x);}\n\n  #define __join_instantiation(Vector,to_string)          \\\n      inline string string::join(const Vector &#x26;vet)const{ \\\n        if(!vet.size())return \"\";                         \\\n        string res=to_string(vet[0]);                     \\\n        for(size_t i=1;i&#x3C;vet.size();i++){                 \\\n          res+=*this;                                     \\\n          res+=to_string(vet[i]);                         \\\n        }                                                 \\\n        return res;                                       \\\n      }\n      __string_join_mapper(__join_instantiation)\n  #undef __join_instantiation\n      \n      inline void print(const str::string &#x26;s){\n        for(size_t i=0;i&#x3C;s.length();i++)mem::io::putc(s[i]);\n      }\n\n  #define __printfm(T)                                                      \\\n      template&#x3C;class... Args> inline void printfm(const T fm,Args... args){ \\\n        print(str::string().format(fm,args...));                            \\\n      }\n      __string_mapper(__printfm)\n  #undef __printfm\n    }\n  #endif\n\n  #undef __integer_mapper\n  #undef __float_mapper\n  #undef __string_mapper\n  #undef __string_join_mapper\n\n  #ifdef MEM_IO\n    using namespace io;\n  #endif\n  #ifdef MEM_STR\n    using namespace str;\n  #endif\n  #ifdef MEM_MATH\n    using namespace math;\n  #endif\n  #ifdef MEM_UTILS\n    using namespace utils;\n  #endif\n  #ifdef MEM_MODINT\n    using namespace modint;\n  #endif\n  #ifdef MEM_RANDOM\n    using namespace random;\n  #endif\n  #ifdef MEM_STDVAL\n    using namespace stdval;\n  #endif\n  #ifdef MEM_CONTAINER\n    using namespace container;\n  #endif\n} // namespace mem\n\nconst int N=10,F=10000,mod=998244353;\nconst int fac[N]={1,1,2,6,24,120,720,5040,40320,362880};\nconst int ifac[N]={1,1,499122177,166374059,291154603,856826403,641926577,376916469,421456191,712324701};\nconst int down[N][N]={\n  {1,0,0,0,0,0,0,0,0,0},\n  {1,1,0,0,0,0,0,0,0,0},\n  {1,2,2,0,0,0,0,0,0,0},\n  {1,3,6,6,0,0,0,0,0,0},\n  {1,4,12,24,24,0,0,0,0,0},\n  {1,5,20,60,120,120,0,0,0,0},\n  {1,6,30,120,360,720,720,0,0,0},\n  {1,7,42,210,840,2520,5040,5040,0,0},\n  {1,8,56,336,1680,6720,20160,40320,40320,0},\n  {1,9,72,504,3024,15120,60480,181440,362880,362880}\n};\nusing z=mem::Z&#x3C;mod>;\nusing namespace mem::io;\nusing namespace mem::modint;\n\nint n,q,c[N],d[N],y[N],fit[N][F];\nz ans,cur[1&#x3C;&#x3C;7];\n\nvoid dfs(int u){\n  if(u>n){\n    int x=0;\n    for(int i=0;i&#x3C;=n;i++){\n      x|=fit[i][d[i]]&#x3C;&#x3C;i;\n    }\n    ans+=cur[x];\n    return;\n  }\n  for(int i=0;i&#x3C;fac[n-u];i++){\n    y[u]=i;\n    for(int i=u;i&#x3C;=n;i++)d[i]+=y[u]*down[i][u];\n    dfs(u+1);\n    for(int i=u;i&#x3C;=n;i++)d[i]-=y[u]*down[i][u];\n  }\n}\n\nvoid mainVI(){\n  y[5]=y[6]=0;\n  for(y[0]=0;y[0]&#x3C;fac[6];y[0]++){\n    for(int i=0;i&#x3C;=6;i++)d[i]+=y[0];\n    for(y[1]=0;y[1]&#x3C;fac[5];y[1]++){\n      for(int i=1;i&#x3C;=6;i++)d[i]+=y[1]*down[i][1];\n      for(y[2]=0;y[2]&#x3C;fac[4];y[2]++){\n        for(int i=2;i&#x3C;=6;i++)d[i]+=y[2]*down[i][2];\n        for(y[3]=0;y[3]&#x3C;fac[3];y[3]++){\n          for(int i=3;i&#x3C;=6;i++)d[i]+=y[3]*down[i][3];\n          for(y[4]=0;y[4]&#x3C;fac[2];y[4]++){\n            for(int i=4;i&#x3C;=6;i++)d[i]+=y[4]*down[i][4];\n            int x=0;\n            for(int i=0;i&#x3C;=6;i++)x|=fit[i][d[i]]&#x3C;&#x3C;i;\n            ans+=cur[x];\n            for(int i=4;i&#x3C;=6;i++)d[i]-=y[4]*down[i][4];\n          }\n          for(int i=3;i&#x3C;=6;i++)d[i]-=y[3]*down[i][3];\n        }\n        for(int i=2;i&#x3C;=6;i++)d[i]-=y[2]*down[i][2];\n      }\n      for(int i=1;i&#x3C;=6;i++)d[i]-=y[1]*down[i][1];\n    }\n    for(int i=0;i&#x3C;=6;i++)d[i]-=y[0];\n  }\n}\n\nint main(){\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n#endif\n  for(read(q);q-->0;ans=0){\n    read(n);\n    for(int i=0;i&#x3C;=n;i++)read(c[i]);\n    for(int i=0;i&#x3C;=n;i++)\n      for(int d=0;d&#x3C;F;d++){\n        fit[i][d]=(c[i]+d)%(fac[i]*fac[n-i])&#x3C;d%(fac[i]*fac[n-i]);\n      }\n    for(int x=0;x&#x3C;(1&#x3C;&#x3C;(n+1));x++){\n      cur[x]=1;\n      for(int i=0;i&#x3C;=n;i++)\n        if((x>>i)&#x26;1){\n          cur[x]*=c[i]/(fac[i]*fac[n-i])+1;\n        }else{\n          cur[x]*=c[i]/(fac[i]*fac[n-i]);\n        }\n    }\n    if(n==6)mainVI();\n    else dfs(0);\n    print((int&#x26;)ans,'\\n');\n  }\n}\n</code></pre>","frontmatter":{"date":"October 04, 2020","title":"「UR #8」宿命多项式","cover":"/cover/20.webp"}}},"pageContext":{"id":"5cfec6da-31dd-5f1d-94da-e9b33da82968","slug":"blog/problem/uoj120"}},"staticQueryHashes":[],"slicesMap":{}}