{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/uoj226/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>给定一张 $n$ 个点的树或基环树，树上的每条边 $(u_i, v_i, w_i)$ 代表 $(u_i, v_i)$ 间有 $w_i$ 道路相连。</p>\n<p>你需要统计有多少种从任意点出发的本质不同路径，使得经过所有道路恰好一次。</p>\n<p>路径可以认为是一个从某个点出发，由经过道路编号和方向组成的序列。两条路线被认为是相同的当且仅当两序列相同，或更换起始边后两序列相同。</p>\n<p>$n, w_i \\leq 1000$。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p>BEST 定理的简单应用。</p>\n<p>我们可以把这个问题转化为两部分：</p>\n<ol>\n<li>为无向边定向</li>\n<li>套用 BEST 定理计算（生成树形图计数）</li>\n</ol>\n<p>前一部分我们可以从树的情况推广。如果 $m=n-1$，那么显然两点之间的无向边，转化成有向边刚好一半一半。对于基环树的情况，我们枚举走整个环的次数，那么也可以计算出有向边。</p>\n<p>后一部分，我们考虑基环树可以枚举一条断边，然后就是把所有指向根的重边条数一次乘起来（选任意一条作为外向树的一部分）。实现中需要处理前缀和保证复杂度。</p>\n<h2>坑</h2>\n<ol>\n<li>对于我的实现，需要保证环一路过去的端点依次按照经过顺序排序。也就是存无向边的数组可能需要把 $(u,v,w)$ swap 成 $(v,u,w)$。不过我倒是写的时候就注意到了。</li>\n<li>这题预处理阶乘的范围有坑啊有坑（x</li>\n</ol>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\nconst int N=1e3+10,mod=998244353,L=1e4+10;\nint n,m,ans,tot,top,min=INT_MAX,cir[N],w0[N],w1[N],deg[N],u[N],v[N],w[N],pre[N],suf[N],stk[N],hed[N],to[N&#x3C;&#x3C;1],val[N&#x3C;&#x3C;1],nxt[N&#x3C;&#x3C;1],fac[N*L],ifac[L];\nbool vis[N],onc[N],inc[N];\nvoid initgraph(){\n  tot=0;\n  memset(hed,-1,sizeof(hed));\n}\nvoid initfac(){\n  fac[0]=ifac[0]=ifac[1]=1;\n  for(int i=1;i&#x3C;N*L;i++)fac[i]=(long long)fac[i-1]*i%mod;\n  for(int i=2;i&#x3C;L;i++)ifac[i]=(long long)(mod-mod/i)*ifac[mod%i]%mod;\n  for(int i=1;i&#x3C;L;i++)ifac[i]=(long long)ifac[i-1]*ifac[i]%mod;\n}\ninline int C(int n,int m){return n&#x3C;m?0:(long long)fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\ninline void link(int u,int v,int w){nxt[tot]=hed[u],to[tot]=v,val[tot]=w,hed[u]=tot++;}\ninline int calc_fac(int x){\n  int res=1;\n  for(int i=1;i&#x3C;=x;i++)res=(long long)res*i%mod;\n  return res;\n}\nvoid solve_tree(){\n  int ans=1;\n  for(int u,v,w,i=1;i&#x3C;=m;i++){\n    scanf(\"%d%d%d\",&#x26;u,&#x26;v,&#x26;w);\n    if(w&#x26;1){puts(\"0\"); return;}\n    deg[u]+=w>>1,deg[v]+=w>>1;\n    ans=(long long)ans*C(w,w>>1)%mod*(w>>1)%mod;\n  }\n  for(int i=1;i&#x3C;=n;i++)ans=(long long)ans*fac[deg[i]-1]%mod;\n  printf(\"%d\\n\",ans);\n}\nvoid dfs(int u,int fa){\n  stk[++top]=u,vis[u]=1;\n  // printf(\"dfs %d %d\\n\",u,fa);\n  for(int i=hed[u];~i;i=nxt[i])\n    if(to[i]!=fa){\n      // printf(\"%d -> %d\\n\",u,to[i]);\n      if(vis[to[i]]){\n        if(*cir)continue;\n        cir[++*cir]=val[i];\n        // printf(\"%d : %d\\n\",i,val[i]);\n        for(int x=u;x!=to[i];x=to[pre[x]^1]){\n          cir[++*cir]=val[pre[x]];\n          // printf(\"(%d) %d : %d\\n\",x,pre[x],val[pre[x]]);\n        }\n      }else{\n        pre[to[i]]=i;\n        dfs(to[i],u);\n      }\n    }\n  --top;\n}\nvoid ordered_circle(){\n  int same=-1;\n  if(u[cir[1]]==u[cir[2]])same=u[cir[1]];\n  if(u[cir[1]]==v[cir[2]])same=u[cir[1]];\n  if(v[cir[1]]==u[cir[2]])same=v[cir[1]];\n  if(v[cir[1]]==v[cir[2]])same=v[cir[1]];\n  assert(~same);\n  int s=u[cir[1]]+v[cir[1]]-same;\n  for(int i=1;i&#x3C;=*cir;i++){\n    // printf(\"i=%d cir=%d s=%d : u=%d v=%d\\n\",i,cir[i],s,u[cir[i]],v[cir[i]]);\n    if(u[cir[i]]!=s)std::swap(u[cir[i]],v[cir[i]]);\n    s=v[cir[i]];\n  }\n}\nint calc(int cur){\n  memset(deg,0,sizeof(deg));\n  int ans=1,sum=0,ano=1;\n  for(int i=1;i&#x3C;=m;i++){\n    if(inc[i]){\n      if((w[i]+cur)&#x26;1)return 0;\n      w0[i]=(w[i]+cur)>>1;\n      w1[i]=(w[i]-cur)>>1;\n    }else{\n      w0[i]=w1[i]=w[i]>>1;\n    }\n    deg[u[i]]+=w1[i];\n    deg[v[i]]+=w0[i];\n    ans=(long long)ans*C(w[i],w0[i])%mod;\n  }\n  for(int i=1;i&#x3C;=n;i++)ans=(long long)ans*fac[deg[i]-1]%mod;\n  for(int i=1;i&#x3C;=m;i++)if(!inc[i])ano=(long long)ano*w0[i]%mod;\n  for(int k=1;k&#x3C;=*cir;k++)pre[k]=(long long)pre[k-1]*w0[cir[k]]%mod;\n  for(int k=*cir;k>=1;k--)suf[k]=(long long)suf[k+1]*w1[cir[k]]%mod;\n  for(int k=1;k&#x3C;=*cir;k++){\n    sum=(sum+(long long)pre[k-1]*suf[k+1]%mod*ano)%mod;\n  }\n  return (long long)sum*ans%mod;\n}\nint main(){\n#ifdef Ciel\n  freopen(\"1.in\",\"r\",stdin);\n  // freopen(\"comp/data.in\",\"r\",stdin);\n#endif\n  initfac();\n  initgraph();\n  scanf(\"%d%d\",&#x26;n,&#x26;m);\n  if(n==m+1)return solve_tree(),0;\n  for(int i=1;i&#x3C;=m;i++){\n    scanf(\"%d%d%d\",&#x26;u[i],&#x26;v[i],&#x26;w[i]);\n    link(u[i],v[i],i);\n    link(v[i],u[i],i);\n    deg[u[i]]+=w[i];\n    deg[v[i]]+=w[i];\n  }\n  for(int i=1;i&#x3C;=n;i++)if(deg[i]&#x26;1)return puts(\"0\"),0;\n  dfs(1,0);\n  ordered_circle();\n  for(int i=1;i&#x3C;=*cir;i++){\n    inc[cir[i]]=onc[u[cir[i]]]=onc[v[cir[i]]]=true;\n    min=std::min(min,w[cir[i]]);\n  }\n  // for(int i=1;i&#x3C;=m;i++)printf(\"%d %d %d %d\\n\",u[i],v[i],w[i],inc[i]);\n  pre[0]=suf[0]=pre[*cir+1]=suf[*cir+1]=1;\n  for(int d=-min;d&#x3C;=min;d++)ans=(ans+calc(d))%mod;\n  printf(\"%d\\n\",ans);\n}\n</code></pre>","frontmatter":{"date":"August 31, 2020","title":"「UR #15」奥林匹克环城马拉松","cover":"/cover/28.webp"}}},"pageContext":{"id":"0da8f7b0-752d-5c9e-aaa2-153f55eee826","slug":"blog/problem/uoj226"}},"staticQueryHashes":[],"slicesMap":{}}