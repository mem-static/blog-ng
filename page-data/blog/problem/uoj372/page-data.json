{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/uoj372/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>给定一个 $n$ 个点 $m$ 条边的无向图，其中每个点的点权是 $[0;1]$ 范围内生成的连续型随机变量，求：</p>\n<p>$$\n\\max { \\max_{i \\in V} x_i + \\max_{(u,v) \\in E} (x_u + x_v) }\n$$</p>\n<p>的期望，答案对 $998244353$ 取模。</p>\n<p>$n \\leq 25$。（实际上可以跑 $n \\leq 30$。。。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p>$$\nans = \\int_0^2 Pr[\\lambda = x] x \\text dx = 2 - \\int_0^2 Pr[\\lambda \\leq x] \\text dx\n$$</p>\n<p>考虑如何计算 $Pr[\\lambda \\leq x]$，设 $g(s,y,t)$ 表示对于点集 $s$，点权最大值 $\\leq y$，答案 $\\leq t$ 的概率。考虑其状态转义：</p>\n<ul>\n<li>如果生成的所有数都 $\\leq \\frac t 2$，则贡献为 $(\\frac t 2)^{|s|}$</li>\n<li>对于其他情况，考虑最大值点 $i$，并递归。</li>\n</ul>\n<p>$$\ng(s,y,t) = (\\tfrac t 2)^{|s|} + \\sum_{i \\in s} \\int_{\\tfrac t 2}^y g(s_i, x, t) (t - x)^{|s| - |s_i| - 1}\\text dx\n$$</p>\n<p>其中 $s_i$ 表示从 $s$ 中删除 $i$ 以及所有和 $i$ 相邻的点得到的点集。</p>\n<p>如果我们直接暴力状压维护二元多项式转移显然麻烦的一比，而且常数还贼他妈大，考虑理性一点的方式。</p>\n<p>首先，如果当前的状态是若干独立的联通块，可以直接把每个联通块的答案相乘，这可以大大减小状态数。</p>\n<p>另外，我们可以注意到，对于二元多项式的每一项 $y^i t^j$，都满足 $i+j$ 是定值，即二元多项式 $g(s)$ 每项的幂次和都是 $|s|$。由二项式定理的系数可以方便得到。</p>\n<p>最后，我们需要注意 $g(s,y,t)$ 的取值范围 $\\tfrac t 2 \\leq y \\leq \\min(1, t)$，所以答案是</p>\n<p>$$\nans = 2 - \\int_0^1 f(t,t) \\text dt  - \\int_1^2 f(1,t) \\text dt\n$$</p>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\nconst int N=30,mod=998244353,inv2=(mod+1)>>1;\nint n,m,tim,G[N],vis[N];\nstruct z {\n  int x;\n  z(int x=0):x(x){}\n  friend inline z operator*(z a,z b){return (long long)a.x*b.x%mod;}\n  friend inline z operator-(z a,z b){return (a.x-=b.x)&#x3C;0?a.x+mod:a.x;}\n  friend inline z operator+(z a,z b){return (a.x+=b.x)>=mod?a.x-mod:a.x;}\n}ans,inp[N],inv[N],C[N][N];\nstd::unordered_map&#x3C;int,std::vector&#x3C;z>> map;\ninline std::vector&#x3C;z> operator*(const std::vector&#x3C;z> &#x26;a,const std::vector&#x3C;z> &#x26;b){\n  std::vector&#x3C;z> c(a.size()+b.size()-1);\n  for(int i=0;i&#x3C;a.size();i++)\n    for(int j=0;j&#x3C;b.size();j++)\n      c[i+j]=c[i+j]+a[i]*b[j];\n  return c;\n}\ninline std::vector&#x3C;z> integral(std::vector&#x3C;z> f){\n  std::vector&#x3C;z> g(f.size()+1);\n  for(int i=1;i&#x3C;=f.size();i++)g[i]=f[i-1]*inv[i];\n  return g;\n}\ninline z evaluation(std::vector&#x3C;z> a,int l,int r){\n  a=integral(a); z p,s; int i;\n  for(p=1,i=0;i&#x3C;a.size();i++)s=s+a[i]*p,p=p*r;\n  for(p=1,i=0;i&#x3C;a.size();i++)s=s-a[i]*p,p=p*l;\n  return s;\n}\nvoid initfac(int n){\n  inp[0]=inv[0]=inv[1]=1;\n  for(int i=2;i&#x3C;n;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n  for(int i=1;i&#x3C;n;i++)inp[i]=inp[i-1]*inv2;\n  for(int i=0;i&#x3C;n;i++){\n    C[i][0]=1;\n    for(int j=1;j&#x3C;=i;j++)C[i][j]=C[i-1][j]+C[i-1][j-1];\n  }\n}\nint dfs(int u,int s){\n  int res=1&#x3C;&#x3C;u; vis[u]=tim;\n  for(int v=0;v&#x3C;n;v++)if(((s>>v)&#x26;1)&#x26;&#x26;((G[u]>>v)&#x26;1)&#x26;&#x26;vis[v]!=tim)res|=dfs(v,s);\n  return res;\n}\nvoid update(std::vector&#x3C;z> &#x26;s,std::vector&#x3C;z> a,int k){\n  std::vector&#x3C;z> b(k+1);\n  for(int i=0;i&#x3C;=k;i++)b[i]=C[k][i]*(i&#x26;1?mod-1:1);\n  a=integral(a*b);\n  for(int i=0;i&#x3C;a.size();i++)s[i]=s[i]+a[i],s[0]=s[0]-inp[i]*a[i];\n}\nstd::vector&#x3C;z> solve(int s){\n  if(map.count(s))return map[s];\n  int l=__builtin_popcount(s); std::vector&#x3C;z> res; std::vector&#x3C;int> set;\n  for(int t,i=0;i&#x3C;n;i++)if((s>>i)&#x26;1)++tim,t=dfs(i,s),set.push_back(t),s^=t;\n  for(int x:set)s|=x;\n  if(set.size()>1){res={1}; for(auto t:set)res=res*solve(t);}\n  else{\n    res.resize(l+1),res[0]=inp[l];\n    for(int i=0;i&#x3C;n;i++)if((s>>i)&#x26;1){\n      int t=s^(s&#x26;(G[i]|(1&#x3C;&#x3C;i)));\n      update(res,solve(t),__builtin_popcount(s&#x26;G[i]));\n    }\n  }\n  return map[s]=res;\n}\nint main(){\n  std::cin>>n>>m,initfac(N),map[0]={1};\n  for(int u,v,i=0;i&#x3C;m;i++)std::cin>>u>>v,--u,--v,G[u]|=1&#x3C;&#x3C;v,G[v]|=1&#x3C;&#x3C;u;\n  std::vector&#x3C;z> s=solve((1&#x3C;&#x3C;n)-1),a(n+1);\n  for(int i=0;i&#x3C;s.size();i++)a[n]=a[n]+s[i];\n  std::reverse(s.begin(),s.end());\n  std::cout&#x3C;&#x3C;(2-evaluation(s,1,2)-evaluation(a,0,1)).x&#x3C;&#x3C;std::endl;\n}\n</code></pre>","frontmatter":{"date":"May 06, 2020","title":"「UR #17」滑稽树前做游戏","cover":"/cover/2.png"}}},"pageContext":{"id":"a9515f85-0d7e-5f95-b82b-58e160756ceb","slug":"blog/problem/uoj372"}},"staticQueryHashes":[],"slicesMap":{}}