{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/uoj498/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>定义两个简单无向图 $G_{1} =( V_{1} , E_{1}) , G_{2} =( V_{2} , E_{2})$ 的乘积为一个新的图 $G_{1} \\times G_{2} =\\left( V^{\\star} , E^{\\star} \\right)$。</p>\n<p>其中新的点集 $V^{\\star}$ 为:</p>\n<p>$$\nV^{\\star} = \\left{ {(a, b)| a \\in V_{1}, b \\in V_{2} }\\right}\n$$</p>\n<p>其中新的边集 $E^{\\star}$ 为：</p>\n<p>$$\nE^{\\star} =\\left{\\left(( u_{1} , v_{1}) , ( u_{2} , v_{2})\\right) \\mid ( u_{1} , u_{2}) \\in E_{1}, ( v_{1} , v_{2}) \\in E_{2}\\right}\n$$</p>\n<p>对于正整数 $n$ ，以及给定的图 $G_{1} , G_{2} , \\dotsc , G_{n}$ ，两只鞋太太的家可以表示成</p>\n<p>$$\nH = (((G_1 \\times G_2) \\times G_3) \\times \\cdots) \\times G_n\n$$</p>\n<p>每个 $G_k$ 中任意两点间都有 $\\frac12$ 的概率连边，求 $H$ 的连通块的期望。显然 $G_k$ 的全体取法共有 ${\\large {2^{\\binom{m_1}2 + \\binom{m_2}2 + \\cdots + \\binom{m_n}2}}}$ 种。</p>\n<p>方便起见，你只需要输出答案乘以 ${\\large {2^{\\binom{m_1}2 + \\binom{m_2}2 + \\cdots + \\binom{m_n}2}}}$ ，对 $998244353$ 取模即可。</p>\n<p>$1\\le n, m_k\\le 10^5$ 。</p>\n</blockquote>\n<!--more-->\n<h2>题解</h2>\n<p>大概是一个二合一状物，我们搞出生成函数以后逐个合并。</p>\n<p>考虑 $k=1$ 怎么做，假设 $G$ 为无标号无向图生成函数：</p>\n<p>$$\nG = \\sum_{i\\ge 0} \\frac {2^{\\binom i 2} x^i} {i!}\n$$</p>\n<p>则 $\\ln G$ 为无标号联通无向图生成函数， $n! [x^n] G \\ln G$ 即为答案。</p>\n<p>考虑 $k=2$ 怎么做，我们需要特判下孤立点的情况。合并的结果和两边的图是否为二分图（即题解所谓没有奇环）是有关的，当且仅当两侧都是二分图时会使得生成的图对应两个联通块。</p>\n<p>考虑无标号二分图生成函数 $B$ （可以卷积解决）：</p>\n<p>$$\nB = \\sum_{i \\ge 0} \\sum_{j \\ge 0} \\frac {2^{ij} x^{i+j}} {i! j!} = \\sum_{i \\ge 0} \\sum_{j \\ge 0} \\frac {2^{\\binom {i+j} 2 - \\binom  i 2 - \\binom j 2} x^{i+j}} {i! j!}\n$$</p>\n<p>故非平凡二分图联通块生成函数为 $G (\\frac {\\ln B} 2 - 1)$ ，非平凡非二分图联通块生成函数为 $G (\\ln G - \\frac {\\ln B} 2)$ ，非平凡联通块生成函数为 $G (\\ln G - 1)$ 。孤立点联通块生成函数为 $x G$ （这几个均为无标号</p>\n<p>考虑记录下期望点数，期望非平凡二分图联通块，期望非平凡非二分图联通块，期望孤立点个数，即可合并两个图的信息，做下去即可（</p>\n<h2>代码</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\n#define poly std::vector&#x3C;z>\n// #define log(...) (void(0))\n#define log(...) fprintf(stderr,__VA_ARGS__)\n#define debug log(\"\\33[2mPassing [%s] in LINE %d\\33[0m\\n\",__FUNCTION__,__LINE__);\ntemplate&#x3C;class T> inline void read(T &#x26;x){\n  x=0; register char c=getchar(); register bool f=0;\n  while(!isdigit(c))f^=c=='-',c=getchar();\n  while(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\nconst int N=1e5+10,mod=998244353;\nint n,l,lim,m[N];\nstruct z {\n  int x;\n  z(int x=0):x(x){}\n  inline int half(){return x&#x26;1?(x+mod)>>1:x>>1;}\n  friend inline z operator*(z a,z b){return (long long)a.x*b.x%mod;}\n  friend inline z operator-(z a,z b){return (a.x-=b.x)&#x3C;0?a.x+mod:a.x;}\n  friend inline z operator+(z a,z b){return (a.x+=b.x)>=mod?a.x-mod:a.x;}\n}a[N],b[N],c[N],d[N],fac[N],inv[N],ifac[N],t1[N];\ninline z fpow(z a,int b){z s=1;for(;b;b>>=1,a=a*a)if(b&#x26;1)s=s*a;return s;}\nnamespace Polynomial{\n  int rev[N&#x3C;&#x3C;2]; z w[N&#x3C;&#x3C;2];\n  int polyInit(int l){\n    int lim=1,k=0; while(lim&#x3C;l)lim&#x3C;&#x3C;=1,++k;\n    for(int i=0;i&#x3C;lim;i++)rev[i]=(rev[i>>1]>>1)|((i&#x26;1)&#x3C;&#x3C;(k-1));\n    static int len=1;\n    for(;len&#x3C;lim;len&#x3C;&#x3C;=1){\n      z wn=fpow(3,(mod-1)/(len&#x3C;&#x3C;1)); w[len]=1;\n      for(int i=1;i&#x3C;len;i++)w[i+len]=w[i+len-1]*wn;\n    }return lim;\n  }\n  void dft(poly &#x26;a,int lim){ \n    a.resize(lim);\n    for(int i=0;i&#x3C;lim;i++)if(i&#x3C;rev[i])std::swap(a[i],a[rev[i]]);\n    for(int len=1;len&#x3C;lim;len&#x3C;&#x3C;=1)\n      for(int i=0;i&#x3C;lim;i+=(len&#x3C;&#x3C;1))\n        for(int j=0;j&#x3C;len;j++){\n          z x=a[i+j],y=a[i+j+len]*w[j+len];\n          a[i+j]=x+y,a[i+j+len]=x-y;\n        }\n  }\n  void idft(poly &#x26;a,int lim){\n    dft(a,lim),std::reverse(&#x26;a[1],&#x26;a[lim]); z inv=fpow(lim,mod-2);\n    for(int i=0;i&#x3C;lim;i++)a[i]=a[i]*inv;\n  }\n  poly polyInc(poly a,const poly &#x26;b){\n    a.resize(std::max(a.size(),b.size()));\n    for(int i=0;i&#x3C;b.size();i++)a[i]=a[i]+b[i]; return a;\n  }\n  poly polyDec(poly a,const poly &#x26;b){\n    a.resize(std::max(a.size(),b.size()));\n    for(int i=0;i&#x3C;b.size();i++)a[i]=a[i]-b[i]; return a;\n  }\n  poly polyMul(poly a,poly b){\n    int lim=polyInit(a.size()+b.size()-1);\n    dft(a,lim),dft(b,lim);\n    for(int i=0;i&#x3C;lim;i++)a[i]=a[i]*b[i];\n    idft(a,lim),a.resize(l); return a;\n  }\n  poly polyInv(poly f,int len=-1){\n    if((len=~len?len:f.size())==1)return {fpow(f[0],mod-2)};\n    poly a(&#x26;f[0],&#x26;f[len]),b=polyInv(f,(len+1)>>1);\n    int lim=polyInit((len&#x3C;&#x3C;1)-1);\n    dft(a,lim),dft(b,lim);\n    for(int i=0;i&#x3C;lim;i++)a[i]=b[i]*(2-a[i]*b[i]);\n    idft(a,lim),a.resize(len); return a;\n  }\n  poly polyDer(poly f){for(int i=0;i&#x3C;=f.size()-2;i++)f[i]=f[i+1]*(i+1); *--f.end()=0; return f;}\n  poly polyInt(poly f){for(int i=f.size()-1;i>=1;i--)f[i]=f[i-1]*inv[i]; *f.begin()=0; return f;}\n  poly polyLn(poly f){return polyInt(polyMul(polyInv(f),polyDer(f)));}\n}\nusing namespace Polynomial;\npoly A,B,C,D,E,F,G,H;\nstruct info{\n  z n,a,b,c;\n  inline z dump(){return a+b+c;}\n  inline void load(int x){n=G[x]*fac[x]*x,a=C[x]*fac[x],b=D[x]*fac[x],c=G[x-1]*fac[x];}\n  friend inline info operator^(const info &#x26;a,const info &#x26;b){\n    static info s;\n    s.n=a.n*b.n;\n    s.a=2*a.a*b.a+a.a*b.b+a.b*b.a;\n    s.b=a.b*b.b;\n    s.c=a.c*b.c+a.c*(b.n-b.c)+b.c*(a.n-a.c);\n    return s;\n  }\n}ans,tmp;\nint main(){\n#ifdef local\n  freopen(\"1.in\",\"r\",stdin);\n#endif\n  read(n);\n  for(int i=1;i&#x3C;=n;i++)read(m[i]),l=std::max(l,m[i]+1);\n  fac[0]=ifac[0]=inv[0]=inv[1]=1;\n  for(int i=1;i&#x3C;=l;i++)fac[i]=fac[i-1]*i;\n  for(int i=2;i&#x3C;=l;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n  for(int i=1;i&#x3C;=l;i++)ifac[i]=ifac[i-1]*inv[i];\n  G.resize(l),B.resize(l);\n  for(int i=0;i&#x3C;l;i++)t1[i]=fpow(2,(long long)i*(i-1)/2%(mod-1));\n  for(int i=0;i&#x3C;l;i++)G[i]=t1[i]*ifac[i];\n  for(int i=0;i&#x3C;l;i++)B[i]=ifac[i]*fpow(t1[i],mod-2);\n  B=polyMul(B,B),B.resize(l);\n  for(int i=0;i&#x3C;l;i++)B[i]=B[i]*t1[i];\n  F=polyLn(G),H=G,F[1]=0,A=polyLn(B),A[1]=0;\n  for(int i=0;i&#x3C;l;i++)A[i]=A[i].half();\n  C=polyMul(G,A),C.resize(l),E=polyMul(G,F),E.resize(l),D=polyDec(E,C);\n  ans.load(m[1]);\n  for(int i=2;i&#x3C;=n;i++)ans=ans^(tmp.load(m[i]),tmp);\n  printf(\"%d\\n\",ans.dump().x);\n}\n</code></pre>","frontmatter":{"date":"April 23, 2020","title":"「UOJ Goodbye Jihai」新年的追逐战","cover":"/cover/31.webp"}}},"pageContext":{"id":"b9339723-b80d-5777-9c95-be80e76a850f","slug":"blog/problem/uoj498"}},"staticQueryHashes":[],"slicesMap":{}}