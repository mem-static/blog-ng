{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/problem/uoj500/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>给定 $n$ 次多项式</p>\n<p>$$\nf(x) = \\sum_{i=0}^n a_i x^i\n$$</p>\n<p>$Q$ 次询问，第 $i$ 次询问 $f(q_i)$ 对 $998244353$ 取模的值。</p>\n<p>其中 $q_i$ 是一个一阶线性递推，给定 $q_0, x, y$ ，满足</p>\n<p>$$\nq_n = x q_{n-1} + y\n$$</p>\n<p>$1 \\leq n \\leq 2.5 \\times 10^5, \\ 1 \\leq Q \\leq 10^6, \\ 2 \\leq x &#x3C; 998244353, \\ 0 \\leq q_0, y &#x3C; 998244353$ 。</p>\n</blockquote>\n<!--more-->\n<h2>Solution Part1</h2>\n<p>首先这玩意儿肯定没法两个 $\\log$ 多点求值，除非你是钱哥哥。</p>\n<img src=\"https://static.memset0.cn/img/v1/20200801203057.png\" width:320px margin:auto>\n<h2>Solution Part2</h2>\n<p>虽然这东西好像小学生都会，但我自己推的时候怎么莫名搞到特征多项式那个方向去了，越学越傻逼了。。。</p>\n<p>$$\n\\left{ \\begin{aligned}\ng_{n+1} = x g_n + y \\\ng_n = x g_{n-1} + y \\\n\\end{aligned} \\right.\n$$</p>\n<p>两式相减得到\n$$\n(g_{n+1}-g_n) = x (g_n - g_{n-1})\n$$\n不妨设\n$$\nh_n = g_{n+1} - g_n\n$$\n可以得到 $h$ 的通项公式\n$$\nh_n = x^n h_0 = x^n ((x-1) g_0 + y)\n$$\n从而得到 $g$ 的通项公式\n$$\ng_n = g_0 + \\sum_{i=0}^{n-1} h_i = g_0 + \\frac {x^n-1} {x-1} ((x-1)g_0 + y)\n$$\n不妨表示成 $ax^n + b$ 的形式，其中\n$$\n\\begin{cases}\na = \\dfrac {(x-1) g_0 + y} {x-1} \\\nb = \\dfrac {y} {x-1} \\\n\\end{cases}\n$$</p>\n<h2>Solution Part3</h2>\n<p>也就是说我们要对于所有 $i \\in [1, Q]$ 求出 $f(a x^i + b)$ 的值，不妨设多项式 $g(x) = f(ax + b)$ ，也就是一个多项式平移。\n$$\n\\begin{aligned}\ng(x)\n&#x26;= f(ax + b) \\\n&#x26;= \\sum_{i=0}^n a_i (ax + b)^i \\\n&#x26;= \\sum_{i=0}^n a_i \\sum_{j=0}^i \\frac {i!} {j! (i-j)!} (ax)^j b^{i-j} \\\n&#x26;= \\sum_{i=0}^n a_i i! \\sum_{j=0}^i \\frac {(ax)^j} {j!} \\cdot \\frac {b^{i-j}} {(i-j)!} \\\n\\end{aligned}\n$$\n容易发现可以卷积维护，需要反转一个多项式。</p>\n<h2>Solution Part4</h2>\n<p>回到之前的式子，现在我们只需要对于所以 $i \\in [1, Q]$ 求出 $g(x^i)$ 的值，相当于求</p>\n<p>$$\n\\begin{aligned}\nG(z)\n&#x26;= \\sum_{i=0}^Q z^i \\sum_{j=0}^n a_j x^{ij} \\\n&#x26;= \\sum_{i=0}^Q z^i \\sum_{j=0}^n a_j x^{\\binom {i+j} 2 - \\binom i 2 - \\binom j 2} \\\n&#x26;= \\sum_{i=0}^Q z^i x^{-\\binom i2} \\sum_{j=0}^n a_j x^{-\\binom j2} \\cdot x^{\\binom {i+j} 2} \\\n\\end{aligned}\n$$</p>\n<p>容易发现可以卷积维护，需要反转一个多项式。</p>\n<blockquote>\n<p>题外话：</p>\n<p>一开始想过把 $ij$ 拆成 $\\binom i 2 + \\binom j 2 - \\binom {i-j} 2$ ，结果 $i-j$ 的值域有正有负，反而难处理，尽量还是避免这种情况。</p>\n</blockquote>\n<h2>Code</h2>\n<pre><code class=\"language-cpp\">#include&#x3C;bits/stdc++.h>\n#define log(...) (void(0))\n// #define log(...) fprintf(stderr,__VA_ARGS__)\nconst int S=1&#x3C;&#x3C;21; char ibuf[S],*iS,*iT;\n#define getchar() (iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,S,stdin),(iS==iT?EOF:*iS++)):*iS++)\ntemplate&#x3C;class T> inline void read(T &#x26;x){\n    x=0; register char c=getchar(); register bool f=0;\n    while(!isdigit(c))f^=c=='-',c=getchar();\n    while(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\n#ifdef local\nconst int N=1e3+10,mod=998244353;\n#else\nconst int N=2.1e6+10,mod=998244353;\n#endif\nint n,q,rev[N];\nstruct z {\n    int x;\n    z(int x=0):x(x){}\n    friend inline z operator*(z a,z b){return (long long)a.x*b.x%mod;}\n    friend inline z operator-(z a,z b){return (a.x-=b.x)&#x3C;0?a.x+mod:a.x;}\n    friend inline z operator+(z a,z b){return (a.x+=b.x)>=mod?a.x-mod:a.x;}\n}q0,qx,qy/*orz qy*/,qc,w[N],f[N],g[N],t1[N],t2[N],t3[N],t4[N],fac[N],ifac[N];\ninline z fpow(z a,int b){z s=1;for(;b;b>>=1,a=a*a)if(b&#x26;1)s=s*a;return s;}\nvoid initFac(int n){\n    fac[0]=ifac[0]=ifac[1]=1;\n    for(int i=1;i&#x3C;=n;i++)fac[i]=fac[i-1]*i;\n    for(int i=2;i&#x3C;=n;i++)ifac[i]=(mod-mod/i)*ifac[mod%i];\n    for(int i=2;i&#x3C;=n;i++)ifac[i]=ifac[i-1]*ifac[i];\n}\nvoid initPow(z c,int n,z *a,z *b){\n    a[0]=b[0]=1;\n    for(int i=1;i&#x3C;n;i++)a[i]=a[i-1]*c;\n    for(int i=1;i&#x3C;n;i++)b[i]=b[i-1]*a[i-1];\n}\nint init(int n){\n    static int wk=1; int k=-1,l=1; while(l&#x3C;n)l&#x3C;&#x3C;=1,++k;\n    for(int i=0;i&#x3C;l;i++)rev[i]=(rev[i>>1]>>1)|((i&#x26;1)&#x3C;&#x3C;k);\n    for(int &#x26;k=wk;k&#x3C;l;k&#x3C;&#x3C;=1){\n        z c=fpow(3,(mod-1)/k/2); w[k]=1;\n        for(int i=1;i&#x3C;k;i++)w[i+k]=w[i+k-1]*c;\n    }return l;\n}\nvoid ntt(z *a,z *b,int l){\n    for(int i=0;i&#x3C;l;i++)b[rev[i]]=a[i];\n    for(int k=1;k&#x3C;l;k&#x3C;&#x3C;=1)\n        for(int i=0;i&#x3C;l;i+=(k&#x3C;&#x3C;1))\n            for(int j=0;j&#x3C;k;j++){\n                z x=b[i+j],y=b[i+j+k]*w[j+k];\n                b[i+j]=x+y,b[i+j+k]=x-y;\n            }\n}\nvoid mul(z *a,z *b,z *c,int n,int m){\n    static z t[N];\n    int l=init(n+m-1); z v=fpow(l,mod-2);\n    ntt(a,c,l),ntt(b,t,l);\n    for(int i=0;i&#x3C;l;i++)t[i]=t[i]*c[i];\n    std::reverse(t+1,t+l),ntt(t,c,l);\n    for(int i=0;i&#x3C;l;i++)c[i]=c[i]*v;\n}\nint main(){\n#ifdef local\n    freopen(\"1.in\",\"r\",stdin);\n#endif\n    read(n),read(q),initFac(std::max(n,q));\n    for(int i=0;i&#x3C;=n;i++)read((int&#x26;)f[i]);\n    read((int&#x26;)q0),read((int&#x26;)qx),read((int&#x26;)qy),qc=(q0*(qx-1)+qy)*fpow(qx-1,mod-2);\n    for(int i=0;i&#x3C;=n;i++)log(\"%d%c\",f[i],\" \\n\"[i==n]);\n    const auto move=[&#x26;](z *a,z c,z k,int n){\n        log(\"\\e[33mMOVE %d %d %d\\e[0m\\n\",c,k,n);\n        int i; z t;\n        for(i=0,t=1;i&#x3C;n;i++)t1[i]=a[i]*fac[i],t2[n-i-1]=ifac[i]*t,t=t*c;\n        mul(t1,t2,t3,n,n);\n        for(i=0,t=1;i&#x3C;n;i++)a[i]=t3[n-1+i]*ifac[i]*t,t=t*k;\n    };\n    memset(t1,0,sizeof(t1)),memset(t2,0,sizeof(t2));\n    move(f,q0-qc,qc,n+1);\n    memset(t1,0,sizeof(t1)),memset(t2,0,sizeof(t2));\n    for(int i=0;i&#x3C;=n;i++)log(\"%d%c\",f[i],\" \\n\"[i==n]);\n    const auto czt=[&#x26;](z *a,z *b,z c,int n,int q){\n        log(\"\\e[33mCZT %d %d %d\\e[0m\\n\",c,n,q);\n        initPow(c,n+q,t3,t1);\n        std::reverse(t1,t1+n+q);\n        initPow(fpow(c,mod-2),std::max(n,q),t3,t4);\n        for(int i=0;i&#x3C;n;i++)t2[i]=a[i]*t4[i];\n        mul(t1,t2,t3,n+q,n);\n        for(int i=0;i&#x3C;q;i++)b[i]=t3[n+q-1-i]*t4[i];\n    };\n    czt(f,g,qx,n+1,q+1);\n    for(int i=0;i&#x3C;=q;i++)log(\"%d%c\",g[i],\" \\n\"[i==q]);\n    printf(\"%d\\n\",std::accumulate(g+1,g+q+1,0,[](int a,z b){return a^b.x;}));\n}\n</code></pre>","frontmatter":{"date":"March 27, 2020","title":"「UOJ500」任意基DFT","cover":"/cover/34.webp"}}},"pageContext":{"id":"f6119212-fa5a-5f21-8791-3279af4e9c02","slug":"blog/problem/uoj500"}},"staticQueryHashes":[],"slicesMap":{}}