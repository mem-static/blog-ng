{"componentChunkName":"component---src-templates-post-js","path":"/course/ca/note/3/","result":{"data":{"site":{"siteMetadata":{"title":"mem 的小站"}},"post":{"id":"9fedc75f-3d41-5f1a-8067-e741db4ad237","excerpt":"1. Introduction to Instruction-Level Parallelism 1.1. Terminologies 时延(latency)：单个指令从进入流水线开始，到它完成执行并可以写会结果所需要的时钟周期数． 功能单元时间(function unit time)：指指令在 EX/MEM…","html":"<style>\n    :root {\n        --slide-width: 1254;\n        --slide-height: 706;\n    }\n    .slide2x {\n        width: 100%;\n        display: flex;\n        border: 1px solid black;\n        margin-left: auto;\n        margin-right: auto;\n        overflow: hidden;\n        border-radius: 6px;\n    }\n    .slide2x .slide1x {\n        width: 50%;\n        height: auto;\n        aspect-ratio: calc(var(--slide-width)) / calc(var(--slide-height) * (1 - var(--crop-top) - var(--crop-bottom)));\n        overflow: hidden;\n        position: relative;\n    }\n    .slide2x .slide1x img {\n        position: absolute;\n        top: calc(100% * var(--crop-top));\n        left: 0;\n        width: 100%;\n        height: auto;\n    }\n    </style>\n<h2 id=\"anchor-b9cef5fbf28b8841\" style=\"position: relative;\"><a href=\"#anchor-b9cef5fbf28b8841\" aria-label=\"anchor b9cef5fbf28b8841 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Introduction to Instruction-Level Parallelism</h2>\n<h3 id=\"anchor-11b30f3eb2a154fc\" style=\"position: relative;\"><a href=\"#anchor-11b30f3eb2a154fc\" aria-label=\"anchor 11b30f3eb2a154fc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. Terminologies</h3>\n<ul>\n<li>\n<p><strong>时延(latency)</strong>：单个指令从进入流水线开始，到它完成执行并可以写会结果所需要的时钟周期数．</p>\n<ul>\n<li>\n<p><strong>功能单元时间(function unit time)</strong>：指指令在 EX/MEM 阶段的 latency．</p>\n</li>\n<li>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>latency </mtext><mo>=</mo><mtext> function unit time </mtext><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\text{latency } = \\text{ function unit time } - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">latency </span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord text\"><span class=\"mord\"> function unit time </span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>．</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>启动间隔(initiation interval)</strong>：一个功能单元需要经过多少个时钟周期才能被重新使用．</p>\n<ul>\n<li>\n<p>对于 <strong>完全流水线的(full pipelined)</strong> 功能单元：<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>initiation interval </mtext><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\text{initiation interval } = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">initiation interval </span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>．</p>\n</li>\n<li>\n<p>对于 <strong>非流水线的(non-pipelined)</strong> 功能单元：<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>initiation interval </mtext><mo>=</mo><mtext> latency </mtext><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\text{initiation interval } = \\text{ latency } + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">initiation interval </span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\"> latency </span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>．</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><details open class=\"callout callout-type-example\"><summary style=\"pointer-events: none;\"> 浮点数流水线中功能单元的时延与启动间隔</summary><div class=\"callout-content\"><p></p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-04-30-20-05-26.png\" style=\"width: calc(0.4 * 50em)\"><p>这里 <code class=\"language-text\">FP add</code> 是四级流水线（<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>latency </mtext><mo>=</mo><mtext> function unit time </mtext><mo>−</mo><mn>1</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">\\text{latency } = \\text{ function unit time } - 1 = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">latency </span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord text\"><span class=\"mord\"> function unit time </span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span>），并且是完全流水线的（说明启动间隔为 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>）功能模块．</p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-04-30-21-06-00.png\" style=\"width: calc(0.5 * 50em)\"></div></details></p>\n<ul>\n<li><strong>基本块(basic block)</strong>：一段连续的、直线执行的代码．只有一个入口和一个出口，没有分支．</li>\n</ul>\n<h2 id=\"anchor-95e95b7662806d1b\" style=\"position: relative;\"><a href=\"#anchor-95e95b7662806d1b\" aria-label=\"anchor 95e95b7662806d1b permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Dependencies &#x26; Hazards | 依赖与冒险</h2>\n<h3 id=\"anchor-413fa623a7c33edb\" style=\"position: relative;\"><a href=\"#anchor-413fa623a7c33edb\" aria-label=\"anchor 413fa623a7c33edb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. Structural Hazards | 结构冒险</h3>\n<h4 id=\"anchor-6a30c2e3f5861cae\" style=\"position: relative;\"><a href=\"#anchor-6a30c2e3f5861cae\" aria-label=\"anchor 6a30c2e3f5861cae permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.1. Structural Hazards for the FP Register Write Port | 浮点数寄存器写端口结构冒险</h4>\n<ul>\n<li>\n<p>浮点数流水线（顺序发射、顺序执行、<strong>乱序完成(out-of-order complete)</strong>）导致的结构冒险问题：</p>\n<ul>\n<li>\n<p>(1) 单个时钟周期内多个 WB 操作．</p>\n</li>\n<li>\n<p>(2) 写回顺序被打乱导致冒险．</p>\n</li>\n</ul>\n</li>\n<li>\n<p>解决方法一：增加写端口的数量，从而允许一个时钟周期内执行多个 WB 操作．、</p>\n</li>\n<li>\n<p>解决方法二：通过<mark>移位寄存器</mark>，在<mark>指令译码阶段</mark>跟踪写端口的使用——因为在静态调度流水线中，必定是顺序执行的，且在译码阶段已经可以计算需要 stall 几个周期，因此也可以直接结算处在什么时候写回．</p>\n</li>\n</ul>\n<img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-04-30-20-31-09.png\" style=\"width: calc(0.64 * 50em)\">\n<ul>\n<li>解决方法三：在指令试图进入 MEM 或 WB 阶段时进行 stall，在托马斯路等算法中可能再次用到．</li>\n</ul>\n<img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-04-30-20-30-02.png\" style=\"width: calc(0.5 * 50em)\">\n<h3 id=\"anchor-017e55aa6c8fd482\" style=\"position: relative;\"><a href=\"#anchor-017e55aa6c8fd482\" aria-label=\"anchor 017e55aa6c8fd482 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. Data Hazards | 数据冒险</h3>\n<h4 id=\"anchor-4fd3717aff254586\" style=\"position: relative;\"><a href=\"#anchor-4fd3717aff254586\" aria-label=\"anchor 4fd3717aff254586 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2.1. RAW Dependences</h4>\n<ul>\n<li>\n<p><strong>读后写依赖(read-after-write dependency, RAW dependency)</strong>，又称 <strong>真数据依赖(true data dependency)</strong>．</p>\n</li>\n<li>\n<p>一般来说，只能通过 forwarding 或 stall 来解决．</p>\n</li>\n</ul>\n<p><details open class=\"callout callout-type-example\"><summary style=\"pointer-events: none;\"> 通过 stall 解决 RAW 冒险</summary><div class=\"callout-content\"><p></p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-04-30-21-01-05.png\" style=\"width: calc(0.8 * 50em)\"></div></details></p>\n<h4 id=\"anchor-3ccb065607e52ca7\" style=\"position: relative;\"><a href=\"#anchor-3ccb065607e52ca7\" aria-label=\"anchor 3ccb065607e52ca7 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2.2. WAW Dependences</h4>\n<ul>\n<li>\n<p><strong>写后写依赖(write-after-write dependency, WAW dependency)</strong>，又称 <strong>输出依赖(output dependency)</strong>，是 <strong>命名依赖(name dependency)</strong> 的一种．</p>\n</li>\n<li>\n<p>WAW 和 WAR 这两种命名依赖都可以通过重命名寄存器的方式解决．</p>\n</li>\n</ul>\n<p><details open class=\"callout callout-type-example\"><summary style=\"pointer-events: none;\"> 通过 stall 解决 WAW 冒险</summary><div class=\"callout-content\"><p></p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-04-30-21-02-20.png\" style=\"width: calc(0.7 * 50em)\"></div></details></p>\n<ul>\n<li>\n<p>解决方法一：取消掉前一条指令的 WB 阶段，可以在 ID 阶段进行检测．</p>\n</li>\n<li>\n<p>解决方法二：检测到冲突时阻滞在 ID 阶段（即后文小结的方法）．</p>\n</li>\n</ul>\n<h4 id=\"anchor-60145b08c967622d\" style=\"position: relative;\"><a href=\"#anchor-60145b08c967622d\" aria-label=\"anchor 60145b08c967622d permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2.3. WAR Dependences</h4>\n<ul>\n<li><strong>写后读依赖(write-after-read dependency, WAR dependency)</strong> 又称 <strong>反依赖(anti-dependency)</strong>，是 <strong>命名依赖(name dependency)</strong> 的一种．</li>\n</ul>\n<img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-04-30-20-59-47.png\" style=\"width: calc(0.42 * 50em)\">\n<ul>\n<li>在大部分顺序发射、顺序执行的流水线（称为 <strong>顺序流水线(sequential pipeline)</strong>）中，因为是顺序读取（一般都是尽可能早的读取出值），不会出现 WAR 冒险．</li>\n</ul>\n<p><details open class=\"callout callout-type-tip\"><summary style=\"pointer-events: none;\"> 小结：顺序流水线解决结构冒险与数据冒险的方法</summary><div class=\"callout-content\"><p></p><p>一种简单且常用的方法是，对于结构冒险、RAW 冒险和 WAR 冒险，全都在 ID 阶段进行判断，如果不行就在 ID 阶段暂停，等到依赖解除后再进行发射．</p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-04-30-20-50-00.png\" style=\"width: calc(0.4 * 50em)\"></div></details></p>\n<p><details open class=\"callout callout-type-summary\"><summary style=\"pointer-events: none;\"> MIPS R4000 流水线</summary><div class=\"callout-content\"><p></p><ul>\n<li><code class=\"language-text\">| IF | IS | RF | EX | DF | DS | TC | WB |</code></li>\n</ul><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-04-30-20-56-06.png\" style=\"width: calc(0.6 * 50em)\"></div></details></p>\n<p>miss?</p>\n<p>这里讲的冒险问题其实没听懂</p>\n<h3 id=\"anchor-ed8dbd917e67d66c\" style=\"position: relative;\"><a href=\"#anchor-ed8dbd917e67d66c\" aria-label=\"anchor ed8dbd917e67d66c permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. Controls Hazards | 控制冒险</h3>\n<ul>\n<li>最常用的方法就是 stall（<strong>延迟分支(delayed branch)</strong>）．</li>\n</ul>\n<h3 id=\"anchor-9c28b8929aa3764a\" style=\"position: relative;\"><a href=\"#anchor-9c28b8929aa3764a\" aria-label=\"anchor 9c28b8929aa3764a permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.4. Hazards among FP Instructions</h3>\n<p>mark</p>\n<h2 id=\"anchor-b267492d161e4cac\" style=\"position: relative;\"><a href=\"#anchor-b267492d161e4cac\" aria-label=\"anchor b267492d161e4cac permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Basic Compiler Techniques | 基本编译技术</h2>\n<p>在本节中，我们考虑以下 C 代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">999</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\">// typeof i is long long</span>\n    x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> s<span class=\"token punctuation\">;</span>               <span class=\"token comment\">// typeof x[i] is double</span></code></pre></div>\n<p>编译到 RISC-V 的结果如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">Loop:\n    fld     f0, 0(x1)\n    fadd.d  f4, f0, f2\n    fsd     f4, 0(x1)\n    addi    x1, x1, -8\n    bne     x1, x2, Loop</code></pre></div>\n<h3 id=\"anchor-4cab3234f8f264bb\" style=\"position: relative;\"><a href=\"#anchor-4cab3234f8f264bb\" aria-label=\"anchor 4cab3234f8f264bb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. Scheduling | 调度</h3>\n<ul>\n<li>使用 <strong>调度(scheduling)</strong> 优化本节实例代码，可以减少一个时钟周期的停顿．</li>\n</ul>\n<table>\n<colgroup>\n<col style=\"width: 50%\">\n<col style=\"width: 50%\">\n</colgroup>\n<thead>\n<tr>\n<th><p><strong>调度前</strong></p></th>\n<th><p><strong>调度后</strong></p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-05-01-00-21-28.png\" style=\"width: calc(0.6 * 50em)\"></p></td>\n<td><p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-05-01-00-21-43.png\" style=\"width: calc(0.6 * 50em)\"></p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"anchor-d9e73448a61283d0\" style=\"position: relative;\"><a href=\"#anchor-d9e73448a61283d0\" aria-label=\"anchor d9e73448a61283d0 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. Loop Unrolling | 循环展开</h3>\n<ul>\n<li>使用 <strong>循环展开(loop unrolling)</strong> 并进行调度，可以进一步减少每次迭代的平均周期数．</li>\n</ul>\n<table>\n<colgroup>\n<col style=\"width: 50%\">\n<col style=\"width: 50%\">\n</colgroup>\n<thead>\n<tr>\n<th><p><strong>循环展开四次的结果</strong></p></th>\n<th><p><strong>循环展开四次并调度的结果</strong></p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>平均每循环 6.5 个时钟周期\n<img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-05-01-00-24-10.png\" style=\"width: 100%\"></p></td>\n<td><p>平均每循环 3.5 个时钟周期\n<img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-05-01-00-24-18.png\" style=\"width: calc(0.6 * 50em)\"></p></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>这里假设了迭代次数是 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span></span> 的倍数，如果不是的话需要再后面再补上单迭代的循环，以确保总迭代次数不变．</li>\n</ul>\n<p>TBD: 具体方法论</p>\n<h2 id=\"anchor-63049a671ce02141\" style=\"position: relative;\"><a href=\"#anchor-63049a671ce02141\" aria-label=\"anchor 63049a671ce02141 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Dynamic Scheduling | 动态调度</h2>\n<ul>\n<li>\n<p>回顾（计组知识）：<strong>静态调度(static scheduling)</strong> 静态调度的流水线处理器在获取指令后会发射该指令，除非发现该指令存在数据依赖且无法通过 <strong>前递(forwarding)</strong> 来隐藏该指令，此时冒险检测硬件会暂停流水线，直到依赖清除后在获取新的指令．</p>\n</li>\n<li>\n<p><strong>动态调度(dynamic scheduling)</strong>：通过硬件重排指令的执行阶段（允许 <strong>顺序发射(in-order issue)</strong> 但是 <strong>乱序执行(out-of-order execution)</strong>）以减少停顿，并且不改变 <strong>数据流(data flow)</strong> 和 <strong>异常(exception behavior)</strong>．</p>\n<ul>\n<li>\n<p>优点：</p>\n<ul>\n<li>\n<p>可以让在某个流水线上被编译的代码在其他流水线上也能高效运行．</p>\n</li>\n<li>\n<p>能够处理在编译时无法处理的依赖，比如内存引用或数据依赖分支，或者采用现代的动态链接或分派．</p>\n</li>\n<li>\n<p>能让处理器容忍无法预测的时延，比如对于高速缓存失效，可通过在等待失效解决时执行其他代码来实现这一点．</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-7b6486258fd299a6\" style=\"position: relative;\"><a href=\"#anchor-7b6486258fd299a6\" aria-label=\"anchor 7b6486258fd299a6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1. The Scoreboard Algorithm | 记分牌算法</h3>\n<ul>\n<li>\n<p>带记分牌的流水线阶段：<code class=\"language-text\">IF - IS - RO - EX - WB</code>．</p>\n<ul>\n<li>\n<p>与 RISC-V 五级流水线的区别：</p>\n<ul>\n<li>\n<p>ID 阶段：分成了 <strong>发射(issue)</strong> 和 <strong>取数(read operands)</strong> 两个阶段．</p>\n</li>\n<li>\n<p>MEM 阶段：省略，合并到 EX 阶段．</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>记分牌流水线工作流程：</p>\n<ul>\n<li>\n<p>IS</p>\n<ul>\n<li>\n<p>当且仅当 (1) 功能单元可用 (2) 没有其他活跃指令占用了相同的目标寄存器 时，发射指令．</p>\n</li>\n<li>\n<p>可以避免结构冒险与 WAW 冒险．</p>\n</li>\n</ul>\n</li>\n<li>\n<p>RO</p>\n<ul>\n<li>\n<p>直到<mark>两个源操作数都可用</mark>时，才进行读取．</p>\n</li>\n<li>\n<p>可以动态地避免 RAW 冒险．</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>记分牌的数据结构：</p>\n<ul>\n<li>\n<p>指令状态：</p>\n</li>\n<li>\n<p><strong>功能单元状态(function unit state)</strong>：</p>\n<ul>\n<li>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Busy</mtext></mrow><annotation encoding=\"application/x-tex\">\\mathrm{\\text{Busy}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">Busy</span></span></span></span></span></span>：表明这个功能单元是否在执行某条指令．</p>\n</li>\n<li>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Op</mtext></mrow><annotation encoding=\"application/x-tex\">\\mathrm{\\text{Op}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">Op</span></span></span></span></span></span>：正在这个功能单元执行的指令操作．</p>\n</li>\n<li>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">F_{i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>：目标寄存器．</p>\n</li>\n<li>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mi>j</mi></msub><mo separator=\"true\">,</mo><msub><mi>F</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">F_{j},F_{k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>：源寄存器．</p>\n</li>\n<li>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>Q</mi><mi>j</mi></msub><mo separator=\"true\">,</mo><msub><mi>Q</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">Q_{j},Q_{k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>：源寄存器会由哪个功能单元产生（如有）．</p>\n</li>\n<li>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub><mo separator=\"true\">,</mo><msub><mi>R</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">R_{j},R_{k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>：源寄存器是否就绪（都就绪时才读），读完在下一周期要标记为 NO．</p>\n</li>\n</ul>\n</li>\n<li>\n<p>计算器结果状态：</p>\n</li>\n</ul>\n</li>\n</ul>\n<table>\n<colgroup>\n<col style=\"width: 50%\">\n<col style=\"width: 50%\">\n</colgroup>\n<thead>\n<tr>\n<th style=\"text-align: left;\"><p><strong>记分牌状态</strong></p></th>\n<th style=\"text-align: left;\"><p><strong>说明</strong></p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-05-01-10-48-25.png\" style=\"width: 100%\"></p></td>\n<td style=\"text-align: left;\"><p><strong>第一个周期</strong>：记分牌是空的，功能部件也都是空闲的，因此第一条指令顺利渡过发射阶段，并在周期结束的时候更新了记分牌．</p>\n<p>注意看更新内容．整数部件现在显示忙碌，而 LD\n指令的操作数不存在冒险，<span class=\"math inline\"><em>R</em><sub><em>k</em></sub></span> 显示\nYes，在寄存器状态里标记 F6 即将被整数部件改写．</p></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-05-01-10-51-08.png\" style=\"width: 100%\"></p></td>\n<td style=\"text-align: left;\"><p><strong>第二个周期</strong>：因为整数部件被占用了，所以第二条\nLD 指令不能发射．同时第一条 LD 已经顺利渡过读数阶段，需要将 <span class=\"math inline\"><em>R</em><sub><em>k</em></sub></span> 标记为\nNO．</p>\n<p>第二条 LD 在周期结束时不会更新记分牌．</p></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-05-06-11-25-52.png\" style=\"width: 100%\"></p></td>\n<td style=\"text-align: left;\"><p><strong>第三个周期</strong>：在流程解读一节，我们已经看到\nINST 寄存器只有一个，所以发射阶段是阻塞的、顺序的．因为第二条 LD\n没法发射，后面的指令都没办法发射．</p>\n<p>第一条 LD\n顺利渡过执行阶段，并在周期结束时改写了记分牌，这里主要是解放了 Rk（从\nYes 变为 No ），即表示自己不再要读取寄存器 R2．</p></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-05-06-11-26-11.png\" style=\"width: 100%\"></p></td>\n<td style=\"text-align: left;\"><p><strong>第四个周期</strong>：后续指令依旧没办法发射．</p>\n<p>第一条 LD\n顺利渡过写回阶段，阶段结束时清空功能状态，并且解放了寄存器状态（清除 F6\n下面的 Integer ），即 F6 已经被写完了，F6\n不再是“即将被整数部件写”的状态．</p></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-05-06-11-26-28.png\" style=\"width: 100%\"></p></td>\n<td style=\"text-align: left;\"><p><strong>第五个周期</strong>：整数部件空闲，所以第二条\nLD 终于可以发射了．</p>\n<p>在周期结束时，LD 改写记分牌，并且改写寄存器状态．</p></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-05-06-11-26-55.png\" style=\"width: 100%\"></p></td>\n<td style=\"text-align: left;\"><p><strong>第六个周期</strong>：乘法部件有空闲，所以\nMULD 顺利发射；LD 要读的寄存器的值都是最新的，所以可以读取．</p>\n<p>周期结束时，LD 指令不会改写记分牌．据寄存器状态可知，源寄存器 F2\n正要被整数部件改写，所以 MULD 要读的 F2\n是过时的，因此记分牌中会打上标记，表示 MULD 指令还不能读 F2.</p>\n<p>周期结束时，LD指令不会改写记分牌．</p></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-05-06-13-10-13.png\" style=\"width: 100%\"></p></td>\n<td style=\"text-align: left;\"><p><strong>第七个周期</strong>：加法部件空闲，所以\nSUBD 指令可以发射；MULD 因为记分牌告诉它它还不能读取 F2\n，所以卡在部件寄存器中，不能读数；LD 指令顺利执行．</p>\n<p>周期结束时，SUBD 指令改写记分牌，根据寄存器状态可知，源寄存器 F2\n要被整数部件改写，所以不能读，因此记分牌中标记 F2.</p>\n<p>周期结束时，MULD 因为卡在部件寄存器中，所以没有任何动作．</p>\n<p>周期结束时，LD 改写记分牌，主要是改写 Rk，以表明自己不再需要读寄存器\nR3.</p></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-05-06-13-10-09.png\" style=\"width: 100%\"></p></td>\n<td style=\"text-align: left;\"><p><strong>第八个周期</strong>：因为除法部件空闲，所以\nDIVD 可以发射；SUBD 和 MULD 指令因为 F2\n寄存器还没准备好（看第七个周期的记分牌），所以这个周期卡在部件寄存器中；LD\n顺利写回．</p>\n<p>周期结束时，DIVD 改写记分牌，根据寄存器状态，源寄存器 F0\n正要被乘法部件 1 改写，所以记分牌标记 F0，表面 F0 还不能读．</p>\n<p>周期结束时，SUBD、MULD\n还没有动作，但是关于这两条指令的记分牌内容出现变化了，具体看下一段．</p>\n<p>周期结束时，LD\n将数据写回寄存器堆，并且改写功能状态，具体工作是通知各个部件寄存器，F2\n寄存器已经被改写好了，寄存器堆中的 F2 现在是最新值，经过 LD\n的通知，SUBD、MULD 指令 R 信息就从 No 被改为 Yes\n；并且解放寄存器状态，表明 F2 不再处于“即将被改写”的状态．</p></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-05-06-13-10-46.png\" style=\"width: 100%\"></p></td>\n<td style=\"text-align: left;\"><p><strong>第九个周期</strong>：因为加法部件被\nSUBD 指令占用，所以 ADDD 指令没办法发射；而 DIVD 指令因为要等到乘法部件\n1 的结果，所以也没法读数；而 SUBD 和 MULD 两条指令因为上一周期 LD\n写回完毕，所以这个周期可以读取所有它们需要的寄存器值，因此顺利渡过读数阶段．</p>\n<p>周期结束时，功能状态和寄存器状态都没有变化．但是注意记分牌 Mult1\n后面的 10 和 Add 后面的 2\n，这是在告诉我们从下一周期开始，乘法和加法将要开始各自的计算，其分别需要\n10 个周期、2 个周期．</p></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><p><img src=\"https://course.cdn.memset0.cn/ca/notes/images/2025-05-06-13-11-05.png\" style=\"width: 100%\"></p></td>\n<td style=\"text-align: left;\"><p><strong>第十个周期</strong>：DVID\n指令还在等待寄存器的新值；而乘法部件和加法部件完成了各自的第一个计算周期．</p>\n<p>周期结束时，MULD 和 SUBD 修改记分牌，把 Rj 和 Rk 的内容置为\nNO，表明自己不再需要读取寄存器．记分牌 Mult1 前面的 9 和 Add 前面的\n1，表示乘法和加法还各自需要 9 个周期、1 个周期才能执行完毕．</p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"anchor-d26dbf0a968137c3\" style=\"position: relative;\"><a href=\"#anchor-d26dbf0a968137c3\" aria-label=\"anchor d26dbf0a968137c3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2. Tomasulo Algorithm | 托马斯路算法</h3>\n<ul>\n<li>\n<p><strong>Tomasulo 算法的优点</strong>：</p>\n</li>\n<li>\n<p><strong>Tomasulo 算法的缺点</strong>：</p>\n<ul>\n<li>\n<p>无法避免内存上的 WAW 与 WAR 冒险，只是通过保留站解决了寄存器上的 WAW 与 WAR 冒险．</p>\n</li>\n<li>\n<p>TBD</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Tomasulo 算法在循环场景中也有助于提升性能（我认为这是因为 Tomasulo 算法的优化不会），但是效果肯定没有直接循环展开的提升来的大．</p>\n</li>\n</ul>\n<h3 id=\"anchor-0cef60d75989d793\" style=\"position: relative;\"><a href=\"#anchor-0cef60d75989d793\" aria-label=\"anchor 0cef60d75989d793 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.3. Scoreboard with Explicit Register Renaming | 带显示寄存器重命名的记分牌</h3>\n<h2 id=\"anchor-b283d4aed4c4c7c4\" style=\"position: relative;\"><a href=\"#anchor-b283d4aed4c4c7c4\" aria-label=\"anchor b283d4aed4c4c7c4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. References</h2>\n<ul>\n<li>\n<p>cwz、jxh 等老师的课件．</p>\n</li>\n<li>\n<p>lxr 等同学的笔记．</p>\n</li>\n<li>\n<p><a href=\"https://note.noughtq.top/system/ca/3\">https://note.noughtq.top/system/ca/3</a></p>\n</li>\n<li>\n<p><a href=\"https://en.wikipedia.org/wiki/Data_dependency\">https://en.wikipedia.org/wiki/Data_dependency</a></p>\n</li>\n<li>\n<p><a href=\"https://zhuanlan.zhihu.com/p/496078836\">https://zhuanlan.zhihu.com/p/496078836</a></p>\n</li>\n<li>\n<p><a href=\"https://zhuanlan.zhihu.com/p/499978902\">https://zhuanlan.zhihu.com/p/499978902</a></p>\n</li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#anchor-b9cef5fbf28b8841\">1. Introduction to Instruction-Level Parallelism</a></p>\n<ul>\n<li><a href=\"#anchor-11b30f3eb2a154fc\">1.1. Terminologies</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-95e95b7662806d1b\">2. Dependencies &#x26; Hazards | 依赖与冒险</a></p>\n<ul>\n<li><a href=\"#anchor-413fa623a7c33edb\">2.1. Structural Hazards | 结构冒险</a></li>\n<li><a href=\"#anchor-017e55aa6c8fd482\">2.2. Data Hazards | 数据冒险</a></li>\n<li><a href=\"#anchor-ed8dbd917e67d66c\">2.3. Controls Hazards | 控制冒险</a></li>\n<li><a href=\"#anchor-9c28b8929aa3764a\">2.4. Hazards among FP Instructions</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-b267492d161e4cac\">3. Basic Compiler Techniques | 基本编译技术</a></p>\n<ul>\n<li><a href=\"#anchor-4cab3234f8f264bb\">3.1. Scheduling | 调度</a></li>\n<li><a href=\"#anchor-d9e73448a61283d0\">3.2. Loop Unrolling | 循环展开</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-63049a671ce02141\">4. Dynamic Scheduling | 动态调度</a></p>\n<ul>\n<li><a href=\"#anchor-7b6486258fd299a6\">4.1. The Scoreboard Algorithm | 记分牌算法</a></li>\n<li><a href=\"#anchor-d26dbf0a968137c3\">4.2. Tomasulo Algorithm | 托马斯路算法</a></li>\n<li><a href=\"#anchor-0cef60d75989d793\">4.3. Scoreboard with Explicit Register Renaming | 带显示寄存器重命名的记分牌</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-b283d4aed4c4c7c4\">5. References</a></p>\n</li>\n</ul>","frontmatter":{"title":"III. Instruction-Level Parallelism","description":null},"fields":{"cover":null,"slug":"/course/ca/note/3/","cssclasses":["m-mubu"],"isDoc":true,"authors":[],"createTime":"2025 年 4 月 29 日","updateTime":"2025 年 4 月 29 日","category":"[{\"name\":\"课程笔记\",\"to\":\"/course/\"}]","propsJson":null}},"previous":null,"next":null},"pageContext":{"id":"9fedc75f-3d41-5f1a-8067-e741db4ad237","previousPostId":null,"nextPostId":null,"navJson":"[{\"slug\":\"/course/ca\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/ca/index.md\",\"title\":\"Home\"},{\"title\":\"Note\",\"children\":[{\"slug\":\"/course/ca/note/1\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/ca/note/1.md\",\"title\":\"I. Introduction\"},{\"slug\":\"/course/ca/note/2\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/ca/note/2.md\",\"title\":\"II. Memory Hierarchy\"},{\"slug\":\"/course/ca/note/3\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/ca/note/3.md\",\"title\":\"III. Instruction-Level Parallelism\"}]}]"}},"staticQueryHashes":["3871233186"],"slicesMap":{}}