{"componentChunkName":"component---src-templates-post-js","path":"/course/co/note/4/","result":{"data":{"site":{"siteMetadata":{"title":"mem 的小站"}},"post":{"id":"04a4dfb8-7594-5d94-8e09-a5f2e8b182e3","excerpt":"本篇笔记详细介绍了处理器的两种主要实现方式：单周期 CPU 和流水线 CPU。对于单周期 CPU，讲解了指令执行的五个阶段（IF、ID、EX、MEM、WB）、数据通路的设计以及控制单元的实现，包括一级译码和二级译码的过程。在流水线 CPU 部分，重点讨论了三种冒险（hazard）及其解决方案：结构冒险（通过分离指令和数据内存解决）、数据冒险（通过前递技术和处理 load-use hazards）以及控制冒险（通过分支预测处理）。通过对比这两种实现方式，深入理解了处理器的工作原理、性能优化方法以及各种设计权衡。（由 claude-3.5-sonnet 生成摘要）","html":"<blockquote>\n<p>本篇笔记详细介绍了处理器的两种主要实现方式：单周期 CPU 和流水线 CPU。对于单周期 CPU，讲解了指令执行的五个阶段（IF、ID、EX、MEM、WB）、数据通路的设计以及控制单元的实现，包括一级译码和二级译码的过程。在流水线 CPU 部分，重点讨论了三种冒险（hazard）及其解决方案：结构冒险（通过分离指令和数据内存解决）、数据冒险（通过前递技术和处理 load-use hazards）以及控制冒险（通过分支预测处理）。通过对比这两种实现方式，深入理解了处理器的工作原理、性能优化方法以及各种设计权衡。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small></p>\n</blockquote>\n<!-- more -->\n<h2 id=\"anchor-6483207c57cba8be\" style=\"position: relative;\"><a href=\"#anchor-6483207c57cba8be\" aria-label=\"anchor 6483207c57cba8be permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Single-Cycle CPU</h2>\n<h3 id=\"anchor-fcea50e2c37fbe57\" style=\"position: relative;\"><a href=\"#anchor-fcea50e2c37fbe57\" aria-label=\"anchor fcea50e2c37fbe57 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. Prelude</h3>\n<ul>\n<li>\n<p>单周期 CPU：每条指令都在一个时钟周期内完成，故 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>CPI</mtext><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\text{CPI}=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">CPI</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>。时钟周期的长度取决于花费时间最长的指令。</p>\n</li>\n<li>\n<p>内存需要被分成 <strong>指令内存(instruction memory)</strong> 和 <strong>数据内存(data memory)</strong> 两个部分，分开进行读写。因为我们在这里默认的 memory 实现是只能在一个时钟周期内读或写一个位置的，所以需要把对 data memory 的访问和从 instruction memory 取出指令这两个部分分开到两块内存中进行。</p>\n</li>\n</ul>\n<p><img src=\"https://img.memset0.cn/2024/11/16/8m8KK7Ar.png\"alt=\"\" style=\"width: 515px; \" ></p>\n<ul>\n<li>注意：不能简单地把线连在一起，需要用 MUX 实现选择功能。——控制信号</li>\n</ul>\n<h3 id=\"anchor-533991c855bc7ed8\" style=\"position: relative;\"><a href=\"#anchor-533991c855bc7ed8\" aria-label=\"anchor 533991c855bc7ed8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. Instruction Execution Overview</h3>\n<p>CPU 执行指令一般分为以下五个阶段：</p>\n<ul>\n<li><strong>取址(Instruction Fetch, IF)</strong>：根据 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC</span></span></span></span></span></span> 所给地址，从存储器中取出指令。<br>\n<img src=\"https://img.memset0.cn/2024/11/16/amfocLym.png\"alt=\"\" style=\"width: 524px; \" ></li>\n<li><strong>译码(Instruction Decode, ID)</strong>：分析指令字段，从寄存器堆中读取一个或两个寄存器的值。</li>\n<li><strong>执行(Execute, EX)</strong>：实验中需要实现的指令只需要用到 ALU。\n<ul>\n<li>对于 R 型指令：ALU 执行相应的算数逻辑运算，并输出结果；</li>\n<li>对于访存指令：ALU 计算基地址和立即数的和，得到数据的真正地址；</li>\n<li>对于分支指令：ALU 将两源操作数相减，根据结果是否为 0，判断两数是否相等。</li>\n</ul>\n</li>\n<li><strong>访存(Memory, MEM)</strong>：从数据内存中读或写数据，用于 load / store 指令中。（注意：不同于 x86 指令集架构，Risc-V 指令集中没有一条指令既从内存中读数据有对读出来的数据进行操作。）</li>\n<li><strong>写回(Write Back, WB)</strong>：将结果写回寄存器堆中。</li>\n</ul>\n<p>除了前两个阶段是所有指令所共有的，其他阶段根据具体指令而定，部分指令就不需要 MEM 或 WB 阶段。</p>\n<h3 id=\"anchor-61011d4dba32dd0a\" style=\"position: relative;\"><a href=\"#anchor-61011d4dba32dd0a\" aria-label=\"anchor 61011d4dba32dd0a permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3. Imm Gen</h3>\n<p>Imm Gen 是 ID 阶段中的一个模块，用于将指令中的立即数进行 <mark class=\"m-mark\">符号拓展</mark> 到 32 位或 64 位以进行后续运算。</p>\n<ul>\n<li>branch 指令的立即数需要补 0（Shift left 1 部分），这是因为 branch 指令的立即数最低位的 0 是省略的，需要补上。</li>\n</ul>\n<h3 id=\"anchor-1860493445f763d5\" style=\"position: relative;\"><a href=\"#anchor-1860493445f763d5\" aria-label=\"anchor 1860493445f763d5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.4. Datapath</h3>\n<p><img src=\"https://img.memset0.cn/2024/11/16/nfSQAg0L.png\"alt=\"\" style=\"width: 644px; \" ></p>\n<p>全数据通路如下，实现了基本都 R 型指令和 I 型指令，以及 <code class=\"language-text\">ld</code>、<code class=\"language-text\">sd</code> 和 <code class=\"language-text\">beq</code> 指令。</p>\n<p><img src=\"https://img.memset0.cn/2024/11/16/w8O0EH27.png\"alt=\"\" style=\"width: 625px; \" ></p>\n<p><details  class=\"callout callout-type-example\"><summary> Example: 在全 datapath 中画出所用到的部分</summary><div class=\"callout-content\"><p></p><ul>\n<li>R-type<br>\n<img src=\"https://img.memset0.cn/2025/01/16/JuhnbDJd.png\"alt=\"\" style=\"width: 400px; \" ></li>\n<li><code class=\"language-text\">ld</code><br>\n<img src=\"https://img.memset0.cn/2025/01/16/969YtfxS.png\"alt=\"\" style=\"width: 400px; \" ></li>\n<li><code class=\"language-text\">sd</code><br>\n<img src=\"https://img.memset0.cn/2025/01/16/Gttikens.png\"alt=\"\" style=\"width: 400px; \" ></li>\n<li><code class=\"language-text\">beq</code><br>\n<img src=\"https://img.memset0.cn/2025/01/16/KfSeaeqM.png\"alt=\"\" style=\"width: 400px; \" ></li>\n<li><code class=\"language-text\">jal</code><br>\n<img src=\"https://img.memset0.cn/2025/01/16/hMLEOOVs.png\"alt=\"\" style=\"width: 400px; \" ></li>\n</ul></div></details></p>\n<h3 id=\"anchor-7c0440f182b38ee6\" style=\"position: relative;\"><a href=\"#anchor-7c0440f182b38ee6\" aria-label=\"anchor 7c0440f182b38ee6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.5. Control Unit</h3>\n<p>通过不同的 <strong>控制信号(control signal)</strong> 控制多个 MUX，可以让在同一条数据通路上实现不同功能的指令，上一小节的途中蓝色的部分就是控制信号。而生成这些控制信号的原件就是 <strong>控制单元(control unit)</strong>。</p>\n<table>\n<thead>\n<tr>\n<th><strong>Signal name</strong></th>\n<th><strong>Effect When deasserted (=0)</strong></th>\n<th><strong>Effect when asserted (=1)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RegWrite</td>\n<td>-</td>\n<td>寄存器写入：将寄存器组 Write data 的输入写入到 Write register (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">rd</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{rd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">rd</span></span></span></span></span></span>) 中</td>\n</tr>\n<tr>\n<td>ALUSrc</td>\n<td>ALU 的第二个操作数从寄存器第二个输出（Read data 2）中来</td>\n<td>ALU 的第二个操作数从符号拓展后的立即数（Imm Gen 生成）</td>\n</tr>\n<tr>\n<td>PCSrc (Branch)</td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC</span></span></span></span></span></span> 的下一个值是 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC+4</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC+4}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC+4</span></span></span></span></span></span></td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC</span></span></span></span></span></span> 的下一个值为分治语句的运算结果</td>\n</tr>\n<tr>\n<td>Jump</td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC</span></span></span></span></span></span> 的下一个值是 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC+4</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC+4}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC+4</span></span></span></span></span></span></td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC</span></span></span></span></span></span> 的下一个值为计算出来的跳跃地址</td>\n</tr>\n<tr>\n<td>MemRead</td>\n<td>-</td>\n<td>数据会从数据内存的 Read data 输出，然后交由 MemtoReg 所控制的 MUX</td>\n</tr>\n<tr>\n<td>MemWrite</td>\n<td>-</td>\n<td>在数据内存 Write data 输入的数据会被写入 address 输入对应的内存</td>\n</tr>\n<tr>\n<td>MemtoReg<br><mark class=\"m-mark\">(2 位)</mark><br><br></td>\n<td>00：ALU 的计算结果会被交给寄存器堆的 Write data 输入（R 型、I 型）</td>\n<td>01：交给寄存器堆的数据为从数据内存中的 Write data 输出（load 指令）<br>10：交给内存器堆的数据为 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC+4</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC+4}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC+4</span></span></span></span></span></span>（<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">jal</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{jal}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.2222em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">jal</span></span></span></span></span></span>、<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">jalr</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{jalr}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.2222em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">jalr</span></span></span></span></span></span> 指令）<mark class=\"m-mark\">？</mark><br></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"anchor-6e5d63a355275748\" style=\"position: relative;\"><a href=\"#anchor-6e5d63a355275748\" aria-label=\"anchor 6e5d63a355275748 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.5.1. ALU Control</h4>\n<p>多种指令中需要用到 ALU。我们可以进行 <strong>二级解码(2-level decode)</strong>。在一级译码后，我们得到 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>+</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">4+3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span> 个控制信号，和 2 位的 <code class=\"language-text\">ALU_op</code>。</p>\n<p><img src=\"https://img.memset0.cn/2024/11/16/xeXC6k5s.png\"alt=\"\" style=\"width: 416px; \" ></p>\n<p><img src=\"https://img.memset0.cn/2024/11/16/EAWXD06S.png\"alt=\"\" style=\"width: 665px; \" ></p>\n<p>在二级译码时，我们通过上一级的 <code class=\"language-text\">ALU_op</code> 和指令中的 <code class=\"language-text\">func7</code>、<code class=\"language-text\">func3</code> 共同决定 ALU 所需操作。</p>\n<p><img src=\"https://img.memset0.cn/2024/11/16/swLHYXUw.png\"alt=\"\" style=\"width: 670px; \" ></p>\n<p>二级译码的方式不是唯一的，这里主要起到一个抛砖引玉的作用。</p>\n<p><details open disabled class=\"callout callout-type-example\"><summary> Example: 粗略估计周期时间</summary><div class=\"callout-content\"><p>\nCalculate cycle time assuming negligible delays except:</p><ul>\n<li>memory (200ps), ALU and adders (200ps), register file access (100ps)</li>\n</ul><p><details  class=\"callout callout-type-quote\"><summary> Answer</summary><div class=\"callout-content\"><p></p><p><img src=\"https://img.memset0.cn/2024/11/16/NwWf9hns.png\"alt=\"\" style=\"width: 558px; \" ></p></div></details></p></div></details></p>\n<h2 id=\"anchor-80d23ed1e2de61c1\" style=\"position: relative;\"><a href=\"#anchor-80d23ed1e2de61c1\" aria-label=\"anchor 80d23ed1e2de61c1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Pipeline CPU</h2>\n<p>我们以小学就学过的洗衣服为例，引出流水线技术的核心思想：</p>\n<p><img src=\"https://img.memset0.cn/2024/11/04/gXlLw0vr.png\"alt=\"\" style=\"width: 425px; \" ></p>\n<p>流水线技术并没有减少所有工作的总时间，甚至单个工作的时间还会增加，但是我们可以让多个工作的不同阶段并行执行，从而提升指令的 <strong>吞吐率(throughput)</strong>，从而减少了完成所有工作的时间。</p>\n<ul>\n<li>流水线的平衡性：指不同阶段的操作所需要的时间是否一致。可以通过对指令阶段的适当划分让流水线更为平衡。</li>\n<li>流水线的级数（深度）：流水线的级数并不是越大越好，因为流水线寄存器会有一个固定延迟。</li>\n</ul>\n<p>所以说，流水线的级数是一个 trade-off 的设计。</p>\n<p><details open disabled class=\"callout callout-type-note\"><summary> RISC-V 架构是为流水线设计的</summary><div class=\"callout-content\"><p></p><ul>\n<li>所有指令都是 32 位的。</li>\n<li>Few and regular instruction formats\n<ul>\n<li>源寄存器和目标寄存器的字段相同，可以在同一步进行译码和读寄存器的操作。</li>\n</ul>\n</li>\n<li>Load/store addressing\n<ul>\n<li>只在 EX 阶段计算地址，只在 MEM 阶段访问内存。</li>\n</ul>\n</li>\n</ul></div></details></p>\n<p>对于流水线 CPU，<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>CPI</mtext><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\text{CPI} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">CPI</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>，因为在每个时钟周期我们将一条指令送入 IF 阶段；而在下面会讲到，因为 <strong>冒险(hazard)</strong> 的问题，有时我们必须要插入一些 bubble。</p>\n<h3 id=\"anchor-20cd1d6db04866cf\" style=\"position: relative;\"><a href=\"#anchor-20cd1d6db04866cf\" aria-label=\"anchor 20cd1d6db04866cf permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. Pipelined Datapath</h3>\n<p><img src=\"https://img.memset0.cn/2024/11/04/MN5uM6ID.png\"alt=\"\" style=\"width: 766px; \" ></p>\n<ul>\n<li>从右到左的流容易导致 <strong>冒险(hazard)</strong>，也就是这里标出的 WB 和 Branch 部分。</li>\n</ul>\n<h3 id=\"anchor-0c48a194ea859ea9\" style=\"position: relative;\"><a href=\"#anchor-0c48a194ea859ea9\" aria-label=\"anchor 0c48a194ea859ea9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. Structure Hazards</h3>\n<p><strong>结构冒险(structure hazard)</strong>：需要的资源正忙。</p>\n<ul>\n<li>我们必须将内存拆分为指令内存和数据内存两个部分，不然在同一时刻，分别处于 IF 和 MEM 阶段的两条指令需要对内存进行操作，只能被迫暂停其中一条。\n<ul>\n<li>所以我们将内存分为了 inst memory 和 data memory 两个部分。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-f7639322b0addd72\" style=\"position: relative;\"><a href=\"#anchor-f7639322b0addd72\" aria-label=\"anchor f7639322b0addd72 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. Data Hazards</h3>\n<p><strong>数据冒险(data hazard)</strong>：一条指令依赖前面指令所得到的数据。在本课程介绍的五级流水线架构中，我们只需要考虑当前指令和前两条指令是否会产生 data hazards 即可；另一方面，在没有进行任何实现任何优化（如 forwarding）的流水线 CPU 中，出现 data hazards 时只需要 stall 至多两个周期。</p>\n<p><details open disabled class=\"callout callout-type-question\"><summary> 为什么只用考虑上两条指令的影响？</summary><div class=\"callout-content\"><p></p><p>这其实关乎到我们实现的一个细节：对寄存器组的读写：WB 阶段的写入发生在时钟上边沿，ID 阶段的读取发生在时钟下边沿。允许我们把相互关联的两条指令的 WB 和 ID 放在同一个时钟周期进行。如果没有实现这一优化，上面的 2 就要改为 3。</p><p>观察下一小节 forwarding 中的配图，阴影区域的位置不同正表现了这一点。</p></div></details></p>\n<h4 id=\"anchor-c4fc5dd51459442d\" style=\"position: relative;\"><a href=\"#anchor-c4fc5dd51459442d\" aria-label=\"anchor c4fc5dd51459442d permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3.1. Forwarding</h4>\n<p><img src=\"https://img.memset0.cn/2024/11/04/RK45A20K.png\"alt=\"\" style=\"width: 607px; \" ></p>\n<p>考察这个例子，第二条指令的源寄存器是上一条指令的目标寄存器 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">x1</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{x1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">x1</span></span></span></span></span></span>，我们可以提前把数据取出来给到第二条指令，也就是蓝色的这条通路，这种技术被称为 <strong>前递(forwarding)</strong> 或 <strong>旁传(bypassing)</strong>。如果不这样做，则需要等两个时钟周期，这样 EX 阶段得到的数据才是对的。</p>\n<p>通过以下条件实现对 data hazards 的判断从而提供 forwarding：</p>\n<p><img src=\"https://img.memset0.cn/2024/11/04/mDBaG3zn.png\"alt=\"\" style=\"width: 460px; \" ></p>\n<ul>\n<li>这里是因为像 <code class=\"language-text\">add</code> 这种指令在 EX 阶段结束后就能得到结果，但是像 <code class=\"language-text\">load</code> 这种指令要到 MEM 阶段结束后才能得到。</li>\n<li>具体判断时，还要注意两个附加条件（即上面截图的这段判断条件是不完整的）：\n<ul>\n<li>对应的 EX/MEM.RegWrite 信号或 MEM/WB.RegWrite 信号为真，即真的写入了那个目标寄存器。</li>\n<li>对应的 EX/MEM.RegisterRd 目标寄存器或 MEM/WB.RegisterRd 目标寄存器不为 <code class=\"language-text\">x0</code>。</li>\n</ul>\n</li>\n</ul>\n<p>我们使用 MUX 来实现对 forwarding 的数据通路控制。在哪个阶段可以得到结果的数据，就从那个阶段直接 forwarding 过来。</p>\n<p><img src=\"https://img.memset0.cn/2024/11/04/er4z1aL3.png\"alt=\"\" style=\"width: 491px; \" ></p>\n<p>还需要注意 double data hazard 的问题，考虑以下示例：</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right left\" columnspacing=\"0em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mrow><mtext mathvariant=\"monospace\">add</mtext><mtext> </mtext><mstyle mathcolor=\"blue\"><mtext mathvariant=\"monospace\">x1</mtext></mstyle><mtext mathvariant=\"monospace\">,</mtext><mtext> </mtext><mtext mathvariant=\"monospace\">x1,</mtext><mtext> </mtext><mtext mathvariant=\"monospace\">x2</mtext></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mrow><mtext mathvariant=\"monospace\">add</mtext><mtext> </mtext><mstyle mathcolor=\"blue\"><mtext mathvariant=\"monospace\">x1</mtext></mstyle><mtext mathvariant=\"monospace\">,</mtext><mtext> </mtext><mstyle mathcolor=\"blue\"><mtext mathvariant=\"monospace\">x1</mtext></mstyle><mtext mathvariant=\"monospace\">,</mtext><mtext> </mtext><mtext mathvariant=\"monospace\">x3</mtext></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mrow><mtext mathvariant=\"monospace\">add</mtext><mtext> </mtext><mtext mathvariant=\"monospace\">x1,</mtext><mtext> </mtext><mstyle mathcolor=\"blue\"><mtext mathvariant=\"monospace\">x1</mtext></mstyle><mtext mathvariant=\"monospace\">,</mtext><mtext> </mtext><mtext mathvariant=\"monospace\">x4</mtext></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{aligned}\n&#x26;\\texttt{add {\\color{blue}x1}, x1, x2}\\\\\n&#x26;\\texttt{add {\\color{blue}x1}, {\\color{blue}x1}, x3}\\\\\n&#x26;\\texttt{add x1, {\\color{blue}x1}, x4}\n\\end{aligned}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:4.5em;vertical-align:-2em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.5em;\"><span style=\"top:-4.5em;\"><span class=\"pstrut\" style=\"height:2.84em;\"></span><span class=\"mord\"></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:2.84em;\"></span><span class=\"mord\"></span></span><span style=\"top:-1.5em;\"><span class=\"pstrut\" style=\"height:2.84em;\"></span><span class=\"mord\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2em;\"><span></span></span></span></span></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.5em;\"><span style=\"top:-4.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mord text\"><span class=\"mord texttt\">add </span><span class=\"mord\"><span class=\"mord texttt\" style=\"color:blue;\">x1</span></span><span class=\"mord texttt\">, x1, x2</span></span></span></span><span style=\"top:-3.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mord text\"><span class=\"mord texttt\">add </span><span class=\"mord\"><span class=\"mord texttt\" style=\"color:blue;\">x1</span></span><span class=\"mord texttt\">, </span><span class=\"mord\"><span class=\"mord texttt\" style=\"color:blue;\">x1</span></span><span class=\"mord texttt\">, x3</span></span></span></span><span style=\"top:-1.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mord text\"><span class=\"mord texttt\">add x1, </span><span class=\"mord\"><span class=\"mord texttt\" style=\"color:blue;\">x1</span></span><span class=\"mord texttt\">, x4</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2em;\"><span></span></span></span></span></span></span></span></span></span></span></span></div>\n<p>在第三条语句执行到 EX 阶段时，同时存在与第一条指令的 MEM Hazard 和与第二条指令的 EX Hazard，我们需要使用最新的（most recent）结果。即，在这两者同时存在时，应处理 EX Hazard 的 forwarding；也就是说，进行对 MEM Hazard 的 forwarding 当且仅当不能进行对 EX Hazard 的 forwarding 时。</p>\n<p>最后得到的判断条件如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// EX hazard</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>EX<span class=\"token operator\">/</span>MEM<span class=\"token punctuation\">.</span>RegWrite <span class=\"token function\">and</span> <span class=\"token punctuation\">(</span>EX<span class=\"token operator\">/</span>MEM<span class=\"token punctuation\">.</span>RegisterRd <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">and</span> <span class=\"token punctuation\">(</span>EX<span class=\"token operator\">/</span>MEM<span class=\"token punctuation\">.</span>RegisterRd <span class=\"token operator\">==</span> ID<span class=\"token operator\">/</span>EX<span class=\"token punctuation\">.</span>RegisterRs1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        ForwardA <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>EX<span class=\"token operator\">/</span>MEM<span class=\"token punctuation\">.</span>RegWrite <span class=\"token function\">and</span> <span class=\"token punctuation\">(</span>EX<span class=\"token operator\">/</span>MEM<span class=\"token punctuation\">.</span>RegisterRd <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">and</span> <span class=\"token punctuation\">(</span>EX<span class=\"token operator\">/</span>MEM<span class=\"token punctuation\">.</span>RegisterRd <span class=\"token operator\">==</span> ID<span class=\"token operator\">/</span>EX<span class=\"token punctuation\">.</span>RegisterRs2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        ForwardB <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n\n<span class=\"token comment\">// MEM hazard</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>MEM<span class=\"token operator\">/</span>WB<span class=\"token punctuation\">.</span>RegWrite <span class=\"token function\">and</span> <span class=\"token punctuation\">(</span>MEM<span class=\"token operator\">/</span>WB<span class=\"token punctuation\">.</span>RegisterRd <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">and</span> <span class=\"token function\">not</span><span class=\"token punctuation\">(</span>EX<span class=\"token operator\">/</span>MEM<span class=\"token punctuation\">.</span>RegWrite <span class=\"token function\">and</span> <span class=\"token punctuation\">(</span>EX<span class=\"token operator\">/</span>MEM<span class=\"token punctuation\">.</span>RegisterRd <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">and</span> <span class=\"token punctuation\">(</span>EX<span class=\"token operator\">/</span>MEM<span class=\"token punctuation\">.</span>RegisterRd <span class=\"token operator\">==</span> ID<span class=\"token operator\">/</span>EX<span class=\"token punctuation\">.</span>RegisterRs1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">and</span> <span class=\"token punctuation\">(</span>MEM<span class=\"token operator\">/</span>WB<span class=\"token punctuation\">.</span>RegisterRd <span class=\"token operator\">==</span> ID<span class=\"token operator\">/</span>EX<span class=\"token punctuation\">.</span>RegisterRs1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        ForwardA <span class=\"token operator\">=</span> <span class=\"token number\">01</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>MEM<span class=\"token operator\">/</span>WB<span class=\"token punctuation\">.</span>RegWrite <span class=\"token function\">and</span> <span class=\"token punctuation\">(</span>MEM<span class=\"token operator\">/</span>WB<span class=\"token punctuation\">.</span>RegisterRd <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">and</span> <span class=\"token function\">not</span><span class=\"token punctuation\">(</span>EX<span class=\"token operator\">/</span>MEM<span class=\"token punctuation\">.</span>RegWrite <span class=\"token function\">and</span> <span class=\"token punctuation\">(</span>EX<span class=\"token operator\">/</span>MEM<span class=\"token punctuation\">.</span>RegisterRd <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">and</span> <span class=\"token punctuation\">(</span>EX<span class=\"token operator\">/</span>MEM<span class=\"token punctuation\">.</span>RegisterRd <span class=\"token operator\">==</span> ID<span class=\"token operator\">/</span>EX<span class=\"token punctuation\">.</span>RegisterRs2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">and</span> <span class=\"token punctuation\">(</span>MEM<span class=\"token operator\">/</span>WB<span class=\"token punctuation\">.</span>RegisterRd <span class=\"token operator\">==</span> ID<span class=\"token operator\">/</span>EX<span class=\"token punctuation\">.</span>RegisterRs2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        ForwardB <span class=\"token operator\">=</span> <span class=\"token number\">01</span></code></pre></div>\n<p><img src=\"https://img.memset0.cn/2024/11/04/A1p7bxI7.png\"alt=\"\" style=\"width: 591px; \" ></p>\n<p>加入 forwarding 后得到的数据通路如下：</p>\n<p><img src=\"https://img.memset0.cn/2024/11/04/jtKJEetu.png\"alt=\"\" style=\"width: 692px; \" ></p>\n<h4 id=\"anchor-e8789f0106fc6ef9\" style=\"position: relative;\"><a href=\"#anchor-e8789f0106fc6ef9\" aria-label=\"anchor e8789f0106fc6ef9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3.2. Load-Use Hazards Detection</h4>\n<p><img src=\"https://img.memset0.cn/2024/11/04/ubBcnr9y.png\"alt=\"\" style=\"width: 585px; \" ></p>\n<p>考察这个例子，当前指令用到了上一条 load 指令读取出的数据。这种情况被称为 <strong>载入-使用型数据冒险(Load-Use Data Hazard)</strong>。即使使用了 forwarding 的技术，也必须插入一个 bubble——因为我们要到 MEM 阶段才能得到结果（而不是 EX 阶段）并 forwarding 给下一个 EX。因此，我们不光需要控制 forwarding，还需要控制 stall 一个周期。</p>\n<p><details  class=\"callout callout-type-example\"><summary> 考虑数据冒险的场景下计算时钟周期数</summary><div class=\"callout-content\"><p></p><p>如果不考虑数据冒险的问题，只需要 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>7</mn><mo>+</mo><mo stretchy=\"false\">(</mo><mn>5</mn><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>11</mn></mrow><annotation encoding=\"application/x-tex\">7+(5-1)=11</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">7</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">11</span></span></span></span></span> 个时钟周期，这里 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span></span> 是因为我们的 RISC-V 架构是五级流水线。但是因为数据冒险的问题，我们必须要 stall 两个周期。可以通过打乱指令顺序的方式，在指令结果相同的情况下，规避掉 Load-Use Data Hazrad 必须 stall 一个周期的问题。</p><p><img src=\"https://img.memset0.cn/2024/11/04/msWVpgrK.png\"alt=\"\" style=\"width: 600px; \" ></p></div></details></p>\n<p>通过以下条件判断是否存在 load-use hazard，如果确实存在，则插入一个 bubble。为什么考察的是 ID/EX.RegisterRd？因为在检测 load-use hazard 时，对应的目标寄存器编号刚好传递到这一阶段。</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right left\" columnspacing=\"0em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mtext>ID/EX.MemRead </mtext><mi mathvariant=\"normal\">&#x26;</mi><mi mathvariant=\"normal\">&#x26;</mi><mtext> </mtext><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mtext>ID/EX.RegisterRd</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mtext>IF/ID.RegisterRs1</mtext><mo stretchy=\"false\">)</mo><mtext> </mtext><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">∣</mi><mtext> </mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mtext> </mtext><mo stretchy=\"false\">(</mo><mtext>ID/EX.RegisterRd</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mtext>IF/ID.RegisterRs2</mtext><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{aligned}\n\\text{ID/EX.MemRead}\\ \\&#x26;\\&#x26;\\ ((\\text{ID/EX.RegisterRd} &#x26;= \\text{IF/ID.RegisterRs1})\\ ||\\ \\\\\\\n(\\text{ID/EX.RegisterRd} &#x26;= \\text{IF/ID.RegisterRs2}))\n\\end{aligned}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.75em;\"><span style=\"top:-3.91em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">ID/EX.MemRead</span></span><span class=\"mspace\"> </span><span class=\"mord\">&#x26;&#x26;</span><span class=\"mspace\"> </span><span class=\"mopen\">((</span><span class=\"mord text\"><span class=\"mord\">ID/EX.RegisterRd</span></span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mspace\"> </span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">ID/EX.RegisterRd</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.25em;\"><span></span></span></span></span></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.75em;\"><span style=\"top:-3.91em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord text\"><span class=\"mord\">IF/ID.RegisterRs1</span></span><span class=\"mclose\">)</span><span class=\"mspace\"> </span><span class=\"mord\">∣∣</span><span class=\"mspace\"> </span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord text\"><span class=\"mord\">IF/ID.RegisterRs2</span></span><span class=\"mclose\">))</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.25em;\"><span></span></span></span></span></span></span></span></span></span></span></span></div>\n<p>通过将指令转变为 <code class=\"language-text\">nop</code> 的方式实现 stall，从而将这一指令的剩余阶段转化为 bubble（可以看做是将其包裹起来，不让其产生影响），具体可以参见实验课的课件。</p>\n<h4 id=\"anchor-c0459b290afb8ca8\" style=\"position: relative;\"><a href=\"#anchor-c0459b290afb8ca8\" aria-label=\"anchor c0459b290afb8ca8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3.3. Code Scheduling to Avoid Stalls</h4>\n<p>前面提到了遇到 load-use hazards 时即使实现了 forwarding 也必须插入一个 stall，这显然是我们不乐意见到的，一种方法是进行 <strong>指令重排(code scheduling)</strong>：在不改变指令执行结果的情况下调整指令顺序，从而避免发生 load-use hazards。</p>\n<p><img src=\"https://img.memset0.cn/2025/01/16/juukFftc.png\"alt=\"\" style=\"width: 487px; \" ></p>\n<h3 id=\"anchor-bc0b2fc5a1631fd9\" style=\"position: relative;\"><a href=\"#anchor-bc0b2fc5a1631fd9\" aria-label=\"anchor bc0b2fc5a1631fd9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.4. Control Hazards</h3>\n<p><strong>控制冒险(control hazard)</strong>：在有分支语句时，下一条执行的指令是什么必须依赖于上一条指令的计算结果。也因此，控制冒险也被叫做 <strong>分支冒险(branch hazard)</strong>。</p>\n<p><img src=\"https://img.memset0.cn/2024/11/04/lcqgxCgf.png\"alt=\"\" style=\"width: 574px; \" ></p>\n<p>解决 control hazard 的方法是使用 <strong>分支预测(branch prediction)</strong>，即提前预读一条指令过来处理的。当然预测可能有错误的时候，这时则需要把错误指令带来的影响 flush 掉，此时必须 stall 并重新获取正确的指令。</p>\n<p><strong>静态的(static)</strong> 分支预测方法比如基于典型分支行为（循环大概率会跳回去接着循环）；<strong>动态的(dynamic)</strong> 分支预测方法比如通过硬件测量实际分支行为（记录跳转指令是否跳转的次数），这一部分将在《计算机体系结构》课程中进一步讨论。</p>\n<p><details open disabled class=\"callout callout-type-question\"><summary> 发生 control hazards 时需要插入几个 bubble？</summary><div class=\"callout-content\"><p></p><p>类似于对 data hazards 的处理，发生 control hazards 时需要插入几个 stall 和控制语句的跳转在哪个阶段决定是有关的。观察下面课本给出的 datapath 可以发现，默认认为对 branch 的决策（即决定是否需要跳转）是在 MEM 阶段处理的。这种时候，一般认为需要添加 stall 使得下一条指令的 IF 阶段在这条指令的 MEM 阶段之后进行，即需要插入 3 个 bubble。</p><p>但容易发现，我们其实可以更早地知道跳转结果，比如在 EX 阶段，我们根据 ALU 的 Zero 输出就已经知道是否需要跳转。甚至，我们可以通过添加一个 ALU 的方式将这一判断提前到 ID 阶段进行。相关的内容在书上有专门的一小节作介绍，感兴趣的读者可以自行阅读。所以严谨的题目应该给出跳转发生的阶段，我们据此才能推定需要插入的 bubble 数。</p></div></details></p>\n<h3 id=\"anchor-d2318c5691a7768a\" style=\"position: relative;\"><a href=\"#anchor-d2318c5691a7768a\" aria-label=\"anchor d2318c5691a7768a permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.5. Pipelined Datapath &#x26; Control</h3>\n<p>控制信号在 ID 阶段全部译出，随后逐级传递下去。当一个信号在之后不再用到时就不需要传递了。</p>\n<p><img src=\"https://img.memset0.cn/2024/11/04/NIrsoPGm.png\"alt=\"\" style=\"width: 850px; \" ></p>\n<h2 id=\"anchor-b55e4a85f99e3192\" style=\"position: relative;\"><a href=\"#anchor-b55e4a85f99e3192\" aria-label=\"anchor b55e4a85f99e3192 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 参考资料</h2>\n<ul>\n<li><a href=\"https://xuan-insr.github.io/computer_organization/4_processor/\">4 Processor - 咸鱼暄的代码空间 (xuan-insr.github.io)</a></li>\n<li><a href=\"https://note.noughtq.top/system/co/4\">Chap 4: The Processor - NoughtQ 的笔记本</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#anchor-6483207c57cba8be\">1. Single-Cycle CPU</a></p>\n<ul>\n<li><a href=\"#anchor-fcea50e2c37fbe57\">1.1. Prelude</a></li>\n<li><a href=\"#anchor-533991c855bc7ed8\">1.2. Instruction Execution Overview</a></li>\n<li><a href=\"#anchor-61011d4dba32dd0a\">1.3. Imm Gen</a></li>\n<li><a href=\"#anchor-1860493445f763d5\">1.4. Datapath</a></li>\n<li><a href=\"#anchor-7c0440f182b38ee6\">1.5. Control Unit</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-80d23ed1e2de61c1\">2. Pipeline CPU</a></p>\n<ul>\n<li><a href=\"#anchor-20cd1d6db04866cf\">2.1. Pipelined Datapath</a></li>\n<li><a href=\"#anchor-0c48a194ea859ea9\">2.2. Structure Hazards</a></li>\n<li><a href=\"#anchor-f7639322b0addd72\">2.3. Data Hazards</a></li>\n<li><a href=\"#anchor-bc0b2fc5a1631fd9\">2.4. Control Hazards</a></li>\n<li><a href=\"#anchor-d2318c5691a7768a\">2.5. Pipelined Datapath &#x26; Control</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-b55e4a85f99e3192\">3. 参考资料</a></p>\n</li>\n</ul>","frontmatter":{"title":"IV. Processor","date":"2024 年 11 月 23 日","description":null},"fields":{"cover":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#081838","images":{"fallback":{"src":"/static/cef4dea1262b0cab93ff6fa4f42bb946/62413/edu7F13u.png","srcSet":"/static/cef4dea1262b0cab93ff6fa4f42bb946/f054f/edu7F13u.png 271w,\n/static/cef4dea1262b0cab93ff6fa4f42bb946/6288d/edu7F13u.png 541w,\n/static/cef4dea1262b0cab93ff6fa4f42bb946/62413/edu7F13u.png 1082w","sizes":"(min-width: 1082px) 1082px, 100vw"},"sources":[{"srcSet":"/static/cef4dea1262b0cab93ff6fa4f42bb946/4248e/edu7F13u.webp 271w,\n/static/cef4dea1262b0cab93ff6fa4f42bb946/23069/edu7F13u.webp 541w,\n/static/cef4dea1262b0cab93ff6fa4f42bb946/9d5bc/edu7F13u.webp 1082w","type":"image/webp","sizes":"(min-width: 1082px) 1082px, 100vw"}]},"width":1082,"height":862}}},"slug":"/course/co/note/4/","cssclasses":null,"isDoc":true,"category":"[{\"name\":\"课程笔记\",\"to\":\"/course/\"}]","propsJson":null}},"previous":{"fields":{"slug":"/course/co/note/3/"},"frontmatter":{"title":"III. Instructions"}},"next":{"fields":{"slug":"/course/ptms/note/4/"},"frontmatter":{"title":"IV. 随机变量的数字特征"}}},"pageContext":{"id":"04a4dfb8-7594-5d94-8e09-a5f2e8b182e3","previousPostId":"de10309d-7f7d-5a0f-a800-67d0afe764f6","nextPostId":"87c03518-cfc4-5365-b91d-a764ab939834","navJson":"[{\"slug\":\"/course/co\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/index.md\",\"title\":\"Intro\"},{\"title\":\"Note\",\"children\":[{\"slug\":\"/course/co/note/1\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/note/1.md\",\"title\":\"I. Prelude\"},{\"slug\":\"/course/co/note/2\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/note/2.md\",\"title\":\"II. Arithmetic\"},{\"slug\":\"/course/co/note/3\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/note/3.md\",\"title\":\"III. Instructions\"},{\"slug\":\"/course/co/note/4\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/note/4.md\",\"title\":\"IV. Processor\"},{\"slug\":\"/course/co/note/5\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/note/5.md\",\"title\":\"V. Memory\"}]}]"}},"staticQueryHashes":[],"slicesMap":{}}