{"componentChunkName":"component---src-templates-post-js","path":"/course/co/note/4/","result":{"data":{"site":{"siteMetadata":{"title":"mem 的小站"}},"post":{"id":"04a4dfb8-7594-5d94-8e09-a5f2e8b182e3","excerpt":"本篇笔记介绍了处理器的基本架构和实现方式。首先讲解了单周期 CPU 的设计，包括指令执行的五个阶段（IF、ID、EX、MEM、WB）、数据通路和控制信号的设计。随后详细讨论了流水线 CPU 的实现，重点阐述了三种冒险（hazard）：结构冒险、数据冒险和控制冒险，以及相应的解决方案，如前递（forwarding）技术和分支预测。通过对比单周期和流水线两种实现方式，深入理解了处理器的工作原理和性能优化方法。（由 claude-3.5-sonnet 生成摘要）","html":"<blockquote>\n<p>本篇笔记介绍了处理器的基本架构和实现方式。首先讲解了单周期 CPU 的设计，包括指令执行的五个阶段（IF、ID、EX、MEM、WB）、数据通路和控制信号的设计。随后详细讨论了流水线 CPU 的实现，重点阐述了三种冒险（hazard）：结构冒险、数据冒险和控制冒险，以及相应的解决方案，如前递（forwarding）技术和分支预测。通过对比单周期和流水线两种实现方式，深入理解了处理器的工作原理和性能优化方法。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small></p>\n</blockquote>\n<!-- more -->\n<h2 id=\"anchor-6483207c57cba8be\" style=\"position: relative;\"><a href=\"#anchor-6483207c57cba8be\" aria-label=\"anchor 6483207c57cba8be permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Single-Cycle CPU</h2>\n<h3 id=\"anchor-fcea50e2c37fbe57\" style=\"position: relative;\"><a href=\"#anchor-fcea50e2c37fbe57\" aria-label=\"anchor fcea50e2c37fbe57 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. Prelude</h3>\n<ul>\n<li>\n<p>单周期 CPU：每条指令都在一个时钟周期内完成，故 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>CPI</mtext><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\text{CPI}=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">CPI</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>。时钟周期的长度取决于花费时间最长的指令。</p>\n</li>\n<li>\n<p>内存应该被分成 <strong>指令内存(instruction memory)</strong> 和 <strong>数据内存(data memory)</strong> 两个部分，分开控制读写。因为我们是单周期处理器，无法在一个周期内既读指令又读数据。这在后面流水线的时候同样需要，因为对 data memory 的访问和从 instruction memory 取出指令这两个阶段可能需要同时进行。</p>\n</li>\n</ul>\n<p><img src=\"https://img.memset0.cn/2024/11/16/8m8KK7Ar.png\"alt=\"\" style=\"width: 515px; \" ></p>\n<ul>\n<li>不能简单地把线连在一起，需要用 MUX 实现选择功能。——控制信号</li>\n</ul>\n<h3 id=\"anchor-533991c855bc7ed8\" style=\"position: relative;\"><a href=\"#anchor-533991c855bc7ed8\" aria-label=\"anchor 533991c855bc7ed8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. Instruction Execution Overview</h3>\n<ul>\n<li><strong>取址(Instruction Fetch, IF)</strong>：根据 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC</span></span></span></span></span></span> 所给地址，从存储器中取出指令。<br>\n<img src=\"https://img.memset0.cn/2024/11/16/amfocLym.png\"alt=\"\" style=\"width: 524px; \" ></li>\n<li><strong>译码(Instruction Decode, ID)</strong>：分析指令字段，从寄存器堆中读取一个或两个寄存器的值。</li>\n<li><strong>执行(Execute, EX)</strong>：实验中需要实现的指令只需要用到 ALU。\n<ul>\n<li>对于 R 型指令：ALU 执行相应的算数逻辑运算，并输出结果；</li>\n<li>对于访存指令：ALU 计算基地址和立即数的和，得到数据的真正地址；</li>\n<li>对于分支指令：ALU 将两源操作数相减，根据结果是否为 0，判断两数是否相等。</li>\n</ul>\n</li>\n<li><strong>访存(Memory, MEM)</strong>：从数据内存中读或写数据，用于 load / store 指令中。（注意：不同于 x86 指令集架构，Risc-V 指令集中没有一条指令既从内存中读数据有对读出来的数据进行操作。）</li>\n<li><strong>写回(Write Back, WB)</strong>：将结果写回寄存器堆中。</li>\n</ul>\n<p>除了前两个阶段是所有指令相同的，其他阶段根据具体指令而定，部分指令就不需要 MEM 或 WB 阶段。</p>\n<h3 id=\"anchor-61011d4dba32dd0a\" style=\"position: relative;\"><a href=\"#anchor-61011d4dba32dd0a\" aria-label=\"anchor 61011d4dba32dd0a permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3. Imm Gen</h3>\n<p>Imm Gen 是 ID 阶段中的一个模块，用于将指令中的立即数进行 <mark class=\"m-mark\">符号拓展</mark> 到 32 位或 64 位以进行后续运算。</p>\n<ul>\n<li>branch 指令的立即数需要补 0（Shift left 1 部分），这是因为 branch 指令的立即数最低位的 0 是省略的，需要补上。</li>\n</ul>\n<h3 id=\"anchor-1860493445f763d5\" style=\"position: relative;\"><a href=\"#anchor-1860493445f763d5\" aria-label=\"anchor 1860493445f763d5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.4. Datapath</h3>\n<p><img src=\"https://img.memset0.cn/2024/11/16/nfSQAg0L.png\"alt=\"\" style=\"width: 644px; \" ></p>\n<p><img src=\"https://img.memset0.cn/2024/11/16/w8O0EH27.png\"alt=\"\" style=\"width: 625px; \" ></p>\n<h3 id=\"anchor-8a6543c82188b4c0\" style=\"position: relative;\"><a href=\"#anchor-8a6543c82188b4c0\" aria-label=\"anchor 8a6543c82188b4c0 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.5. Control</h3>\n<p>通过不同的 <strong>控制信号(control signal)</strong> 控制多个 MUX，可以让在同一条数据通路上实现不同功能的指令。</p>\n<table>\n<thead>\n<tr>\n<th><strong>Signal name</strong></th>\n<th><strong>Effect When deasserted (=0)</strong></th>\n<th><strong>Effect when asserted (=1)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RegWrite</td>\n<td>-</td>\n<td>寄存器写入：将寄存器组 Write data 的输入写入到 Write register (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">rd</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{rd}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">rd</span></span></span></span></span></span>) 中</td>\n</tr>\n<tr>\n<td>ALUSrc</td>\n<td>ALU 的第二个操作数从寄存器第二个输出（Read data 2）中来</td>\n<td>ALU 的第二个操作数从符号拓展后的立即数（Imm Gen 生成）</td>\n</tr>\n<tr>\n<td>PCSrc (Branch)</td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC</span></span></span></span></span></span> 的下一个值是 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC+4</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC+4}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC+4</span></span></span></span></span></span></td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC</span></span></span></span></span></span> 的下一个值为分治语句的运算结果</td>\n</tr>\n<tr>\n<td>Jump</td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC</span></span></span></span></span></span> 的下一个值是 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC+4</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC+4}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC+4</span></span></span></span></span></span></td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC</span></span></span></span></span></span> 的下一个值为计算出来的跳跃地址</td>\n</tr>\n<tr>\n<td>MemRead</td>\n<td>-</td>\n<td>数据会从数据内存的 Read data 输出，然后交由 MemtoReg 所控制的 MUX</td>\n</tr>\n<tr>\n<td>MemWrite</td>\n<td>-</td>\n<td>在数据内存 Write data 输入的数据会被写入 address 输入对应的内存</td>\n</tr>\n<tr>\n<td>MemtoReg<br><mark class=\"m-mark\">(2 位)</mark><br><br></td>\n<td>00：ALU 的计算结果会被交给寄存器堆的 Write data 输入（R 型、I 型）</td>\n<td>01：交给寄存器堆的数据为从数据内存中的 Write data 输出（load 指令）<br>10：交给内存器堆的数据为 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">PC+4</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{PC+4}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">PC+4</span></span></span></span></span></span>（<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">jal</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{jal}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.2222em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">jal</span></span></span></span></span></span>、<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">jalr</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{jalr}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.2222em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">jalr</span></span></span></span></span></span> 指令）<mark class=\"m-mark\">？</mark><br></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"anchor-6e5d63a355275748\" style=\"position: relative;\"><a href=\"#anchor-6e5d63a355275748\" aria-label=\"anchor 6e5d63a355275748 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.5.1. ALU Control</h4>\n<p>多种指令中需要用到 ALU。我们可以进行 <strong>二级解码(2-level decode)</strong>。在一级译码后，我们得到 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>+</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">4+3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span> 个控制信号，和 2 位的 <code class=\"language-text\">ALU_op</code>。</p>\n<p><img src=\"https://img.memset0.cn/2024/11/16/xeXC6k5s.png\"alt=\"\" style=\"width: 438px; \" ></p>\n<p><img src=\"https://img.memset0.cn/2024/11/16/EAWXD06S.png\"alt=\"\" style=\"width: 665px; \" ></p>\n<p>在二级译码时，我们通过上一级的 <code class=\"language-text\">ALU_op</code> 和指令中的 <code class=\"language-text\">func7</code>、<code class=\"language-text\">func3</code> 共同决定 ALU 所需操作。</p>\n<p><img src=\"https://img.memset0.cn/2024/11/16/swLHYXUw.png\"alt=\"\" style=\"width: 670px; \" ></p>\n<p>二级译码的方式不是唯一的，这里主要起到一个抛砖引玉的作用。</p>\n<p><details open disabled class=\"callout callout-type-example\"><summary> Example: 粗略估计周期时间</summary><div class=\"callout-content\"><p>\nCalculate cycle time assuming negligible delays except:</p><ul>\n<li>memory (200ps), ALU and adders (200ps), register file access (100ps)</li>\n</ul><p><details  class=\"callout callout-type-quote\"><summary> Answer</summary><div class=\"callout-content\"><p></p><p><img src=\"https://img.memset0.cn/2024/11/16/NwWf9hns.png\"alt=\"\" style=\"width: 558px; \" ></p></div></details></p></div></details></p>\n<h2 id=\"anchor-80d23ed1e2de61c1\" style=\"position: relative;\"><a href=\"#anchor-80d23ed1e2de61c1\" aria-label=\"anchor 80d23ed1e2de61c1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Pipeline CPU</h2>\n<p>我们以小学就学过的洗衣服为例：</p>\n<p><img src=\"https://img.memset0.cn/2024/11/04/gXlLw0vr.png\"alt=\"\" style=\"width: 425px; \" ></p>\n<p>流水线技术并没有减少所有工作的总时间，甚至单个工作的时间还会增加，但是我们可以让多个工作的不同阶段并行执行，从而提升指令的 <strong>吞吐率(throughput)</strong>，从而减少了完成所有工作的时间。</p>\n<ul>\n<li>流水线的平衡性：指不同阶段的操作所需要的时间是否一致。可以通过对指令阶段的适当划分让流水线更为平衡。</li>\n<li>流水线的级数（深度）：流水线的级数并不是越大越好，因为流水线寄存器会有一个固定延迟。</li>\n</ul>\n<p>所以说，流水线的级数是一个 trade-off 的设计。</p>\n<p>对于一条 RISC-V 指令来说，一般可以分为五个阶段（被称为五级流水线）：</p>\n<ol>\n<li><strong>IF, Inst Fetch</strong>：从内存中获取指令 Instruction fetch from memory</li>\n<li><strong>ID, Inst Decode</strong>：读取寄存器、指令译码 Instruction decode &#x26; register read</li>\n<li><strong>EX, Execute</strong>：计算操作结果和/或地址 Execute operation or calculate address</li>\n<li><strong>MEM, Memory</strong>：内存读取或存储（如果需要的话） Access memory operand</li>\n<li><strong>WB, Write Back</strong>：将结果写回<mark class=\"m-mark\">寄存器</mark>（如果需要的话） Write result back to register</li>\n</ol>\n<p><details open disabled class=\"callout callout-type-note\"><summary> RISC-V 架构是为流水线设计的</summary><div class=\"callout-content\"><p></p><ul>\n<li>所有指令都是 32 位的。</li>\n<li>Few and regular instruction formats\n<ul>\n<li>源寄存器和目标寄存器的字段相同，可以在同一步进行译码和读寄存器的操作。</li>\n</ul>\n</li>\n<li>Load/store addressing\n<ul>\n<li>只在 EX 阶段计算地址，只在 MEM 阶段访问内存。</li>\n</ul>\n</li>\n</ul></div></details></p>\n<p>对于流水线 CPU，<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>CPI</mtext><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\text{CPI} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">CPI</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>，因为在每个时钟周期中，我们将一条指令送入 IF 阶段；而在下面会讲到，因为 <strong>冒险(hazard)</strong> 的问题，我们有时必须要插入一些 bubble。</p>\n<h3 id=\"anchor-20cd1d6db04866cf\" style=\"position: relative;\"><a href=\"#anchor-20cd1d6db04866cf\" aria-label=\"anchor 20cd1d6db04866cf permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. Pipelined Datapath</h3>\n<ul>\n<li><strong>单时钟周期流水线图(single-clock-cycle pipeline diagram)</strong>: Shows pipeline usage in a single cycle; Highlight resources used</li>\n<li><strong>多时钟周期流水线图(multi-clock-cycle diagram)</strong>: Graph of operation over time</li>\n</ul>\n<p><img src=\"https://img.memset0.cn/2024/11/04/MN5uM6ID.png\"alt=\"\" style=\"width: 766px; \" ></p>\n<ul>\n<li>从右到左的流容易导致 <strong>冒险(hazard)</strong>，也就是这里标出的 WB 和 Branch 部分。</li>\n</ul>\n<h3 id=\"anchor-0d192d43d4cb195a\" style=\"position: relative;\"><a href=\"#anchor-0d192d43d4cb195a\" aria-label=\"anchor 0d192d43d4cb195a permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. Structure Hazard</h3>\n<p><strong>结构冒险(structure hazard)</strong>：需要的资源正忙。</p>\n<p>我们必须将内存拆分为指令内存和数据内存两个部分，不然在同一时刻，分别处于 IF 和 MEM 阶段的两条指令需要对内存进行操作，只能被迫暂停其中一条。（或者划分出不同的指令/数据缓存）</p>\n<h3 id=\"anchor-395f5f6c6f007955\" style=\"position: relative;\"><a href=\"#anchor-395f5f6c6f007955\" aria-label=\"anchor 395f5f6c6f007955 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. Data Hazard</h3>\n<p><strong>数据冒险(data hazard)</strong>：一条指令依赖上一条指令所需的数据。</p>\n<h4 id=\"anchor-c4fc5dd51459442d\" style=\"position: relative;\"><a href=\"#anchor-c4fc5dd51459442d\" aria-label=\"anchor c4fc5dd51459442d permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3.1. Forwarding</h4>\n<p><img src=\"https://img.memset0.cn/2024/11/04/RK45A20K.png\"alt=\"\" style=\"width: 607px; \" ></p>\n<p>考察这个例子，第二条指令的源寄存器是上一条指令的目标寄存器 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">x1</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{x1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">x1</span></span></span></span></span></span>，我们可以提前把数据取出来给到第二条指令，也就是蓝色的这条通路，这种技术被称为 <strong>前递(forwarding)</strong> 或 <strong>旁传(bypassing)</strong>。如果不这样做，则需要等两个时钟周期，这样 EX 阶段得到的数据才是对的。</p>\n<p>通过以下条件实现对 data hazards 的判断从而提供 forwarding：</p>\n<p><img src=\"https://img.memset0.cn/2024/11/04/mDBaG3zn.png\"alt=\"\" style=\"width: 460px; \" ></p>\n<ul>\n<li>这里是因为像 <code class=\"language-text\">add</code> 这种指令在 EX 阶段结束后就能得到结果，但是像 <code class=\"language-text\">load</code> 这种指令要到 MEM 阶段结束后才能得到。</li>\n<li>具体判断时，还要注意两个附加条件：\n<ul>\n<li>对应的 EX/MEM.RegWrite 信号或 MEM/WB.RegWrite 信号为真，即真的写入了那个目标寄存器。</li>\n<li>对应的 EX/MEM.RegisterRd 目标寄存器或 MEM/WB.RegisterRd 目标寄存器不为 <code class=\"language-text\">x0</code>。</li>\n</ul>\n</li>\n</ul>\n<p>我们使用 MUX 来实现对 forwarding 的数据通路控制。在哪个阶段可以得到结果的数据，就从那个阶段直接 forwarding 过来。</p>\n<p><img src=\"https://img.memset0.cn/2024/11/04/er4z1aL3.png\"alt=\"\" style=\"width: 491px; \" ></p>\n<p><img src=\"https://img.memset0.cn/2024/11/04/A1p7bxI7.png\"alt=\"\" style=\"width: 573px; \" ></p>\n<p>还需要注意 double data hazard 的问题，考虑以下示例：</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right left\" columnspacing=\"0em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mrow><mtext mathvariant=\"monospace\">add</mtext><mtext> </mtext><mstyle mathcolor=\"blue\"><mtext mathvariant=\"monospace\">x1</mtext></mstyle><mtext mathvariant=\"monospace\">,</mtext><mtext> </mtext><mtext mathvariant=\"monospace\">x1,</mtext><mtext> </mtext><mtext mathvariant=\"monospace\">x2</mtext></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mrow><mtext mathvariant=\"monospace\">add</mtext><mtext> </mtext><mstyle mathcolor=\"blue\"><mtext mathvariant=\"monospace\">x1</mtext></mstyle><mtext mathvariant=\"monospace\">,</mtext><mtext> </mtext><mstyle mathcolor=\"blue\"><mtext mathvariant=\"monospace\">x1</mtext></mstyle><mtext mathvariant=\"monospace\">,</mtext><mtext> </mtext><mtext mathvariant=\"monospace\">x3</mtext></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mrow><mtext mathvariant=\"monospace\">add</mtext><mtext> </mtext><mtext mathvariant=\"monospace\">x1,</mtext><mtext> </mtext><mstyle mathcolor=\"blue\"><mtext mathvariant=\"monospace\">x1</mtext></mstyle><mtext mathvariant=\"monospace\">,</mtext><mtext> </mtext><mtext mathvariant=\"monospace\">x4</mtext></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{aligned}\n&#x26;\\texttt{add {\\color{blue}x1}, x1, x2}\\\\\n&#x26;\\texttt{add {\\color{blue}x1}, {\\color{blue}x1}, x3}\\\\\n&#x26;\\texttt{add x1, {\\color{blue}x1}, x4}\n\\end{aligned}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:4.5em;vertical-align:-2em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.5em;\"><span style=\"top:-4.5em;\"><span class=\"pstrut\" style=\"height:2.84em;\"></span><span class=\"mord\"></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:2.84em;\"></span><span class=\"mord\"></span></span><span style=\"top:-1.5em;\"><span class=\"pstrut\" style=\"height:2.84em;\"></span><span class=\"mord\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2em;\"><span></span></span></span></span></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.5em;\"><span style=\"top:-4.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mord text\"><span class=\"mord texttt\">add </span><span class=\"mord\"><span class=\"mord texttt\" style=\"color:blue;\">x1</span></span><span class=\"mord texttt\">, x1, x2</span></span></span></span><span style=\"top:-3.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mord text\"><span class=\"mord texttt\">add </span><span class=\"mord\"><span class=\"mord texttt\" style=\"color:blue;\">x1</span></span><span class=\"mord texttt\">, </span><span class=\"mord\"><span class=\"mord texttt\" style=\"color:blue;\">x1</span></span><span class=\"mord texttt\">, x3</span></span></span></span><span style=\"top:-1.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mord text\"><span class=\"mord texttt\">add x1, </span><span class=\"mord\"><span class=\"mord texttt\" style=\"color:blue;\">x1</span></span><span class=\"mord texttt\">, x4</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2em;\"><span></span></span></span></span></span></span></span></span></span></span></span></div>\n<p>在第三条语句执行到 EX 阶段时，同时存在与第一条指令的 MEM Hazard 和与第二条指令的 EX Hazard，我们需要使用最新的（most recent）结果。即，在这两者同时存在时，应处理 EX Hazard 的 forwarding；也就是说，进行对 MEM Hazard 的 forwarding 当且仅当不能进行对 EX Hazard 的 forwarding 时。</p>\n<h4 id=\"anchor-c238429613dd400e\" style=\"position: relative;\"><a href=\"#anchor-c238429613dd400e\" aria-label=\"anchor c238429613dd400e permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3.2. Load-Use Hazard Detection</h4>\n<p><img src=\"https://img.memset0.cn/2024/11/04/ubBcnr9y.png\"alt=\"\" style=\"width: 585px; \" ></p>\n<p>再考察这个例子，上一条语句是 load 指令。这种情况被称为 <strong>载入-使用型数据冒险(Load-Use Data Hazard)</strong>。即使使用了 forwarding 的技术，也必须插入一个 bubble——因为我们要到 MEM 阶段才能得到结果而不是 EX 阶段才能把数据给下一个 EX。因此，我们不光需要控制 forwarding，还需要控制是否 stall 一个周期。</p>\n<p><details  class=\"callout callout-type-example\"><summary> 考虑数据冒险的场景下计算时钟周期数</summary><div class=\"callout-content\"><p></p><p>如果不考虑数据冒险的问题，只需要 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>7</mn><mo>+</mo><mo stretchy=\"false\">(</mo><mn>5</mn><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>11</mn></mrow><annotation encoding=\"application/x-tex\">7+(5-1)=11</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">7</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">5</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">11</span></span></span></span></span> 个时钟周期，这里 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">5</span></span></span></span></span> 是因为我们的 RISC-V 架构是五级流水线。但是因为数据冒险的问题，我们必须要 stall 两个周期。可以通过打乱指令顺序的方式，在指令结果相同的情况下，规避掉 Load-Use Data Hazrad 必须 stall 一个周期的问题。</p><p><img src=\"https://img.memset0.cn/2024/11/04/msWVpgrK.png\"alt=\"\" style=\"width: 600px; \" ></p></div></details></p>\n<p>通过以下条件判断是否存在 load-use hazard，如果确实存在，则插入一个 bubble。为什么考察的是 ID/EX.RegisterRd？因为在检测 load-use hazard 时，对应的目标寄存器编号刚好传递到这一阶段。</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right left\" columnspacing=\"0em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mtext>ID/EX.MemRead </mtext><mi mathvariant=\"normal\">&#x26;</mi><mi mathvariant=\"normal\">&#x26;</mi><mtext> </mtext><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mtext>ID/EX.RegisterRd</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mtext>IF/ID.RegisterRs1</mtext><mo stretchy=\"false\">)</mo><mtext> </mtext><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">∣</mi><mtext> </mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mtext> </mtext><mo stretchy=\"false\">(</mo><mtext>ID/EX.RegisterRd</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mtext>IF/ID.RegisterRs2</mtext><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{aligned}\n\\text{ID/EX.MemRead}\\ \\&#x26;\\&#x26;\\ ((\\text{ID/EX.RegisterRd} &#x26;= \\text{IF/ID.RegisterRs1})\\ ||\\ \\\\\\\n(\\text{ID/EX.RegisterRd} &#x26;= \\text{IF/ID.RegisterRs2}))\n\\end{aligned}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.75em;\"><span style=\"top:-3.91em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">ID/EX.MemRead</span></span><span class=\"mspace\"> </span><span class=\"mord\">&#x26;&#x26;</span><span class=\"mspace\"> </span><span class=\"mopen\">((</span><span class=\"mord text\"><span class=\"mord\">ID/EX.RegisterRd</span></span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mspace\"> </span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">ID/EX.RegisterRd</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.25em;\"><span></span></span></span></span></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.75em;\"><span style=\"top:-3.91em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord text\"><span class=\"mord\">IF/ID.RegisterRs1</span></span><span class=\"mclose\">)</span><span class=\"mspace\"> </span><span class=\"mord\">∣∣</span><span class=\"mspace\"> </span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord text\"><span class=\"mord\">IF/ID.RegisterRs2</span></span><span class=\"mclose\">))</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.25em;\"><span></span></span></span></span></span></span></span></span></span></span></span></div>\n<p>通过将指令转变为 <code class=\"language-text\">nop</code> 的方式实现 stall，从而将这一指令的剩余阶段转化为 bubble（可以看做是将其包裹起来，不让其产生影响）。</p>\n<p>最后得到的数据通路如下：</p>\n<p><img src=\"https://img.memset0.cn/2024/11/04/jtKJEetu.png\"alt=\"\" style=\"width: 692px; \" ></p>\n<h4 id=\"anchor-e38bfd5166931887\" style=\"position: relative;\"><a href=\"#anchor-e38bfd5166931887\" aria-label=\"anchor e38bfd5166931887 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3.3. Control Hazard</h4>\n<p><strong>控制冒险(control hazard)</strong>：在有分支语句时，下一条执行的指令是什么必须依赖于上一条指令的计算结果。也因此，控制冒险也被叫做 <strong>分支冒险(branch hazard)</strong>。</p>\n<p>一个想法是，像 <code class=\"language-text\">beq</code> 这种基于比较的跳转指令，提前在 ID 阶段就得到比较结果，这样只需要插入一条 bubble 即可，只拖慢了一个而不是三个时钟周期。</p>\n<p><img src=\"https://img.memset0.cn/2024/11/04/lcqgxCgf.png\"alt=\"\" style=\"width: 574px; \" ></p>\n<p>所以需要一个更爆炸的解决思路——<strong>分支预测(branch prediction)</strong>，即提前预读一条指令过来处理的。当然预测可能有错误的时候，这时则需要把错误指令带来的影响 flush 掉，且必须 stall 并 <strong>重新获取(re-fetch)</strong> 正确的指令。</p>\n<p><strong>静态的(static)</strong> 分支预测方法比如基于典型分支行为（循环大概率会跳回去接着循环）；<strong>动态的(dynamic)</strong> 分支预测方法比如通过硬件测量实际分支行为（记录跳转指令是否跳转的次数）。</p>\n<p><details open disabled class=\"callout callout-type-question\"><summary> 发生 control hazards 时需要插入几个 bubble？</summary><div class=\"callout-content\"><p></p><p>类似于对 data hazards 的处理，发生 control hazards 时需要插入几个 stall 和控制语句的跳转在哪个阶段决定是有关的。观察下面课本给出的 datapath 可以发现，默认认为对 branch 的决策（即决定是否需要跳转）是在 MEM 阶段处理的。这种时候，一般认为需要添加 stall 使得下一条指令的 IF 阶段在这条指令的 MEM 阶段之后进行，即需要插入 3 个 bubble。</p><p>但容易发现，我们其实可以更早地知道跳转结果，比如在 EX 阶段，我们根据 ALU 的 Zero 输出就已经知道是否需要跳转。甚至，我们可以通过添加一个 ALU 的方式将这一判断提前到 ID 阶段进行。相关的内容在书上有专门的一小节作介绍，感兴趣的读者可以自行阅读。所以严谨的题目应该给出跳转发生的阶段，我们据此才能推定需要插入的 bubble 数。</p></div></details></p>\n<h3 id=\"anchor-64cd20fe725e6a97\" style=\"position: relative;\"><a href=\"#anchor-64cd20fe725e6a97\" aria-label=\"anchor 64cd20fe725e6a97 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.4. Pipelined Datapath &#x26; Control</h3>\n<p>控制信号在 ID 阶段全部译出，随后逐级传递下去。当一个信号在之后不再用到时就不需要传递了。</p>\n<p><img src=\"https://img.memset0.cn/2024/11/04/NIrsoPGm.png\"alt=\"\" style=\"width: 850px; \" ></p>\n<h2 id=\"anchor-b55e4a85f99e3192\" style=\"position: relative;\"><a href=\"#anchor-b55e4a85f99e3192\" aria-label=\"anchor b55e4a85f99e3192 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 参考资料</h2>\n<ul>\n<li><a href=\"https://xuan-insr.github.io/computer_organization/4_processor/\">4 Processor - 咸鱼暄的代码空间 (xuan-insr.github.io)</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#anchor-6483207c57cba8be\">1. Single-Cycle CPU</a></p>\n<ul>\n<li><a href=\"#anchor-fcea50e2c37fbe57\">1.1. Prelude</a></li>\n<li><a href=\"#anchor-533991c855bc7ed8\">1.2. Instruction Execution Overview</a></li>\n<li><a href=\"#anchor-61011d4dba32dd0a\">1.3. Imm Gen</a></li>\n<li><a href=\"#anchor-1860493445f763d5\">1.4. Datapath</a></li>\n<li><a href=\"#anchor-8a6543c82188b4c0\">1.5. Control</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-80d23ed1e2de61c1\">2. Pipeline CPU</a></p>\n<ul>\n<li><a href=\"#anchor-20cd1d6db04866cf\">2.1. Pipelined Datapath</a></li>\n<li><a href=\"#anchor-0d192d43d4cb195a\">2.2. Structure Hazard</a></li>\n<li><a href=\"#anchor-395f5f6c6f007955\">2.3. Data Hazard</a></li>\n<li><a href=\"#anchor-64cd20fe725e6a97\">2.4. Pipelined Datapath &#x26; Control</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-b55e4a85f99e3192\">3. 参考资料</a></p>\n</li>\n</ul>","frontmatter":{"title":"IV. Processor","date":"2024 年 11 月 23 日","description":null},"fields":{"cover":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#081838","images":{"fallback":{"src":"/static/cef4dea1262b0cab93ff6fa4f42bb946/62413/edu7F13u.png","srcSet":"/static/cef4dea1262b0cab93ff6fa4f42bb946/f054f/edu7F13u.png 271w,\n/static/cef4dea1262b0cab93ff6fa4f42bb946/6288d/edu7F13u.png 541w,\n/static/cef4dea1262b0cab93ff6fa4f42bb946/62413/edu7F13u.png 1082w","sizes":"(min-width: 1082px) 1082px, 100vw"},"sources":[{"srcSet":"/static/cef4dea1262b0cab93ff6fa4f42bb946/4248e/edu7F13u.webp 271w,\n/static/cef4dea1262b0cab93ff6fa4f42bb946/23069/edu7F13u.webp 541w,\n/static/cef4dea1262b0cab93ff6fa4f42bb946/9d5bc/edu7F13u.webp 1082w","type":"image/webp","sizes":"(min-width: 1082px) 1082px, 100vw"}]},"width":1082,"height":862}}},"slug":"/course/co/note/4/","cssclasses":null,"isDoc":true,"category":"[{\"name\":\"课程笔记\",\"to\":\"/course/\"}]","propsJson":null}},"previous":{"fields":{"slug":"/course/co/note/3/"},"frontmatter":{"title":"III. Instructions"}},"next":{"fields":{"slug":"/course/ptms/note/4/"},"frontmatter":{"title":"IV. 随机变量的数字特征"}}},"pageContext":{"id":"04a4dfb8-7594-5d94-8e09-a5f2e8b182e3","previousPostId":"de10309d-7f7d-5a0f-a800-67d0afe764f6","nextPostId":"87c03518-cfc4-5365-b91d-a764ab939834","navJson":"[{\"slug\":\"/course/co\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/index.md\",\"title\":\"Intro\"},{\"title\":\"Note\",\"children\":[{\"slug\":\"/course/co/note/1\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/note/1.md\",\"title\":\"I. Prelude\"},{\"slug\":\"/course/co/note/2\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/note/2.md\",\"title\":\"II. Arithmetic\"},{\"slug\":\"/course/co/note/3\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/note/3.md\",\"title\":\"III. Instructions\"},{\"slug\":\"/course/co/note/4\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/note/4.md\",\"title\":\"IV. Processor\"}]}]"}},"staticQueryHashes":[],"slicesMap":{}}