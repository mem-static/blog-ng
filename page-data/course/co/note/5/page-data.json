{"componentChunkName":"component---src-templates-post-js","path":"/course/co/note/5/","result":{"data":{"site":{"siteMetadata":{"title":"mem 的小站"}},"post":{"id":"51807d27-808f-5640-a002-efe438a563d9","excerpt":"本篇笔记介绍了计算机系统中的内存层次结构及其关键技术。首先讨论了 SRAM 和 DRAM 两种基本的内存技术，并引入内存层次的概念。随后详细阐述了 Cache 的工作原理，包括直接映射、全相连和组相连三种映射策略，以及处理 Cache 命中与缺失的各种策略。最后介绍了虚拟内存技术，重点讨论了页表的概念和 TLB 的应用，以及它们在地址转换过程中的作用。通过这些技术的结合，计算机系统得以在保证性能的同时有效管理内存资源。（由 claude-3.5-sonnet 生成摘要）","html":"<blockquote>\n<p>本篇笔记介绍了计算机系统中的内存层次结构及其关键技术。首先讨论了 SRAM 和 DRAM 两种基本的内存技术，并引入内存层次的概念。随后详细阐述了 Cache 的工作原理，包括直接映射、全相连和组相连三种映射策略，以及处理 Cache 命中与缺失的各种策略。最后介绍了虚拟内存技术，重点讨论了页表的概念和 TLB 的应用，以及它们在地址转换过程中的作用。通过这些技术的结合，计算机系统得以在保证性能的同时有效管理内存资源。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small></p>\n</blockquote>\n<!-- more -->\n<h2 id=\"anchor-fb0cf57f9f29e539\" style=\"position: relative;\"><a href=\"#anchor-fb0cf57f9f29e539\" aria-label=\"anchor fb0cf57f9f29e539 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Memory Hierarchy</h2>\n<p>在前文中，我们将 instruction 和 data 存储在内存中，而内存的读写也有快慢之分，这里介绍两种常用的内存技术：</p>\n<ul>\n<li><strong>静态随机访问存储器(Static Random Access Memory, SRAM)</strong>：\n<ul>\n<li>数据存储在晶体管中（通常用 6-8 个晶体管表示一个位），无需刷新</li>\n<li>读写速度快，但是空间（指占用的物理空间）占用高。</li>\n</ul>\n</li>\n<li><strong>动态随机访问存储器(Dynamic Random Access Memory, DRAM)</strong>：\n<ul>\n<li>数据存储在电容中，需要定期刷新</li>\n<li>读写速度慢（一般是 SRAM 的 5-10 倍），但是空间占用低。</li>\n</ul>\n</li>\n</ul>\n<p>显然，我们不可能把所有内存数据都用 SRAM 存储，只能将其中一小部分放在 SRAM 中（<strong>一般是缓存(cache)</strong>），而大部分放在 DRAM 中（一般是 <strong>主存(main memory)</strong>），这就是 <strong>内存层级(memory hierarchy)</strong> 的概念。</p>\n<p><img src=\"https://img.memset0.cn/2024/12/09/ZcczK4K0.png\"alt=\"\" style=\"width: 517px; \" ></p>\n<h2 id=\"anchor-e1171ee8a654bc1d\" style=\"position: relative;\"><a href=\"#anchor-e1171ee8a654bc1d\" aria-label=\"anchor e1171ee8a654bc1d permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Cache</h2>\n<p>由于 CPU 的执行速度远快于主存（使用了 DRAM）的速度，如果直接从 DRAM 中读写数据，CPU 就必须为了等待主存而暂停若干个时钟周期，这就是 CPU 与主存速度不匹配产生的矛盾。为此我们需要引入 cache 技术。可以关注到程序对内存的访问有如下特点：</p>\n<ul>\n<li><strong>时间局部性(temporal locality)</strong>，即近期访问的项目很有可能会在短时间内再次被访问。例如循环中的指令、induction variables (循环中用来计数的变量) 等。</li>\n<li><strong>空间局部性(spatial locality)</strong>，即近期访问项目附近的项目也有可能会在短时间内再次被访问。例如连续的指令执行，或者数组变量等。</li>\n</ul>\n<p>利用好这些性质，我们可以设计 cache 来在合理成本的代价下大幅优化对内存的读写速度。</p>\n<h3 id=\"anchor-53cbdaa220bf2bd2\" style=\"position: relative;\"><a href=\"#anchor-53cbdaa220bf2bd2\" aria-label=\"anchor 53cbdaa220bf2bd2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. Cache Mapping Strategies</h3>\n<p><img src=\"https://img.memset0.cn/2024/12/09/XQHOmHlB.png\"alt=\"\" style=\"width: 559px; \" ></p>\n<table>\n<thead>\n<tr>\n<th><strong>问题</strong></th>\n<th><strong>直接映射</strong></th>\n<th><strong>全相连</strong></th>\n<th><strong>组相连</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Q1: Block Placement</strong></td>\n<td>每个块只能映射到缓存中的<mark class=\"m-mark\">一个位置</mark>：地址 MOD 缓存块数量</td>\n<td>块可以放置在缓存中的<mark class=\"m-mark\">任意位置</mark></td>\n<td>块可以放置在一个组中的任意位置，地址 MOD 组数量；<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>-路组相连缓存中，每组有 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> 个块</td>\n</tr>\n<tr>\n<td><strong>Q2: Block Identification</strong></td>\n<td>使用索引字段选择块（直接映射）</td>\n<td>使用标签字段匹配块地址</td>\n<td>使用索引字段选择组，使用标签字段匹配组内块地址</td>\n</tr>\n<tr>\n<td><strong>Q3: Block Replacement</strong></td>\n<td>不存在替换问题，因为每个块只能映射到一个固定位置</td>\n<td>替换策略包括随机替换、LRU（最近最少使用）、FIFO（先进先出）</td>\n<td>在组内进行替换，替换策略包括随机替换、LRU（最近最少使用）、FIFO（先进先出）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"anchor-195b144d6111d571\" style=\"position: relative;\"><a href=\"#anchor-195b144d6111d571\" aria-label=\"anchor 195b144d6111d571 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.1. Direct Map</h4>\n<p><details open disabled class=\"callout callout-type-note\"><summary> Block</summary><div class=\"callout-content\"><p></p><p>将相邻的若干个 byte 合并为一个 <strong>块(block)</strong>，下文关于 cache 的讨论都是以 block 作为基本单元进行的。我们将 byte address 的低若干位（称为 byte offset）拿掉，就可以得到对应的 block address。则一个 block 中包含 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mtext>#(byte offset)</mtext></msup></mrow><annotation encoding=\"application/x-tex\">2^{\\text{\\#(byte offset)}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.888em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">#(byte offset)</span></span></span></span></span></span></span></span></span></span></span></span></span></span> 个 bytes。</p></div></details></p>\n<p><strong>直接映射(direct map)</strong> 的策略是将每个内存中的 block 唯一映射到一个缓存的 block 中。</p>\n<p><img src=\"https://img.memset0.cn/2024/12/09/PCNbpY7S.png\"alt=\"\" style=\"width: 582px; \" ></p>\n<p>如上图所示：memory 有 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>5</mn></msup><mo>=</mo><mn>32</mn></mrow><annotation encoding=\"application/x-tex\">2^{5} = 32</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">32</span></span></span></span></span> 个 block，cache 有 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">2^{3}=8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span></span></span></span></span> 个 block，直接根据 memory 地址的低 3 位作为 cache 地址。我们将这个低 3 位称为 <strong>索引(index)</strong>。</p>\n<p>为了知道 cache 中实际存放的到底是 memory 中的哪个 block，我们在 cache 中还需要存储 memory 地址的高几位（上图中就是高 2 位）。我们将这个高 2 位成为 <strong>标签(tag)</strong>。</p>\n<p>另外，我们需要一个 <strong>有效位(valid bit)</strong> 来判断 cache 中存储的这个 block 是否是有效的。初始时全部无效，valid bit 为 0；当从内存中取出一个 block 后，就变成有效的了，valid bit 为 1。cache hit 当且仅当 valid bit 为 1 且 tag 与目标地址一致。</p>\n<p><img src=\"https://img.memset0.cn/2024/12/09/PTUhlfoQ.png\"alt=\"\" style=\"width: 432px; \" ></p>\n<ul>\n<li>tag：用于标识对应内存块的唯一性</li>\n<li>index：用于定位缓存中块的位置</li>\n<li>offset / byte offset：用于定位块内具体的数据</li>\n</ul>\n<p><details open disabled class=\"callout callout-type-tip\"><summary> Tip: direct map cache 相关计算题</summary><div class=\"callout-content\"><p></p><ol>\n<li>根据一个 block 有多少个 byte/word 算出 offset；</li>\n<li>根据 cache 包含多少个 block（或者叫做 cache 行）算出 index；</li>\n<li>地址剩下的位为 tag；</li>\n<li>不要忘了 cache 中还需要 valid bit、data bits、tag bit、dirty bit（可选），注意 index bit 并不在 cache 里面。</li>\n</ol></div></details></p>\n<h4 id=\"anchor-28e347418a7c3eae\" style=\"position: relative;\"><a href=\"#anchor-28e347418a7c3eae\" aria-label=\"anchor 28e347418a7c3eae permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.2. Fully Associative</h4>\n<p><strong>全相连(fully associative)</strong> 策略简单来说就是 block 可能存放到 cache 中的每一个位置（因为它们都有连线），但坏处是我们在判断 hit 时的复杂度大大增加（需要一次跟所有 cache 中的 block 比较看是否 hit）。</p>\n<ul>\n<li><mark class=\"m-mark\">注意，全相连的实现中没有 index</mark>，无论在地址划分还是在 cache 空间中。</li>\n</ul>\n<p><img src=\"https://img.memset0.cn/2024/12/16/jYFHq6QI.png\"alt=\"\" style=\"width: 455px; \" ></p>\n<p>另外，在替换 cache block 时也有多种策略可以采用：</p>\n<ul>\n<li><strong>随机替换(random replacement)</strong>：随机一个 cache 中的 block 进行替换（需要实现一个随机数生成算法）。</li>\n<li><strong>先进先出(first in first out, FIFO)</strong>：即选择进入时间最少的 block 覆盖掉。</li>\n<li><strong>最近最少使用(least recently used, LRU)</strong>：选择上一次使用时间距离现在最远的 block 覆盖掉（需要一些额外的位记录信息）。</li>\n</ul>\n<h4 id=\"anchor-8e0c572d42368e53\" style=\"position: relative;\"><a href=\"#anchor-8e0c572d42368e53\" aria-label=\"anchor 8e0c572d42368e53 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.3. Set Associative</h4>\n<p><strong>组相连(set associative)</strong> 策略是一种介于直接映射策略和全相连策略的策略。即每个 block 根据其 block address 可以对应到一组 cache blocks 中。其中每一组中都采用全相连中介绍过的替换算法。</p>\n<p><img src=\"https://img.memset0.cn/2024/12/16/tVrBA8zf.png\"alt=\"\" style=\"width: 612px; \" ></p>\n<p>像上图就是一个 2-way set associative 的示意图，展示了数据在 set-associative 的 cache 中的去向。更严谨的，我们可以画出其原理图，以 4-way set associative 的 cache 为例（见下图），我们用一行表示一个组，并使用 MUX 在组中选择匹配的 line。</p>\n<p><img src=\"https://img.memset0.cn/2025/01/16/HTghKphL.png\"alt=\"\" style=\"width: 563px; \" ></p>\n<p>特别地，我们称组的大小为 <strong>associativity</strong>，则判断 hit 时需要比较的次数就等于 associativity。</p>\n<h3 id=\"anchor-bb369c8ba7bb0e2b\" style=\"position: relative;\"><a href=\"#anchor-bb369c8ba7bb0e2b\" aria-label=\"anchor bb369c8ba7bb0e2b permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. Handling Hits &#x26; Misses</h3>\n<p>我们根据 read / write、hit / miss、inst / data 的情况进行分类讨论，这一部分的理解会在后文关系到性能计算。</p>\n<ul>\n<li>Read\n<ul>\n<li>Hit：直接就从 cache 里读就好了</li>\n<li>Miss\n<ul>\n<li>Data：从 memory 里把对应 block 拿到 cache，再读取相应内容。</li>\n<li>Inst：暂停 CPU 运行，从 memory 里把对应的 block 拿到 cache，从第一个 step 开始重新运行当前这条指令。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Write\n<ul>\n<li>Hit\n<ul>\n<li><strong>写穿(write-through)</strong> 策略：每次写数据时既写在 cache 中，也写到 main memory 中。好处是 cache 和 main memory 始终是一致的。\n<ul>\n<li>一个常见的改进是引入 <strong>write buffer</strong>——即需要写入 main memory 时先加入到缓冲队列中，并允许 CPU 继续运行了。当 write buffer 满了的时候，也需要暂停处理器来做写入 main memory 的工作，直到 buffer 中有空闲的 entry。（因此，如果 main memory 的写入速率低于 CPU 产生写操作的速率，多大的缓冲都无济于事。）</li>\n</ul>\n</li>\n<li><strong>写回(write-back)</strong> 策略：只将要修改的内容写在 cache 里，当这个 block 要被替换掉的时候才将对应的修改写回 main memory。这种情况需要在 cache 中额外创建一个 <strong>脏位(dirty bit)</strong> 用于记录该 block 是否发生或修改。这对于在同一个 block 中连续有多次修改情况优化是巨大的。</li>\n</ul>\n</li>\n<li>Miss\n<ul>\n<li><strong>write-around</strong> 策略：直接在 main memory 中进行修改，不用拿到 cache 里了。一般搭配 write-through 策略。</li>\n<li><strong>write-allocate</strong> 策略：先将对应 block 拿到 cache 中再写入。<mark class=\"m-mark\">对于 write-back 策略，必须搭配这一策略。</mark></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img.memset0.cn/2025/01/02/kBa9D2g0.png\"alt=\"\" style=\"width: 667px; \" ></p>\n<h3 id=\"anchor-08123731986cf764\" style=\"position: relative;\"><a href=\"#anchor-08123731986cf764\" aria-label=\"anchor 08123731986cf764 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. Cache Performance</h3>\n<p>注意到无论我们采用什么策略，都不能保证 cache 的每次访问都 hit。而一旦 miss，就需要等待若干时钟周期去访问主存，这一代价成为 <strong>miss penalty</strong>。在计算 cache 性能时，必须要考虑这一部分。</p>\n<p><strong>平均内存访问时间(average memory access time)</strong> 定义为：</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mtext>Average Memory Access Time</mtext><mo>=</mo><mtext>Hit Time</mtext><mo>+</mo><mtext>Miss Rate</mtext><mo>×</mo><mtext>Memory Time</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{Average Memory Access Time} = \\text{Hit Time} + \\text{Miss Rate} \\times \\text{Memory Time}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">Average Memory Access Time</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord text\"><span class=\"mord\">Hit Time</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord text\"><span class=\"mord\">Miss Rate</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">Memory Time</span></span></span></span></span></span></div>\n<p>一般用 CPU 时间来衡量 cache 性能，即在 CPU 执行时间的基础上加上因为 cache miss 而惩罚的时间：</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right\" columnspacing=\"\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mtext>CPU Time</mtext><mo>=</mo><mo stretchy=\"false\">(</mo><mtext>CPU execution clock cycles</mtext><mo>+</mo><mtext>memory-stall clock cycles</mtext><mo stretchy=\"false\">)</mo><mo>×</mo><mtext>clock cycle time</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{aligned}\n\\text{CPU Time} = (\\text{CPU execution clock cycles} + \\text{memory-stall clock cycles}) \\times \\text{clock cycle time}\\\\\n\\end{aligned}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.5em;vertical-align:-0.5em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1em;\"><span style=\"top:-3.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">CPU Time</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">CPU execution clock cycles</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord text\"><span class=\"mord\">memory-stall clock cycles</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord text\"><span class=\"mord\">clock cycle time</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5em;\"><span></span></span></span></span></span></span></span></span></span></span></span></div>\n<ul>\n<li>读延迟周期：<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mtext>Read-stall cycles</mtext><mo>=</mo><mfrac><mtext>Read</mtext><mtext>Program</mtext></mfrac><mo>×</mo><mtext>Read Miss Rate</mtext><mo>×</mo><mtext>Read Miss Penalty</mtext></mrow></mstyle></mrow><annotation encoding=\"application/x-tex\">\\displaystyle{\\text{Read-stall cycles} = \\frac{\\text{Read}}{\\text{Program}} \\times \\text{Read Miss Rate} \\times \\text{Read Miss Penalty}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.2519em;vertical-align:-0.8804em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Read-stall cycles</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Program</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Read</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord text\"><span class=\"mord\">Read Miss Rate</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord text\"><span class=\"mord\">Read Miss Penalty</span></span></span></span></span></span></span></li>\n<li>写延迟周期：<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mtext>Write-stall cycles</mtext><mo>=</mo><mfrac><mtext>Write</mtext><mtext>Program</mtext></mfrac><mo>×</mo><mtext>Write Miss Rate</mtext><mo>×</mo><mtext>Write Miss Penalty</mtext><mo>+</mo><mtext>Write Buffer Stalls</mtext></mrow></mstyle></mrow><annotation encoding=\"application/x-tex\">\\displaystyle{\\text{Write-stall cycles} = \\frac{\\text{Write}}{\\text{Program}} \\times \\text{Write Miss Rate} \\times \\text{Write Miss Penalty} + \\text{Write Buffer Stalls}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.2408em;vertical-align:-0.8804em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Write-stall cycles</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3603em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Program</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Write</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord text\"><span class=\"mord\">Write Miss Rate</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord text\"><span class=\"mord\">Write Miss Penalty</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord text\"><span class=\"mord\">Write Buffer Stalls</span></span></span></span></span></span></span>\n<ul>\n<li>如果 write buffer penalty 很小，可以忽略不计。</li>\n<li>如果 block size 为 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>，则 write miss penalty 近乎于 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span>。</li>\n</ul>\n</li>\n<li>在 write-through 的 cache 中，read penalty 和 write penalty 可近似为相同的，由此得到：<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mtext>Memory-stall clock cycles</mtext><mo>=</mo><mfrac><mtext>Memory Accesses</mtext><mtext>Program</mtext></mfrac><mo>×</mo><mtext>Miss Rate</mtext><mo>×</mo><mtext>Miss Penalty</mtext></mrow></mstyle></mrow><annotation encoding=\"application/x-tex\">\\displaystyle{\\text{Memory-stall clock cycles} = \\frac{\\text{Memory Accesses}}{\\text{Program}} \\times \\text{Miss Rate} \\times \\text{Miss Penalty} }</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.2408em;vertical-align:-0.8804em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Memory-stall clock cycles</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3603em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Program</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Memory Accesses</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord text\"><span class=\"mord\">Miss Rate</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord text\"><span class=\"mord\">Miss Penalty</span></span></span></span></span></span></span>。</li>\n</ul>\n<h2 id=\"anchor-b6c3b60ff9d31a98\" style=\"position: relative;\"><a href=\"#anchor-b6c3b60ff9d31a98\" aria-label=\"anchor b6c3b60ff9d31a98 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Virtual Memory</h2>\n<p>为了让多个程序可以共用一个地址，同时提高内存寻址空间，我们可以引入 <strong>虚拟内存(virtual memory)</strong> 的概念，这是相对于 <strong>物理内存(physical memory)</strong> 的而言的。当然，（需要用到的）数据还是需要被加载到物理内存中，本小节主要关注的是 <strong>虚拟地址(virtual address)</strong> 和 <strong>物理地址(physical address)</strong> 进行<mark class=\"m-mark\">转换</mark>的技术。</p>\n<h3 id=\"anchor-d7a2e0cfb39c72d8\" style=\"position: relative;\"><a href=\"#anchor-d7a2e0cfb39c72d8\" aria-label=\"anchor d7a2e0cfb39c72d8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. Page Table</h3>\n<p><strong>页(page)</strong> 是虚拟内存和物理内存的基本单元，可以类比 cache 中 block / line 的概念。一方面，我们利用了内存访问的连续性；另一方面，我们可以减少对页表大小的要求，因为虚拟地址和物理地址的 page offset 部分是相同的，不需要转换。</p>\n<p>通过虚拟内存技术，我们可以让程序访问超过物理内存本身限制的内存，这是通过和磁盘 的交互得到的，这其实比较类似于操作系统中 swap 内存的概念（但其实是两个东西）。也就是说，程序所需要的内存数据一开始在磁盘中，并通过虚拟地址的方式索引。等到程序用到时才从磁盘中取出加载到物理内存里，由于这一物理内存地址是实时分配的，我们需要通过一个 <strong>页表(page table)</strong> 记录虚拟内存到底被对应到了物理内存的哪一地址，根据这一物理地址我们才能在主存中查找数据。</p>\n<p><img src=\"https://img.memset0.cn/2024/12/16/yyoQ90oT.png\"alt=\"\" style=\"width: 407px; \" ></p>\n<p>当我们在 page table 中 miss 时，实际上就是发生了 <strong>页错误(page fault)</strong>，即我们请求的页并不在主存中，而在 disk 中。当 page fault 发生时，一般由操作系统负责将对应页从磁盘中取出，并载入到主存中。这也是为什么使用虚拟内存技术时，一般只能使用 write back 策略而不能使用 write through 策略，因为对 disk 的写是极慢的，不能接受一旦 miss 就只能等待 disk 写。</p>\n<p><details open disabled class=\"callout callout-type-question\"><summary> Page table 是 DRAM 到 disk 的缓存？</summary><div class=\"callout-content\"><p></p><p>有人把 cache 理解成 SRAM 层和主存（DRAM 层）的缓存，而把 page table 理解成 DRAM 层和 disk 的缓存。这种说法大体上是说得通的，但并不是很严谨。就比如，在 page table 中我们并不实际存储数据，而是只存放虚拟地址和物理地址的转换关系，数据仍是存储在物理内存（主存；DRAM 层）中。</p></div></details></p>\n<p><details open disabled class=\"callout callout-type-question\"><summary> Page table 是 fully-associative 还是 direct mapped？</summary><div class=\"callout-content\"><p></p><p>因为 page table 中的每一个位置都可以存放任意一个物理地址（即每个虚拟地址都可能对应任一个物理地址），而课件把 page table 看成一种 DRAM 层到外部存储的 cache，从而说 page table 是 fully-associative 的。但这种全相连的实现方法是通过地址转换+根据物理地址寻址实现的，而不是 cache 的那种直接连线，两者还是有不小的区别的。不过共同点是我们都可以实现 LRU 策略等等（取决于在 page faults 发生时怎么操作）。</p><p>而如果换一个理解，把 page table 看作是虚拟地址到物理地址的转换函数（假装是另一种定义地不太严谨的 cache？），那又可以说 page table 是 direct mapped 的。因为我们其实是直接根据虚拟地址在 page table 中查表，这和 direct mapped cache 的实现类似。</p><p>因此我觉得这个怎么说取决于具体语境，取决于你怎么理解。个人认为不必太纠结这个。</p></div></details></p>\n<h3 id=\"anchor-69ccba3bd2c62727\" style=\"position: relative;\"><a href=\"#anchor-69ccba3bd2c62727\" aria-label=\"anchor 69ccba3bd2c62727 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. Translation-lookahead Buffer</h3>\n<p>注意到 page table 很大，需要存储在 DRAM 中。即和主存一样，对 page table 的访问其实是较慢的，那有没有什么办法给 page table 再实现一个缓存呢？这就是 <strong>快表(Translation-lookahead Buffer, TLB)</strong> 扮演的工作。TLB 放在 SRAM 中，一般采用组相连的策略（也可以是其他两种），作为 page table 的 cache。当 TLB 命中时，能直接返回 physical address，否则才需要在 page table 中重新查找。</p>\n<p>如果把 TLB 和 page table 结合起来，并且考虑根据物理地址从 cache 和主存中找数据的步骤，就可以得到下面这张流程图，据此也很好分析课件中给出的 possible / impossible 判断。</p>\n<p><img src=\"https://img.memset0.cn/2025/01/03/VT7hwrqh.png\"alt=\"\" style=\"width: 621px; \" ></p>\n<ul>\n<li>如果 page table 中 miss，则不可能在 TLB 中 hit。因为 TLB 中的数据是从 page table 中取出并放入的。</li>\n<li>如果在 page table 和 tlb 中 miss，则不可能在 cache 中 hit，因为页如果在 cache 中说明其有被分配物理地址，这种情况下一定能在 page table 中查到。</li>\n</ul>\n<p><img src=\"https://img.memset0.cn/2025/01/16/IwvSuBr8.png\"alt=\"\" style=\"width: 654px; \" ></p>\n<p>一般在组相连的 TLB 中使用 LRU 策略，但完整的 LRU 策略实现开销较大，一般采用一种近似的 LRU 策略。即在 TLB 中加入一个 rel bit。CPU 每隔一段时间将 rel bit 置 0，如果进行了访问就将 rel bit 置 1。当需要从 TLB 中移出 line 时，选择一个 rel bit 为 0 的行即可。</p>\n<p><details open disabled class=\"callout callout-type-question\"><summary> TLB 需要 dirty bit 吗？</summary><div class=\"callout-content\"><p></p><p>如果要实现写操作，我们在 TLB 中也需要实现 dirty bit。这是因为根据 write-back 策略，我们如果对一个页进行了修改，就必须把其 dirty bit 设置为 1。而根据 write-back 策略，这个页肯定已经被加载到 TLB 中，所以我们只需要在 TLB 中讲其 dirty bit 设置为 1，并且在这个页被移出 TLB 时把修改应用到 page table 中即可。</p><p>设想如果我们没有在 TLB 中实现 dirty bit，则每次标记 dirty bit 都需要对 page table 进行操作，这显然会带来额外的时间开销。</p></div></details></p>\n<h2 id=\"anchor-40daec724f0b1b41\" style=\"position: relative;\"><a href=\"#anchor-40daec724f0b1b41\" aria-label=\"anchor 40daec724f0b1b41 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. References</h2>\n<ul>\n<li>感谢 514imb 同学提供帮助。</li>\n<li><a href=\"https://xuan-insr.github.io/computer_organization/5_cache/\">5 Cache - 咸鱼暄的代码空间 (xuan-insr.github.io)</a></li>\n<li><a href=\"https://birchtree2.github.io/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/5_Memory.html\">5 Memory - 时雨的笔记本</a></li>\n<li><a href=\"https://note.noughtq.top/system/co/5\">Chap 5: Memory Hierarchy - NoughtQ 的笔记本</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#anchor-fb0cf57f9f29e539\">1. Memory Hierarchy</a></p>\n</li>\n<li>\n<p><a href=\"#anchor-e1171ee8a654bc1d\">2. Cache</a></p>\n<ul>\n<li><a href=\"#anchor-53cbdaa220bf2bd2\">2.1. Cache Mapping Strategies</a></li>\n<li><a href=\"#anchor-bb369c8ba7bb0e2b\">2.2. Handling Hits &#x26; Misses</a></li>\n<li><a href=\"#anchor-08123731986cf764\">2.3. Cache Performance</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-b6c3b60ff9d31a98\">3. Virtual Memory</a></p>\n<ul>\n<li><a href=\"#anchor-d7a2e0cfb39c72d8\">3.1. Page Table</a></li>\n<li><a href=\"#anchor-69ccba3bd2c62727\">3.2. Translation-lookahead Buffer</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-40daec724f0b1b41\">4. References</a></p>\n</li>\n</ul>","frontmatter":{"title":"V. Memory","date":"2025 年 01 月 16 日","description":null},"fields":{"cover":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#081838","images":{"fallback":{"src":"/static/cef4dea1262b0cab93ff6fa4f42bb946/62413/edu7F13u.png","srcSet":"/static/cef4dea1262b0cab93ff6fa4f42bb946/f054f/edu7F13u.png 271w,\n/static/cef4dea1262b0cab93ff6fa4f42bb946/6288d/edu7F13u.png 541w,\n/static/cef4dea1262b0cab93ff6fa4f42bb946/62413/edu7F13u.png 1082w","sizes":"(min-width: 1082px) 1082px, 100vw"},"sources":[{"srcSet":"/static/cef4dea1262b0cab93ff6fa4f42bb946/4248e/edu7F13u.webp 271w,\n/static/cef4dea1262b0cab93ff6fa4f42bb946/23069/edu7F13u.webp 541w,\n/static/cef4dea1262b0cab93ff6fa4f42bb946/9d5bc/edu7F13u.webp 1082w","type":"image/webp","sizes":"(min-width: 1082px) 1082px, 100vw"}]},"width":1082,"height":862}}},"slug":"/course/co/note/5/","cssclasses":null,"isDoc":true,"category":"[{\"name\":\"课程笔记\",\"to\":\"/course/\"}]","propsJson":null}},"previous":{"fields":{"slug":"/course/oop/review/"},"frontmatter":{"title":"OOP 一站式速通笔记"}},"next":null},"pageContext":{"id":"51807d27-808f-5640-a002-efe438a563d9","previousPostId":"97ef5ad5-d0d0-5ed6-a167-e014ff5f8efe","nextPostId":null,"navJson":"[{\"slug\":\"/course/co\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/index.md\",\"title\":\"Intro\"},{\"title\":\"Note\",\"children\":[{\"slug\":\"/course/co/note/1\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/note/1.md\",\"title\":\"I. Prelude\"},{\"slug\":\"/course/co/note/2\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/note/2.md\",\"title\":\"II. Arithmetic\"},{\"slug\":\"/course/co/note/3\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/note/3.md\",\"title\":\"III. Instructions\"},{\"slug\":\"/course/co/note/4\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/note/4.md\",\"title\":\"IV. Processor\"},{\"slug\":\"/course/co/note/5\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/co/note/5.md\",\"title\":\"V. Memory\"}]}]"}},"staticQueryHashes":[],"slicesMap":{}}