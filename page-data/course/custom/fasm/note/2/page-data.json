{"componentChunkName":"component---src-templates-doc-js","path":"/course/custom/fasm/note/2/","result":{"data":{"site":{"siteMetadata":{"title":"mem 的小站"}},"post":{"id":"0ae01f57-51fd-5ce0-925d-9cb3762c377e","excerpt":"1. 数据的表示 1.1. 二进制数据的组织 名字 宽度 英文 定义方式 C 语言中等价类型 字节 8 bit byte db (unsigned) char; 字 16 bit word dw (unsigned) short int; 双字 32 bit double word dd (unsigned) long…","html":"<h2>1. 数据的表示</h2>\n<h3>1.1. 二进制数据的组织</h3>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名字</th>\n<th>宽度</th>\n<th>英文</th>\n<th>定义方式</th>\n<th>C 语言中等价类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">字节</td>\n<td>8 bit</td>\n<td>byte</td>\n<td>db</td>\n<td>(unsigned) char;</td>\n</tr>\n<tr>\n<td align=\"center\">字</td>\n<td>16 bit</td>\n<td>word</td>\n<td>dw</td>\n<td>(unsigned) short int;</td>\n</tr>\n<tr>\n<td align=\"center\">双字</td>\n<td>32 bit</td>\n<td>double word</td>\n<td>dd</td>\n<td>(unsigned) long int; float;</td>\n</tr>\n<tr>\n<td align=\"center\">四字</td>\n<td>64 bit</td>\n<td>quadruple word (qword)</td>\n<td>dq</td>\n<td>(unsigned) long long; double;</td>\n</tr>\n<tr>\n<td align=\"center\">十字节</td>\n<td>80 bit</td>\n<td>ten byte (tbyte)</td>\n<td>dt</td>\n<td>long double;</td>\n</tr>\n</tbody>\n</table>\n<p>在 data 段中可以定义变量和数组，对应语法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">data segment\n  s db &quot;Hello, World&quot; ; 字符串 char[13]\n  a dd 1, 2, 3, 4, 5  ; 数组 int[5]\n  b dw 0 dup(5)       ; 数组 short int[5]，初始值全为0\n  c db 0FFh;          ; 值为0FFh的字符 char\n  f dd 3.14           ; 值为3.14的浮点数 float\ndata ends</code></pre></div>\n<ul>\n<li>用 <code class=\"language-text\">dup(数)</code> 来表示数组，用 <code class=\"language-text\">?</code> 表示无初始值或初始值任意。</li>\n<li>在定义字符串时，可以通过 <code class=\"language-text\">0Dh</code>、<code class=\"language-text\">0Ah</code> 来表示换行。</li>\n</ul>\n<h3>1.2. 浮点数的表示</h3>\n<blockquote>\n<p>10.18 1:30:00</p>\n</blockquote>\n<h2>2. 数据的运算</h2>\n<h3>2.1. 零扩充和符号扩充</h3>\n<ul>\n<li>当把低位无符号数赋给高位无符号数时，必须采用<strong>零扩充</strong>规则，即在左边补 0。</li>\n<li>当把低位有符号数赋给高位有符号数时，必须采用<strong>符号扩充</strong>规则，即在左边补上原数的最高位（符号位）。</li>\n</ul>\n<h4>2.1.1. <code class=\"language-text\">cbw</code>、<code class=\"language-text\">cwd</code> 符号扩充</h4>\n<ul>\n<li><code class=\"language-text\">cbw</code>，即 convert byte to word，可将 AL 中的值符号扩充到 AX 中</li>\n<li><code class=\"language-text\">cwd</code>，即 convert word to double word，可将 AX 中的值符号扩充到 DX:AX 中</li>\n</ul>\n<h4>2.1.2. <code class=\"language-text\">movzx</code> 零扩充</h4>\n<p><code class=\"language-text\">movzx dest, src</code> 把 src 零扩充到寄存器 dest 中。指令格式：</p>\n<ul>\n<li><code class=\"language-text\">movzx reg16, reg8|reg8</code></li>\n<li><code class=\"language-text\">movzx reg32, reg8|mem8|reg16|mem16</code></li>\n</ul>\n<h4>2.1.3. <code class=\"language-text\">movsx</code> 符号扩充</h4>\n<p><code class=\"language-text\">movsx dest, src</code> 功能与格式与 <code class=\"language-text\">movzx</code> 类似，区别在于 <code class=\"language-text\">movsx</code> 是符号扩充。</p>\n<h3>2.2. 整数运算</h3>\n<h4>2.2.1. 加法 <code class=\"language-text\">add</code> / <code class=\"language-text\">inc</code> / <code class=\"language-text\">adc</code></h4>\n<ul>\n<li><code class=\"language-text\">add dest, src</code>：<code class=\"language-text\">dest += src</code></li>\n<li><code class=\"language-text\">adc dest, src</code>（带进位加）：<code class=\"language-text\">dest += src + CF</code></li>\n<li><code class=\"language-text\">inc op</code>：<code class=\"language-text\">op++</code></li>\n</ul>\n<p><code class=\"language-text\">add</code> / <code class=\"language-text\">adc</code> 指令若发生进位会将 CF 寄存器置 1，否则将 CF 寄存器置 0。<code class=\"language-text\">inc</code> 指令不会影响 CF 寄存器</p>\n<h4>2.2.2. 减法 <code class=\"language-text\">sub</code> / <code class=\"language-text\">sbb</code> / <code class=\"language-text\">dec</code> / <code class=\"language-text\">neg</code></h4>\n<ul>\n<li><code class=\"language-text\">sub dest, src</code>：<code class=\"language-text\">dest -= src</code></li>\n<li><code class=\"language-text\">sbb dest, src</code>（带错位减）：<code class=\"language-text\">dest -= src + CF</code>（<code class=\"language-text\">dest = dest - src - CF</code>）</li>\n<li><code class=\"language-text\">dec op</code>：<code class=\"language-text\">op--</code></li>\n<li><code class=\"language-text\">neg op</code>（取相反数）：<code class=\"language-text\">op = -op</code></li>\n</ul>\n<h4>2.2.3. 乘法 <code class=\"language-text\">mul</code> / <code class=\"language-text\">imul</code></h4>\n<p>用 <code class=\"language-text\">mul</code> 进行<strong>无符号</strong>整数乘法。</p>\n<ul>\n<li>当 mul 后跟一个 8 位寄存器或 8 位变量作为乘数时，被乘数一定是 AL，乘积一定是 AX。</li>\n<li>当 mul 后跟一个 16 位寄存器或 16 位变量作为乘数时，被乘数一定是 AX，乘积一定是 DX:AX。</li>\n<li>当 mul 后跟一个 32 位寄存器或 32 位变量作为乘数时，被乘数一定是 EAX，乘积一定是 EDX:EAX。</li>\n</ul>\n<p>用 <code class=\"language-text\">imul</code> 进行<strong>有符号</strong>整数乘法，其第一类用法和 <code class=\"language-text\">mul</code> 的上述用法相同。第二类用法可以包含两个或三个操作数，其中前两个操作数可以是寄存器或变量，第三个操作数只能是常数：</p>\n<ul>\n<li><code class=\"language-text\">imul eax, ebx</code>：EAX = EAX × EBX</li>\n<li><code class=\"language-text\">imul eax, ebx, 3</code>：EAX = EAX × EBX × 3</li>\n</ul>\n<h4>2.2.4. 除法 <code class=\"language-text\">div</code> / <code class=\"language-text\">idiv</code></h4>\n<p>用 <code class=\"language-text\">div</code> 进行<strong>无符号</strong>整数除法。</p>\n<ul>\n<li>当 div 后跟一个 8 位寄存器或 8 位变量作为除数时，被除数一定是 AX，商是 AL，余数是 AH</li>\n<li>当 div 后跟一个 16 位寄存器或 16 位变量作为除数时，被除数一定是 DX:AX，商是 AX，余数是 DX</li>\n<li>当 div 后跟一个 32 位寄存器或 32 位变量作为除数时，被除数一定是 EDX:EAX，商是 EAX，余数是 EDX</li>\n</ul>\n<p>除法溢出有来两种情形：</p>\n<ul>\n<li>除数是 0。</li>\n<li>被除数除以除数的商无法保存到相应寄存器中。</li>\n</ul>\n<p>当发生<strong>除法溢出</strong>时，会在 <code class=\"language-text\">div</code> 指令<strong>上方</strong>插入并调用一条 <code class=\"language-text\">int 00h</code> 中断指令（默认行为：显示 divide overflow 并强行结束程序运行）。如果修改 0:0 处的中断向量，则可以在发生中断时转到我们自己的中断函数，对除法溢出的问题进行处理。<code class=\"language-text\">iret</code> 后会重新执行除法指令。</p>\n<p>用 <code class=\"language-text\">idiv</code> 进行<strong>有符号</strong>整数除法，用法参考 <code class=\"language-text\">div</code>。</p>\n<h3>2.3. 浮点数运算</h3>\n<p><img src=\"https://static.memset0.cn/img/v6/2024/02/08/OCj4BEST.png\"alt=\"\" ></p>\n<ul>\n<li><code class=\"language-text\">fld</code> 压入小数类型的变量。</li>\n<li><code class=\"language-text\">fild</code> 把整数类型的变量转化为小数类型并压入。</li>\n<li><code class=\"language-text\">fst</code> 把小数寄存器 st(0) 保存到变量中。</li>\n<li><code class=\"language-text\">fstp</code> 把小数寄存器 st(0) 保存到变量中并弹出 st(0)。</li>\n<li><code class=\"language-text\">fadd</code> / <code class=\"language-text\">fsub</code> / <code class=\"language-text\">fmul</code> / <code class=\"language-text\">fdiv</code> 进行浮点数的四则运算；如用 <code class=\"language-text\">fmul st, st(1)</code> 进行乘法计算。</li>\n</ul>\n<p>CPU 内部一共有 8 个小数寄存器，分别叫做 st(0)、st(1)、…、st(7)。其中 st(0)简称 st 这8个寄存器的宽度均达到 80 位，相当于 C 语言中的 long double 类型。</p>\n<h3>2.4. 位运算</h3>\n<h4>2.4.1. 逻辑运算</h4>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>用法</th>\n<th>含义</th>\n<th>C 语言等价运算符言</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">and</code></td>\n<td><code class=\"language-text\">add ax, bx</code></td>\n<td>与</td>\n<td>&#x26;</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">or</code></td>\n<td><code class=\"language-text\">or ax, bx</code></td>\n<td>或</td>\n<td>|</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">xor</code></td>\n<td><code class=\"language-text\">xor ax, ax</code></td>\n<td>异或</td>\n<td>^</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">not</code></td>\n<td><code class=\"language-text\">not ax</code></td>\n<td>取反</td>\n<td>~</td>\n</tr>\n</tbody>\n</table>\n<h4>2.4.2. 逻辑移位 <code class=\"language-text\">shl</code>、<code class=\"language-text\">shr</code></h4>\n<p>适用于无符号数的移位运算，空位补 0，最后一个被移动的位会被放到 CF 标志中。</p>\n<h4>2.4.3. 算术移位 <code class=\"language-text\">sal</code>、<code class=\"language-text\">sar</code></h4>\n<p>适用于有符号数的移位运算。<code class=\"language-text\">sal</code> 与 <code class=\"language-text\">shl</code> 完全相同，<code class=\"language-text\">sar</code> 会在被操作数是负数时补 1，否则行为和 <code class=\"language-text\">shr</code> 相同。同样的，最后一个被移动的位会被放到 CF 标志中。</p>\n<h4>2.4.4. 循环移位 <code class=\"language-text\">rol</code> 、<code class=\"language-text\">ror</code></h4>\n<p>对应变量进行循环移位操作，即被移出的值会从另一侧填补到数中。注意最后一个被移动的位会在被放到另一端的同时放到 CF 标志中。</p>\n<h4>2.4.5. 带进位循环移位 <code class=\"language-text\">rcl</code>、<code class=\"language-text\">rcr</code></h4>\n<p>同样是循环移位操作，但会把 CF 标志看作其中一位参与运算（如被操作数宽度为 16 位，可看作一个长度为 17 的环）。</p>\n<h3>2.5. 字符串操作与运算</h3>\n<blockquote>\n<p>[!note]- Fun Fact：C 语言中的三个关于字符串的库函数</p>\n<ul>\n<li>\n<p>strcpy(target, source); 永远按正方向复制</p>\n</li>\n<li>\n<p>memcpy(target, source); 永远按正方向复制</p>\n</li>\n<li>\n<p>memmove(target, source); 会自行选择方向保证部分重叠时正确</p>\n</li>\n</ul>\n</blockquote>\n<p>字符串指令的方向会被 DF 标志控制，当 DF=0 时会按照正方向（低地址到高地址）运行，当 DF=1 时会按照反方向（高地址到低地址）运行。可通过执行 <code class=\"language-text\">cld</code> 和 <code class=\"language-text\">std</code> 来控制。</p>\n<h4>2.5.1. 字符串复制指令 <code class=\"language-text\">rep movsb/w/d</code></h4>\n<p><code class=\"language-text\">rep movsb</code>，即 move string in byte，会以<strong>字节</strong>（<strong>byte</strong>）为单位复制字符串。如果将 <code class=\"language-text\">movsb</code> 换成 <code class=\"language-text\">movsw</code> 和 <code class=\"language-text\">movsd</code>，则分别会以 word、double word 为单位复制字符串。</p>\n<p>在执行 <code class=\"language-text\">repo movsb</code> 执行前需要做以下准备工作：</p>\n<ol>\n<li>DS:SI 指向源字符串（SI 就是 source index）</li>\n<li>ES:DI 指向目标字符串（DI 就是 destination index）</li>\n<li>CX 寄存器存储移动次数</li>\n<li>DF 标志表示方向（如果）</li>\n</ol>\n<p><code class=\"language-text\">rep movsb</code> 的行为的伪代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">again<span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cx <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">goto</span> done\n\t<span class=\"token keyword\">asm</span> mov byte ptr es<span class=\"token operator\">:</span><span class=\"token punctuation\">[</span>di<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> byte ptr es<span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">do</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\">// movsw/d的话这里就换为word/dword</span>\n\tdf <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span>si<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span> di<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>si<span class=\"token operator\">--</span><span class=\"token punctuation\">,</span> di<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>      <span class=\"token comment\">// movsw/d的话这里就需要增减2/4</span>\n\tcx<span class=\"token operator\">--</span>\n\t<span class=\"token keyword\">goto</span> again\ndone<span class=\"token operator\">:</span></code></pre></div>\n<h4>2.5.2. 字符串比较指令 <code class=\"language-text\">repe/ne cmpsb/w/d</code></h4>\n<p>单条 <code class=\"language-text\">cmpsb</code> 指令的行为如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">asm</span> cmp byte ptr ds<span class=\"token operator\">:</span><span class=\"token punctuation\">[</span>si<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> byte ptr es<span class=\"token operator\">:</span><span class=\"token punctuation\">[</span>di<span class=\"token punctuation\">]</span>\ndf <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span>si<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span> di<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>si<span class=\"token operator\">--</span><span class=\"token punctuation\">,</span> di<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">repe</code> 和 <code class=\"language-text\">repne</code> 则控制了 <code class=\"language-text\">cmp</code> 比较结果的行为，如 <code class=\"language-text\">repe</code> 的行为如下（若本次比较相等则继续比较下一个）：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">again<span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cx <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">goto</span> done\n\t<span class=\"token keyword\">asm</span> cmp byte ptr ds<span class=\"token operator\">:</span><span class=\"token punctuation\">[</span>si<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> byte ptr es<span class=\"token operator\">:</span><span class=\"token punctuation\">[</span>di<span class=\"token punctuation\">]</span>\n\tdf <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span>si<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span> di<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>si<span class=\"token operator\">--</span><span class=\"token punctuation\">,</span> di<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n\tcx<span class=\"token operator\">--</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>zf <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">goto</span> again    <span class=\"token comment\">// repne的话这里就要求ZF=0</span>\ndone<span class=\"token operator\">:</span></code></pre></div>\n<h4>2.5.3. 字符串搜索指令 <code class=\"language-text\">repe/ne sacsb/w/d</code></h4>\n<p>这条字符串指令就只和 ES:DI （注意不是 DS:SI 哦）所指向的字符串有关，CPU 将在其中搜索 AL/AX/EAX 的值（取决于是 <code class=\"language-text\">sacsb</code> 还是 <code class=\"language-text\">sacsw</code> 或 <code class=\"language-text\">sacsd</code>）。</p>\n<p><code class=\"language-text\">repe sacsb</code> 的行为如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">again<span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cx <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">goto</span> done\n\t<span class=\"token keyword\">asm</span> cmp al<span class=\"token punctuation\">,</span> byte ptr es<span class=\"token operator\">:</span><span class=\"token punctuation\">[</span>di<span class=\"token punctuation\">]</span>  <span class=\"token comment\">// sacsw/d的话这里还要换成AX/EAX</span>\n\tdf <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span>di<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>di<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n\tcx<span class=\"token operator\">--</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>zf <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">goto</span> again       <span class=\"token comment\">// repne的话这里就要求ZF=0</span>\ndone<span class=\"token operator\">:</span></code></pre></div>\n<h4>2.5.4. 写入字符串指令 <code class=\"language-text\">rep stosb/w/d</code></h4>\n<p>把 AL/AX/EAX 的值写入 ES:DI 指向的目标字符串中。</p>\n<h4>2.5.5. 读取字符串指令 <code class=\"language-text\">lodsb/w/d</code></h4>\n<p>从 DS:SI 所指向的源字符串中读取一个 byte/word/double word 保存到 AL/AX/EAX。</p>\n<blockquote>\n<p>[!info]- 示例：用 <code class=\"language-text\">lodsb</code>、<code class=\"language-text\">stosb</code> 指令过滤掉字符串中的空格并存储到另一字符串中</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">data segment\ns db &quot;Ada Lovelace is often regarded as &quot;\n  db &quot;the first computer programmer.&quot;\nslen = $ - offset s\nt db slen dup(&#39;T&#39;)\ndata ends\n\ncode segment\nassume cs:code, ds:data\nmain:\n   mov ax, data\n   mov ds, ax\n   mov es, ax\n   mov si, offset s; ds:si-&gt;s[0]\n   mov di, offset t; es:di-&gt;t[0]\n   mov cx, slen    ; CX = length of s\n   cld             ; DF = 0\n   jcxz done       ; jump if cx is zero\nagain:\n   lodsb           ; AL=ds:[si], si++\n   cmp al, &#39; &#39;\n   je skip\n   stosb           ; es:[di]=AL, di++\nskip:\n   loop again      ; dec cx\n                   ; jnz again\ndone:\n   xor al, al      ; AL = 00h\n   stosb           ; es:[di]=AL, di++\n   mov ah, 4Ch\n   int 21h\ncode ends\nend main</code></pre></div>\n</blockquote>","frontmatter":{"title":"数据的表示与运算","date":null,"description":null},"fields":{"navJson":null,"category":"[{\"name\":\"课程笔记\",\"to\":\"/course/\"}]"}},"previous":{"fields":{"slug":"/course/custom/fasm/note/3/"},"frontmatter":{"title":"CPU、内存和端口"}},"next":{"fields":{"slug":"/course/custom/fasm/note/5/"},"frontmatter":{"title":"汇编语言进阶"}}},"pageContext":{"id":"0ae01f57-51fd-5ce0-925d-9cb3762c377e","previousPostId":"6237aedd-dc1e-54de-82f9-fe9180626be9","nextPostId":"bf4bec5b-a150-5e93-a617-d0c0f44e06ba"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}