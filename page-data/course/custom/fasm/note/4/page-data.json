{"componentChunkName":"component---src-templates-doc-js","path":"/course/custom/fasm/note/4/","result":{"data":{"site":{"siteMetadata":{"title":"mem 的小站"}},"post":{"id":"94b0ddc3-abd6-57cd-8289-a4b7bea7f0a9","excerpt":"1. 数据传送指令 1.1.1. 赋值指令   可以将 src 的值赋值给 dest，需要注意的是： 两个操作数不能同时为内存变量 两个操作数必须等宽 不能把常数或段寄存器赋值给段寄存器 不允许对 CS 进行赋值 不能用  指令引用寄存器 IP 及 FL。 1.1.2. 堆栈指令 、 指令，参见 [[…","html":"<h2>1. 数据传送指令</h2>\n<h4>1.1.1. 赋值指令 <code class=\"language-text\">mov</code></h4>\n<p><code class=\"language-text\">mov dest, src</code> 可以将 src 的值赋值给 dest，需要注意的是：</p>\n<ul>\n<li>两个操作数不能同时为内存变量</li>\n<li>两个操作数必须等宽</li>\n<li>不能把常数或段寄存器赋值给段寄存器</li>\n<li>不允许对 CS 进行赋值</li>\n<li>不能用 <code class=\"language-text\">mov</code> 指令引用寄存器 IP 及 FL。</li>\n</ul>\n<h4>1.1.2. 堆栈指令</h4>\n<p><code class=\"language-text\">push</code>、<code class=\"language-text\">pop</code> 指令，参见 [[5. 汇编语言进阶]]。</p>\n<h4>1.1.3. 交换指令 <code class=\"language-text\">xchg</code></h4>\n<p><code class=\"language-text\">xchg op1, op2</code> 可以实现：1. 两个寄存器；2. 一个寄存器和一个变量之间的值的<strong>交换</strong>操作。</p>\n<h3>1.2. 输入输出指令</h3>\n<p><code class=\"language-text\">in</code>、<code class=\"language-text\">out</code> 指令，参见 [[3. CPU、内存和端口]]。</p>\n<h3>1.3. 地址传送指令</h3>\n<h4>1.3.1. <code class=\"language-text\">lea</code></h4>\n<p><code class=\"language-text\">lea dest:reg src:mem</code>：load effective address，即取变量 src 的<strong>偏移地址</strong>存储到寄存器 dest 中。</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">lea dx, ds:[1000h]    ; 等价于 mov dx, 1000h\nlea dx, [abc]         ; 等价于 mov dx, offset abc\nlea dx, ds:[bx+si+3]  ; 令dx=bx+si+3，无法直接用mov实现</code></pre></div>\n<h4>1.3.2. <code class=\"language-text\">lds</code>、<code class=\"language-text\">les</code> 等</h4>\n<p><code class=\"language-text\">lds dest:reg, src:mem32</code>、<code class=\"language-text\">les dest:reg, src:mem32</code> 可以取出<strong>保存在变量 src 中的远地址</strong>，且将其中的段地址部分赋值给 DS（<code class=\"language-text\">lds</code> 的行为）或 ES（<code class=\"language-text\">les</code> 的行为），偏移地址部分赋值给 dest 寄存器。等效于如下汇编：</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">mov dest, word ptr [src]     ; 这里dest是一个寄存器名\nmov ds, word ptr[src+2]      ; 如果是les指令这里就是es</code></pre></div>\n<h3>1.4. 标志寄存器传送指令</h3>\n<p><code class=\"language-text\">pushf</code>、<code class=\"language-text\">popf</code> 指令，参见 [[3. CPU、内存和端口]]。</p>\n<h2>2. 转换指令</h2>\n<h3>2.1. 扩充指令</h3>\n<p>详见 [[2. 数据的表示与运算]]。</p>\n<h3>2.2. 换码指令 <code class=\"language-text\">xlat</code></h3>\n<p><code class=\"language-text\">xlat</code>（<strong>没有参数</strong>）会把 byte ptr DS:[BX:AL] 的值赋值给 AL，必须要在操作前让 DS:BX 指向表，AL 指向需要的下标。</p>\n<blockquote>\n<p>[!info]- 利用 xlat 指令将 32 位整数化为 16 进制输出</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">.386\ndata segment use16\nt db &quot;0123456789ABCDEF&quot;\nx dd 2147483647\ndata ends\n\ncode segment use16\nassume cs:code, ds:data\nmain:\n  mov ax, data      ;\\\n  mov ds, ax        ; | ds:bx-&gt;t[0]\n  mov bx, offset t  ;/\n  mov cx, 8\n  mov eax, [x]\nnext:\n  rol eax, 4\n  push eax\n  and eax, 0Fh\n  xlat\n  mov ah, 2\n  mov dl, al\n  int 21h\n  pop eax\n  sub cx, 1\n  jnz next\n  mov ah, 4Ch\n  int 21h\ncode ends\nend main</code></pre></div>\n</blockquote>\n<h2>3. 算术运算指令</h2>\n<p>详见 [[2. 数据的表示与运算]]。</p>\n<h2>4. 十进制调整指令</h2>\n<p>咕咕咕。</p>\n<h2>5. 逻辑运算指令和移位指令</h2>\n<p>详见 [[2. 数据的表示与运算]]。</p>\n<h2>6. 字符串操作指令</h2>\n<p>详见 [[2. 数据的表示与运算]]。</p>\n<h2>7. 控制转移指令</h2>\n<h3>7.1. 无条件跳转指令 <code class=\"language-text\">jmp</code></h3>\n<p>根据跳转距离的远近，可以将 <code class=\"language-text\">jmp</code> 分成三类：</p>\n<ul>\n<li>短跳（short jump）：跳转距离用一个字节表示</li>\n<li>近跳（near jump）：跳转距离或目标地址用一个字表示</li>\n<li>远跳（far jump）：目标地址用一个原指针表示</li>\n</ul>\n<h4>7.1.1. <code class=\"language-text\">jmp short dest</code></h4>\n<p>短跳的机器码由 2 个字节构成 <code class=\"language-text\">0EBh, idata8</code>。其中 <code class=\"language-text\">idata8</code> 是一个 8 位整数，表示短跳的跳转距离。在编写汇编程序的过程中，我们可以使用标号代替，编译器会自动计算出标号与下条指令之间的距离，公式如下：</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mtext>idata8</mtext><mo>=</mo><mtext>标号</mtext><mo>−</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">$</mi><mo>+</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{idata8} = \\text{标号} - (\\$ + 2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">idata8</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">标号</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">$</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span></span></div>\n<p>这里 <code class=\"language-text\">$</code> 表示的是短跳指令自身的偏移地址，故 <code class=\"language-text\">$+2</code> 实际上就是下条指令的偏移地址。</p>\n<h4>7.1.2. <code class=\"language-text\">jmp near ptr dest</code></h4>\n<p>近跳的机器码由 3 个字节构成 <code class=\"language-text\">0E9h, idata16_ls, idata16_hs</code>。其中 <code class=\"language-text\">idata16_ls</code> 和 <code class=\"language-text\">idata16_hs</code> 分别是 <code class=\"language-text\">idata16</code> 的低 8 位和高 8 位，同样的 <code class=\"language-text\">idata16</code> 就是近跳的目标地址和<strong>下条指令</strong>的偏移地址之差，计算公式如下：</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mtext>idata16</mtext><mo>=</mo><mtext>标号</mtext><mo>−</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">$</mi><mo>+</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{idata16} = \\text{标号} - (\\$ + 3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">idata16</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">标号</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">$</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">3</span><span class=\"mclose\">)</span></span></span></span></span></div>\n<p>由于近跳和短跳相比多了一个字节，故下条指令的地址变成了 <code class=\"language-text\">$+3</code>。在使用近跳指令时，<code class=\"language-text\">near ptr</code> <strong>可以省略</strong>不写。</p>\n<p>近跳指令还支持直接给定目标地址的偏移地址，格式为 <code class=\"language-text\">jmp reg16|mem16</code>，相当于直接给 IP 寄存器赋值。注意这里如果是 <code class=\"language-text\">mem16</code> 的话别忘了用 <code class=\"language-text\">word ptr</code> 修饰宽度。</p>\n<h4>7.1.3. <code class=\"language-text\">jmp far ptr dest</code></h4>\n<p>远跳的字节码有 5 个字节构成，<code class=\"language-text\">0EAh, idata32_l16, idata32_h16</code>。其中 <code class=\"language-text\">idata32</code> 是一个 32 位的远指针，表示跳转的目标地址，其端地址就是 <code class=\"language-text\">idata32_h16</code>，偏移地址就是 <code class=\"language-text\">idata32_l16</code>。注意这里的地址仍然是<strong>小端存储</strong>。例如：机器码 <code class=\"language-text\">0EAh, 78h, 56h, 34h, 12h</code> 对应的目标地址是 1234:5678。</p>\n<p>当远跳指令<strong>向后引用</strong>（引用的变量或标号在当前语句的上方）一个不在同一段内的<strong>远标号</strong>时，<code class=\"language-text\">far ptr</code> <strong>可以省略</strong>不写；否则必须写出 <code class=\"language-text\">far ptr</code> 不然 CPU 会报错：</p>\n<ul>\n<li>当引用了一个不在同一段的<strong>近标号</strong>而不写明 <code class=\"language-text\">far ptr</code> 时会报“Near JMP/CALL to different CS”错误</li>\n<li>当<strong>向前引用</strong>（引用的变量或标号在当前语句下方）了一个不在同一段内的原标号而不写明 <code class=\"language-text\">far ptr</code> 时会报“Forward needs override or FAR”错误。（不过这一问题可以通过用 <code class=\"language-text\">tasm /m2</code> 代替 <code class=\"language-text\">masm</code> 编译来解决）</li>\n</ul>\n<p>远跳指令可以跳转到远标号（定义方法：<code class=\"language-text\">标号名 label far</code>），也可以直接给定目标地址，相当于同时修改了 CS 和 IP 寄存器的值。示例代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"asm\"><pre class=\"language-asm\"><code class=\"language-asm\">mov word ptr es:[di], 5678h\nmov word ptr es:[di+4], 1234h\njmp dword ptr es:[di]  ; 将会跳转到1234:5678</code></pre></div>\n<h3>7.2. 条件跳转指令 <code class=\"language-text\">jcc</code></h3>\n<ul>\n<li>关于 <code class=\"language-text\">test</code> 指令（相当于只影响寄存器的 <code class=\"language-text\">and</code> 指令）的 JCC 指令有 <code class=\"language-text\">jz</code> 和 <code class=\"language-text\">jnz</code>。通过对两操作数执行 <code class=\"language-text\">test</code> 指令，如果他们的逻辑与的值为 0，ZF 就会被置 1，这时可用 <code class=\"language-text\">jz</code> 指令跳转。</li>\n<li>关于 <code class=\"language-text\">cmp</code> 指令（相当于只影响寄存器的 <code class=\"language-text\">sub</code> 指令）的 JCC 指令有 <code class=\"language-text\">je</code>、<code class=\"language-text\">ja</code> 、<code class=\"language-text\">jb</code>、<code class=\"language-text\">jl</code>、<code class=\"language-text\">jg</code> 、<code class=\"language-text\">jae</code>、<code class=\"language-text\">jbe</code>、<code class=\"language-text\">jle</code>、<code class=\"language-text\">jge</code> 等。</li>\n<li>进一步地、关于标志寄存器的 JCC 指令有 <code class=\"language-text\">jc</code>、<code class=\"language-text\">jnc</code>、<code class=\"language-text\">jz</code>、<code class=\"language-text\">jnz</code>、<code class=\"language-text\">js</code>、<code class=\"language-text\">jns</code>、<code class=\"language-text\">jo</code>、<code class=\"language-text\">jno</code>、<code class=\"language-text\">jp</code>、<code class=\"language-text\">jnp</code> 十个，分别对应相应的标志寄存器。</li>\n<li>特别地，还有 <code class=\"language-text\">jcxz</code> 和 <code class=\"language-text\">jexcz</code> 指令，检查 CX 或 ECX 寄存器是否为 0，是的话则跳转，往往和 <code class=\"language-text\">loop</code> 指令配合使用。</li>\n</ul>\n<p>注意 JCC 指令的跳转距离为 1 字节，也就是说跳转的目标地址和下条指令的偏移地址的之间的距离必须在 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mo>−</mo><mn>128</mn><mo separator=\"true\">,</mo><mn>127</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[-128,127]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">−</span><span class=\"mord\">128</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">127</span><span class=\"mclose\">]</span></span></span></span></span> 的范围内。</p>\n<h3>7.3. 循环指令 <code class=\"language-text\">loop</code></h3>\n<p><code class=\"language-text\">loop dest</code> 指令会<strong>先</strong>将 CX 寄存器的值自减，再检查 CX 是否不等于零，如果是的话则跳转到 <code class=\"language-text\">dest</code> 标号处。在不能确定 CX 的初值非零的情况下，最好先用 <code class=\"language-text\">jcxz</code> 指令判断，避免程序陷入“死循环”中。</p>\n<p><code class=\"language-text\">loop</code> 指令与 JCC 指令一样，跳转距离为 1 字节。</p>\n<blockquote>\n<p>[!info] 例：求 1+2+3 的和</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  mov ax, 0\n  mov cx, 3\nnext:\n  add ax, cx\n  loop next</code></pre></div>\n<p>这里的 <code class=\"language-text\">loop next</code> 等价于 <code class=\"language-text\">dec cx</code> 和 <code class=\"language-text\">jnz next</code> 这两条指令。</p>\n</blockquote>\n<h3>7.4. 子程序调用与返回指令 <code class=\"language-text\">call</code>、<code class=\"language-text\">ret</code> 、<code class=\"language-text\">retf</code></h3>\n<p>详见 [[5. 汇编语言进阶]] 的函数部分。</p>\n<h3>7.5. 中断和中断返回指令 <code class=\"language-text\">int</code>、<code class=\"language-text\">int3</code>、<code class=\"language-text\">into</code>、<code class=\"language-text\">iret</code></h3>\n<p>详见 [[5. 汇编语言进阶]] 的中断程序设计部分。</p>","frontmatter":{"title":"8086指令系统","date":null,"description":null},"fields":{"category":"[{\"name\":\"课程笔记\",\"to\":\"/course/\"}]"}},"previous":null,"next":null},"pageContext":{"id":"94b0ddc3-abd6-57cd-8289-a4b7bea7f0a9","previousPostId":null,"nextPostId":null,"navJson":"[{\"slug\":\"/course/custom/fasm\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/custom/fasm/index.md\",\"title\":\"课程简介\"},{\"title\":\"笔记\",\"children\":[{\"slug\":\"/course/custom/fasm/note/1\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/custom/fasm/note/1.md\",\"title\":\"汇编语言入门\"},{\"slug\":\"/course/custom/fasm/note/2\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/custom/fasm/note/2.md\",\"title\":\"数据的表示与运算\"},{\"slug\":\"/course/custom/fasm/note/3\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/custom/fasm/note/3.md\",\"title\":\"CPU、内存和端口\"},{\"slug\":\"/course/custom/fasm/note/4\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/custom/fasm/note/4.md\",\"title\":\"8086指令系统\"},{\"slug\":\"/course/custom/fasm/note/5\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/custom/fasm/note/5.md\",\"title\":\"汇编语言进阶\"}]}]"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}