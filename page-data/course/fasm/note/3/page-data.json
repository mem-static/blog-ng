{"componentChunkName":"component---src-templates-post-js","path":"/course/fasm/note/3/","result":{"data":{"site":{"siteMetadata":{"title":"mem 的小站"}},"post":{"id":"08c1b574-dc95-56a0-8617-a3ec875e083f","excerpt":"1. CPU 从存储器中取一条指令 分析指令的操作码 从存储器中读取操作数 执行指令 写入结果集 回到 1. 运算器进行信息处理，寄存器进行信息存储，控制器控制各种器件工作，总线连接各种器件。   16 位操作系统中的中断调用相当于 32 位操作系统中的 API 调用。16 位操作系统中的段地址和偏移地址在 3…","html":"<h2 id=\"1-CPU\" style=\"position:relative;\">1. CPU<a href=\"#1-CPU\" aria-label=\"1 CPU permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ol>\n<li>从存储器中取一条指令</li>\n<li>分析指令的操作码</li>\n<li>从存储器中读取操作数</li>\n<li>执行指令</li>\n<li>写入结果集</li>\n<li>回到 1.</li>\n</ol>\n<img src=\"https://static.memset0.cn/img/v6/2024/02/12/DohzKqKA.png\" alt=\"\" style=\"max-width: 33em\">\n<p>运算器进行信息处理，寄存器进行信息存储，控制器控制各种器件工作，总线连接各种器件。</p>\n<p><details open disabled class=\"callout callout-type-info\"><summary>16 位和 32 位操作系统的区别</summary><div><p></p><ul>\n<li>16 位操作系统中的中断调用相当于 32 位操作系统中的 API 调用。16 位操作系统中的段地址和偏移地址在 32 位中消失了，在 32 位操作系统中统一采用平坦的内存地址模式寻址。</li>\n<li>16 位操作系统中的程序运行在 RING0 级，也就是说普通程序和操作系统运行在同一个级别并拥有最高权限，而 32 位操作系统中的程序一般只拥有 RING3 级运行权限，程序的所有操作都受到操作系统控制，若程序要获得 RING0 操作特权，只能通过驱动程序实现。</li>\n<li>16 位操作系统的可执行文件格式和 32 位操作系统的可执行文件格式不同，在 32 位的 windows 操作系统中，可执行文件的格式叫 PE 格式，32 位的 windows 操作系统运行在 CPU 的保护模式之上，而 16 位的系统则运行在 CPU 的实模式上。</li>\n</ul></div></details></p>\n<h2 id=\"2-内存\" style=\"position:relative;\">2. 内存<a href=\"#2-%E5%86%85%E5%AD%98\" aria-label=\"2 内存 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"21-地址\" style=\"position:relative;\">2.1. 地址<a href=\"#21-%E5%9C%B0%E5%9D%80\" aria-label=\"21 地址 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>8086 汇编中可供使用的内存空间有 1MB。故<strong>物理地址</strong>的取值范围为 00000h 到 0FFFFFh。由于没有 20 位的寄存器来直接表示物理地址，我们一般采用<strong>逻辑地址</strong>来间接访问物理地址。逻辑地址由 16 位段地址：16 位偏移地址构成，计算方式为：</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mtext>物理地址</mtext><mo>=</mo><mtext>段地址</mtext><mo>×</mo><mn>10</mn><mi>h</mi><mo>+</mo><mtext>偏移地址</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{物理地址} = \\text{段地址} \\times 10h + \\text{偏移地址}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">物理地址</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">段地址</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord\">10</span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">偏移地址</span></span></span></span></span></span></div>\n<p>故一个段可以表示的内存有 64KB，且其是首地址的物理地址的 16 进制表示的个位必然是 0。</p>\n<p>选用不同的偏移地址，对应的段可能会有重合。一个端的结束地址即起始地址加上 10000h。</p>\n<h4 id=\"211-偏移地址和段地址\" style=\"position:relative;\">2.1.1. 偏移地址和段地址<a href=\"#211-%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%92%8C%E6%AE%B5%E5%9C%B0%E5%9D%80\" aria-label=\"211 偏移地址和段地址 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<div class=\"gatsby-highlight\" data-language=\"armasm\"><pre class=\"language-armasm\"><code class=\"language-armasm\">data segment\na db <span class=\"token string\">\"ABC\"</span>\ns db <span class=\"token string\">\"Hello<span class=\"token variable\">$World</span>\"</span><span class=\"token punctuation\">,</span> 0Dh<span class=\"token punctuation\">,</span> 0Ah<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span>\ndata ends</code></pre></div>\n<p>这里数组 a 和 s 都在 data 段中，data 段的首字节为 a[0]，数组 s 的偏移地址为 offset s = 3，因为 s[0] 和 a[0] 的距离是 3 字节。</p>\n<ul>\n<li>\n<p>使用 <code class=\"language-text\">offset 变量名或标号名</code> 来引用变量或标号的偏移地址。</p>\n</li>\n<li>\n<p>使用 <code class=\"language-text\">seg 变量名或标号名</code> 或 <code class=\"language-text\">段名</code> 来引用段地址。比如使用 <code class=\"language-text\">mov ax, data</code> 语句的效果和 <code class=\"language-text\">mov ax, seg s</code> 或 <code class=\"language-text\">mov ax, seg a</code> 的效果一样。</p>\n</li>\n</ul>\n<h4 id=\"212-直接寻址和间接寻址\" style=\"position:relative;\">2.1.2. 直接寻址和间接寻址<a href=\"#212-%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E5%92%8C%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80\" aria-label=\"212 直接寻址和间接寻址 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><strong>直接寻址</strong>的两种方式：</p>\n<ol>\n<li><code class=\"language-text\">段寄存器:[常数]</code>；如：<code class=\"language-text\">cs:[1000h]</code>，<code class=\"language-text\">ds:[2000h]</code>。</li>\n<li><code class=\"language-text\">段寄存器:var[常数]</code> 等价于 <code class=\"language-text\">段寄存器:[var+常数]</code>，这里 var 是程序里定义的变量名或函数名；如 <code class=\"language-text\">ds:s[-2]</code> 等价于 <code class=\"language-text\">ds:[s-2]</code>，编译器在编译期会自动把 var 的偏移地址给加进来，如 offset s=8，则编译后变为 <code class=\"language-text\">ds:[7]</code>。</li>\n</ol>\n<p>直接寻址时的缺省段址为 DS，即在不指定段寄存器时，默认为 DS。</p>\n<p><strong>间接寻址</strong>的两种方式：</p>\n<ol>\n<li><code class=\"language-text\">段寄存器:[寄存器(+常数)]</code>，仅 BX、BP、SI、DI 四个寄存器可选。</li>\n<li><code class=\"language-text\">段寄存器:[寄存器+寄存器(+常数)]</code>，其中一个必须从 BX、BP 中选，另一个必须从 SI、DI 中选。</li>\n</ol>\n<p>间接寻址时如果寄存器中有 BP，则缺省段址为 SS，否则也为 DS。</p>\n<p><details open disabled class=\"callout callout-type-note\"><summary>笔记</summary><div><p></p><ul>\n<li>直接寻址和间接寻址的区别在于寻址时通不通过寄存器（只能是四个中的一个）</li>\n<li>缺省段址的规则可以简记为出现寄存器 BP 时为 SS，否则为 DS。</li>\n</ul></div></details></p>\n<p><details open disabled class=\"callout callout-type-info\"><summary>在 32 位系统中...</summary><div><p>\n在 32 位系统中，新增了用 <code class=\"language-text\">寄存器+寄存器*n+常数</code>（这里 <code class=\"language-text\">n</code> 可以为 2、4、8）的寻址方法，可以方便数组的访问。与 16 位系统不同，32 位系统中对中括号中的寄存器没有要求，EBP、EBX、EDI、EAX、ECX、EDX、ESP 都可以放在中括号中。</p></div></details></p>\n<h4 id=\"213-小端规则\" style=\"position:relative;\">2.1.3. 小端规则<a href=\"#213-%E5%B0%8F%E7%AB%AF%E8%A7%84%E5%88%99\" aria-label=\"213 小端规则 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>当 CPU 把大于 8 位的数据写入内存时，会遵循<strong>小端规则</strong>：会先写入<strong>低</strong> 8 位再写入<strong>高</strong> 8 位。</p>\n<h4 id=\"214-宽度修饰\" style=\"position:relative;\">2.1.4. 宽度修饰<a href=\"#214-%E5%AE%BD%E5%BA%A6%E4%BF%AE%E9%A5%B0\" aria-label=\"214 宽度修饰 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>汇编语言中可以通过这 3 个宽度修饰词限定变量的宽度：</p>\n<ul>\n<li><code class=\"language-text\">byte ptr</code>：8 位（1 字节）</li>\n<li><code class=\"language-text\">word ptr</code>：16 位（2 字节）</li>\n<li><code class=\"language-text\">dword ptr</code>：32 位（4 字节）</li>\n</ul>\n<p>在符合这两种情况时，不需要加宽度修饰：</p>\n<ul>\n<li>指令中的变量有变量名：可以根据变量的声明确认宽度</li>\n<li>指令中的另一个操作数有明确宽度（比如寄存器）：说明当前变量的宽度需与另一操作数的确定宽度保持一致</li>\n</ul>\n<p>对于 <code class=\"language-text\">mov ds:[bx], 1</code> 这种指令，其中一个变量没有变量名修饰，也没法根据另一个操作数来确定宽度，这时候就需要用宽度修饰符来修饰。</p>\n<h4 id=\"215-地址传送指令\" style=\"position:relative;\">2.1.5. 地址传送指令<a href=\"#215-%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4\" aria-label=\"215 地址传送指令 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>详见 <a href=\"/course/fasm/note/4/\">IV 8086指令系统</a>。</p>\n<h3 id=\"22-内存空间划分\" style=\"position:relative;\">2.2. 内存空间划分<a href=\"#22-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86\" aria-label=\"22 内存空间划分 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h3 id=\"23-显卡\" style=\"position:relative;\">2.3. 显卡<a href=\"#23-%E6%98%BE%E5%8D%A1\" aria-label=\"23 显卡 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h4 id=\"231-文本模式的显卡地址映射\" style=\"position:relative;\">2.3.1. 文本模式的显卡地址映射<a href=\"#231-%E6%96%87%E6%9C%AC%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%98%BE%E5%8D%A1%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84\" aria-label=\"231 文本模式的显卡地址映射 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>文本模式下显卡共 <strong>80×25</strong> 个位置，以左上角为原点。显卡将被映射到 B800 这个段，每个屏幕上的字符占用两个内存单元，前一个（如 B800:0000）决定字符，后一个（如 B800:0001）决定前景色和背景色。屏幕上某个字符的偏移地址可以这样计算：</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mtext>offset</mtext><mo>=</mo><mo stretchy=\"false\">(</mo><mi>y</mi><mo>×</mo><mn>80</mn><mo>+</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mn>2</mn><mo>+</mo><mo stretchy=\"false\">(</mo><mtext>存储文本 </mtext><mo stretchy=\"false\">?</mo><mtext> </mtext><mn>0</mn><mo>:</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{offset} = (y \\times 80+x)\\times 2 + (\\text{存储文本}\\ ?\\ 0:1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">offset</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">80</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">存储文本</span></span><span class=\"mspace\"> </span><span class=\"mclose\">?</span><span class=\"mspace\"> </span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></div>\n<h4 id=\"232-图形模式的显卡地址映射\" style=\"position:relative;\">2.3.2. 图形模式的显卡地址映射<a href=\"#232-%E5%9B%BE%E5%BD%A2%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%98%BE%E5%8D%A1%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84\" aria-label=\"232 图形模式的显卡地址映射 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>图形模式下共支持 <strong>320×200</strong> 个像素点，以左上角为原点。显卡将被映射到 A000 这个段。一个内存地址表示一个像素点，故屏幕上某像素的偏移地址可以这样计算：</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mtext>offset</mtext><mo>=</mo><mi>y</mi><mo>×</mo><mn>320</mn><mo>+</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">\\text{offset} = y \\times 320 +x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">offset</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">320</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span></div>\n<img src=\"https://static.memset0.cn/img/v6/2024/02/08/N0X5wLg1.png\" alt=\"Pasted image 20240109190925\" style=\"max-width: 30em\">\n<h2 id=\"3-寄存器\" style=\"position:relative;\">3. 寄存器<a href=\"#3-%E5%AF%84%E5%AD%98%E5%99%A8\" aria-label=\"3 寄存器 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"31-通用寄存器\" style=\"position:relative;\">3.1. 通用寄存器<a href=\"#31-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8\" aria-label=\"31 通用寄存器 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>通用寄存器包括：</p>\n<ul>\n<li>AX：Accumulator 累加器（和 <code class=\"language-text\">mul</code>、<code class=\"language-text\">div</code> 有关）</li>\n<li>BX：Base 基地址寄存器（和取地址有关，如 <code class=\"language-text\">ds:[bx]</code>）</li>\n<li>CX：Count 计数器（和 <code class=\"language-text\">loop</code> 指令有关）</li>\n<li>DX：Data 数据寄存器（和 <code class=\"language-text\">mul</code>、<code class=\"language-text\">div</code> 有关，也与输入输出的暂存有关）</li>\n</ul>\n<h3 id=\"32-段地址寄存器\" style=\"position:relative;\">3.2. 段地址寄存器<a href=\"#32-%E6%AE%B5%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8\" aria-label=\"32 段地址寄存器 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>段地址寄存器包括：</p>\n<ul>\n<li>CS：代码段寄存器，CS:IP 指向当前将要执行的指令。\n<ul>\n<li>只能通过 <code class=\"language-text\">jmp far ptr</code>、<code class=\"language-text\">jmp dword ptr</code>、<code class=\"language-text\">call far ptr</code>、<code class=\"language-text\">retf</code>、<code class=\"language-text\">int</code>、<code class=\"language-text\">iret</code> 等指令间接改变，<strong>不能</strong>通过 <code class=\"language-text\">mov</code> 指令直接修改。</li>\n</ul>\n</li>\n<li>DS：数据段寄存器。\n<ul>\n<li>在开始运行时，DS 内的数据并不是数据段的段地址，而是 PSP 段址，因此需要手动先 <code class=\"language-text\">mov ax, data</code> 再 <code class=\"language-text\">mov dx, ax</code> 来将 DS 设为数据段的段址。</li>\n</ul>\n</li>\n<li>ES：附加段寄存器。</li>\n<li>SS：堆栈段寄存器，SS:SP 指向堆栈顶端。</li>\n</ul>\n<p>DS、ES、SS 寄存器可以用 <code class=\"language-text\">mov</code> 指令赋值，但源操作数不能是常数，只能是寄存器或变量。可以对段寄存器赋值的寄存器仅限 AX、BX、CX、DX、SP、BP、SI、DI，变量必须是 word ptr 宽度的。</p>\n<h3 id=\"33-偏移地址寄存器\" style=\"position:relative;\">3.3. 偏移地址寄存器<a href=\"#33-%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8\" aria-label=\"33 偏移地址寄存器 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>偏移地址寄存器包括：IP、SP、BP、SI、DI，其中 IP 必须搭配 CS 使用，SP 必须搭配 SS 使用。</p>\n<p>特别的，BX 也可以作为偏移地址寄存器使用，故实际能放在 <code class=\"language-text\">[]</code> 被用于间接寻址的寄存器有：BX、BP、SI、DI。这四个寄存器除了用于间接寻址外，也可以正常参与运算。</p>\n<h3 id=\"34-标志寄存器\" style=\"position:relative;\">3.4. 标志寄存器<a href=\"#34-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8\" aria-label=\"34 标志寄存器 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>FL 是标志寄存器，共16个位，其中6个是状态标志：CF、ZF、SF、OF、PF、AF，3个是控制标志：DF、IF、TF，还有7个是保留位。</p>\n<p>标志寄存器的值不能被直接修改，但是可以通过 <code class=\"language-text\">pushf</code> 和 <code class=\"language-text\">popf</code> 被存入/取出到堆栈中，因此也可以搭配 <code class=\"language-text\">push</code>，<code class=\"language-text\">pop</code> 指令和别的寄存器对其进行简介修改。</p>\n<p>CF、ZF、SF、OF、PF 寄存器都有与之相关的跳转指令，如：<code class=\"language-text\">jc</code> 表示 jump if carry，即 CF=1 时跳转；<code class=\"language-text\">jnc</code> 表示 jump if not carry，即 CF=0 时跳转。他们被称作 JCC 指令，在 <a href=\"/course/fasm/note/4/\">IV 8086指令系统</a> 中会进一步介绍。</p>\n<p>CF、DF、IF 寄存器有与之相关的设置或清空指令，如：<code class=\"language-text\">clc</code> 表示 clear carry，即将 CF 置 0；<code class=\"language-text\">stc</code> 表示 set carry，即将 CF 置 1。</p>\n<h4 id=\"341-进位标志CFCarry-Flag\" style=\"position:relative;\">3.4.1. 进位标志CF（Carry Flag）<a href=\"#341-%E8%BF%9B%E4%BD%8D%E6%A0%87%E5%BF%97CFCarry-Flag\" aria-label=\"341 进位标志CFCarry Flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>CF 会被加减、乘法、移位运算影响，发生下列事件时 CF 会被置 1，否则置 0：</p>\n<ul>\n<li>两数相加（最高位）发生进位</li>\n<li>两数相减（最高位）发生借位</li>\n<li>两数相乘的宽度超过被乘数的宽度</li>\n<li>移位时<strong>最后被移除</strong>的一位为 1</li>\n</ul>\n<h4 id=\"342-零标志-ZFZero-Flag\" style=\"position:relative;\">3.4.2. 零标志 ZF（Zero Flag）<a href=\"#342-%E9%9B%B6%E6%A0%87%E5%BF%97-ZFZero-Flag\" aria-label=\"342 零标志 ZFZero Flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>ZF 会被算术运算、逻辑运算、移位运算影响，运算结果不等于 0 时 ZF 置1，否则 ZF 置0。</p>\n<h4 id=\"343-符号标志-SFSign-Flag\" style=\"position:relative;\">3.4.3. 符号标志 SF（Sign Flag）<a href=\"#343-%E7%AC%A6%E5%8F%B7%E6%A0%87%E5%BF%97-SFSign-Flag\" aria-label=\"343 符号标志 SFSign Flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>CF 会被算术运算、逻辑运算、移位运算影响，SF 将被置为运算结果的<strong>最高位</strong>。</p>\n<h4 id=\"344-溢出标志-OFOverflow-Flag\" style=\"position:relative;\">3.4.4. 溢出标志 OF（Overflow Flag）<a href=\"#344-%E6%BA%A2%E5%87%BA%E6%A0%87%E5%BF%97-OFOverflow-Flag\" aria-label=\"344 溢出标志 OFOverflow Flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>OF 会被 <code class=\"language-text\">add</code>、<code class=\"language-text\">sub</code>、<code class=\"language-text\">mul</code>、<code class=\"language-text\">imul</code> 指令影响，发生下列事件时 OF 会被置 1，否则置 0：</p>\n<ul>\n<li>两个正数相加变负数</li>\n<li>两个负数相加变正数</li>\n<li>两数相乘的乘积宽度超过被乘数宽度</li>\n<li>移位前后<strong>最高位</strong>发生改变</li>\n</ul>\n<h4 id=\"345-奇偶校验标志-PFParity-Flag\" style=\"position:relative;\">3.4.5. 奇偶校验标志 PF（Parity Flag）<a href=\"#345-%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E6%A0%87%E5%BF%97-PFParity-Flag\" aria-label=\"345 奇偶校验标志 PFParity Flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>ZF 会被算术运算、逻辑运算、移位运算影响，运算结果的低八位有偶数个 1 时将 PF 置 1，否则将 PF 置 0。</p>\n<h4 id=\"346-辅助进位标志-AFAuxiliary-Flag\" style=\"position:relative;\">3.4.6. 辅助进位标志 AF（Auxiliary Flag）<a href=\"#346-%E8%BE%85%E5%8A%A9%E8%BF%9B%E4%BD%8D%E6%A0%87%E5%BF%97-AFAuxiliary-Flag\" aria-label=\"346 辅助进位标志 AFAuxiliary Flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>AX 会被 <code class=\"language-text\">add</code> 和 <code class=\"language-text\">sub</code> 指令影响，当第3 位向第 4 位进位/借位时 AF 置 1 否则将 AF 置 0。</p>\n<h4 id=\"347-方向标志DFDirection-Flag\" style=\"position:relative;\">3.4.7. 方向标志DF（Direction Flag）<a href=\"#347-%E6%96%B9%E5%90%91%E6%A0%87%E5%BF%97DFDirection-Flag\" aria-label=\"347 方向标志DFDirection Flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>DF 可以控制 <code class=\"language-text\">rep movsb</code> 的运行方向（类似于 memcpy 函数）。当 DF=0 时，字符串操作按正方向（低地址到高地址）执行；当 DF=1 时，字符串操作按反方向（高地址到低地址）执行。详见 <a href=\"/course/fasm/note/4/\">IV 8086指令系统</a> 中的字符串操作部分。</p>\n<h4 id=\"348-中断标志IFInterrupt-Flag\" style=\"position:relative;\">3.4.8. 中断标志IF（Interrupt Flag）<a href=\"#348-%E4%B8%AD%E6%96%AD%E6%A0%87%E5%BF%97IFInterrupt-Flag\" aria-label=\"348 中断标志IFInterrupt Flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>IF 用于禁止或允许硬件中断。当 IF=0 时禁止硬件中断；当 IF=1时允许硬件中断。</p>\n<p>这样，被 <code class=\"language-text\">cli</code> 到 <code class=\"language-text\">sti</code> 包裹起来的代码在执行时就不会被硬件中断，可在需要修改中断向量等场景下。</p>\n<h4 id=\"349-陷阱标志Trap-Flag\" style=\"position:relative;\">3.4.9. 陷阱标志（Trap Flag）<a href=\"#349-%E9%99%B7%E9%98%B1%E6%A0%87%E5%BF%97Trap-Flag\" aria-label=\"349 陷阱标志Trap Flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>TF 用于让 CPU 进入单步模式。当 TF=1 时，每执行一条指令后，CPU 会自动插入一条 <code class=\"language-text\">int 01h</code> 中断。</p>\n<h2 id=\"4-端口\" style=\"position:relative;\">4. 端口<a href=\"#4-%E7%AB%AF%E5%8F%A3\" aria-label=\"4 端口 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>端口地址与内存地址独立，仅有 16 位偏移地址，其取值范围是 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mtext>0000h:0FFFFh</mtext><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[\\text{0000h:0FFFFh}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord text\"><span class=\"mord\">0000h:0FFFFh</span></span><span class=\"mclose\">]</span></span></span></span></span>。CPU 不能直接对 I/O 设备进行控制，需要通过向端口发送控制信号或读取来自端口的信号，指令如下：</p>\n<ul>\n<li><code class=\"language-text\">in 寄存器 端口地址</code>：从端口读入信号并存储到寄存器中。</li>\n<li><code class=\"language-text\">out 端口地址 寄存器</code>：将寄存器的值发送到对应端口。</li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-cpu\">1. CPU</a></p>\n</li>\n<li>\n<p><a href=\"#2-%E5%86%85%E5%AD%98\">2. 内存</a></p>\n<ul>\n<li><a href=\"#21-%E5%9C%B0%E5%9D%80\">2.1. 地址</a></li>\n<li><a href=\"#22-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86\">2.2. 内存空间划分</a></li>\n<li><a href=\"#23-%E6%98%BE%E5%8D%A1\">2.3. 显卡</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-%E5%AF%84%E5%AD%98%E5%99%A8\">3. 寄存器</a></p>\n<ul>\n<li><a href=\"#31-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8\">3.1. 通用寄存器</a></li>\n<li><a href=\"#32-%E6%AE%B5%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8\">3.2. 段地址寄存器</a></li>\n<li><a href=\"#33-%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8\">3.3. 偏移地址寄存器</a></li>\n<li><a href=\"#34-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8\">3.4. 标志寄存器</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-%E7%AB%AF%E5%8F%A3\">4. 端口</a></p>\n</li>\n</ul>","frontmatter":{"title":"III CPU、内存和端口","date":null,"description":null},"fields":{"cover":null,"slug":"/course/fasm/note/3/","isDoc":true,"category":"[{\"name\":\"课程笔记\",\"to\":\"/course/\"}]","propsJson":null}},"previous":null,"next":null},"pageContext":{"id":"08c1b574-dc95-56a0-8617-a3ec875e083f","previousPostId":null,"nextPostId":null,"navJson":"[{\"slug\":\"/course/fasm\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/index.md\",\"title\":\"课程简介\"},{\"title\":\"笔记\",\"children\":[{\"slug\":\"/course/fasm/note/1\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/1.md\",\"title\":\"I 汇编语言入门\"},{\"slug\":\"/course/fasm/note/2\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/2.md\",\"title\":\"II 数据的表示与运算\"},{\"slug\":\"/course/fasm/note/3\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/3.md\",\"title\":\"III CPU、内存和端口\"},{\"slug\":\"/course/fasm/note/4\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/4.md\",\"title\":\"IV 8086指令系统\"},{\"slug\":\"/course/fasm/note/5\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/5.md\",\"title\":\"V 汇编语言进阶\"}]}]"}},"staticQueryHashes":[],"slicesMap":{}}