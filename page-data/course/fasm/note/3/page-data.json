{"componentChunkName":"component---src-templates-post-js","path":"/course/fasm/note/3/","result":{"data":{"site":{"siteMetadata":{"title":"mem 的小站"}},"post":{"id":"08c1b574-dc95-56a0-8617-a3ec875e083f","excerpt":"1. CPU 从存储器中取一条指令 分析指令的操作码 从存储器中读取操作数 执行指令 写入结果集 回到 1. 运算器进行信息处理，寄存器进行信息存储，控制器控制各种器件工作，总线连接各种器件。  16 位和 32 位操作系统的区别  16 位操作系统中的中断调用相当于 32 位操作系统中的 API 调用。1…","html":"<h2 id=\"anchor-07ad748f54d37719\" style=\"position: relative;\"><a href=\"#anchor-07ad748f54d37719\" aria-label=\"anchor 07ad748f54d37719 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. CPU</h2>\n<ol>\n<li>从存储器中取一条指令</li>\n<li>分析指令的操作码</li>\n<li>从存储器中读取操作数</li>\n<li>执行指令</li>\n<li>写入结果集</li>\n<li>回到 1.</li>\n</ol>\n<img src=\"https://static.memset0.cn/img/v6/2024/02/12/DohzKqKA.png\" alt=\"\" style=\"width: 33em\">\n<p>运算器进行信息处理，寄存器进行信息存储，控制器控制各种器件工作，总线连接各种器件。</p>\n<p><details open disabled class=\"callout callout-type-info\"><summary> 16 位和 32 位操作系统的区别</summary><div class=\"callout-content\"><p></p><ul>\n<li>16 位操作系统中的中断调用相当于 32 位操作系统中的 API 调用。16 位操作系统中的段地址和偏移地址在 32 位中消失了，在 32 位操作系统中统一采用平坦的内存地址模式寻址。</li>\n<li>16 位操作系统中的程序运行在 RING0 级，也就是说普通程序和操作系统运行在同一个级别并拥有最高权限，而 32 位操作系统中的程序一般只拥有 RING3 级运行权限，程序的所有操作都受到操作系统控制，若程序要获得 RING0 操作特权，只能通过驱动程序实现。</li>\n<li>16 位操作系统的可执行文件格式和 32 位操作系统的可执行文件格式不同，在 32 位的 windows 操作系统中，可执行文件的格式叫 PE 格式，32 位的 windows 操作系统运行在 CPU 的保护模式之上，而 16 位的系统则运行在 CPU 的实模式上。</li>\n</ul></div></details></p>\n<h2 id=\"anchor-2bed3641595b6d4e\" style=\"position: relative;\"><a href=\"#anchor-2bed3641595b6d4e\" aria-label=\"anchor 2bed3641595b6d4e permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 内存</h2>\n<h3 id=\"anchor-4af8039fd82044d9\" style=\"position: relative;\"><a href=\"#anchor-4af8039fd82044d9\" aria-label=\"anchor 4af8039fd82044d9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. 地址</h3>\n<p>8086 汇编中可供使用的内存空间有 1MB。故<strong>物理地址</strong>的取值范围为 00000h 到 0FFFFFh。由于没有 20 位的寄存器来直接表示物理地址，我们一般采用<strong>逻辑地址</strong>来间接访问物理地址。逻辑地址由 16 位段地址：16 位偏移地址构成，计算方式为：</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mtext>物理地址</mtext><mo>=</mo><mtext>段地址</mtext><mo>×</mo><mn>10</mn><mi>h</mi><mo>+</mo><mtext>偏移地址</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{物理地址} = \\text{段地址} \\times 10h + \\text{偏移地址}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">物理地址</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">段地址</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord\">10</span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord cjk_fallback\">偏移地址</span></span></span></span></span></span></div>\n<p>故一个段可以表示的内存有 64KB，且其是首地址的物理地址的 16 进制表示的个位必然是 0。</p>\n<p>选用不同的偏移地址，对应的段可能会有重合。一个端的结束地址即起始地址加上 10000h。</p>\n<h4 id=\"anchor-fbfafdb2000291af\" style=\"position: relative;\"><a href=\"#anchor-fbfafdb2000291af\" aria-label=\"anchor fbfafdb2000291af permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.1. 偏移地址和段地址</h4>\n<div class=\"gatsby-highlight\" data-language=\"armasm\"><pre class=\"language-armasm\"><code class=\"language-armasm\">data segment\na db <span class=\"token string\">\"ABC\"</span>\ns db <span class=\"token string\">\"Hello<span class=\"token variable\">$World</span>\"</span><span class=\"token punctuation\">,</span> 0Dh<span class=\"token punctuation\">,</span> 0Ah<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span>\ndata ends</code></pre></div>\n<p>这里数组 a 和 s 都在 data 段中，data 段的首字节为 a[0]，数组 s 的偏移地址为 offset s = 3，因为 s[0] 和 a[0] 的距离是 3 字节。</p>\n<ul>\n<li>\n<p>使用 <code class=\"language-text\">offset 变量名或标号名</code> 来引用变量或标号的偏移地址。</p>\n</li>\n<li>\n<p>使用 <code class=\"language-text\">seg 变量名或标号名</code> 或 <code class=\"language-text\">段名</code> 来引用段地址。比如使用 <code class=\"language-text\">mov ax, data</code> 语句的效果和 <code class=\"language-text\">mov ax, seg s</code> 或 <code class=\"language-text\">mov ax, seg a</code> 的效果一样。</p>\n</li>\n</ul>\n<h4 id=\"anchor-a5d4edc0f6196593\" style=\"position: relative;\"><a href=\"#anchor-a5d4edc0f6196593\" aria-label=\"anchor a5d4edc0f6196593 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.2. 直接寻址和间接寻址</h4>\n<p><strong>直接寻址</strong>的两种方式：</p>\n<ol>\n<li><code class=\"language-text\">段寄存器:[常数]</code>；如：<code class=\"language-text\">cs:[1000h]</code>，<code class=\"language-text\">ds:[2000h]</code>。</li>\n<li><code class=\"language-text\">段寄存器:var[常数]</code> 等价于 <code class=\"language-text\">段寄存器:[var+常数]</code>，这里 var 是程序里定义的变量名或函数名；如 <code class=\"language-text\">ds:s[-2]</code> 等价于 <code class=\"language-text\">ds:[s-2]</code>，编译器在编译期会自动把 var 的偏移地址给加进来，如 offset s=8，则编译后变为 <code class=\"language-text\">ds:[7]</code>。</li>\n</ol>\n<p>直接寻址时的缺省段址为 DS，即在不指定段寄存器时，默认为 DS。</p>\n<p><strong>间接寻址</strong>的两种方式：</p>\n<ol>\n<li><code class=\"language-text\">段寄存器:[寄存器(+常数)]</code>，仅 BX、BP、SI、DI 四个寄存器可选。</li>\n<li><code class=\"language-text\">段寄存器:[寄存器+寄存器(+常数)]</code>，其中一个必须从 BX、BP 中选，另一个必须从 SI、DI 中选。</li>\n</ol>\n<p>间接寻址时如果寄存器中有 BP，则缺省段址为 SS，否则也为 DS。</p>\n<p><details open disabled class=\"callout callout-type-note\"><summary> 笔记</summary><div class=\"callout-content\"><p></p><ul>\n<li>直接寻址和间接寻址的区别在于寻址时通不通过寄存器（只能是四个中的一个）</li>\n<li>缺省段址的规则可以简记为出现寄存器 BP 时为 SS，否则为 DS。</li>\n</ul></div></details></p>\n<p><details open disabled class=\"callout callout-type-info\"><summary> 在 32 位系统中...</summary><div class=\"callout-content\"><p>\n在 32 位系统中，新增了用 <code class=\"language-text\">寄存器+寄存器*n+常数</code>（这里 <code class=\"language-text\">n</code> 可以为 2、4、8）的寻址方法，可以方便数组的访问。与 16 位系统不同，32 位系统中对中括号中的寄存器没有要求，EBP、EBX、EDI、EAX、ECX、EDX、ESP 都可以放在中括号中。</p></div></details></p>\n<h4 id=\"anchor-43f66b89b3825d53\" style=\"position: relative;\"><a href=\"#anchor-43f66b89b3825d53\" aria-label=\"anchor 43f66b89b3825d53 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.3. 小端规则</h4>\n<p>当 CPU 把大于 8 位的数据写入内存时，会遵循<strong>小端规则</strong>：会先写入<strong>低</strong> 8 位再写入<strong>高</strong> 8 位。</p>\n<h4 id=\"anchor-08d4993856e9b073\" style=\"position: relative;\"><a href=\"#anchor-08d4993856e9b073\" aria-label=\"anchor 08d4993856e9b073 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.4. 宽度修饰</h4>\n<p>汇编语言中可以通过这 3 个宽度修饰词限定变量的宽度：</p>\n<ul>\n<li><code class=\"language-text\">byte ptr</code>：8 位（1 字节）</li>\n<li><code class=\"language-text\">word ptr</code>：16 位（2 字节）</li>\n<li><code class=\"language-text\">dword ptr</code>：32 位（4 字节）</li>\n</ul>\n<p>在符合这两种情况时，不需要加宽度修饰：</p>\n<ul>\n<li>指令中的变量有变量名：可以根据变量的声明确认宽度</li>\n<li>指令中的另一个操作数有明确宽度（比如寄存器）：说明当前变量的宽度需与另一操作数的确定宽度保持一致</li>\n</ul>\n<p>对于 <code class=\"language-text\">mov ds:[bx], 1</code> 这种指令，其中一个变量没有变量名修饰，也没法根据另一个操作数来确定宽度，这时候就需要用宽度修饰符来修饰。</p>\n<h4 id=\"anchor-ea67aaf9212bbde6\" style=\"position: relative;\"><a href=\"#anchor-ea67aaf9212bbde6\" aria-label=\"anchor ea67aaf9212bbde6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.5. 地址传送指令</h4>\n<p>详见 <a href=\"/course/fasm/note/4/\">IV 8086指令系统</a>。</p>\n<h3 id=\"anchor-9f1ed298eb10dd6d\" style=\"position: relative;\"><a href=\"#anchor-9f1ed298eb10dd6d\" aria-label=\"anchor 9f1ed298eb10dd6d permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. 内存空间划分</h3>\n<h3 id=\"anchor-4b02b42f448cdb59\" style=\"position: relative;\"><a href=\"#anchor-4b02b42f448cdb59\" aria-label=\"anchor 4b02b42f448cdb59 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. 显卡</h3>\n<h4 id=\"anchor-9f7b7e793c05d180\" style=\"position: relative;\"><a href=\"#anchor-9f7b7e793c05d180\" aria-label=\"anchor 9f7b7e793c05d180 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3.1. 文本模式的显卡地址映射</h4>\n<p>文本模式下显卡共 <strong>80×25</strong> 个位置，以左上角为原点。显卡将被映射到 B800 这个段，每个屏幕上的字符占用两个内存单元，前一个（如 B800:0000）决定字符，后一个（如 B800:0001）决定前景色和背景色。屏幕上某个字符的偏移地址可以这样计算：</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mtext>offset</mtext><mo>=</mo><mo stretchy=\"false\">(</mo><mi>y</mi><mo>×</mo><mn>80</mn><mo>+</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mn>2</mn><mo>+</mo><mo stretchy=\"false\">(</mo><mtext>存储文本 </mtext><mo stretchy=\"false\">?</mo><mtext> </mtext><mn>0</mn><mo>:</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{offset} = (y \\times 80+x)\\times 2 + (\\text{存储文本}\\ ?\\ 0:1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">offset</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">80</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord cjk_fallback\">存储文本</span></span><span class=\"mspace\"> </span><span class=\"mclose\">?</span><span class=\"mspace\"> </span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></div>\n<h4 id=\"anchor-0045840791571bb6\" style=\"position: relative;\"><a href=\"#anchor-0045840791571bb6\" aria-label=\"anchor 0045840791571bb6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3.2. 图形模式的显卡地址映射</h4>\n<p>图形模式下共支持 <strong>320×200</strong> 个像素点，以左上角为原点。显卡将被映射到 A000 这个段。一个内存地址表示一个像素点，故屏幕上某像素的偏移地址可以这样计算：</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mtext>offset</mtext><mo>=</mo><mi>y</mi><mo>×</mo><mn>320</mn><mo>+</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">\\text{offset} = y \\times 320 +x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">offset</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">320</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span></div>\n<img src=\"https://static.memset0.cn/img/v6/2024/02/08/N0X5wLg1.png\" alt=\"Pasted image 20240109190925\" style=\"width: 30em\">\n<h2 id=\"anchor-d2cc713ec69f3016\" style=\"position: relative;\"><a href=\"#anchor-d2cc713ec69f3016\" aria-label=\"anchor d2cc713ec69f3016 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 寄存器</h2>\n<h3 id=\"anchor-f53ce791770343dc\" style=\"position: relative;\"><a href=\"#anchor-f53ce791770343dc\" aria-label=\"anchor f53ce791770343dc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. 通用寄存器</h3>\n<p>通用寄存器包括：</p>\n<ul>\n<li>AX：Accumulator 累加器（和 <code class=\"language-text\">mul</code>、<code class=\"language-text\">div</code> 有关）</li>\n<li>BX：Base 基地址寄存器（和取地址有关，如 <code class=\"language-text\">ds:[bx]</code>）</li>\n<li>CX：Count 计数器（和 <code class=\"language-text\">loop</code> 指令有关）</li>\n<li>DX：Data 数据寄存器（和 <code class=\"language-text\">mul</code>、<code class=\"language-text\">div</code> 有关，也与输入输出的暂存有关）</li>\n</ul>\n<h3 id=\"anchor-d39f4c684b834890\" style=\"position: relative;\"><a href=\"#anchor-d39f4c684b834890\" aria-label=\"anchor d39f4c684b834890 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. 段地址寄存器</h3>\n<p>段地址寄存器包括：</p>\n<ul>\n<li>CS：代码段寄存器，CS:IP 指向当前将要执行的指令。\n<ul>\n<li>只能通过 <code class=\"language-text\">jmp far ptr</code>、<code class=\"language-text\">jmp dword ptr</code>、<code class=\"language-text\">call far ptr</code>、<code class=\"language-text\">retf</code>、<code class=\"language-text\">int</code>、<code class=\"language-text\">iret</code> 等指令间接改变，<strong>不能</strong>通过 <code class=\"language-text\">mov</code> 指令直接修改。</li>\n</ul>\n</li>\n<li>DS：数据段寄存器。\n<ul>\n<li>在开始运行时，DS 内的数据并不是数据段的段地址，而是 PSP 段址，因此需要手动先 <code class=\"language-text\">mov ax, data</code> 再 <code class=\"language-text\">mov dx, ax</code> 来将 DS 设为数据段的段址。</li>\n</ul>\n</li>\n<li>ES：附加段寄存器。</li>\n<li>SS：堆栈段寄存器，SS:SP 指向堆栈顶端。</li>\n</ul>\n<p>DS、ES、SS 寄存器可以用 <code class=\"language-text\">mov</code> 指令赋值，但源操作数不能是常数，只能是寄存器或变量。可以对段寄存器赋值的寄存器仅限 AX、BX、CX、DX、SP、BP、SI、DI，变量必须是 word ptr 宽度的。</p>\n<h3 id=\"anchor-bc84f53c6dbbe218\" style=\"position: relative;\"><a href=\"#anchor-bc84f53c6dbbe218\" aria-label=\"anchor bc84f53c6dbbe218 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3. 偏移地址寄存器</h3>\n<p>偏移地址寄存器包括：IP、SP、BP、SI、DI，其中 IP 必须搭配 CS 使用，SP 必须搭配 SS 使用。</p>\n<p>特别的，BX 也可以作为偏移地址寄存器使用，故实际能放在 <code class=\"language-text\">[]</code> 被用于间接寻址的寄存器有：BX、BP、SI、DI。这四个寄存器除了用于间接寻址外，也可以正常参与运算。</p>\n<h3 id=\"anchor-0860b9ddf8d51271\" style=\"position: relative;\"><a href=\"#anchor-0860b9ddf8d51271\" aria-label=\"anchor 0860b9ddf8d51271 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4. 标志寄存器</h3>\n<p>FL 是标志寄存器，共 16 个位，其中 6 个是状态标志：CF、ZF、SF、OF、PF、AF，3 个是控制标志：DF、IF、TF，还有 7 个是保留位。</p>\n<p>标志寄存器的值不能被直接修改，但是可以通过 <code class=\"language-text\">pushf</code> 和 <code class=\"language-text\">popf</code> 被存入/取出到堆栈中，因此也可以搭配 <code class=\"language-text\">push</code>，<code class=\"language-text\">pop</code> 指令和别的寄存器对其进行简介修改。</p>\n<p>CF、ZF、SF、OF、PF 寄存器都有与之相关的跳转指令，如：<code class=\"language-text\">jc</code> 表示 jump if carry，即 CF=1 时跳转；<code class=\"language-text\">jnc</code> 表示 jump if not carry，即 CF=0 时跳转。他们被称作 JCC 指令，在 <a href=\"/course/fasm/note/4/\">IV 8086指令系统</a> 中会进一步介绍。</p>\n<p>CF、DF、IF 寄存器有与之相关的设置或清空指令，如：<code class=\"language-text\">clc</code> 表示 clear carry，即将 CF 置 0；<code class=\"language-text\">stc</code> 表示 set carry，即将 CF 置 1。</p>\n<h4 id=\"anchor-57a50a1557129067\" style=\"position: relative;\"><a href=\"#anchor-57a50a1557129067\" aria-label=\"anchor 57a50a1557129067 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4.1. 进位标志 CF（Carry Flag）</h4>\n<p>CF 会被加减、乘法、移位运算影响，发生下列事件时 CF 会被置 1，否则置 0：</p>\n<ul>\n<li>两数相加（最高位）发生进位</li>\n<li>两数相减（最高位）发生借位</li>\n<li>两数相乘的宽度超过被乘数的宽度</li>\n<li>移位时<strong>最后被移除</strong>的一位为 1</li>\n</ul>\n<h4 id=\"anchor-8012526be1ff90a4\" style=\"position: relative;\"><a href=\"#anchor-8012526be1ff90a4\" aria-label=\"anchor 8012526be1ff90a4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4.2. 零标志 ZF（Zero Flag）</h4>\n<p>ZF 会被算术运算、逻辑运算、移位运算影响，运算结果不等于 0 时 ZF 置 1，否则 ZF 置 0。</p>\n<h4 id=\"anchor-37cb5051af478bf0\" style=\"position: relative;\"><a href=\"#anchor-37cb5051af478bf0\" aria-label=\"anchor 37cb5051af478bf0 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4.3. 符号标志 SF（Sign Flag）</h4>\n<p>CF 会被算术运算、逻辑运算、移位运算影响，SF 将被置为运算结果的<strong>最高位</strong>。</p>\n<h4 id=\"anchor-20a6bc705b3950b3\" style=\"position: relative;\"><a href=\"#anchor-20a6bc705b3950b3\" aria-label=\"anchor 20a6bc705b3950b3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4.4. 溢出标志 OF（Overflow Flag）</h4>\n<p>OF 会被 <code class=\"language-text\">add</code>、<code class=\"language-text\">sub</code>、<code class=\"language-text\">mul</code>、<code class=\"language-text\">imul</code> 指令影响，发生下列事件时 OF 会被置 1，否则置 0：</p>\n<ul>\n<li>两个正数相加变负数</li>\n<li>两个负数相加变正数</li>\n<li>两数相乘的乘积宽度超过被乘数宽度</li>\n<li>移位前后<strong>最高位</strong>发生改变</li>\n</ul>\n<h4 id=\"anchor-d4726ae7cdae2d01\" style=\"position: relative;\"><a href=\"#anchor-d4726ae7cdae2d01\" aria-label=\"anchor d4726ae7cdae2d01 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4.5. 奇偶校验标志 PF（Parity Flag）</h4>\n<p>ZF 会被算术运算、逻辑运算、移位运算影响，运算结果的低八位有偶数个 1 时将 PF 置 1，否则将 PF 置 0。</p>\n<h4 id=\"anchor-37ec474f084097e8\" style=\"position: relative;\"><a href=\"#anchor-37ec474f084097e8\" aria-label=\"anchor 37ec474f084097e8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4.6. 辅助进位标志 AF（Auxiliary Flag）</h4>\n<p>AX 会被 <code class=\"language-text\">add</code> 和 <code class=\"language-text\">sub</code> 指令影响，当第 3 位向第 4 位进位/借位时 AF 置 1 否则将 AF 置 0。</p>\n<h4 id=\"anchor-ce89baecb9723c25\" style=\"position: relative;\"><a href=\"#anchor-ce89baecb9723c25\" aria-label=\"anchor ce89baecb9723c25 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4.7. 方向标志 DF（Direction Flag）</h4>\n<p>DF 可以控制 <code class=\"language-text\">rep movsb</code> 的运行方向（类似于 memcpy 函数）。当 DF=0 时，字符串操作按正方向（低地址到高地址）执行；当 DF=1 时，字符串操作按反方向（高地址到低地址）执行。详见 <a href=\"/course/fasm/note/4/\">IV 8086指令系统</a> 中的字符串操作部分。</p>\n<h4 id=\"anchor-2e5188061a6587b1\" style=\"position: relative;\"><a href=\"#anchor-2e5188061a6587b1\" aria-label=\"anchor 2e5188061a6587b1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4.8. 中断标志 IF（Interrupt Flag）</h4>\n<p>IF 用于禁止或允许硬件中断。当 IF=0 时禁止硬件中断；当 IF=1 时允许硬件中断。</p>\n<p>这样，被 <code class=\"language-text\">cli</code> 到 <code class=\"language-text\">sti</code> 包裹起来的代码在执行时就不会被硬件中断，可在需要修改中断向量等场景下。</p>\n<h4 id=\"anchor-6dc4c88ecdba325a\" style=\"position: relative;\"><a href=\"#anchor-6dc4c88ecdba325a\" aria-label=\"anchor 6dc4c88ecdba325a permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4.9. 陷阱标志（Trap Flag）</h4>\n<p>TF 用于让 CPU 进入单步模式。当 TF=1 时，每执行一条指令后，CPU 会自动插入一条 <code class=\"language-text\">int 01h</code> 中断。</p>\n<h2 id=\"anchor-728b44f645fbae9a\" style=\"position: relative;\"><a href=\"#anchor-728b44f645fbae9a\" aria-label=\"anchor 728b44f645fbae9a permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 端口</h2>\n<p>端口地址与内存地址独立，仅有 16 位偏移地址，其取值范围是 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mtext>0000h:0FFFFh</mtext><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[\\text{0000h:0FFFFh}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord text\"><span class=\"mord\">0000h:0FFFFh</span></span><span class=\"mclose\">]</span></span></span></span></span>。CPU 不能直接对 I/O 设备进行控制，需要通过向端口发送控制信号或读取来自端口的信号，指令如下：</p>\n<ul>\n<li><code class=\"language-text\">in 寄存器 端口地址</code>：从端口读入信号并存储到寄存器中。</li>\n<li><code class=\"language-text\">out 端口地址 寄存器</code>：将寄存器的值发送到对应端口。</li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#anchor-07ad748f54d37719\">1. CPU</a></p>\n</li>\n<li>\n<p><a href=\"#anchor-2bed3641595b6d4e\">2. 内存</a></p>\n<ul>\n<li><a href=\"#anchor-4af8039fd82044d9\">2.1. 地址</a></li>\n<li><a href=\"#anchor-9f1ed298eb10dd6d\">2.2. 内存空间划分</a></li>\n<li><a href=\"#anchor-4b02b42f448cdb59\">2.3. 显卡</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-d2cc713ec69f3016\">3. 寄存器</a></p>\n<ul>\n<li><a href=\"#anchor-f53ce791770343dc\">3.1. 通用寄存器</a></li>\n<li><a href=\"#anchor-d39f4c684b834890\">3.2. 段地址寄存器</a></li>\n<li><a href=\"#anchor-bc84f53c6dbbe218\">3.3. 偏移地址寄存器</a></li>\n<li><a href=\"#anchor-0860b9ddf8d51271\">3.4. 标志寄存器</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-728b44f645fbae9a\">4. 端口</a></p>\n</li>\n</ul>","frontmatter":{"title":"III CPU、内存和端口","date":null,"description":null},"fields":{"cover":null,"slug":"/course/fasm/note/3/","isDoc":true,"category":"[{\"name\":\"课程笔记\",\"to\":\"/course/\"}]","propsJson":null}},"previous":null,"next":null},"pageContext":{"id":"08c1b574-dc95-56a0-8617-a3ec875e083f","previousPostId":null,"nextPostId":null,"navJson":"[{\"slug\":\"/course/fasm\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/index.md\",\"title\":\"课程简介\"},{\"title\":\"笔记\",\"children\":[{\"slug\":\"/course/fasm/note/1\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/1.md\",\"title\":\"I 汇编语言入门\"},{\"slug\":\"/course/fasm/note/2\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/2.md\",\"title\":\"II 数据的表示与运算\"},{\"slug\":\"/course/fasm/note/3\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/3.md\",\"title\":\"III CPU、内存和端口\"},{\"slug\":\"/course/fasm/note/4\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/4.md\",\"title\":\"IV 8086指令系统\"},{\"slug\":\"/course/fasm/note/5\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/5.md\",\"title\":\"V 汇编语言进阶\"}]}]"}},"staticQueryHashes":[],"slicesMap":{}}