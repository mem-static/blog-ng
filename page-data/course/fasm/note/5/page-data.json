{"componentChunkName":"component---src-templates-post-js","path":"/course/fasm/note/5/","result":{"data":{"site":{"siteMetadata":{"title":"mem 的小站"}},"post":{"id":"6870df5e-e43c-53cd-b437-5de15b2b596d","excerpt":"1. 堆栈 SS:SP 是堆栈顶端的逻辑地址。注意不能直接用  或  的方式引用堆栈中的元素，需要用 BX、BP、SI、DI 中的某个替换。  可以将 op 压入堆栈。CPU 会先让 SP 寄存器减少 op 的宽度，再将 op 的值保存到 SS:SP。  可以将 op 弹出堆栈。CPU 会先将 SS:SP…","html":"<h2 id=\"anchor-3e6e402c20c7de1b\" style=\"position: relative;\"><a href=\"#anchor-3e6e402c20c7de1b\" aria-label=\"anchor 3e6e402c20c7de1b permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 堆栈</h2>\n<p>SS:SP 是堆栈顶端的逻辑地址。注意<strong>不能</strong>直接用 <code class=\"language-text\">[sp]</code> 或 <code class=\"language-text\">[sp+常数或其他寄存器]</code> 的方式引用堆栈中的元素，需要用 BX、BP、SI、DI 中的某个替换。</p>\n<ul>\n<li><code class=\"language-text\">push op</code> 可以将 op 压入堆栈。CPU 会先让 SP 寄存器<strong>减少</strong> op 的宽度，再将 op 的值保存到 SS:SP。</li>\n<li><code class=\"language-text\">pop op</code> 可以将 op 弹出堆栈。CPU 会先将 SS:SP 的值保存到 op，再将 SP 寄存器<strong>增加</strong> op 的宽度。</li>\n</ul>\n<p>注意这里 op <strong>不能</strong>是一个 8 位的寄存器或变量。注意如果这里的 op 是内存地址的话，因为没有另一个操作数可以作宽度参考，必须用 <code class=\"language-text\">word ptr</code> 或 <code class=\"language-text\">dword ptr</code> 指明宽度。</p>\n<p><code class=\"language-text\">pusha</code> 和 <code class=\"language-text\">popa</code> 是 <code class=\"language-text\">push</code> 和 <code class=\"language-text\">pop</code> 的变体，在 16 位系统中，<code class=\"language-text\">pusha</code> 会依次将以下寄存器放入到堆栈中：AX、CX、DX、BX、SP、BP、SI、DI，<code class=\"language-text\">popa</code> 则是对应的反向弹出。</p>\n<h2 id=\"anchor-46d55f6d683678db\" style=\"position: relative;\"><a href=\"#anchor-46d55f6d683678db\" aria-label=\"anchor 46d55f6d683678db permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 函数</h2>\n<h3 id=\"anchor-f79019e144f4152d\" style=\"position: relative;\"><a href=\"#anchor-f79019e144f4152d\" aria-label=\"anchor f79019e144f4152d permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. 函数的定义</h3>\n<h4 id=\"anchor-025d7236e4de5b73\" style=\"position: relative;\"><a href=\"#anchor-025d7236e4de5b73\" aria-label=\"anchor 025d7236e4de5b73 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.1. 用标号定义函数</h4>\n<div class=\"gatsby-highlight\" data-language=\"armasm\"><pre class=\"language-armasm\"><code class=\"language-armasm\">标号名:  <span class=\"token comment\">; 定义近函数</span>\n        <span class=\"token comment\">; 或写成“标号名 label near”</span>\n  ...\n  retn  <span class=\"token comment\">; 可简写为ret</span>\n标号名 label far  <span class=\"token comment\">; 定义远函数</span>\n  ...\n  retf</code></pre></div>\n<h4 id=\"anchor-454384a95d41599f\" style=\"position: relative;\"><a href=\"#anchor-454384a95d41599f\" aria-label=\"anchor 454384a95d41599f permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1.2. 用 proc 定义函数</h4>\n<div class=\"gatsby-highlight\" data-language=\"armasm\"><pre class=\"language-armasm\"><code class=\"language-armasm\">函数名 proc near  <span class=\"token comment\">; 定义近函数</span>\n  ...\n  retn           <span class=\"token comment\">; 可简写为ret</span>\n函数名 endp\n函数名 proc far   <span class=\"token comment\">; 定义远函数</span>\n  ...\n  retf\n函数名 endp</code></pre></div>\n<h3 id=\"anchor-840a76a471fe186d\" style=\"position: relative;\"><a href=\"#anchor-840a76a471fe186d\" aria-label=\"anchor 840a76a471fe186d permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. 函数的调用</h3>\n<p>函数定义后可以用 <code class=\"language-text\">call</code> 指令调用。</p>\n<ul>\n<li>近调用 <code class=\"language-text\">call near ptr dest</code>，近返回 <code class=\"language-text\">retn</code>（在多数情况下可以简写为 <code class=\"language-text\">ret</code>）；</li>\n<li>远调用 <code class=\"language-text\">call far ptr dest</code>，远返回 <code class=\"language-text\">retf</code> 。</li>\n</ul>\n<p><strong>使用调用进行跳转之后一定要返回</strong>，否则栈空间会出现问题。</p>\n<h4 id=\"anchor-4de8d39cdcf1a1a9\" style=\"position: relative;\"><a href=\"#anchor-4de8d39cdcf1a1a9\" aria-label=\"anchor 4de8d39cdcf1a1a9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2.1. 近调用的原理</h4>\n<p>执行 <code class=\"language-text\">call</code> 时，CPU 首先把下一条要执行的指令压入堆栈中，然后跳转到目标地址。</p>\n<p>执行 <code class=\"language-text\">ret</code> 时，CPU 将从堆栈中取出地址，跳转到目标地址。这可以理解为 <code class=\"language-text\">pop ip</code> 指令 （回顾：ip 寄存器即指令寄存器，cs:ip 指向 CPU 下一条要执行的地址。但 ip 寄存器不能被直接引用，故只能写 <code class=\"language-text\">ret</code>）。</p>\n<p><img src=\"https://img.memset0.cn/2024/02/08/9MBYnAqu.png\"alt=\"\" ></p>\n<h4 id=\"anchor-376ae22e03f90a9b\" style=\"position: relative;\"><a href=\"#anchor-376ae22e03f90a9b\" aria-label=\"anchor 376ae22e03f90a9b permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2.2. 远调用的原理</h4>\n<p>远调用时会依次把下一条指令的段地址和偏移地址压入堆栈中，远返回时会倒序弹出（先弹出后压入的 ip 寄存器）。这里 <code class=\"language-text\">retf</code> 的弹出是通过硬件实现的，所以对 cs 和 ip 寄存器的修改是同时进行的。</p>\n<p><img src=\"https://img.memset0.cn/2024/02/08/ghGy5rFZ.png\"alt=\"\" ></p>\n<h3 id=\"anchor-fcea8c8e466f8903\" style=\"position: relative;\"><a href=\"#anchor-fcea8c8e466f8903\" aria-label=\"anchor fcea8c8e466f8903 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. 函数的参数传递</h3>\n<p>函数的参数传递方式主要有：</p>\n<ol>\n<li>寄存器传递（一般推荐使用 AX 寄存器）</li>\n<li>变量传递</li>\n<li>堆栈传递</li>\n</ol>\n<p>使用<strong>变量传递</strong>或<strong>寄存器传递</strong>的方式意味着函数在运行过程中使用全局变量，这会导致该函数在运行过程中不可<strong>重入（reentrant）</strong>，因为该函数在第一次调用尚未结束时被再次调用时会造成全局变量的覆盖，意为着该函数不能递归或者在多线程程序中被使用。这就是为什么我们需要介绍<strong>堆栈传递</strong>。</p>\n<h4 id=\"anchor-31ef61fac10dfd0e\" style=\"position: relative;\"><a href=\"#anchor-31ef61fac10dfd0e\" aria-label=\"anchor 31ef61fac10dfd0e permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3.1. <code class=\"language-text\">__cdecl</code> 规范</h4>\n<p>参数按从右到左的顺序传入堆栈，由调用者通过 <code class=\"language-text\">add sp, 常数</code> 指令清理堆栈中的参数，或者 <code class=\"language-text\">pop 寄存器</code> 指令弹出到不使用的寄存器中。</p>\n<p><img src=\"https://img.memset0.cn/2024/02/08/3bZl4zil.png\"alt=\"\" ></p>\n<p>在调用函数之前把需要传递的参数压入堆栈中。调用结束之后<strong>不要忘记将堆栈中的元素弹出</strong>，可以用 <code class=\"language-text\">pop</code> 指令传递给一个不用的寄存器，也可以直接用 <code class=\"language-text\">add sp, 2</code> 指令实现隐式的 pop。</p>\n<p>通过 <code class=\"language-text\">push bp</code> 及 <code class=\"language-text\">move bp sp</code> 的组合来构成<strong>堆栈框架（stack frame）</strong>，从而引用堆栈中的参数。由于 sp 寄存器不能被直接使用，这里 bp 寄存器取 ss:[bp+4] 这一地址，即我们希望传递给函数的参数。这也是这里使用 bp 寄存器的意义。（这里 ss: [bp] 存放原来 bp 寄存器的值；ss:[bp+2] 指向 ret 函数需返回的地址）</p>\n<p>这里必须用 <code class=\"language-text\">push bp</code> 和 <code class=\"language-text\">pop bp</code> 来保护 bp 寄存器的原值，否则容易出现问题。如：在函数 f 中使用 ss:[bp+4] 来获取参数，但是使用之后调用了不保护 bp 的函数 g，这时如果还想再使用 ss:[bp+4] 来获取参数就可能出现问题。</p>\n<p>如果需要使用多个参数，则可都压入堆栈中然后类比地使用 ss:[bp+6] 等。这也是为什么 C 语言中的函数参数执行顺序是从右到左的原因之一。</p>\n<p>同时注意 C 语言的函数中要求保护 BP、BX、SI、DI 寄存器不被修改。</p>\n<h4 id=\"anchor-4fc99b1c2fd0be10\" style=\"position: relative;\"><a href=\"#anchor-4fc99b1c2fd0be10\" aria-label=\"anchor 4fc99b1c2fd0be10 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3.2. <code class=\"language-text\">__pascal</code> 规范</h4>\n<p>参数按照从左到右顺序传入堆栈，由调用者通过 <code class=\"language-text\">ret 常数</code> 指令清理参数。</p>\n<h4 id=\"anchor-20ff8afd83a1b5fa\" style=\"position: relative;\"><a href=\"#anchor-20ff8afd83a1b5fa\" aria-label=\"anchor 20ff8afd83a1b5fa permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3.3. <code class=\"language-text\">__stdcall</code> 规范</h4>\n<h3 id=\"anchor-7961bf35053ea785\" style=\"position: relative;\"><a href=\"#anchor-7961bf35053ea785\" aria-label=\"anchor 7961bf35053ea785 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.4. 动态变量</h3>\n<p>在进入函数体前，用 <code class=\"language-text\">mov bp, sp</code> 暂存 SP 寄存器，通过 <code class=\"language-text\">sub sp, 字节数</code> 划出分配给局部动态变量的内存空间。在函数体结束后，用 <code class=\"language-text\">mov sp, bp</code> 指令恢复原来的 SP 寄存器即可。</p>\n<p>这样实现的话，一般通过 <code class=\"language-text\">[bp+4/6/...]</code> 来访问函数参数，通过 <code class=\"language-text\">[bp-2/4/...]</code> 来访问局部动态变量，具体可以参考示例代码。</p>\n<p><details  class=\"callout callout-type-example\"><summary> 例：实现 C 语言中的动态局部变量</summary><div class=\"callout-content\"><p></p><div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// c是局部动态变量</span>\n      c <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div><p>把上面的 C 语言代码转化为汇编：</p><div class=\"gatsby-highlight\" data-language=\"armasm\"><pre class=\"language-armasm\"><code class=\"language-armasm\">f:\n       push bp<span class=\"token comment\">; (4)</span>\n       mov bp<span class=\"token punctuation\">,</span> sp\n       sub sp<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token comment\">; (5) 这里挖的坑就是给变量c的</span>\n       mov ax<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>bp<span class=\"token operator\">+</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\n       add ax<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>bp<span class=\"token operator\">+</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span>\n       mov <span class=\"token punctuation\">[</span>bp<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> ax\n       mov ax<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>bp<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n       mov sp<span class=\"token punctuation\">,</span> bp<span class=\"token comment\">; (6)此时变量c死亡</span>\n       pop bp<span class=\"token comment\">; (7)</span>\n       ret<span class=\"token comment\">; (8)</span>\nmain:\n       mov ax<span class=\"token punctuation\">,</span> <span class=\"token number\">20</span>\n       push ax<span class=\"token comment\">; (1)</span>\n       mov ax<span class=\"token punctuation\">,</span> <span class=\"token number\">10</span>\n       push ax<span class=\"token comment\">; (2)</span>\n       call f<span class=\"token comment\">; (3)</span>\nhere:\n   \tadd sp<span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token comment\">;(9)此时参数a,b死亡</span></code></pre></div><p>执行上述代码时，堆栈布局如下：</p><div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">ss:1FF6 [30] (5) 变量c\nss:1FF8 old bp&lt;- bp(4)(6)\nss:1FFA here &lt;- (3)(7)\nss:1FFC 10 &lt;- (2)(8)\nss:1FFE 20 &lt;- (1)\nss:2000    &lt;-(9)</code></pre></div></div></details></p>\n<h2 id=\"anchor-bbdea5a48d3b73db\" style=\"position: relative;\"><a href=\"#anchor-bbdea5a48d3b73db\" aria-label=\"anchor bbdea5a48d3b73db permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 中断程序设计</h2>\n<p>中断指令的格式 <code class=\"language-text\">int n</code>，其中 n 的取值范围是 [0, 0FFh]。</p>\n<p>0:0 到 0:3FF 共 400h 内存空间存储中断向量表，初始由保存调用中断时需要跳转到的段地址和偏移地址（注意这里都是小端存储的），计算方法如下（如 <code class=\"language-text\">dword ptr 0:[84h]</code> 就是 <code class=\"language-text\">int 21h</code> 的中断向量）：</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right left\" columnspacing=\"0em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mtext>int </mtext><mi>n</mi><mtext> 的偏移地址</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mn>0</mn><mo>:</mo><mo stretchy=\"false\">[</mo><mi>n</mi><mo>×</mo><mn>4</mn><mo stretchy=\"false\">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mtext>int </mtext><mi>n</mi><mtext> 的段地址</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>=</mo><mn>0</mn><mo>:</mo><mo stretchy=\"false\">[</mo><mi>n</mi><mo>×</mo><mn>4</mn><mo>+</mo><mn>2</mn><mo stretchy=\"false\">]</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{aligned}\\text{int }n\\text{ 的偏移地址} &#x26;= 0:[n\\times 4] \\\\\n\\text{int }n\\text{ 的段地址} &#x26;= 0:[n\\times 4+2]\\end{aligned}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.75em;\"><span style=\"top:-3.91em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">int </span></span><span class=\"mord mathnormal\">n</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">的偏移地址</span></span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">int </span></span><span class=\"mord mathnormal\">n</span><span class=\"mord text\"><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">的段地址</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.25em;\"><span></span></span></span></span></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.75em;\"><span style=\"top:-3.91em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">4</span><span class=\"mclose\">]</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">]</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.25em;\"><span></span></span></span></span></span></span></span></span></span></span></span></div>\n<div class=\"gatsby-highlight\" data-language=\"armasm\"><pre class=\"language-armasm\"><code class=\"language-armasm\"><span class=\"token number\">1000</span>:<span class=\"token number\">2000</span> int 21h <span class=\"token comment\">; 当CPU执行这条指令时，会做一下动作</span>\n          pushf\n          push cs <span class=\"token comment\">; 即1000h</span>\n          push 下条指令的偏移地址 <span class=\"token comment\">; 即2002h</span>\n          jmp dword ptr <span class=\"token number\">0</span>:<span class=\"token punctuation\">[</span>21h<span class=\"token operator\">*</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">; jmp mem32指令，假设存放着1234:5678</span>\n<span class=\"token number\">1000</span>:<span class=\"token number\">2002</span> mov ah<span class=\"token punctuation\">,</span> 4ch\n\n<span class=\"token number\">1234</span>:<span class=\"token number\">5678</span> cmp ah<span class=\"token punctuation\">,</span> <span class=\"token number\">9</span>  <span class=\"token comment\">; 对应的中断函数从这里开始</span>\n<span class=\"token number\">1234</span>:567A ...\n<span class=\"token number\">1234</span>:<span class=\"token number\">5688</span> iret <span class=\"token comment\">; 当CPU执行这条指令时，会做以下动作</span>\n          pop ip\n          pop cs\n          popf</code></pre></div>\n<h2 id=\"anchor-cf5f757c6a2761ab\" style=\"position: relative;\"><a href=\"#anchor-cf5f757c6a2761ab\" aria-label=\"anchor cf5f757c6a2761ab permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 混合语言编程</h2>\n<p>还在路上。</p>\n<h2 id=\"anchor-b766f807a3ce6ecc\" style=\"position: relative;\"><a href=\"#anchor-b766f807a3ce6ecc\" aria-label=\"anchor b766f807a3ce6ecc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 内存分配与文件操作</h2>\n<p>咕咕咕。</p>\n<h2 id=\"anchor-ca46acaf83ed7c9f\" style=\"position: relative;\"><a href=\"#anchor-ca46acaf83ed7c9f\" aria-label=\"anchor ca46acaf83ed7c9f permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. 保护模式程序设计</h2>\n<p>咕咕咕。</p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#anchor-3e6e402c20c7de1b\">1. 堆栈</a></p>\n</li>\n<li>\n<p><a href=\"#anchor-46d55f6d683678db\">2. 函数</a></p>\n<ul>\n<li><a href=\"#anchor-f79019e144f4152d\">2.1. 函数的定义</a></li>\n<li><a href=\"#anchor-840a76a471fe186d\">2.2. 函数的调用</a></li>\n<li><a href=\"#anchor-fcea8c8e466f8903\">2.3. 函数的参数传递</a></li>\n<li><a href=\"#anchor-7961bf35053ea785\">2.4. 动态变量</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-bbdea5a48d3b73db\">3. 中断程序设计</a></p>\n</li>\n<li>\n<p><a href=\"#anchor-cf5f757c6a2761ab\">4. 混合语言编程</a></p>\n</li>\n<li>\n<p><a href=\"#anchor-b766f807a3ce6ecc\">5. 内存分配与文件操作</a></p>\n</li>\n<li>\n<p><a href=\"#anchor-ca46acaf83ed7c9f\">6. 保护模式程序设计</a></p>\n</li>\n</ul>","frontmatter":{"title":"V 汇编语言进阶","description":null},"fields":{"cover":null,"slug":"/course/fasm/note/5/","cssclasses":null,"isDoc":true,"authors":[],"createTime":null,"updateTime":null,"category":"[{\"name\":\"课程笔记\",\"to\":\"/course/\"}]","propsJson":null}},"previous":null,"next":null},"pageContext":{"id":"6870df5e-e43c-53cd-b437-5de15b2b596d","previousPostId":null,"nextPostId":null,"navJson":"[{\"slug\":\"/course/fasm\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/index.md\",\"title\":\"课程简介\"},{\"title\":\"笔记\",\"children\":[{\"slug\":\"/course/fasm/note/1\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/1.md\",\"title\":\"I 汇编语言入门\"},{\"slug\":\"/course/fasm/note/2\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/2.md\",\"title\":\"II 数据的表示与运算\"},{\"slug\":\"/course/fasm/note/3\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/3.md\",\"title\":\"III CPU、内存和端口\"},{\"slug\":\"/course/fasm/note/4\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/4.md\",\"title\":\"IV 8086指令系统\"},{\"slug\":\"/course/fasm/note/5\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/fasm/note/5.md\",\"title\":\"V 汇编语言进阶\"}]}]"}},"staticQueryHashes":[],"slicesMap":{}}