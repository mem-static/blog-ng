{"componentChunkName":"component---src-templates-post-js","path":"/course/java/note/2/","result":{"data":{"site":{"siteMetadata":{"title":"mem 的小站"}},"post":{"id":"52cd8b44-293a-58f8-a097-dcccf44ea187","excerpt":"本篇笔记主要介绍了 Java 面向对象编程的核心概念和实践。涵盖了类与对象的基本概念、封装与访问控制、继承与多态、接口与抽象类等重要主题。通过理论讲解和代码示例，系统地阐述了 Java 面向对象编程的设计理念和实现方法，帮助读者深入理解面向对象程序设计的思想。（由 claude-3.5-sonnet 生成摘要）","html":"<blockquote>\n<p>本篇笔记主要介绍了 Java 面向对象编程的核心概念和实践。涵盖了类与对象的基本概念、封装与访问控制、继承与多态、接口与抽象类等重要主题。通过理论讲解和代码示例，系统地阐述了 Java 面向对象编程的设计理念和实现方法，帮助读者深入理解面向对象程序设计的思想。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small></p>\n</blockquote>\n<!-- more -->\n<h2 id=\"anchor-4525d562cd577168\" style=\"position: relative;\"><a href=\"#anchor-4525d562cd577168\" aria-label=\"anchor 4525d562cd577168 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Ch09 Objects and Classes</h2>\n<h3 id=\"anchor-f8b76a62399ea654\" style=\"position: relative;\"><a href=\"#anchor-f8b76a62399ea654\" aria-label=\"anchor f8b76a62399ea654 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. Object-Oriented Programming (OOP)</h3>\n<ul>\n<li><strong>对象(object)</strong>：\n<ul>\n<li>对象一般用来表示现实世界中可以被识别的实体，具有唯一标识、状态和行为。</li>\n<li><strong>状态(state)</strong>：由数据字段（属性）及其当前值组成。</li>\n<li><strong>行为(behavior)</strong>：由方法定义。</li>\n<li>对象与基本数据类型的区别\n<ul>\n<li><strong>基本类型变量</strong>：存储实际值。</li>\n<li><strong>对象引用变量</strong>：存储对象的内存地址。</li>\n<li><mark class=\"m-mark\">Java 中的参数传递始终是值传递。因为 Java 中的对象实际上是一种引用，我们在传递参数时是将对应的地址作为值传递进去的；而在传递基本类型时那更是直接传递这个值了。</mark></li>\n</ul>\n</li>\n<li><mark class=\"m-mark\">所有对象的实例都存储在堆中，只有局部的基本类型变量和对象引用存储在栈中，这是 Java 语言的一大特性。</mark></li>\n</ul>\n</li>\n<li><strong>类(class)</strong>：\n<ul>\n<li>类是定义相同类型对象的构造。</li>\n<li>Java 中的类用 <strong>变量(variable)</strong> 来表示状态，用 <strong>方法(method)</strong> 来表示行为。</li>\n<li><strong>UML 类图(UML class diagram)</strong>：通过图形化方式展示类的属性和方法。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-97dcd0317ee85134\" style=\"position: relative;\"><a href=\"#anchor-97dcd0317ee85134\" aria-label=\"anchor 97dcd0317ee85134 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. Constructors</h3>\n<ul>\n<li><strong>构造函数(constructor)</strong> 是一类特殊的方法，用于创建对象并初始化其属性。</li>\n<li>使用 <code class=\"language-text\">new</code> 运算符创建对象并触发构造函数。</li>\n<li><strong>要求</strong>：\n<ul>\n<li>构造函数的名称必须与类名相同。</li>\n<li>无返回类型（不是 <code class=\"language-text\">void</code>，直接不用写）。</li>\n</ul>\n</li>\n<li><strong>默认构造函数(default constructor)</strong>\n<ul>\n<li>如果类没有定义构造函数，Java 会自动提供一个默认的空的无参构造函数。</li>\n<li>当且仅当类没有显式声明的构造函数时才会创建。</li>\n</ul>\n</li>\n<li><strong>默认初始化</strong>：\n<ul>\n<li><mark class=\"m-mark\">对于没有进行初始化的对象中的变量会分配<strong>默认值(default value)</strong></mark>：\n<ul>\n<li>引用类型：<code class=\"language-text\">null</code></li>\n<li>数值类型：<code class=\"language-text\">0</code></li>\n<li>字符类型：<code class=\"language-text\">\\u0000</code></li>\n</ul>\n</li>\n<li><mark class=\"m-mark\">注意：在方法内的局部变量并不会有默认值，这种时候会 CE 报错（variable not initialized）</mark>！</li>\n<li>这其实是关系到使用 <code class=\"language-text\">new</code> 运算符创建对象时，是在堆中申请了一块新的空间，Java 会将其中的 data fields 自动初始化为全 0，这也就是不同类型所对应的默认值。</li>\n</ul>\n</li>\n<li><strong>指定初始化</strong>：\n<ul>\n<li>示例\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">STATIC_ONE</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token constant\">STATIC_TWO</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token constant\">STATIC_TWO</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>指定初始化的其实是在默认初始化的动作之后执行的。（如在这里执行 <code class=\"language-text\">STATIC_TWO = 2;</code> 语句之前 <code class=\"language-text\">STATIC_TWO</code> 的值应为 0。）</li>\n</ul>\n</li>\n<li>三种初始化方法的顺序是：<mark class=\"m-mark\">① 默认初始化 ② 指定初始化（直接给变量赋值，或者一个直接写在 class 里的块） ③ 构造函数</mark>。</li>\n</ul>\n<h3 id=\"anchor-9738eb39ab8b5e99\" style=\"position: relative;\"><a href=\"#anchor-9738eb39ab8b5e99\" aria-label=\"anchor 9738eb39ab8b5e99 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3. Garbage Collection (GC)</h3>\n<ul>\n<li><strong>垃圾回收(garbage collection)</strong>：Java 虚拟机（JVM）会自动回收不再被引用的对象。</li>\n<li><strong>内存泄漏(memory leak)</strong>：如果程序不正确地管理对象的引用，让其无法自动释放，就会存在内存泄漏的问题。\n<ul>\n<li><mark class=\"m-mark\">这里 <code class=\"language-text\">return elements[--size]</code> 时没有释放 <code class=\"language-text\">elements</code> 数组中对对应对象的引用（因为这不是一个基本类型的栈，而是一个 Object 的栈），这种时候就会有内存泄漏的问题产生</mark>。\n<img src=\"https://img.memset0.cn/2024/12/17/wh5AT5RR.png\"alt=\"\" style=\"width: 403px; \" ></li>\n</ul>\n</li>\n<li><mark class=\"m-mark\"><strong>手动释放引用</strong>：可以通过显式地将对象引用赋值为 <code class=\"language-text\">null</code>，来提示 JVM 进行回收</mark>。\n<ul>\n<li>示例：\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Circle</span> c1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Circle</span><span class=\"token punctuation\">(</span><span class=\"token number\">5.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nc1 <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// c1指向的对象会被回收</span></code></pre></div>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-d1f8bfb6e60a90cc\" style=\"position: relative;\"><a href=\"#anchor-d1f8bfb6e60a90cc\" aria-label=\"anchor d1f8bfb6e60a90cc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.4. Static Variables &#x26; Methods</h3>\n<ul>\n<li>使用 <code class=\"language-text\">static</code> 关键字修饰全局变量、常量和方法。\n<ul>\n<li>对于全局常量，使用 <code class=\"language-text\">final static</code> 修饰。</li>\n</ul>\n</li>\n<li><strong>静态成员</strong>：属于类，而不是某个实例。</li>\n<li><strong>实例成员</strong>：属于特定对象的实例。</li>\n<li><strong>访问限制</strong>：\n<ul>\n<li>静态方法只能访问静态的变量和方法。</li>\n<li>实例方法可以访问静态和实例的变量和方法。</li>\n</ul>\n</li>\n<li><strong>生命周期</strong>：<mark class=\"m-mark\">第一次通过类名访问静态变量或静态方法时，Java 会将类加载进内存，为这个类分配一块空间，包含了定义、变量和方法信息，还有类的静态变量，并对静态变量复制。类在加载进内存之后一般不会释放，直到程序结束。一般情况下，类只会这样加载一次</mark>。（具体参见“类加载过程”的部分）</li>\n</ul>\n<h3 id=\"anchor-5a9e524a4cf6370a\" style=\"position: relative;\"><a href=\"#anchor-5a9e524a4cf6370a\" aria-label=\"anchor 5a9e524a4cf6370a permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.5. Encapsulation and Access Control</h3>\n<ul>\n<li><strong>封装(encapsulation)</strong>：保护数据，便于维护。</li>\n<li><strong>访问修饰符(visibility modifiers)</strong>：\n<ul>\n<li><code class=\"language-text\">private</code>：仅类内部可访问。</li>\n<li><code class=\"language-text\">public</code>：所有类均可访问。</li>\n<li><mark class=\"m-mark\">默认（无修饰符）：同一包内可访问。</mark></li>\n<li><img src=\"https://img.memset0.cn/2024/12/17/Cm4bIw3D.png\"alt=\"\" style=\"width: 555px; \" ></li>\n</ul>\n</li>\n<li>通过让类提供 <code class=\"language-text\">get</code> 和 <code class=\"language-text\">set</code> 方法来从外部访问私有数据字段。</li>\n<li><mark class=\"m-mark\"><code class=\"language-text\">private Constructor</code>：通过 <code class=\"language-text\">private</code> 修饰构造函数，防止从外部创建类的示例</mark>。\n<ul>\n<li>示例 1（只能静态访问）：Java 提供的 <code class=\"language-text\">Math</code> 类的构造函数就是 <code class=\"language-text\">private Math() {}</code>。</li>\n<li><mark class=\"m-mark\">示例 2（只能被类的静态方法调用）：单例模式</mark><br>\n<img src=\"https://img.memset0.cn/2024/12/17/LVn4d5uF.png\"alt=\"\" style=\"width: 640px; \" ></li>\n<li><mark class=\"m-mark\">示例 3（只能被类的其他构造函数调用，用于减少重复代码）</mark></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-01f528ab0ceb9cc8\" style=\"position: relative;\"><a href=\"#anchor-01f528ab0ceb9cc8\" aria-label=\"anchor 01f528ab0ceb9cc8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.6. Immutable Objects and Classes</h3>\n<ul>\n<li><strong>不可变对象</strong>：不可变类的对象，一旦创建，其内容不能更改。（典例：<code class=\"language-text\">String</code>）</li>\n<li><strong>不可变类的设计规则</strong>：\n<ol>\n<li>不提供修改对象状态的方法。</li>\n<li>==将类声明为 <code class=\"language-text\">final</code>，防止继承=。\n<ul>\n<li>还可以采用一种更为灵活的方式让类的所有构造器都变为私有的或包级私有的，并添加公共的静态工厂来代替公有的构造器。（如常量池技术，下一章会详细介绍。）</li>\n</ul>\n</li>\n<li><mark class=\"m-mark\">所有字段声明为 <code class=\"language-text\">private</code> 和 <code class=\"language-text\">final</code></mark>。</li>\n<li>确保没有返回可变对象引用的方法。</li>\n</ol>\n</li>\n<li><strong>不可变类的优点</strong>：\n<ul>\n<li>不可变对象是线程安全的。</li>\n<li><mark class=\"m-mark\">不需要进行保护性拷贝，因为对象的引用不会被修改。（TODO：？）</mark></li>\n<li>可以提供静态工厂，把频繁被请求的实例缓存起来。\n<img src=\"https://img.memset0.cn/2024/12/17/59fbk4bi.png\"alt=\"\" style=\"width: 450px; \" ></li>\n<li>对于特殊不可变对象的部分常用方法，可以直接提供结果。\n<img src=\"https://img.memset0.cn/2024/12/17/KP1Be31g.png\"alt=\"\" style=\"width: 450px; \" ></li>\n</ul>\n</li>\n<li><mark class=\"m-mark\">必要时进行保护性拷贝：必须要返回对象的场合，重新创建一个临时对象返回，确保当前对象不被修改</mark>。\n<ul>\n<li><img src=\"https://img.memset0.cn/2024/12/17/rs5sEnMw.png\"alt=\"\" style=\"width: 528px; \" ></li>\n<li>另一个例子：类具有公有的静态 final 数组域，或者返回这种域的访问方法，这是安全漏洞的一个常见根源。<br>\n<img src=\"https://img.memset0.cn/2024/12/17/ijwg7L04.png\"alt=\"\" style=\"width: 420px; \" ></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-bb9931fabdb9a930\" style=\"position: relative;\"><a href=\"#anchor-bb9931fabdb9a930\" aria-label=\"anchor bb9931fabdb9a930 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.7. this</h3>\n<ul>\n<li><strong>用途</strong>：\n<ol>\n<li>引用当前对象。</li>\n<li>调用类的其他构造函数。</li>\n</ol>\n</li>\n<li>示例：\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Circle</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">double</span> radius<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">Circle</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> radius<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>radius <span class=\"token operator\">=</span> radius<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 只能通过 this 引用当前对象的 radius 字段</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">Circle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 调用另一个构造函数</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getArea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>radius <span class=\"token operator\">*</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>radius <span class=\"token operator\">*</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token constant\">PI</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 这里一般省略 this</span>\n\t\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<h3 id=\"anchor-943e57257327b961\" style=\"position: relative;\"><a href=\"#anchor-943e57257327b961\" aria-label=\"anchor 943e57257327b961 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.8. Package</h3>\n<ul>\n<li><strong>包(package)</strong>：用于组织类，避免命名冲突。\n<ul>\n<li><mark class=\"m-mark\">如果缺省 package 语句，则类属于<strong>默认包(default package)</strong></mark>。</li>\n<li>约定俗称的包命名方式为将公司域名倒过来写。</li>\n<li><mark class=\"m-mark\">编译器在编译源文件时不会检查目录结构，但是会在运行时报错。</mark></li>\n</ul>\n</li>\n<li><strong>导入(import)</strong>：\n<ul>\n<li>使用 <code class=\"language-text\">import</code> 语句导入包中的某个类或整个包。</li>\n<li>默认行为：<code class=\"language-text\">import java.lang.*</code>。</li>\n<li>当导入的多个包中存在同名类时，可以用通过指定包名来区分。\n<ul>\n<li>举例：\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token operator\">*</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>sql<span class=\"token punctuation\">.</span></span><span class=\"token operator\">*</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Date</span> d <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 错误</span>\n<span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span>Date</span> d <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span>Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 正确</span></code></pre></div>\n</li>\n</ul>\n</li>\n<li><strong>静态导入(static import)</strong>：\n<ul>\n<li><mark class=\"m-mark\">使用 <code class=\"language-text\">import static</code> 语句导入包中的静态方法和静态域</mark>。\n<ul>\n<li>示例：\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token keyword\">static</span> <span class=\"token import static\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span></span><span class=\"token punctuation\">;</span>\nout<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, World!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// System.out</span>\n<span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// System.exit</span></code></pre></div>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-ac93657f1ef53a87\" style=\"position: relative;\"><a href=\"#anchor-ac93657f1ef53a87\" aria-label=\"anchor ac93657f1ef53a87 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.9. JAR</h3>\n<ul>\n<li><strong>创建 JAR 文件</strong>：\n<ul>\n<li>命令行：<code class=\"language-text\">jar -cvf filename.jar files</code></li>\n</ul>\n</li>\n<li><strong>运行 JAR 文件</strong>：\n<ul>\n<li>命令行：<code class=\"language-text\">java -jar filename.jar</code></li>\n</ul>\n</li>\n<li>在 JAR 中打包资源。</li>\n</ul>\n<h2 id=\"anchor-5a5c221d0e5f4f14\" style=\"position: relative;\"><a href=\"#anchor-5a5c221d0e5f4f14\" aria-label=\"anchor 5a5c221d0e5f4f14 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Ch10 Thinking in Objects</h2>\n<h3 id=\"anchor-75d4e39c51f2b1f9\" style=\"position: relative;\"><a href=\"#anchor-75d4e39c51f2b1f9\" aria-label=\"anchor 75d4e39c51f2b1f9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. Association &#x26; Aggregation &#x26; Composition</h3>\n<ol>\n<li><strong>关联(association)</strong>：表示对象之间的多重性关系。\n<ul>\n<li>示例：学生和教师之间的关联。</li>\n</ul>\n</li>\n<li><strong>聚合(aggregation)</strong>：一种方向性关联关系，表示 \"has-a\" 关系。\n<ul>\n<li>示例：一个部门包含多个员工。</li>\n</ul>\n</li>\n<li><strong>组合(composition)</strong>：聚合的一种特殊形式（即也是一种 \"has-a\" 关系），表示更强的依赖关系。\n<ul>\n<li>示例：一个人包含一个心脏，心脏不能脱离人存在。</li>\n<li>聚合和组合的区别：组合更为严格，聚合的多个对象可以均独立存在，而组合的多个对象不能独立存在。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"anchor-b0abdbff50967f0b\" style=\"position: relative;\"><a href=\"#anchor-b0abdbff50967f0b\" aria-label=\"anchor b0abdbff50967f0b permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. Wrapper Classes</h3>\n<ul>\n<li><strong>包装类(wrapper class)</strong>：指将基本数据类型封装为对象的类。\n<ul>\n<li>如 <code class=\"language-text\">Boolean</code>, <code class=\"language-text\">Integer</code>, <code class=\"language-text\">Double</code> 等等。</li>\n</ul>\n</li>\n<li>特点：\n<ol>\n<li><mark class=\"m-mark\">没有无参构造器（总得来个参数才能被包装吧）</mark>。</li>\n<li>包装类对象是不可变的。</li>\n</ol>\n</li>\n<li><strong>数值包装类(numeric wrapper class)</strong>：\n<ul>\n<li>所有数值包装类都继承自 <code class=\"language-text\">Number</code> 类，有 <code class=\"language-text\">doubleValue</code>、<code class=\"language-text\">intValue</code>、<code class=\"language-text\">longValue</code>、<code class=\"language-text\">floatValue</code>、<code class=\"language-text\">shortValue</code> 等方法，用于把包装类对象转换为对应的基本数据类型。</li>\n<li>所有数值包装类都有 <code class=\"language-text\">MAX_VALUE</code> 和 <code class=\"language-text\">MIN_VALUE</code> 两个静态常量：\n<ul>\n<li>对于整数（<code class=\"language-text\">Integer</code>, <code class=\"language-text\">Short</code>, <code class=\"language-text\">Byte</code>, <code class=\"language-text\">Long</code>）：用来表示该类型的最大值和最小值。</li>\n<li>对于浮点数（<code class=\"language-text\">Float</code>, <code class=\"language-text\">Double</code>）：<mark class=\"m-mark\"><code class=\"language-text\">MIN_VALUE</code> 用来表示该类型能表示的最小正数</mark>，<code class=\"language-text\">MAX_VALUE</code> 用来表示该类型能表示的最大值。</li>\n</ul>\n</li>\n<li>数值包装类的 <code class=\"language-text\">valueOf()</code> 静态方法不光可以将基本类型转化为对应包装类对象，也可以把字符串转化为对应包装类对象。</li>\n<li><mark class=\"m-mark\">整型包装类的 <code class=\"language-text\">parseInt(str, radix)</code> 静态方法还可以把指定进制的字符串转化为对应整型包装类</mark>。</li>\n<li>浮点数包装类的 <code class=\"language-text\">parseDouble(str)</code> 静态方法还可以把字符串转化为对应浮点数包装类。</li>\n<li><img src=\"https://img.memset0.cn/2024/12/18/qMgyh6eq.png\"alt=\"\" style=\"width: 620px; \" ></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-c46e4da49d664107\" style=\"position: relative;\"><a href=\"#anchor-c46e4da49d664107\" aria-label=\"anchor c46e4da49d664107 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. Automatic Boxing &#x26; Unboxing</h3>\n<ul>\n<li><strong>自动装箱(automatic boxing)</strong>：基本类型自动转换为包装类对象。\n<ul>\n<li>示例：<code class=\"language-text\">Integer[] intArray = {2, 4, 3};</code></li>\n<li><mark class=\"m-mark\">自动装箱会带来额外的性能开销</mark>，在需要频繁装箱和拆箱的场合，建议使用基本类型。\n<ul>\n<li>举例：这段代码答案是正确的，但是速度会慢特别多：\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Long</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0L</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tsum <span class=\"token operator\">+=</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>自动拆箱(automatic unboxing)</strong>：包装类对象自动转换为基本类型。\n<ul>\n<li>示例：<code class=\"language-text\">System.out.println(intArray[0] + intArray[1] + intArray[2]);</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-e2d2525b21ed1b85\" style=\"position: relative;\"><a href=\"#anchor-e2d2525b21ed1b85\" aria-label=\"anchor e2d2525b21ed1b85 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.4. <code class=\"language-text\">BigInteger</code> &#x26; <code class=\"language-text\">BigDecimal</code></h3>\n<ul>\n<li><mark class=\"m-mark\"><code class=\"language-text\">BigInteger</code> 和 <code class=\"language-text\">BigDecimal</code> 都是不可变类</mark>。</li>\n<li><strong><code class=\"language-text\">BigInteger</code></strong>：支持任意大小的整数运算。\n<ul>\n<li>示例：\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">BigInteger</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigInteger</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"9223372036854775807\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BigInteger</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigInteger</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BigInteger</span> c <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">multiply</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 结果：18446744073709551614</span></code></pre></div>\n</li>\n</ul>\n</li>\n<li><strong><code class=\"language-text\">BigDecimal</code></strong>：支持高精度的浮点数运算。\n<ul>\n<li>示例：\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">BigDecimal</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BigDecimal</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BigDecimal</span> c <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">divide</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span><span class=\"token constant\">ROUND_UP</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-0d15cd64740fe51b\" style=\"position: relative;\"><a href=\"#anchor-0d15cd64740fe51b\" aria-label=\"anchor 0d15cd64740fe51b permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.5. Interned Strings</h3>\n<ul>\n<li>因为字符串是不可变的且被频繁使用，为了提升性能并节省内存，Java 引入了 <strong>字符串池(string pool)</strong> 的技术，只为每一种相同的字符串只创建一份实例，这样的实例被称为 <strong>被池化的(interned)</strong> 字符串。</li>\n<li>使用 <code class=\"language-text\">new</code> 关键词创建的字符串一定会创建一个新的对象（不会被池化），使用 string initializer 创建的对象会被池化，即只有在字符串池中没有相同字符串时才会创建新的对象。\n<ul>\n<li>示例：（第一个判断是 false，第二个判断是 true）<br>\n<img src=\"https://img.memset0.cn/2024/12/18/rgcyKLVI.png\"alt=\"\" style=\"width: 618px; \" ></li>\n<li>可以使用字符串对象的 <code class=\"language-text\">intern()</code> 方法显式地将 <code class=\"language-text\">new</code> 关键词创建的字符串加入字符串池。</li>\n</ul>\n</li>\n<li>像这种字符串拼接的情况，如果不能在编译器常量化得到结果的化，则会编译到 <code class=\"language-text\">StringBuilder</code> 来拼接，并在最后返回时创建一个新的字符串对象，这种时候是不会被自动池化的，需要显式调用 <code class=\"language-text\">intern()</code> 方法。\n<ul>\n<li><img src=\"https://img.memset0.cn/2024/12/18/RKxu0vRv.png\"alt=\"\" style=\"width: 397px; \" ></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-206239058c265d89\" style=\"position: relative;\"><a href=\"#anchor-206239058c265d89\" aria-label=\"anchor 206239058c265d89 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.6. Constant Pool</h3>\n<ul>\n<li>Java 的常量池技术，是提升创建某些对象的性能而出现的，当需要一个对象时，直接从池中取一个出来，能节省不少创建对象的时间。</li>\n<li>常量池其实就是一块内存空间，存在于方法区中。</li>\n<li>对于字符串类，JVM 编译器会在编译器将字符串字面量常量化，即直接加入到常量池中。</li>\n<li>对于整数包装类，只会对 -128 到 127 之间的整数进行常量化，且不创建或管理超出这一范围的整数包装类对象。\n<ul>\n<li>为了性能提升，应尽量使用 <code class=\"language-text\">Integer.valueOf(int)</code> 方法来创建对象，而不是使用 <code class=\"language-text\">new Integer(int)</code> 方法。</li>\n<li>示例：这里划红框的两个部分的区别是前者可以在编译器优化，后者则在运行自动拆箱并计算。\n<img src=\"https://img.memset0.cn/2024/12/18/scbQfK7B.png\"alt=\"\" style=\"width: 422px; \" ></li>\n</ul>\n</li>\n<li>对于浮点数包装类，没有实现常量池。</li>\n</ul>\n<h3 id=\"anchor-a028ba515db488f2\" style=\"position: relative;\"><a href=\"#anchor-a028ba515db488f2\" aria-label=\"anchor a028ba515db488f2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.7. <code class=\"language-text\">StringBuilder</code> &#x26; <code class=\"language-text\">StringBuffer</code></h3>\n<ul>\n<li><strong><code class=\"language-text\">StringBuilder</code></strong>：\n<ul>\n<li><mark class=\"m-mark\">非线程安全</mark>，但性能更高。适用于单线程场景。</li>\n<li>方法：\n<ul>\n<li><code class=\"language-text\">+StringBuilder()</code>：构造空 StringBuilder，默认容量为 16。</li>\n<li><code class=\"language-text\">+StringBuilder(capacity: int)</code>：构造空 StringBuilder，容量为 <code class=\"language-text\">capacity</code>。</li>\n<li><code class=\"language-text\">+StringBuilder(s: String)</code>：构造一个 StringBuilder，内容为字符串 <code class=\"language-text\">s</code>。</li>\n<li><code class=\"language-text\">+append(data: char[]) : StringBuilder</code>：将字符数组追加到此字符串生成器中。</li>\n<li><code class=\"language-text\">+append(data: char[], offset: int, len: int) : StringBuilder</code>：将字符数组从 <code class=\"language-text\">offset</code> 开始，长度为 <code class=\"language-text\">len</code> 的字符追加到此字符串生成器中。</li>\n<li><code class=\"language-text\">+append(v: aPrimitiveType) : StringBuilder</code>：将原始类型的值作为字符串追加。</li>\n<li><code class=\"language-text\">+append(s: String) : StringBuilder</code>：将字符串追加到此字符串生成器中。</li>\n<li><code class=\"language-text\">+delete(startIndex: int, endIndex: int) : StringBuilder</code>：删除指定范围内的字符。</li>\n<li><code class=\"language-text\">+deleteCharAt(index: int) : StringBuilder</code>：删除指定索引处的字符。</li>\n<li><code class=\"language-text\">+insert(index: int, data: char[], offset: int, len: int) : StringBuilder</code>：将字符数组从 <code class=\"language-text\">offset</code> 开始，长度为 <code class=\"language-text\">len</code> 的字符插入到指定索引处。</li>\n<li><code class=\"language-text\">+insert(offset: int, data: char[], len: int) : StringBuilder</code>：在指定位置插入字符数组。</li>\n<li><code class=\"language-text\">+insert(offset: int, s: String) : StringBuilder</code>：在指定位置插入字符串。</li>\n<li><code class=\"language-text\">+replace(startIndex: int, endIndex: int, s: String) : StringBuilder</code>：用指定字符串替换指定范围内的字符。</li>\n<li><code class=\"language-text\">+reverse() : StringBuilder</code>：反转此字符串生成器中的字符。</li>\n<li><code class=\"language-text\">+setCharAt(index: int, ch: char) : void</code>：在指定索引处设置新字符。</li>\n<li><code class=\"language-text\">+toString() : String</code>：返回一个字符串对象。</li>\n<li><code class=\"language-text\">+capacity() : int</code>：返回此字符串生成器的容量。</li>\n<li><code class=\"language-text\">+charAt(index: int) : char</code>：返回指定索引处的字符。</li>\n<li><code class=\"language-text\">+length() : int</code>：返回字符串生成器中的字符数。</li>\n<li><code class=\"language-text\">+setLength(newLength: int) : void</code>：设置字符串生成器的新长度。</li>\n<li><code class=\"language-text\">+substring(startIndex: int) : String</code>：返回从 startIndex 开始到末尾的子字符串。</li>\n<li><code class=\"language-text\">+substring(startIndex: int, endIndex: int) : String</code>：返回从 startIndex 到 endIndex-1 的子字符串。</li>\n<li><code class=\"language-text\">+trimToSize() : void</code>：减少用于字符串生成器的存储空间大小。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code class=\"language-text\">StringBuffer</code></strong>：\n<ul>\n<li>线程安全，适用于多线程场景。</li>\n<li>接口与 <code class=\"language-text\">StringBuilder</code> 相同。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-4c60410655dc20dd\" style=\"position: relative;\"><a href=\"#anchor-4c60410655dc20dd\" aria-label=\"anchor 4c60410655dc20dd permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.8. Enum</h3>\n<ul>\n<li>使用 <code class=\"language-text\">enum</code> 关键字定义。</li>\n<li><mark class=\"m-mark\">每个枚举值都是该枚举类的实例</mark>，所有枚举类都是 <code class=\"language-text\">java.lang.Enum</code> 的子类。\n<ul>\n<li>没有可访问的构造器，不能通过 <code class=\"language-text\">new</code> 关键词创建枚举类，是真正的 final 类。</li>\n</ul>\n</li>\n<li><mark class=\"m-mark\">提供编译时的类型安全检查</mark>，若声明参数的类型为枚举类，则只能传入该参数的非 null 对象引用一定属于该枚举类的某个值。</li>\n<li><mark class=\"m-mark\">在 enum 类外使用枚举值时，需要使用 <code class=\"language-text\">enumName.enumValue</code> 的完全限定名形式</mark>。</li>\n<li>可以在 <code class=\"language-text\">switch</code> 语句中使用，此时可以不使用完全限定名。</li>\n<li>方法：\n<ul>\n<li><code class=\"language-text\">ordinal()</code> 方法：返回该枚举值的顺序，这个顺序就是根据枚举值声明的顺序确定的，从 0 开始。</li>\n<li><code class=\"language-text\">name()</code> 方法：返回该枚举值的名称。</li>\n<li><code class=\"language-text\">toString()</code> 方法：返回该枚举值的名称。</li>\n<li><code class=\"language-text\">values()</code> 静态方法：返回枚举类的所有值。</li>\n<li><code class=\"language-text\">valueOf(name: String)</code> 静态方法：可以通过枚举值的名字返回对应的枚举值实例。</li>\n</ul>\n</li>\n<li>高级用法（<strong>关联数据</strong>）：构造函数参数通过括号给出，方法通过大括号给出；两者都可缺省。\n<ul>\n<li>在一些需要用到枚举类编号的地方，不建议直接用 <code class=\"language-text\">ordinal()</code> 方法得到编号，因为这种时候返回的值就和代码中编码的顺序有关了，可以考虑通过这种方式：\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> <span class=\"token class-name\">Fruit</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">APPLE</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">PEAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">ORANGE</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 每个枚举值的构造函数参数</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 定义一个字段，用于存储水果编号</span>\n    <span class=\"token class-name\">Fruit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 构造函数，用于初始化每个枚举值的字段</span>\n        number <span class=\"token operator\">=</span> num<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">numberOfFruit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> number<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>特定于常量的方法实现：\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> <span class=\"token class-name\">Operation</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token constant\">PLUS</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">double</span> <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token constant\">MINUS</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">double</span> <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> x <span class=\"token operator\">-</span> y<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token constant\">TIMES</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">double</span> <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> x <span class=\"token operator\">*</span> y<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token constant\">DIVIDE</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">double</span> <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> x <span class=\"token operator\">/</span> y<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">double</span> <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> x<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li><strong>策略枚举</strong>：<br>\n<img src=\"https://img.memset0.cn/2024/12/18/WOszsFdr.png\"alt=\"\" style=\"width: 561px; \" ></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"anchor-450d2f485a8af607\" style=\"position: relative;\"><a href=\"#anchor-450d2f485a8af607\" aria-label=\"anchor 450d2f485a8af607 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Ch11 Inheritance and Polymorphism</h2>\n<h3 id=\"anchor-4587ec527a3d950a\" style=\"position: relative;\"><a href=\"#anchor-4587ec527a3d950a\" aria-label=\"anchor 4587ec527a3d950a permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. Superclasses and Subclasses</h3>\n<ul>\n<li><mark class=\"m-mark\">超类的构造函数是否会被继承不会被 <strong>继承(inherite)</strong>，但可以显式或隐式调用</mark>。\n<ul>\n<li>显式调用：必须使用 <code class=\"language-text\">super</code> 关键字。\n<ul>\n<li>使用 <code class=\"language-text\">super</code> 调用必须放在构造函数的第一行。</li>\n<li><mark class=\"m-mark\">不能使用超类构造函数的名称来调用超类的构造函数</mark>。</li>\n</ul>\n</li>\n<li>如果未显式调用，<mark class=\"m-mark\">会默认调用超类的无参构造函数（没有就会CE），且顺序在子类构造函数之前</mark>。</li>\n</ul>\n</li>\n<li>使用 <code class=\"language-text\">super.methodName()</code> 调用超类的方法。</li>\n<li>调用顺序类初始化时构造函数的调用顺序：\n<ul>\n<li>初始化对象的存储空间为默认值（<code class=\"language-text\">0</code>、<code class=\"language-text\">null</code> 或 <code class=\"language-text\">false</code>）。</li>\n<li>调用父类的构造函数。</li>\n<li>按顺序分别调用类成员变量和实例成员变量的初始化表达式。</li>\n<li>调用子类的构造函数剩余部分。</li>\n</ul>\n</li>\n<li>当子类的 <strong>实例变量(instance variable)</strong> 和超类的变量重名时，<mark class=\"m-mark\">子类变量会隐藏超类变量</mark>。\n<ul>\n<li>注意，这并不以为着超类变量会被覆盖，重名的实例变量和类变量是两个不同的变量，都会被保留。</li>\n<li>可以使用 <code class=\"language-text\">super.variableName</code> 访问被隐藏的超类变量。</li>\n<li>如果我们把子类实例赋值给超类对象的引用，也会访问到被隐藏的类变量。</li>\n</ul>\n</li>\n<li><mark class=\"m-mark\">继承时与超类重名的静态方法和静态变量的处理，都遵循类似的方式</mark>。</li>\n</ul>\n<h3 id=\"anchor-6954ef4eb0b98fd4\" style=\"position: relative;\"><a href=\"#anchor-6954ef4eb0b98fd4\" aria-label=\"anchor 6954ef4eb0b98fd4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. Overriding</h3>\n<ul>\n<li>子类可以重写从超类继承的方法，这种特性称为 <strong>重写(overriding)</strong>。</li>\n<li><strong>要求</strong>：\n<ul>\n<li>方法签名（方法名和参数列表）必须完全相同。</li>\n<li>只有可访问的方法才能被重写（即 private 的方法不能被重写）。\n<ul>\n<li>否则其实是实现了两个无关的方法。</li>\n</ul>\n</li>\n<li><mark class=\"m-mark\">静态方法不能被重写，只能被隐藏</mark>。</li>\n<li><mark class=\"m-mark\">重写后的方法不能比被重写的方法拥有更严格的访问权限</mark>。</li>\n</ul>\n</li>\n<li><code class=\"language-text\">@Override</code> 注解：<mark class=\"m-mark\">编译器会负责检查是否真的重写了方法，否则会报 CE</mark>。推荐始终使用 <code class=\"language-text\">@Override</code> 注解，尽管它不是必须的。</li>\n<li><mark class=\"m-mark\">重载的方法选择是静态绑定的（compile-time）， 而重写的方法选择是动态绑定的（runtime）</mark>。</li>\n<li><mark class=\"m-mark\">在父类构造函数中调用被重写的方法，调用的实际上是子类的重写后的方法</mark>。（这也是动态绑定机制的一个体现。）\n<ul>\n<li>注意：如果父类中的方法是 <code class=\"language-text\">private</code> 的话，那这里实际上没有发生重写，调用的还是父类的方法。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-2e4721a4abfd96e3\" style=\"position: relative;\"><a href=\"#anchor-2e4721a4abfd96e3\" aria-label=\"anchor 2e4721a4abfd96e3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3. Polymorphism</h3>\n<ul>\n<li><strong>多态(polymorphism)</strong>：一个超类类型的变量可以引用子类的对象。\n<ul>\n<li>示例：\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">GeometricObject</span> obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Circle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n</li>\n<li>选用的方法调用（如果存在重写的情况，则）在运行时解析，就是上文提到的动态绑定机制。</li>\n</ul>\n<h3 id=\"anchor-3df2d5b8a6620d6a\" style=\"position: relative;\"><a href=\"#anchor-3df2d5b8a6620d6a\" aria-label=\"anchor 3df2d5b8a6620d6a permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4. Generic Programming &#x26; Object Casting</h3>\n<ul>\n<li><strong>泛型编程(generic programming)</strong>：允许我们编写可以处理多种类型的代码，而不需要为每种类型单独编写代码；多态是实现泛型编程的基础。我</li>\n<li><strong>向上转换(upcasting)</strong>：子类对象可以隐式转换为超类类型。\n<ul>\n<li>示例：\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Object</span> o <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n</li>\n<li><strong>向下转换(downcasting)</strong>：超类转化为子类类型时必须显式转换。\n<ul>\n<li>向下转换并不总是成功，<mark class=\"m-mark\">在类型转换失败时会抛出一个异常</mark>。而不是像 C++ 的 <code class=\"language-text\">dynamic_cast</code> 一样返回一个空指针。</li>\n<li>可以使用 <code class=\"language-text\">instanceof</code> 检查能否进行类型转换。</li>\n<li>示例：\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Student</span> s <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">)</span> o<span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n</li>\n<li><strong><code class=\"language-text\">instanceof</code> 运算符</strong>：用于测试对象是否是某个类的实例。\n<ul>\n<li>示例：\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Circle</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Circle</span> c <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Circle</span><span class=\"token punctuation\">)</span> o<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-9880fac33b53642c\" style=\"position: relative;\"><a href=\"#anchor-9880fac33b53642c\" aria-label=\"anchor 9880fac33b53642c permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.5. <code class=\"language-text\">equals</code> method &#x26; <code class=\"language-text\">==</code> operator</h3>\n<ul>\n<li><code class=\"language-text\">==</code> 运算符用于比较两个对象的引用是否相等，即比较两个对象是否指向同一个内存地址。\n<ul>\n<li><code class=\"language-text\">==</code> 只能用于比较基本类型的内容是否相同，在比较对象引用类型时，只会比较引用是否相同而不会比较内容。</li>\n</ul>\n</li>\n<li><code class=\"language-text\">equals</code> 方法用于比较两个对象的内容是否相等，即比较两个对象的属性值是否相同。\n<ul>\n<li>对于自己定义的类，这需要重写 <code class=\"language-text\">equals</code> 方法。</li>\n<li><strong>重写 <code class=\"language-text\">equals</code> 方法</strong>。\n<ul>\n<li><mark class=\"m-mark\"><code class=\"language-text\">Object.equals</code> 方法的参数是 <code class=\"language-text\">Object</code> 类型，为了成功重写我们需要保持这一方法签名相同，并用 <code class=\"language-text\">instanceof</code> 检查参数是否是当前类的实例</mark>。</li>\n<li>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">              <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Bigram</span> <span class=\"token punctuation\">{</span>\n                  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">char</span> first<span class=\"token punctuation\">;</span>\n                  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">char</span> second<span class=\"token punctuation\">;</span>\n                  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Bigram</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> first<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> second<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>first <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span>\n                      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>second <span class=\"token operator\">=</span> second<span class=\"token punctuation\">;</span>\n                  <span class=\"token punctuation\">}</span>\n                  <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Bigram</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 错误</span>\n                      <span class=\"token keyword\">return</span> b<span class=\"token punctuation\">.</span>first <span class=\"token operator\">==</span> first <span class=\"token operator\">&amp;&amp;</span> b<span class=\"token punctuation\">.</span>second <span class=\"token operator\">==</span> second<span class=\"token punctuation\">;</span>\n                  <span class=\"token punctuation\">}</span>\n                  <span class=\"token annotation punctuation\">@Override</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 正确 (需要与 Object 类的 equals 方法签名相同)</span>\n                      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>o <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Bigram</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                      <span class=\"token class-name\">Bigram</span> b <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Bigram</span><span class=\"token punctuation\">)</span> o<span class=\"token punctuation\">;</span>\n                      <span class=\"token keyword\">return</span> b<span class=\"token punctuation\">.</span>first <span class=\"token operator\">==</span> first <span class=\"token operator\">&amp;&amp;</span> b<span class=\"token punctuation\">.</span>second <span class=\"token operator\">==</span> second<span class=\"token punctuation\">;</span>\n                  <span class=\"token punctuation\">}</span>\n              <span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-b72215d82fbbc410\" style=\"position: relative;\"><a href=\"#anchor-b72215d82fbbc410\" aria-label=\"anchor b72215d82fbbc410 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.6. The <code class=\"language-text\">final</code> Modifier</h3>\n<ul>\n<li><strong><code class=\"language-text\">final</code> 类</strong>：不能被继承。</li>\n<li><strong><code class=\"language-text\">final</code> 方法</strong>：不能被子类重写。</li>\n<li><strong><code class=\"language-text\">final</code> 变量</strong>：不能被修改。\n<ul>\n<li>如果是基本类型变量，可以理解为类似常量的概念（只能被赋值一次，之后不能被修改）。</li>\n<li>如果是对象引用变量，则只是引用的地址是常量，而对象内部的内容是可以更改的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-7ea20408fd35b93a\" style=\"position: relative;\"><a href=\"#anchor-7ea20408fd35b93a\" aria-label=\"anchor 7ea20408fd35b93a permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.7. Review: Handling Objects</h3>\n<ul>\n<li><strong>类加载过程</strong>：第一次使用类时，才会加载类\n<ul>\n<li>分配内存保存类的信息</li>\n<li>给类变量（静态变量）赋默认值</li>\n<li>加载父类</li>\n<li>设置父子关系</li>\n<li>执行类初始化代码\n<ul>\n<li>定义静态变量时的赋值语句</li>\n<li>静态初始化代码块</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>对象创建过程</strong>：\n<ul>\n<li>分配内存</li>\n<li>对所有实例变量赋默认值（<code class=\"language-text\">0</code>、<code class=\"language-text\">null</code> 或 <code class=\"language-text\">false</code>）</li>\n<li>执行实例初始化代码</li>\n</ul>\n</li>\n<li><strong>方法调用过程</strong>：\n<ul>\n<li>由于是动态绑定，所以这一实例是什么类就从什么类开始找方法。</li>\n<li>如果在当前类中找不到，就依次向父类寻找，直到找到为止。</li>\n<li>如果找不到方法，则报 <code class=\"language-text\">NoSuchMethodError</code> 错误。</li>\n<li>如果存在重载的情况，则会根据参数链表选择最匹配的方法，如果同时存在多个最优匹配，则会报错（不过需要注意，可能父类的方法被子类重写了，这种时候只会找到子类的方法）。</li>\n</ul>\n</li>\n<li>如何应对继承的双面性?\n<ul>\n<li>避免使用继承：\n<ul>\n<li>使用 <code class=\"language-text\">final</code> 限制继承。</li>\n<li>优先使用组合而非继承。</li>\n</ul>\n</li>\n<li>正确使用继承：\n<ul>\n<li>确保超类设计稳定。</li>\n<li>使用接口代替继承。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-389e594f6a393c11\" style=\"position: relative;\"><a href=\"#anchor-389e594f6a393c11\" aria-label=\"anchor 389e594f6a393c11 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.8. Decorator Pattern</h3>\n<ul>\n<li><strong>装饰器模式(decorator pattern)</strong>：允许我们通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</li>\n</ul>\n<h3 id=\"anchor-a64587e0e2669fba\" style=\"position: relative;\"><a href=\"#anchor-a64587e0e2669fba\" aria-label=\"anchor a64587e0e2669fba permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.9. Nested Classes</h3>\n<ul>\n<li><strong>嵌套类(nested class)</strong>：在一个类中嵌套另一个类。外面的类叫 <strong>外部类(outer class)</strong>，里面的类叫 <strong>内部类(inner class)</strong>。\n<ul>\n<li>内部类和外部类可以互相访问对方的私有成员变量和方法，多个内部类可以相互访问对方的私有成员变量和方法。</li>\n<li>内部类可以声明为 private 从而实现对外完全隐藏，拥有更好的封装性。</li>\n</ul>\n</li>\n<li>内部类需要调用方法时：\n<ul>\n<li>首先检查内部类是否有该方法，如果有就调用。</li>\n<li>如果内部类没有该方法，则检查并调用外部类的方法。</li>\n<li><mark class=\"m-mark\">如果内部类和外部类的方法重名且想要调用外部类的方法，需要使用 <code class=\"language-text\">OuterClass.this.methodName()</code></mark>。</li>\n<li><mark class=\"m-mark\">如果内部类和外部类的方法重名但参数列表不同，则 Java 会根据参数列表选择最匹配的方法，注意这一过程只在内部类中进行，而不会跨越到外部类的方法</mark>。</li>\n</ul>\n</li>\n<li>四种内部类：\n<ul>\n<li><strong>静态内部类(static inner class)</strong>：\n<ul>\n<li>使用 <code class=\"language-text\">static</code> 修饰。</li>\n<li>可以访问外部类的静态成员变量和静态方法，但是不能访问外部类的实例成员变量和实例方法。</li>\n<li>可以在外部类外被使用，例：<code class=\"language-text\">new OuterClass.StaticInnerClass()</code>。</li>\n</ul>\n</li>\n<li><strong>成员内部类(member inner class)</strong>：\n<ul>\n<li>没有 <code class=\"language-text\">static</code> 修饰。</li>\n<li>成员内部类需要与一个外部类实例绑定，可以访问外部类的所有成员变量和方法。</li>\n<li>在外部类外使用时需要外部类实例才能创建。<code class=\"language-text\">outer.new InnerClass()</code>。</li>\n</ul>\n</li>\n<li><strong>方法内部类(local class)</strong>：\n<ul>\n<li>定义在方法中且只能在方法中使用。</li>\n<li>方法内部类也区分是否是 <code class=\"language-text\">static</code> 修饰的，如果是 <code class=\"language-text\">static</code> 则只能访问外部类的静态成员，否则可以访问所有成员。</li>\n<li><mark class=\"m-mark\">方法内部类访问方法中的参数和局部变量时，这些变量需要声明为 <code class=\"language-text\">final</code> 的</mark>。这些变量实际上会在方法内部类创建时被复制一份作为方法内部类自己的成员变量所使用。</li>\n</ul>\n</li>\n<li><strong>匿名内部类(anonymous class)</strong>：\n<ul>\n<li>匿名内部类没有单独的类定义，而是在创建对象的同时定义类。</li>\n<li>匿名内部类没有构造函数，但可以通过参数列表调用对应的父类构造函数。</li>\n<li>和方法内部类相同，可以访问外部类的所有变量和方法，也可以访问方法中的 <code class=\"language-text\">final</code> 参数和局部变量。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"anchor-978bf9c5bdd4e2b8\" style=\"position: relative;\"><a href=\"#anchor-978bf9c5bdd4e2b8\" aria-label=\"anchor 978bf9c5bdd4e2b8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Ch12 Abstract Classes and Interfaces</h2>\n<h3 id=\"anchor-f206ccdc98113fcd\" style=\"position: relative;\"><a href=\"#anchor-f206ccdc98113fcd\" aria-label=\"anchor f206ccdc98113fcd permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1. Abstract Classes</h3>\n<ul>\n<li><strong>抽象类(abstract class)</strong> 是相对于 <strong>具体类(concrete class)</strong> 而言的：\n<ul>\n<li>抽象类是一种不能直接实例化的类（即不能通过 new 操作创建对象）。</li>\n<li>抽象类可以包含抽象方法（没有实现的方法）和具体方法（有实现的方法）。非抽象类不能包含抽象方法。</li>\n<li><mark class=\"m-mark\">抽象方法必须在子类中被完全实现，否则子类也必须是抽象类</mark>。</li>\n</ul>\n</li>\n<li>即使父类是具体类，子类也可以是抽象类。</li>\n<li>即使父类中实现了某一方法，子类也可以重写该方法为抽象方法。</li>\n<li><mark class=\"m-mark\">抽象类不能实例化，但可以作为一种数据类型使用</mark>。例如可以定义一个抽象类数组，用于存放其作为具体类的子类对象。</li>\n</ul>\n<h3 id=\"anchor-f0f3721c2c97857b\" style=\"position: relative;\"><a href=\"#anchor-f0f3721c2c97857b\" aria-label=\"anchor f0f3721c2c97857b permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2. Interfaces</h3>\n<ul>\n<li><strong>接口(interface)</strong> 是一种特殊的类的结构，用于定义类的行为规范。\n<ul>\n<li>一个类只能继承一个抽象类，但是<mark class=\"m-mark\">一个类可以实现多个接口</mark>。\n<ul>\n<li><mark class=\"m-mark\">如果多个接口中存在相同的方法签名，则会被编译器检测并报 CE</mark>。</li>\n</ul>\n</li>\n<li>接口中只能包含常量和抽象方法。\n<ul>\n<li>所有方法默认是 <code class=\"language-text\">public abstract</code> 的。</li>\n<li>所有成员变量默认是 <code class=\"language-text\">public static final</code> 的。</li>\n</ul>\n</li>\n<li>接口中不能有构造器。</li>\n<li>（Java 8 新增）静态方法：\n<ul>\n<li>属于接口本身，而不是实现类。</li>\n<li><mark class=\"m-mark\">只能通过接口名调用，而不能通过实现类或对象调用</mark>。</li>\n</ul>\n</li>\n<li>（Java 8 新增）默认方法：\n<ul>\n<li>通过 <code class=\"language-text\">default</code> 关键字修饰。</li>\n<li>提供了接口方法的默认实现，实现类可以选择重写该默认方法。</li>\n</ul>\n</li>\n<li>（Java 9 新增）私有方法：\n<ul>\n<li>只能在接口中被其他默认方法和或静态方法调用，不能被实现类访问。</li>\n</ul>\n</li>\n<li>（Java 9 新增）私有静态方法：\n<ul>\n<li>只能在接口中被其他静态方法调用，不能被实现类或默认方法访问。</li>\n</ul>\n</li>\n<li>接口可以通过 <code class=\"language-text\">extends</code> 关键词继承另一个接口。</li>\n</ul>\n</li>\n<li>相比于抽象类被设计用于描述“是什么”，接口被设计用于描述“能做什么”。\n<ul>\n<li>常用的接口如：<code class=\"language-text\">Comparable</code>、<code class=\"language-text\">Cloneable</code>。</li>\n</ul>\n</li>\n<li>类似于抽象类，接口不能被实例化，但可以作为数据类型使用。</li>\n<li>示例：自定义类实现 <code class=\"language-text\">Cloneable</code> 接口，用于标记类的对象可被克隆。\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">CloneNotSupportedException</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<h3 id=\"anchor-6edb8ba2b8eb9d4e\" style=\"position: relative;\"><a href=\"#anchor-6edb8ba2b8eb9d4e\" aria-label=\"anchor 6edb8ba2b8eb9d4e permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.3. 面向对象的设计原则</h3>\n<ul>\n<li>原则 1：不要重复自己（DRY）\n<ul>\n<li>消除重复代码，降低维护成本。</li>\n<li><strong>三次法则</strong>：\n<ol>\n<li>第一次写重复代码。</li>\n<li>第二次写时考虑重构。</li>\n<li>第三次写时必须重构。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>原则 2：封装变化\n<ul>\n<li>封装可能会变化的代码，减少对其他部分的影响。</li>\n</ul>\n</li>\n<li>原则 3：开闭原则（OCP）\n<ul>\n<li>软件实体应对扩展开放，对修改关闭。</li>\n</ul>\n</li>\n<li>原则 4：单一职责原则（SRP）\n<ul>\n<li>每个类只负责一项职责，避免职责耦合。</li>\n</ul>\n</li>\n<li>原则 5：依赖倒置原则（DIP）\n<ul>\n<li>高层模块不依赖低层模块，二者都依赖于抽象。</li>\n</ul>\n</li>\n<li>原则 6：合成复用原则（CRP）\n<ul>\n<li>优先使用组合而非继承来实现复用。</li>\n</ul>\n</li>\n<li>原则 7：里氏代换原则（LSP）\n<ul>\n<li>子类必须能够替换掉父类。</li>\n</ul>\n</li>\n<li>原则 8：接口隔离原则（ISP）\n<ul>\n<li>使用多个专门的接口，而不是一个庞大的接口。</li>\n</ul>\n</li>\n<li>原则 9：针对接口编程\n<ul>\n<li>使用接口而非具体实现，提升代码灵活性。</li>\n</ul>\n</li>\n<li>原则 10：委托原则\n<ul>\n<li>将职责委托给类本身而非客户端，减少代码重复。</li>\n</ul>\n</li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#anchor-4525d562cd577168\">1. Ch09 Objects and Classes</a></p>\n<ul>\n<li><a href=\"#anchor-f8b76a62399ea654\">1.1. Object-Oriented Programming (OOP)</a></li>\n<li><a href=\"#anchor-97dcd0317ee85134\">1.2. Constructors</a></li>\n<li><a href=\"#anchor-9738eb39ab8b5e99\">1.3. Garbage Collection (GC)</a></li>\n<li><a href=\"#anchor-d1f8bfb6e60a90cc\">1.4. Static Variables &#x26; Methods</a></li>\n<li><a href=\"#anchor-5a9e524a4cf6370a\">1.5. Encapsulation and Access Control</a></li>\n<li><a href=\"#anchor-01f528ab0ceb9cc8\">1.6. Immutable Objects and Classes</a></li>\n<li><a href=\"#anchor-bb9931fabdb9a930\">1.7. this</a></li>\n<li><a href=\"#anchor-943e57257327b961\">1.8. Package</a></li>\n<li><a href=\"#anchor-ac93657f1ef53a87\">1.9. JAR</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-5a5c221d0e5f4f14\">2. Ch10 Thinking in Objects</a></p>\n<ul>\n<li><a href=\"#anchor-75d4e39c51f2b1f9\">2.1. Association &#x26; Aggregation &#x26; Composition</a></li>\n<li><a href=\"#anchor-b0abdbff50967f0b\">2.2. Wrapper Classes</a></li>\n<li><a href=\"#anchor-c46e4da49d664107\">2.3. Automatic Boxing &#x26; Unboxing</a></li>\n<li><a href=\"#anchor-e2d2525b21ed1b85\">2.4. <code class=\"language-text\">BigInteger</code> &#x26; <code class=\"language-text\">BigDecimal</code></a></li>\n<li><a href=\"#anchor-0d15cd64740fe51b\">2.5. Interned Strings</a></li>\n<li><a href=\"#anchor-206239058c265d89\">2.6. Constant Pool</a></li>\n<li><a href=\"#anchor-a028ba515db488f2\">2.7. <code class=\"language-text\">StringBuilder</code> &#x26; <code class=\"language-text\">StringBuffer</code></a></li>\n<li><a href=\"#anchor-4c60410655dc20dd\">2.8. Enum</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-450d2f485a8af607\">3. Ch11 Inheritance and Polymorphism</a></p>\n<ul>\n<li><a href=\"#anchor-4587ec527a3d950a\">3.1. Superclasses and Subclasses</a></li>\n<li><a href=\"#anchor-6954ef4eb0b98fd4\">3.2. Overriding</a></li>\n<li><a href=\"#anchor-2e4721a4abfd96e3\">3.3. Polymorphism</a></li>\n<li><a href=\"#anchor-3df2d5b8a6620d6a\">3.4. Generic Programming &#x26; Object Casting</a></li>\n<li><a href=\"#anchor-9880fac33b53642c\">3.5. <code class=\"language-text\">equals</code> method &#x26; <code class=\"language-text\">==</code> operator</a></li>\n<li><a href=\"#anchor-b72215d82fbbc410\">3.6. The <code class=\"language-text\">final</code> Modifier</a></li>\n<li><a href=\"#anchor-7ea20408fd35b93a\">3.7. Review: Handling Objects</a></li>\n<li><a href=\"#anchor-389e594f6a393c11\">3.8. Decorator Pattern</a></li>\n<li><a href=\"#anchor-a64587e0e2669fba\">3.9. Nested Classes</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-978bf9c5bdd4e2b8\">4. Ch12 Abstract Classes and Interfaces</a></p>\n<ul>\n<li><a href=\"#anchor-f206ccdc98113fcd\">4.1. Abstract Classes</a></li>\n<li><a href=\"#anchor-f0f3721c2c97857b\">4.2. Interfaces</a></li>\n<li><a href=\"#anchor-6edb8ba2b8eb9d4e\">4.3. 面向对象的设计原则</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"Java 面向对象设计","description":null},"fields":{"cover":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#181818","images":{"fallback":{"src":"/static/ce39237edd02ddf67556432457e5f2c2/3a325/RM5PPRBV.png","srcSet":"/static/ce39237edd02ddf67556432457e5f2c2/5189a/RM5PPRBV.png 321w,\n/static/ce39237edd02ddf67556432457e5f2c2/64eff/RM5PPRBV.png 642w,\n/static/ce39237edd02ddf67556432457e5f2c2/3a325/RM5PPRBV.png 1284w","sizes":"(min-width: 1284px) 1284px, 100vw"},"sources":[{"srcSet":"/static/ce39237edd02ddf67556432457e5f2c2/a741e/RM5PPRBV.webp 321w,\n/static/ce39237edd02ddf67556432457e5f2c2/565a3/RM5PPRBV.webp 642w,\n/static/ce39237edd02ddf67556432457e5f2c2/856a5/RM5PPRBV.webp 1284w","type":"image/webp","sizes":"(min-width: 1284px) 1284px, 100vw"}]},"width":1284,"height":946}}},"slug":"/course/java/note/2/","cssclasses":null,"isDoc":true,"authors":[],"createTime":"2024 年 12 月 22 日","updateTime":"2024 年 12 月 22 日","category":"[{\"name\":\"课程笔记\",\"to\":\"/course/\"}]","propsJson":null}},"previous":{"fields":{"slug":"/course/java/note/1/"},"frontmatter":{"title":"Java 语言基础"}},"next":{"fields":{"slug":"/course/ptms/note/8/"},"frontmatter":{"title":"VIII. 假设检验"}}},"pageContext":{"id":"52cd8b44-293a-58f8-a097-dcccf44ea187","previousPostId":"1e5b3373-f109-5c97-8c4d-d20c6831740d","nextPostId":"957bc106-d6f3-5c1b-8297-60ba5e66954d","navJson":"[{\"slug\":\"/course/java\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/java/index.md\",\"title\":\"Intro\"},{\"title\":\"Note\",\"children\":[{\"slug\":\"/course/java/note/1\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/java/note/1.md\",\"title\":\"Java 语言基础\"},{\"slug\":\"/course/java/note/2\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/java/note/2.md\",\"title\":\"Java 面向对象设计\"},{\"slug\":\"/course/java/note/3\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/java/note/3.md\",\"title\":\"Java 高级特性\"}]}]"}},"staticQueryHashes":["3871233186"],"slicesMap":{}}