{"componentChunkName":"component---src-templates-post-js","path":"/course/java/note/3/","result":{"data":{"site":{"siteMetadata":{"title":"mem 的小站"}},"post":{"id":"9baa1919-5953-5e15-ae74-4b35b71654ae","excerpt":"本篇笔记主要介绍了 Java 的六个高级特性：异常处理、IO、泛型、集合框架、多线程以及 Lambda 表达式与流式处理。在异常处理部分，详细讲解了异常的分类、捕获与处理机制；IO 部分介绍了文本和二进制的输入输出操作；泛型部分阐述了泛型的使用规则与限制；集合框架部分系统地介绍了 Java 常用的集合类；多线程部分包含了线程的创建、控制与同步机制；最后的 Lambda 与流式处理部分则介绍了 Java 的函数式编程特性。（由 claude-3.5-sonnet 生成摘要）","html":"<blockquote>\n<p>本篇笔记主要介绍了 Java 的六个高级特性：异常处理、IO、泛型、集合框架、多线程以及 Lambda 表达式与流式处理。在异常处理部分，详细讲解了异常的分类、捕获与处理机制；IO 部分介绍了文本和二进制的输入输出操作；泛型部分阐述了泛型的使用规则与限制；集合框架部分系统地介绍了 Java 常用的集合类；多线程部分包含了线程的创建、控制与同步机制；最后的 Lambda 与流式处理部分则介绍了 Java 的函数式编程特性。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small></p>\n</blockquote>\n<!-- more -->\n<h2 id=\"anchor-8edaa39071c9cc48\" style=\"position: relative;\"><a href=\"#anchor-8edaa39071c9cc48\" aria-label=\"anchor 8edaa39071c9cc48 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Ch13 Exception Handling and Text IO</h2>\n<h3 id=\"anchor-f511808121211d99\" style=\"position: relative;\"><a href=\"#anchor-f511808121211d99\" aria-label=\"anchor f511808121211d99 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1. Exceptions</h3>\n<ul>\n<li><strong>异常(exception)</strong>  是程序运行时发生的错误事件，可能导致程序无法正常运行。</li>\n<li>常见的异常：\n<ul>\n<li><code class=\"language-text\">ArithmeticException</code>：除零错误。</li>\n<li><code class=\"language-text\">InputMismatchException</code>：输入数据类型不匹配。</li>\n<li><code class=\"language-text\">NullPointerException</code>：访问未初始化的对象。</li>\n</ul>\n</li>\n<li><strong>异常分类</strong>：\n<ul>\n<li><img src=\"https://img.memset0.cn/2024/12/22/3gCP2gwM.png\"alt=\"\" style=\"width: 576px; \" ></li>\n<li>上半部分的 <code class=\"language-text\">Exception</code> 是程序级错误，可以捕获并处理。\n<ul>\n<li>运行时异常（<code class=\"language-text\">RuntimeException</code>）通常由逻辑错误引发，属于 <strong>非检查型异常(unchecked exception)</strong>。\n<ul>\n<li>不需要强制捕获，通常由逻辑错误引发。</li>\n</ul>\n</li>\n<li>非运行时异常（如  <code class=\"language-text\">IOException</code> 等）需要显式处理，属于 <strong>检查型异常(checked exception)</strong>。\n<ul>\n<li><mark class=\"m-mark\">编译器强制程序员检查并处理</mark>，即程序员应该使用使用 <code class=\"language-text\">try-catch</code> 块进行捕获这些异常并进行操作。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>下半部分的 <code class=\"language-text\">Error</code> 是系统级错误，由 JVM 检测，通常不可恢复，比如内存不足。</li>\n</ul>\n</li>\n<li><strong>抛出异常</strong>：用 <code class=\"language-text\">throw</code> 关键词抛出异常示例，异常示例通常使用 <code class=\"language-text\">new</code> 运算进行创建。\n<ul>\n<li>语法：<code class=\"language-text\">throw new TheException();</code></li>\n</ul>\n</li>\n<li><strong>声明异常</strong>：定义方法时用 <code class=\"language-text\">throws</code> 关键词声明可能抛出的异常，多个异常之间用逗号隔开。\n<ul>\n<li><mark class=\"m-mark\">使用这种方法声明的异常是检查型异常，必须在调用该方法的代码中进行显示捕获，否则会报 CE</mark>。</li>\n<li>语法：<code class=\"language-text\">public void myMethod() throws IOException</code></li>\n<li>调用时，必须用：<code class=\"language-text\">try { } catch(IOException ex) { }</code> 来处理可能抛出的异常。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-b7fb0d1897aac953\" style=\"position: relative;\"><a href=\"#anchor-b7fb0d1897aac953\" aria-label=\"anchor b7fb0d1897aac953 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2. Exception Handling</h3>\n<ul>\n<li>用 <code class=\"language-text\">try-catch</code> 块捕获异常。\n<ul>\n<li>语法：<code class=\"language-text\">try { } catch(ExceptionType ex) { }</code></li>\n</ul>\n</li>\n<li><code class=\"language-text\">finally</code> 块：\n<ul>\n<li><code class=\"language-text\">finally</code> 块中的代码无论是否发生异常都会执行。</li>\n<li>使用 <code class=\"language-text\">finally</code> 块与在 <code class=\"language-text\">try-catch</code> 块之后跟语句的区别时：<mark class=\"m-mark\">如果在 <code class=\"language-text\">catch</code> 块中抛出异常（或者 return 等情况），则 <code class=\"language-text\">try-catch</code> 块之后的代码不会执行，但是 <code class=\"language-text\">finally</code> 中的代码始终会执行</mark>。<br>\n<img src=\"https://img.memset0.cn/2024/12/22/aEfAfKjt.png\"alt=\"\" style=\"width: 494px; \" ></li>\n<li><code class=\"language-text\">finally</code> 关键字保证无论程序使用何种方式退出 <code class=\"language-text\">try-catch</code> 块，<code class=\"language-text\">finally</code> 块中的代码都会被执行。更具体的，<code class=\"language-text\">finally</code> 块会在以下情况发生之后执行：\n<ul>\n<li>try 块中的代码正常执行完毕。</li>\n<li>在 try 块中抛出异常。</li>\n<li>在 try 块中执行 return、break、continue。</li>\n<li>catch 块中代码执行完毕。</li>\n<li>在 catch 块中抛出异常。</li>\n<li>在 catch 块中执行 return、break、continue</li>\n</ul>\n</li>\n<li>通常使用 <code class=\"language-text\">finally</code> 块来释放资源。</li>\n</ul>\n</li>\n<li><strong>多个 <code class=\"language-text\">catch</code> 块的情况</strong>：\n<ul>\n<li>拥有多个 <code class=\"language-text\">catch</code> 块时，JVM 会由上而下来检测每个异常是否被捕获。</li>\n<li><strong>不可达代码检测机制</strong>：如果先 <code class=\"language-text\">catch</code> 了一个异常，又 <code class=\"language-text\">catch</code> 了另一个异常的子类，则后者是不可达的。因为无论抛出什么异常，都会被先前的 <code class=\"language-text\">catch</code> 块捕获。<mark class=\"m-mark\">编译器会检测这种不可达的 <code class=\"language-text\">catch</code> 块，并报 CE</mark>。\n<ul>\n<li><mark class=\"m-mark\">所以捕获子类异常的 <code class=\"language-text\">catch</code> 块要放在捕获父类异常的 <code class=\"language-text\">catch</code> 块之前</mark>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>捕获到异常 <code class=\"language-text\">e</code> 后：\n<ul>\n<li>使用 <code class=\"language-text\">e.getMessage()</code> 获取异常信息。</li>\n<li>使用 <code class=\"language-text\">e.printStackTrace()</code> 打印异常调用堆栈。</li>\n<li>如果需要进一步抛出异常，建议带上 <code class=\"language-text\">e</code> 的异常信息：可以使用 <code class=\"language-text\">Throwable(Throwable cause)</code> 或者 <code class=\"language-text\">Throwable(String message, Throwable cause)</code> 的构造方法。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-7abcd86dc7042275\" style=\"position: relative;\"><a href=\"#anchor-7abcd86dc7042275\" aria-label=\"anchor 7abcd86dc7042275 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3. Assertions</h3>\n<ul>\n<li><strong>断言(assertions)</strong>：用于验证程序中的某些假设是否成立。</li>\n<li>语法：\n<ul>\n<li><code class=\"language-text\">assert condition;</code>，其中 <code class=\"language-text\">condition</code> 是一个布尔表达式。</li>\n<li><code class=\"language-text\">assert condition : message;</code>，其中 <code class=\"language-text\">message</code> 可以是基本数据类型或对象。</li>\n</ul>\n</li>\n<li>当断言失败时，JVM 会抛出 <code class=\"language-text\">AssertionError</code> 异常。</li>\n<li>设计原则：\n<ul>\n<li>断言仅用于开发阶段的内部检查。</li>\n<li>不应在公共方法中使用断言检查参数。</li>\n</ul>\n</li>\n<li>断言默认在运行时禁用，需要在命令行手动使用 <code class=\"language-text\">-enableassertions</code> 或 <code class=\"language-text\">-ea</code> 选项启用。</li>\n</ul>\n<h3 id=\"anchor-507a08794cd71a17\" style=\"position: relative;\"><a href=\"#anchor-507a08794cd71a17\" aria-label=\"anchor 507a08794cd71a17 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.4. Text IO</h3>\n<ul>\n<li><code class=\"language-text\">File</code> 类：提供文件和路径的抽象。\n<ul>\n<li><strong>常用方法</strong>：\n<ul>\n<li><code class=\"language-text\">exists()</code>：检查文件是否存在。</li>\n<li><code class=\"language-text\">createNewFile()</code>：创建新文件。</li>\n<li><code class=\"language-text\">delete()</code>：删除文件。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>使用 <code class=\"language-text\">Scanner</code> 类读取数据。\n<ul>\n<li><mark class=\"m-mark\">使用 <code class=\"language-text\">new Scanner(Paths.get(path))</code> 从文件中创建 <code class=\"language-text\">Scanner</code> 对象，注意不能直接写字符串</mark>。</li>\n<li><mark class=\"m-mark\">使用 <code class=\"language-text\">new Scanner((new URL(url)).openStream())</code> 从网络资源中创建 <code class=\"language-text\">Scanner</code> 对象</mark>。</li>\n<li><mark class=\"m-mark\">第二个参数（可选）用于指定编码，否则使用该系统的默认编码</mark>。</li>\n</ul>\n</li>\n<li>使用 <code class=\"language-text\">PrintWriter</code> 类向文件写入数据。\n<ul>\n<li>支持 <code class=\"language-text\">print(...)</code>、<code class=\"language-text\">println(...)</code>、<code class=\"language-text\">printf(...)</code> 等方法。</li>\n<li>第二个参数（可选）用于指定编码，否则使用该系统的默认编码。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"anchor-1960ce9ee6a3847b\" style=\"position: relative;\"><a href=\"#anchor-1960ce9ee6a3847b\" aria-label=\"anchor 1960ce9ee6a3847b permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Ch14 Binary IO</h2>\n<h3 id=\"anchor-4f646986f21aaa6d\" style=\"position: relative;\"><a href=\"#anchor-4f646986f21aaa6d\" aria-label=\"anchor 4f646986f21aaa6d permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1. Binary IO Basic</h3>\n<ul>\n<li>几乎所有方法都需要显示捕捉 <code class=\"language-text\">java.io.Exception</code> 异常，故应显式声明或捕捉。</li>\n<li><code class=\"language-text\">inputStream.read()</code> 的返回值和 <code class=\"language-text\">outputStream.write(int b)</code> 都是 <code class=\"language-text\">int</code>，但实际上都是以 <code class=\"language-text\">byte</code> 为单位读写的。\n<ul>\n<li>其中 <code class=\"language-text\">inputStream.read()</code> 在 EOF 时会返回 -1，这就是为什么需要用 <code class=\"language-text\">int</code> 而不是 <code class=\"language-text\">byte</code> 表示。</li>\n</ul>\n</li>\n<li><code class=\"language-text\">DataInputStream</code> 在到达文件末尾后继续读取数据会抛出 <code class=\"language-text\">EOFException</code> 异常。</li>\n<li><code class=\"language-text\">Reader</code> 是读取字符流的抽象类，<code class=\"language-text\">Writer</code> 是写入字符流的抽象类。\n<ul>\n<li><code class=\"language-text\">InputStreamReader</code>：字节流转字符流</li>\n<li><code class=\"language-text\">OutputStreamWrite</code>：字符流转字节流</li>\n<li><code class=\"language-text\">BufferedReader</code>、<code class=\"language-text\">BufferedWriter</code>：字符缓冲流</li>\n<li><code class=\"language-text\">FileReader</code>：<code class=\"language-text\">InputStreamReader</code> 类的直接子类，用来读取<mark class=\"m-mark\">字符</mark>文件</li>\n<li><code class=\"language-text\">FileWriter</code>：<code class=\"language-text\">OutputStreamWriter</code> 类的直接子类，用来写入<mark class=\"m-mark\">字符</mark>文件</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"anchor-79c65628383f13a5\" style=\"position: relative;\"><a href=\"#anchor-79c65628383f13a5\" aria-label=\"anchor 79c65628383f13a5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2. Object IO Stream</h3>\n<ul>\n<li><code class=\"language-text\">transient</code> 关键字：在序列化时忽略（静态成员也会被忽略）。</li>\n<li>如果一个对象不止一次写入对象流，不会存储对象的多份副本。JVM 会将对象的内容和序号一起写入对象流。</li>\n<li>反序列化后的对象，不需要调用构造函数重新构造。</li>\n<li>序列前的对象与序列化后的对象是深复制。</li>\n<li>类需要显示地实现 <code class=\"language-text\">Serializable</code> 接口才能被序列化。（即使成员都可以序列化也需要这么做）</li>\n<li>如果数组中的所有元素都是可序列化的，这个数组就是可序列化的。</li>\n<li><em>24-25 秋冬期末考试还考察了子类/父类中只有一个实现了序列化接口在序列化/反序列化时的行为，读者可以自行查阅相关资料</em>。</li>\n</ul>\n<h3 id=\"anchor-8acdbb75eb321cb1\" style=\"position: relative;\"><a href=\"#anchor-8acdbb75eb321cb1\" aria-label=\"anchor 8acdbb75eb321cb1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3. Piped IO Stream</h3>\n<ul>\n<li>PipedOutputStream 和 PipedInputStream 的作用是让多线程可以通过管道进行线程间的通讯。PipedReader 和 PipedWriter 和这两个的区别也类似：操作字符而不是字节。</li>\n<li>我们在线程 A 中向 PipedOutputStream 中写入数据，这些数据会自动的发送到与 PipedOutputStream 对应的 PipedInputStream 中，进而存储在 PipedInputStream 的缓冲中；此时，线程 B 通过读取 PipedInputStream 中的数据。就可以实现，线程 A 和线程 B 的通信。</li>\n</ul>\n<h2 id=\"anchor-9d8cf78445916ae9\" style=\"position: relative;\"><a href=\"#anchor-9d8cf78445916ae9\" aria-label=\"anchor 9d8cf78445916ae9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Ch16 Generics</h2>\n<ul>\n<li>构造方法中不需要写泛型（如是 <code class=\"language-text\">Stack()</code> 而不是 <code class=\"language-text\">Stack&lt;E>()</code>）</li>\n<li>泛型方法若编译器可以推断则可省略，否则用类似 <code class=\"language-text\">GenericMethodDemo.&lt;Integer>print(integers)</code> 的语法。</li>\n<li><strong>有界泛型类型(bounded generic type)</strong>：<code class=\"language-text\">&lt;E extends GeometricObject></code> 表示 <code class=\"language-text\">E</code> 必须是 <code class=\"language-text\">GeometricObject</code> 或其子类。</li>\n<li>泛型类型之间没有继承关系\n<ul>\n<li>如 <code class=\"language-text\">Integer</code> 和 <code class=\"language-text\">Number</code> 有继承关系但是 <code class=\"language-text\">GenericStack&lt;Integer></code> 和 <code class=\"language-text\">GenericStack&lt;Number></code> 没有</li>\n<li><code class=\"language-text\">List&lt;Integer> list = new List&lt;Object>();</code> 报错且<mark class=\"m-mark\">反之亦然</mark></li>\n</ul>\n</li>\n<li>三种通配\n<ul>\n<li><strong>unbound wildcard</strong>：<code class=\"language-text\">&lt;?></code> 适用于任何类型</li>\n<li><strong>bound wildcard</strong>：<code class=\"language-text\">&lt;? extends T></code> 类型参数必须是 T 或其子类。\n<ul>\n<li><code class=\"language-text\">List&lt;? extends Number> list = new ArrayList&lt;Integer>();</code></li>\n<li>不能添加 <code class=\"language-text\">Number</code> 或 <code class=\"language-text\">Integer</code> 或 <code class=\"language-text\">Double</code> 到 list 中</li>\n</ul>\n</li>\n<li><strong>lower-bound wildcard</strong>：<code class=\"language-text\">&lt;? super T></code> 表示类型参数必须是 T 或其父类。\n<ul>\n<li><code class=\"language-text\">List&lt;? super Integer> list = new ArrayList&lt;Number>();</code></li>\n<li>只能添加 <code class=\"language-text\">Integer</code> 或 <code class=\"language-text\">Integer</code> 的子类到 list 中</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>泛型的限制\n<ul>\n<li>不能创建泛型类型的实例\n<ul>\n<li><code class=\"language-text\">new E()</code> 会 CE</li>\n</ul>\n</li>\n<li>不能创建泛型数组\n<ul>\n<li><code class=\"language-text\">new E[10]</code> 会 CE，应改为 <code class=\"language-text\">(E[]) new Object[10]</code></li>\n</ul>\n</li>\n<li>泛型类的静态上下文中不能使用类型参数\n<ul>\n<li>泛型类的所有实例都<mark class=\"m-mark\">有相同的运行时类</mark>，所以泛型类的静态变量和方法是被它的所有实例共享的。</li>\n<li>在静态方法、数据域或初始化语句中，为了类而引用泛型参数是非法的。</li>\n</ul>\n</li>\n<li>泛型类不能继承 <code class=\"language-text\">Throwable</code>\n<ul>\n<li><code class=\"language-text\">class MyException&lt;T> extends Exception {}</code> 会 CE</li>\n<li>主要是为了 catch 的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code class=\"language-text\">ArrayList&lt;String></code> 不是一个类，所以 <code class=\"language-text\">ArrayList&lt;String> list1 = new ArrayList&lt;String>();</code> 后调用 <code class=\"language-text\">list1 instanceof ArrayList&lt;String></code> 是错误的。</li>\n</ul>\n<h2 id=\"anchor-d42ef800e4ac93bb\" style=\"position: relative;\"><a href=\"#anchor-d42ef800e4ac93bb\" aria-label=\"anchor d42ef800e4ac93bb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Ch17 Java Collections Framework</h2>\n<ul>\n<li>Collection 接口关系图（<mark class=\"m-mark\">P22</mark>）\n<ul>\n<li><code class=\"language-text\">Map</code> 是独立的接口，不继承自 <code class=\"language-text\">Collection</code></li>\n<li><code class=\"language-text\">ArrayList</code> 和 <code class=\"language-text\">LinkedList</code> 实现了 <code class=\"language-text\">List</code> 接口。</li>\n<li><code class=\"language-text\">HashSet</code> 和 <code class=\"language-text\">TreeSet</code> 实现了 <code class=\"language-text\">Set</code> 接口。</li>\n<li><code class=\"language-text\">HashMap</code> 和 <code class=\"language-text\">TreeMap</code> 实现了 <code class=\"language-text\">Map</code> 接口。</li>\n</ul>\n</li>\n<li><code class=\"language-text\">addAll</code>、<code class=\"language-text\">removeAll</code>、<code class=\"language-text\">retainAll</code> 类似于集合的并、差、交。</li>\n<li>Set\n<ul>\n<li><code class=\"language-text\">HashSet</code>\n<ul>\n<li>通过 <code class=\"language-text\">hashCode</code> 和 <code class=\"language-text\">equals</code> 方法保证元素唯一性。</li>\n<li>集合元素可以是 null，但只能放入一个 null</li>\n</ul>\n</li>\n<li><code class=\"language-text\">LinkedHashSet</code>\n<ul>\n<li>额外使用双向链表维护元素的插入顺序（似乎访问也还会被提到最前，即遵循 LRU）。</li>\n</ul>\n</li>\n<li><code class=\"language-text\">TreeSet</code>\n<ul>\n<li><code class=\"language-text\">TreeSet</code> 是 <code class=\"language-text\">SortedSet</code> 接口的唯一实现类</li>\n<li><code class=\"language-text\">SortedSet</code> 是 Set 的一个子接口。first()和 last()返回集合中的第一个和最后一个元素；headSet(toElement)和 tailSet(fromElement)返回集合中元素小于 toElement 和大于 fromElement 的那部分。</li>\n<li>NavigableSet 扩展了 SortedSet，提供导航方法 lower(e),floor(e), ceiling(e)和 higher(e)，分别返回小于、小于或等于、大于或等于、大于一个元素的元素，若没这样的元素，则返回 null。</li>\n<li>pollFirst()和 pollLast()则分别删除和返回 TreeSet 中的第一个和最后一个元素。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>List\n<ul>\n<li>ArrayList：基于动态数组。\n<ul>\n<li>支持随机访问，访问速度快。插入和删除操作效率低（特别是中间位置）。</li>\n</ul>\n</li>\n<li>LinkedList：基于双向链表。\n<ul>\n<li>插入和删除速度快。查询效率较低。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Map：<code class=\"language-text\">HashMap</code>、<code class=\"language-text\">TreeMap</code>、<code class=\"language-text\">LinkedHashMap</code>。\n<ul>\n<li>对于 <code class=\"language-text\">HashMap</code> 和 <code class=\"language-text\">LinkedHashMap</code>，自定义对象作为 key 时需要重写 <code class=\"language-text\">hashcode()</code> 和 <code class=\"language-text\">equals()</code> 方法</li>\n</ul>\n</li>\n<li>ArrayList 中迭代器的陷阱\n<ul>\n<li>在迭代过程中，调用容器的删除方法，则会抛出异常</li>\n<li>迭代器内部会维护索引位置相关的数据（包含最近返回的元素的索引和下一个返回的元素的索引），在迭代过程中，容器不能发生结构性变化</li>\n</ul>\n</li>\n<li><code class=\"language-text\">List&lt;String> a = new ArrayList&lt;String>();</code> 和 <code class=\"language-text\">List&lt;String> a = new ArrayList&lt;>();</code> 都是合法的写法。</li>\n<li><code class=\"language-text\">Map</code>  不能直接使用  <code class=\"language-text\">Iterator</code>  遍历，但可以通过  <code class=\"language-text\">entrySet()</code>、<code class=\"language-text\">keySet()</code>  或  <code class=\"language-text\">values()</code>  方法间接获取可迭代的集合。\n<code class=\"language-text\">for (Map.Entry&lt;String, Integer> entry : map.entrySet()) { System.out.println(entry.getKey() + \": \" + entry.getValue()); }</code></li>\n</ul>\n<h2 id=\"anchor-cc7b5eeb2f01f7a5\" style=\"position: relative;\"><a href=\"#anchor-cc7b5eeb2f01f7a5\" aria-label=\"anchor cc7b5eeb2f01f7a5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Ch25 Multithreading</h2>\n<ul>\n<li>创建线程\n<ul>\n<li>实现 <code class=\"language-text\">Runnable</code> 接口并将实例传递给 <code class=\"language-text\">Thread</code> 构造函数</li>\n<li>继承 <code class=\"language-text\">Thread</code> 类：重写 <code class=\"language-text\">run()</code> 方法</li>\n</ul>\n</li>\n<li>线程控制\n<ul>\n<li>使用 <code class=\"language-text\">run()</code> 启动在当前线程创建，使用 <code class=\"language-text\">start()</code> 启动在新线程创建</li>\n<li><code class=\"language-text\">Thread.yield()</code>：让出当前线程的 CPU 时间片。</li>\n<li><code class=\"language-text\">Thread.sleep(long millis)</code> 静态方法：当前线程休眠指定时间。</li>\n<li><code class=\"language-text\">anotherThread.join()</code>：等待另一个线程结束。</li>\n<li>中断\n<ul>\n<li>InterruptedException：是 sleep 和 join 的必检异常，注意放在循环体中要手动 break。</li>\n<li>线程的生命周期\n<ul>\n<li>New（新建）：线程对象被创建，但未调用 <code class=\"language-text\">start()</code> 方法。</li>\n<li>Runnable（就绪）：调用 <code class=\"language-text\">start()</code> 方法后，线程处于可运行状态，但可能未获得 CPU 时间。</li>\n<li>Running（运行）：线程获得 CPU 时间，正在执行任务。</li>\n<li>Blocked（阻塞）：线程等待某些资源（如锁或 IO）。</li>\n<li>Terminated（终止）：线程执行完毕或被中断。</li>\n</ul>\n</li>\n<li><code class=\"language-text\">isAlive()</code>：用于检查线程是否处于活动状态（Ready、Blocked 或 Running）</li>\n<li><code class=\"language-text\">interrupt()</code>：设置中断标志。对于受阻塞（<code class=\"language-text\">Object.wait()</code>、<code class=\"language-text\">Thread.join()</code>、<code class=\"language-text\">Thread.sleep()</code>）的线程，将其唤醒并抛出 InterruptedException；否则将暂时不起作用。</li>\n<li><code class=\"language-text\">isInterrupted()</code>：检查线程的中断标志是否被设置。不会清除中断标志。</li>\n</ul>\n</li>\n<li>优先级控制\n<ul>\n<li><code class=\"language-text\">setPriority(int newPriority)</code>：设置线程的优先级。</li>\n<li><code class=\"language-text\">Thread.MAX_PRIORITY</code> / <code class=\"language-text\">Thread.MIN_PRIORITY</code> / <code class=\"language-text\">Thread.NORM_PRIORITY</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>线程同步(thread synchronization)</strong>\n<ul>\n<li>内存可见性问题：一个线程对共享变量的修改，可能不被另一个线程及时看到。因为每个线程都有自己的工作内存，而共享变量存储在主内存中。如果线程对共享变量的修改没有及时刷新到主内存就可能出现问题。</li>\n<li><code class=\"language-text\">volatile</code> 关键词：保证变量的可见性。</li>\n<li><code class=\"language-text\">synchronized</code> 关键词或 <code class=\"language-text\">synchronized</code> 块\n<ul>\n<li>成员方法加 <code class=\"language-text\">synchronized</code> 相当于对 <code class=\"language-text\">this</code> 上锁，静态方法加 <code class=\"language-text\">synchronized</code> 相当于对 <code class=\"language-text\">XXClass.class</code> 上锁。</li>\n<li>功能\n<ul>\n<li>保证可见性：释放锁时，所有的写入都会写回内存，获得锁后，会从内存中读最新数据。</li>\n<li>保证互斥性：同一时刻只有一个线程可以执行 synchronized 块中的代码。</li>\n</ul>\n</li>\n<li>可重入性：对同一个线程，它在获得锁之后，在调用其他需要同样锁的代码时，可以直接调用。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code class=\"language-text\">wait()</code> &#x26; <code class=\"language-text\">notify()</code>\n<ul>\n<li>必须在 <code class=\"language-text\">synchronized</code> 方法或代码块中使用。</li>\n<li><img src=\"https://img.memset0.cn/2025/01/12/hixSD3p6.png\"alt=\"\" style=\"width: 804px; \" ></li>\n<li>用法\n<ul>\n<li><code class=\"language-text\">wait()</code>：当前线程等待，释放锁。</li>\n<li><code class=\"language-text\">notify()</code>：唤醒一个等待线程。</li>\n<li><code class=\"language-text\">notifyAll()</code>：唤醒所有等待线程。</li>\n</ul>\n</li>\n<li>机制\n<ul>\n<li>把当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为 WAITING 或 TIMED_WAITING。</li>\n<li>等待时间到或被其他线程调用 notify/notifyAll 从条件队列中移除，这是，要重新竞争对象锁</li>\n<li>如果能获得锁，线程变为 RUNNABLE，并从 wait 调用中返回</li>\n<li>否则，线程加入对象锁等待队列，线程变为 BLOCKED，只有在获得锁后才会从 wait 调用中返回。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"anchor-831444f62997703f\" style=\"position: relative;\"><a href=\"#anchor-831444f62997703f\" aria-label=\"anchor 831444f62997703f permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Ch28 Lambda &#x26; Stream &#x26; RTTI</h2>\n<ul>\n<li>Lambda 表达式是一种特殊的匿名内部类。</li>\n<li>任何可以接受一个函数式接口（Functional Interface, FI）实例的地方，都可以使用 Lambda 表达式。</li>\n<li>函数式接口：只能有一个抽象方法。可以有多个静态方法和默认方法。接口中的方法默认是 <code class=\"language-text\">public abstract</code>。\n<ul>\n<li><code class=\"language-text\">java.util.function</code> 包中包含了多种函数式接口，例如：<code class=\"language-text\">Function</code>：接收参数并返回结果。<code class=\"language-text\">Predicate</code>：接收参数并返回布尔值。<code class=\"language-text\">Consumer</code>：接收参数但无返回值。<code class=\"language-text\">Supplier</code>：无参数但返回结果。</li>\n</ul>\n</li>\n<li>Stream 对象：实现了  <code class=\"language-text\">java.util.stream.Stream</code>  接口。\n<ul>\n<li>生成流：<code class=\"language-text\">stream()</code> 或 <code class=\"language-text\">parallelStream()</code> 或 <code class=\"language-text\">Stream.of(\"a1\", \"a2\", \"a3\")</code></li>\n<li>常用方法：\n<ul>\n<li>filter：过滤满足条件的元素。</li>\n<li>map：映射为新值</li>\n<li>flatMap：映射成流并 flat 成一个</li>\n<li>distinct：去重（基于 <code class=\"language-text\">hashCode</code> 和 <code class=\"language-text\">equals</code>）</li>\n<li>sorted：排序</li>\n<li>limit(int n)：只保留前至多 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> 个</li>\n<li>skip(int n)：跳过前 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> 个</li>\n</ul>\n</li>\n<li>终端操作：\n<ul>\n<li><code class=\"language-text\">boolean allMatch(Predicate&lt;? super T> predicate);</code> 检查是否匹配所有元素。</li>\n<li><code class=\"language-text\">boolean anyMatch(Predicate&lt;? super T> predicate);</code> 检查是否至少匹配一个元素。</li>\n<li><code class=\"language-text\">boolean noneMatch(Predicate&lt;? super T> predicate);</code> 检查是否没有匹配所有元素。</li>\n<li><code class=\"language-text\">Optional&lt;T> findFirst();</code> 返回当前流中的第一个元素。</li>\n<li><code class=\"language-text\">Optional&lt;T> findAny();</code> 返回当前流中的任意元素。</li>\n<li><code class=\"language-text\">long count();</code> 返回流中元素总数。</li>\n<li><code class=\"language-text\">Optional&lt;T> max(Comparator&lt;? super T> comparator);</code> 返回流中最大值。</li>\n<li><code class=\"language-text\">Optional&lt;T> min(Comparator&lt;? super T> comparator);</code> 返回流中最小值。</li>\n<li><code class=\"language-text\">T reduce(T identity, BinaryOperator&lt;T> accumulator);</code> 可以将流中元素反复结合起来，得到一个值。返回 T。这是一个归约操作。</li>\n<li><code class=\"language-text\">collect</code>：转化为其他形式，如 <code class=\"language-text\">.collect(Collectors.toSet())</code>、<code class=\"language-text\">toList()</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code class=\"language-text\">IntStream</code> 与 <code class=\"language-text\">getAsInt()</code></li>\n<li>RTTI\n<ul>\n<li><code class=\"language-text\">object.getClass()</code> 或 <code class=\"language-text\">TheClass.class</code> 来获取类对象。</li>\n<li><code class=\"language-text\">clazz.isInstance(obj)</code> 判断 <code class=\"language-text\">obj</code> 是不是当前类或当前类子类的实例</li>\n<li><code class=\"language-text\">getSuperclass()</code>、<code class=\"language-text\">getInterfaces()</code>、<code class=\"language-text\">getModifiers()</code></li>\n<li>Method 类\n<ul>\n<li>invoke()</li>\n<li>instanceof 运算符</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#anchor-8edaa39071c9cc48\">1. Ch13 Exception Handling and Text IO</a></p>\n<ul>\n<li><a href=\"#anchor-f511808121211d99\">1.1. Exceptions</a></li>\n<li><a href=\"#anchor-b7fb0d1897aac953\">1.2. Exception Handling</a></li>\n<li><a href=\"#anchor-7abcd86dc7042275\">1.3. Assertions</a></li>\n<li><a href=\"#anchor-507a08794cd71a17\">1.4. Text IO</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-1960ce9ee6a3847b\">2. Ch14 Binary IO</a></p>\n<ul>\n<li><a href=\"#anchor-4f646986f21aaa6d\">2.1. Binary IO Basic</a></li>\n<li><a href=\"#anchor-79c65628383f13a5\">2.2. Object IO Stream</a></li>\n<li><a href=\"#anchor-8acdbb75eb321cb1\">2.3. Piped IO Stream</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#anchor-9d8cf78445916ae9\">3. Ch16 Generics</a></p>\n</li>\n<li>\n<p><a href=\"#anchor-d42ef800e4ac93bb\">4. Ch17 Java Collections Framework</a></p>\n</li>\n<li>\n<p><a href=\"#anchor-cc7b5eeb2f01f7a5\">5. Ch25 Multithreading</a></p>\n</li>\n<li>\n<p><a href=\"#anchor-831444f62997703f\">6. Ch28 Lambda &#x26; Stream &#x26; RTTI</a></p>\n</li>\n</ul>","frontmatter":{"title":"Java 高级特性","description":null},"fields":{"cover":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#181818","images":{"fallback":{"src":"/static/ce39237edd02ddf67556432457e5f2c2/3a325/RM5PPRBV.png","srcSet":"/static/ce39237edd02ddf67556432457e5f2c2/5189a/RM5PPRBV.png 321w,\n/static/ce39237edd02ddf67556432457e5f2c2/64eff/RM5PPRBV.png 642w,\n/static/ce39237edd02ddf67556432457e5f2c2/3a325/RM5PPRBV.png 1284w","sizes":"(min-width: 1284px) 1284px, 100vw"},"sources":[{"srcSet":"/static/ce39237edd02ddf67556432457e5f2c2/a741e/RM5PPRBV.webp 321w,\n/static/ce39237edd02ddf67556432457e5f2c2/565a3/RM5PPRBV.webp 642w,\n/static/ce39237edd02ddf67556432457e5f2c2/856a5/RM5PPRBV.webp 1284w","type":"image/webp","sizes":"(min-width: 1284px) 1284px, 100vw"}]},"width":1284,"height":946}}},"slug":"/course/java/note/3/","cssclasses":null,"isDoc":true,"authors":[],"createTime":"2025 年 1 月 10 日","updateTime":"2025 年 1 月 10 日","category":"[{\"name\":\"课程笔记\",\"to\":\"/course/\"}]","propsJson":null}},"previous":{"fields":{"slug":"/course/ptms/note/8/"},"frontmatter":{"title":"VIII. 假设检验"}},"next":{"fields":{"slug":"/course/oop/review/"},"frontmatter":{"title":"OOP 一站式速通笔记"}}},"pageContext":{"id":"9baa1919-5953-5e15-ae74-4b35b71654ae","previousPostId":"957bc106-d6f3-5c1b-8297-60ba5e66954d","nextPostId":"97ef5ad5-d0d0-5ed6-a167-e014ff5f8efe","navJson":"[{\"slug\":\"/course/java\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/java/index.md\",\"title\":\"Intro\"},{\"title\":\"Note\",\"children\":[{\"slug\":\"/course/java/note/1\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/java/note/1.md\",\"title\":\"Java 语言基础\"},{\"slug\":\"/course/java/note/2\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/java/note/2.md\",\"title\":\"Java 面向对象设计\"},{\"slug\":\"/course/java/note/3\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/java/note/3.md\",\"title\":\"Java 高级特性\"}]}]"}},"staticQueryHashes":["3871233186"],"slicesMap":{}}