{"componentChunkName":"component---src-templates-post-js","path":"/course/oop/review/","result":{"data":{"site":{"siteMetadata":{"title":"mem 的小站"}},"post":{"id":"97ef5ad5-d0d0-5ed6-a167-e014ff5f8efe","excerpt":"本篇笔记全面总结了面向对象程序设计课程的核心内容，包括 C++ 的基础特性（引用、常量、内存管理）、类的概念（构造、继承、多态）、运算符重载、模板编程和异常处理机制。笔记重点关注了一些易错细节，如构造顺序、虚函数机制、类型转换等，并提供了大量实用的代码示例和考试要点提示。适合有 C++ 基础的同学快速掌握 OOP 的核心概念和重要细节。（由 claude-3.5-sonnet 生成摘要）","html":"<blockquote>\n<p>本篇笔记全面总结了面向对象程序设计课程的核心内容，包括 C++ 的基础特性（引用、常量、内存管理）、类的概念（构造、继承、多态）、运算符重载、模板编程和异常处理机制。笔记重点关注了一些易错细节，如构造顺序、虚函数机制、类型转换等，并提供了大量实用的代码示例和考试要点提示。适合有 C++ 基础的同学快速掌握 OOP 的核心概念和重要细节。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small></p>\n</blockquote>\n<!-- more -->\n<p><details open disabled class=\"callout callout-type-warning\"><summary> 注意</summary><div class=\"callout-content\"><p></p><p>仅推荐有一定 C++ 基础（但没有 OOP 基础）的同学阅读此笔记，否则你可能会错过一些语言细节。</p></div></details></p>\n<h2 id=\"anchor-7b2ab744793fff11\" style=\"position: relative;\"><a href=\"#anchor-7b2ab744793fff11\" aria-label=\"anchor 7b2ab744793fff11 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. C++ Features</h2>\n<ul>\n<li>引用&#x26;\n<ul>\n<li>必须立即进行初始化，不能声明完后再赋值。</li>\n<li>引用不能重新赋值，即不能再把该引用名作为其他变量名的别名。</li>\n<li>不能创建引用的引用</li>\n<li>不能创建引用的指针（<code class=\"language-text\">int &amp;*</code> illegal）</li>\n<li>可以创建指针的引用（<code class=\"language-text\">int *&amp;</code> ok）</li>\n<li>不能创建“引用”的数组</li>\n</ul>\n</li>\n<li>常量\n<ul>\n<li>常量的值（编译器确定）记录在符号表里\n<ul>\n<li>但 <code class=\"language-text\">extern</code> 的常量不会记到符号表里</li>\n</ul>\n</li>\n<li><mark class=\"m-mark\"><code class=\"language-text\">*</code> 后的 <code class=\"language-text\">const</code> ,表示不能移动指向的位置（<code class=\"language-text\">std::string* const</code>）；<code class=\"language-text\">*</code> 前的 <code class=\"language-text\">const</code>，表示不能修改指向的对象的内容。（<code class=\"language-text\">const std::string *</code> 或 <code class=\"language-text\">std::string const *</code>）</mark></li>\n<li>String Literals\n<ul>\n<li><code class=\"language-text\">char *s = \"Hello World!\";</code> 可以移动，不能修改（因为实际上是 <code class=\"language-text\">const char*</code>）</li>\n<li><code class=\"language-text\">char s[] = \"Hello World!\";</code> 不能移动，可以修改</li>\n</ul>\n</li>\n<li>对象的常量不是编译期常量\n<ul>\n<li><code class=\"language-text\">class Array{ const int size = 10; int array[size]; };</code> 不能通过编译</li>\n<li>可以声明为 <code class=\"language-text\">static</code>：<code class=\"language-text\">static const int size = 10;</code></li>\n<li>可以使用 <code class=\"language-text\">enum</code>：<code class=\"language-text\">enum {size = 10};</code></li>\n</ul>\n</li>\n<li>注意一下：<img src=\"https://img.memset0.cn/2025/01/10/P6qrYh1P.png\"alt=\"\" style=\"width: 410px; \" ></li>\n</ul>\n</li>\n<li><code class=\"language-text\">new</code> &#x26; <code class=\"language-text\">delete</code>\n<ul>\n<li>对空地址 <code class=\"language-text\">nullptr</code> 使用 <code class=\"language-text\">delete</code> 是安全的</li>\n<li>对不是 <code class=\"language-text\">new</code> 分配的空间或已经 delete 的指针使用 <code class=\"language-text\">delete</code> 会引发错误。</li>\n<li><code class=\"language-text\">new int[10]()</code> 或 <code class=\"language-text\">new int[10]{}</code> 这种写法会初始化（Pitfall：不能写成 <code class=\"language-text\">new int[10](0)</code>）</li>\n</ul>\n</li>\n<li><img src=\"https://img.memset0.cn/2025/01/11/Aof9NG9F.png\"alt=\"\" style=\"width: 647px; \" ></li>\n</ul>\n<h2 id=\"anchor-4fb7cd18153f97ef\" style=\"position: relative;\"><a href=\"#anchor-4fb7cd18153f97ef\" aria-label=\"anchor 4fb7cd18153f97ef permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Class</h2>\n<ul>\n<li>构造顺序：<mark class=\"m-mark\">静态成员、虚基类、基类、成员变量、（自己的）构造函数</mark></li>\n<li><strong>代理构造(delegating constructor)</strong>：可以在构造函数中调用另一个构造函数\n<ul>\n<li><code class=\"language-text\">clazz(int a, int b) : clazz(a) { }</code></li>\n<li>常量数据成员直接赋值或者在代理构造中进行初始化，之后不能修改，不能在构造函数中初始化</li>\n</ul>\n</li>\n<li>静态成员变量：\n<ul>\n<li><code class=\"language-text\">static</code> 的静态成员变量不能直接赋初值，除非声明为 <code class=\"language-text\">static const</code> 的。</li>\n<li>可以先声明然后在外面用 <code class=\"language-text\">int Class::size = 10;</code> 的语法例化。</li>\n</ul>\n</li>\n<li>静态内容：\n<ul>\n<li>使用 <code class=\"language-text\">&lt;class name>::&lt;static member></code> 或 <code class=\"language-text\">&lt;object name>.&lt;static member</code> 的方法访问静态方法或者静态成员变量</li>\n</ul>\n</li>\n<li>重载\n<ul>\n<li>overload 时<mark class=\"m-mark\">先考虑是否有完全匹配的函数，找不到再考虑模板，还是找不到再考虑隐式类型转换（其中先考虑提升再考虑强制类型转化）</mark>。</li>\n</ul>\n</li>\n<li>继承：\n<ul>\n<li>权限控制\n<ul>\n<li><code class=\"language-text\">private</code> 继承：只有子类可以调用父类方法；</li>\n<li><code class=\"language-text\">protected</code> 继承：只有子类及其派生类可以调用父类方法；</li>\n<li><code class=\"language-text\">public</code> 继承：子类、派生类、外部类可以调用父类方法。</li>\n</ul>\n</li>\n<li>Constructors, Destructors 和 Assignment operation（=） 是不会继承的</li>\n</ul>\n</li>\n<li><strong>name hiding</strong>：如果子类重载了父类函数，那么父类所有同名的重载均会失效。可以使用 <code class=\"language-text\">using Base::f</code> 引入父类的这些方法。</li>\n<li>虚函数 <code class=\"language-text\">virtual</code>\n<ul>\n<li>一个父类的成员函数被声明为虚函数后，所有子类的同名函数都被<mark class=\"m-mark\">隐式</mark>地声明为虚函数。</li>\n<li>虚析构函数：为了能调用子类的析构，理论上来说我们应该将父类的析构函数声明为虚函数，即所有的析构函数都应该声明为虚函数。\n<ul>\n<li>如果不这么做，<code class=\"language-text\">delete</code> 父类指针时就只会调用静态绑定的父类析构函数</li>\n<li>如果这么做，会调用子类的析构函数，并在之后<mark class=\"m-mark\">自动</mark>调用父类的析构函数。</li>\n<li>进一步,所有的类都应该存在 vptr ,这是 RTTI 的基础。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>多继承：\n<ul>\n<li>菱形继承：A 同时被 B 、 C 继承, D 继承 B 和 C。 那么当我们把 A 的指针指向 D 的对象时,就不知道应该指向 B::A 还是 C::A ,出现冲突。 同理，如果 D 访问 A 的成员时,不知道应该访问 B::A 还是 C::A 。\n<ul>\n<li>重名的变量同时存在，通过 <code class=\"language-text\">B::a</code> 或者 <code class=\"language-text\">C::a</code> 访问，如果直接访问 <code class=\"language-text\">a</code> 会报错</li>\n</ul>\n</li>\n<li>虚继承：在继承时添加 <code class=\"language-text\">virtual</code> 关键字实现。虚继承时子类中不存在父类的对象,而是保有父类的指针。不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</li>\n</ul>\n</li>\n<li>拷贝构造\n<ul>\n<li>场景：函数传参（特例：构造函数传参：<code class=\"language-text\">Class a = c;</code>，注意 <code class=\"language-text\">Class a; a = c</code> 并不会拷贝构造）。</li>\n<li>如果不需要拷贝构造，可以将其声明为 private，在外部调用时就会报错。这种情况下不需要函数实现（<code class=\"language-text\">private: Person(const Person &amp;);</code>）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"anchor-36821b170966d8f5\" style=\"position: relative;\"><a href=\"#anchor-36821b170966d8f5\" aria-label=\"anchor 36821b170966d8f5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Overload &#x26; Casting</h2>\n<ul>\n<li>重载\n<ul>\n<li>不能被重载的运算符：<code class=\"language-text\">.</code>、<code class=\"language-text\">.*</code>、<code class=\"language-text\">::</code>、<code class=\"language-text\">?:</code>、<code class=\"language-text\">sizeof</code>、<code class=\"language-text\">typeid</code>、四种 cast（注意 <code class=\"language-text\">,</code> 是可以重载的）</li>\n<li>只能作为成员重载而不能作为友元函数重载的：<code class=\"language-text\">=</code>、<code class=\"language-text\">()</code>、<code class=\"language-text\">[]</code>、<code class=\"language-text\">-></code>、<code class=\"language-text\">->*</code></li>\n<li>成员函数 VS 自由函数\n<ul>\n<li><code class=\"language-text\">=</code>、<code class=\"language-text\">()</code>（用于类型转换）、<code class=\"language-text\">[]</code>、<code class=\"language-text\">-></code>、<code class=\"language-text\">->*</code> 必须是成员</li>\n</ul>\n</li>\n<li>重载自增运算符和自减运算符：\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">const</span> Integer<span class=\"token operator\">&amp;</span> Integer<span class=\"token double-colon punctuation\">::</span><span class=\"token keyword\">operator</span><span class=\"token operator\">++</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// ++prefix</span>\n  <span class=\"token operator\">*</span><span class=\"token keyword\">this</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> Integer Integer<span class=\"token double-colon punctuation\">::</span><span class=\"token keyword\">operator</span><span class=\"token operator\">++</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token comment\">/* unnamed */</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// postfix++</span>\n  Integer <span class=\"token function\">old</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">return</span> old<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>函数原型：\n<ul>\n<li><code class=\"language-text\">+ - * / % ^ &amp; | ~</code>\n<ul>\n<li><code class=\"language-text\">const _Tp operator X(const _Tp&amp; l, const _Tp&amp; r);</code></li>\n</ul>\n</li>\n<li><code class=\"language-text\">== != &lt; > &lt;= >= </code>\n<ul>\n<li><code class=\"language-text\">bool operator X(const _Tp&amp; l, const _Tp&amp; r);</code></li>\n</ul>\n</li>\n<li><code class=\"language-text\">[]</code>\n<ul>\n<li><code class=\"language-text\">_Tp&amp; operator X(int index); </code></li>\n</ul>\n</li>\n<li><code class=\"language-text\">= += -= *= /= &lt;&lt;= >>=</code>\n<ul>\n<li><code class=\"language-text\">_Tp&amp; operator X(_Tp&amp; l, const _Tp&amp; r);</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>类型转换\n<ul>\n<li>自定义类型转换：通过重载 <code class=\"language-text\">operator _Tp() const;</code></li>\n<li>自定义类的默认类型转换：\n<ul>\n<li><code class=\"language-text\">T => T&amp; T&amp; => T T => (const T)</code></li>\n<li><code class=\"language-text\">T[] => T* T* => T[] T* => void*</code></li>\n</ul>\n</li>\n<li>（隐式）转换的匹配规则（将 <code class=\"language-text\">A</code> 转化为 <code class=\"language-text\">B</code>）\n<ul>\n<li>精确的类型匹配（<code class=\"language-text\">A</code> 就是 <code class=\"language-text\">B</code>）</li>\n<li>内置类型转换</li>\n<li>自定义的类型转换\n<ul>\n<li>如果有 <code class=\"language-text\">B(A)</code> 的不为 <code class=\"language-text\">explicit</code> 的构造函数，则使用\n<ul>\n<li>注意语义：<code class=\"language-text\">explicit</code> 表明不能进行隐式类型转换</li>\n<li>如果使用 <code class=\"language-text\">static_cast&lt;B></code>，那么明确使用构造函数（解决 <code class=\"language-text\">explicit</code> 的问题）</li>\n</ul>\n</li>\n<li>如果有 <code class=\"language-text\">A</code> 到 <code class=\"language-text\">B</code> 的自定义类型转换，则使用</li>\n</ul>\n</li>\n<li>对于模板函数的参数，如果上述条件均不满足，则编译器会考虑使用其他版本的函数。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>cast\n<ul>\n<li><code class=\"language-text\">static_cast</code>：在相关类型之间转换，<mark class=\"m-mark\">编译时</mark>。\n<ul>\n<li>基本类型的转换（遵循上面的规则）</li>\n<li>子类指针/引用向父类指针/引用的转换（up-casting，安全）</li>\n<li>父类指针/引用向子类指针/引用的转换（down-casting，不安全，可能导致 UB）</li>\n<li><code class=\"language-text\">void*</code> 和其他类型指针的转换（安全，由开发者确保正确）</li>\n<li>否则会在编译器报错。</li>\n</ul>\n</li>\n<li><code class=\"language-text\">dynamic_cast</code>：用于<mark class=\"m-mark\">多态类型</mark>（有虚函数的类）的 down-casting，在运行时刻检查类型安全\n<ul>\n<li>父类指针/引用向子类指针/引用的转换。\n<ul>\n<li>引用类型转换失败：抛出 <code class=\"language-text\">std::bad_cast</code> 异常；</li>\n<li>指针类型转换失败：返回 <code class=\"language-text\">nullptr</code>；</li>\n</ul>\n</li>\n<li>编译期错误：不是多态类型（基类没有虚函数，<mark class=\"m-mark\">除非</mark>本身是 up-casting 这种编译器可确定的）、类型之间没有继承关系。</li>\n</ul>\n</li>\n<li><code class=\"language-text\">const_cast</code>：用于修改类型的 <code class=\"language-text\">const</code> 或 <code class=\"language-text\">volatile</code> 属性。\n<ul>\n<li>去除 <code class=\"language-text\">const</code> 属性，使变量可以修改（传给另一个指针来修改）<code class=\"language-text\">const int x = 0; const_cast&lt;int*>(&amp;x)</code></li>\n<li><code class=\"language-text\">volatile</code> 属性指的是变量不能被优化在寄存器中，每次修改必须访问内存</li>\n</ul>\n</li>\n<li><code class=\"language-text\">reinterpret_cast</code>：低级别的、无类型检查的转换。可以在几乎任何类型间转换，但是非常危险。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"anchor-27c00742cbf9aeec\" style=\"position: relative;\"><a href=\"#anchor-27c00742cbf9aeec\" aria-label=\"anchor 27c00742cbf9aeec permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Template</h2>\n<ul>\n<li>模板可以从实例类继承，可以从类模板继承。实例类只能从实例类继承。</li>\n<li>对于静态成员变量，同样在类里只能先声明，然后使用 <code class=\"language-text\">template&lt;typename T> int Derived&lt;T>::size = 10;</code> 创建。这样实际调用时，会为每个不同的 <code class=\"language-text\">T</code> 生成一个 <code class=\"language-text\">size</code> 变量。</li>\n<li>模板函数和普通函数同时存在的情况：模板函数不能进行自动类型转换但普通函数可以。</li>\n</ul>\n<h2 id=\"anchor-252b5cba70c11726\" style=\"position: relative;\"><a href=\"#anchor-252b5cba70c11726\" aria-label=\"anchor 252b5cba70c11726 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Exception</h2>\n<ul>\n<li><code class=\"language-text\">catch</code> 的括号内 <code class=\"language-text\">ErrorType&amp; e</code> 表示捕获 <code class=\"language-text\">ErrorType</code> 及其子类（如果是基本类型就不考虑子类）。使用 <code class=\"language-text\">...</code> 表示捕捉任何异常。\n<ul>\n<li><img src=\"https://img.memset0.cn/2025/01/10/QZSWliuV.png\"alt=\"\" style=\"width: 700px; \" ></li>\n</ul>\n</li>\n<li>可以直接写 <code class=\"language-text\">throw</code> 表示再抛出。</li>\n<li>异常规范：声明函数可能返回何种异常\n<ul>\n<li><code class=\"language-text\">void print(Document&amp; p) throw(PrintOffLine, BadDocument);</code></li>\n<li><code class=\"language-text\">void goodguy() throw();// throw no exceptions, until C++11</code></li>\n<li><code class=\"language-text\">void alloc() throw(...);// can throw any exception</code></li>\n<li><code class=\"language-text\">void abc() noexcept;// throw no exceptions, since C++11</code></li>\n<li>(*) 如果在函数中返回了规范之外的异常，系统会调用 <a href=\"https://en.cppreference.com/w/cpp/error/unexpected\"><code class=\"language-text\">std::unexpected()</code></a> 来处理。\n<ul>\n<li><code class=\"language-text\">std::unexpected()</code> 默认调用 <code class=\"language-text\">std::terminate()</code> 来终止程序。</li>\n<li>可以用 <code class=\"language-text\">std::set_unexpected(func)</code>将 <code class=\"language-text\">std::unexpected()</code> 重载为 <code class=\"language-text\">func()</code>；</li>\n<li>也可以用 <code class=\"language-text\">std::set_terminate(func)</code> 将 <code class=\"language-text\">std::terminate()</code> 重载为 <code class=\"language-text\">func()</code>。</li>\n<li>如果 <code class=\"language-text\">std::unexpected()</code> 被调用后，抛出的异常仍然不符合异常规范，则会抛出 <code class=\"language-text\">std::bad_exception</code> 异常。</li>\n<li>C++17 之后，异常规范说明已被弃用。使用 <code class=\"language-text\">noexcept</code> 说明函数不会抛出任何异常时，若抛出了异常，则会直接调用 <code class=\"language-text\">std::terminate()</code>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://en.cppreference.com/w/cpp/error/exception\"><code class=\"language-text\">exception</code></a>：所有异常的公共基类\n<ul>\n<li>bad 系列\n<ul>\n<li><code class=\"language-text\">bad_alloc</code>：<code class=\"language-text\">new</code> 无法分配空间抛出的异常\n<ul>\n<li><code class=\"language-text\">malloc</code> 在未成功分配空间时会返回 <code class=\"language-text\">NULL</code>。</li>\n</ul>\n</li>\n<li><code class=\"language-text\">bad_cast</code>：<code class=\"language-text\">dynamic_cast</code> 对引用的类型检查出错，抛出的异常</li>\n<li><code class=\"language-text\">bad_typeid</code>：对多态类型的空指针使用 <code class=\"language-text\">typeid</code> 抛出的异常</li>\n<li><code class=\"language-text\">bad_exception</code>：当前抛出异常的拷贝构造出错时，抛出的异常</li>\n</ul>\n</li>\n<li><code class=\"language-text\">runtime_error</code>：事件超出程序范围抛出的异常\n<ul>\n<li><code class=\"language-text\">overflow_error</code>：算数上溢抛出的异常（STL 中仅 <code class=\"language-text\">std::bitset::to_ulong</code>）</li>\n<li><code class=\"language-text\">range_error</code>：算数超界抛出的异常</li>\n</ul>\n</li>\n<li><code class=\"language-text\">logic_error</code>：程序逻辑错误引发的异常，并且可能是可以预防的\n<ul>\n<li><code class=\"language-text\">domain_error</code>：当输入超出了其类型的定义域时抛出的异常</li>\n<li><code class=\"language-text\">length_error</code>：当对容器的操作使其超出了预定义的长度上限时抛出的异常</li>\n<li><code class=\"language-text\">out_of_range</code>：当对容器的操作超出了其当前范围时抛出的异常</li>\n<li><code class=\"language-text\">invalid_argument</code>：当传入参数不合法时抛出的异常</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>空间安全：使用两步构造（不要直接在构造函数里申请空间，否则抛出异常时不会调用析构函数）\n<ul>\n<li>在构造函数内对基本变量赋值</li>\n<li>任何需要申请资源和空间的操作，在显式的 <code class=\"language-text\">init()</code> 函数内执行</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"anchor-899e6f132e37b694\" style=\"position: relative;\"><a href=\"#anchor-899e6f132e37b694\" aria-label=\"anchor 899e6f132e37b694 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Others</h2>\n<ul>\n<li><code class=\"language-text\">class</code> 中的权限控制默认为 <code class=\"language-text\">private</code>、<code class=\"language-text\">struct</code> 中的权限控制默认为 <code class=\"language-text\">public</code></li>\n<li>构造和析构的顺序是相反的。\n<ul>\n<li>无论是直接创建数组还是使用 <code class=\"language-text\">new</code> &#x26; <code class=\"language-text\">delete</code>，构造的顺序都是从小到大，析构的顺序都是从大到小</li>\n</ul>\n</li>\n<li><code class=\"language-text\">malloc</code> 不执行类的构造函数，而 <code class=\"language-text\">new</code> 出新的对象的时候会执行对象的构造函数。</li>\n<li>在类内定义的方法都会被自动声明为 <code class=\"language-text\">inline</code>，但是是否会被内联由编译器决定。</li>\n<li><code class=\"language-text\">extern</code> 说明全局变量或函数会在另一个文件中有（并链接过来）；<code class=\"language-text\">static</code> 修饰的全局变量或函数只能在当前文件中使用。</li>\n<li>volatile：表示变量或对象的值可能会在程序控制之外被改变，例如由硬件或操作系统修改。它用于告诉编译器不要对涉及 volatile 变量的代码进行优化，以确保每次访问 volatile 变量时都从内存中读取其值.</li>\n</ul>\n<h2 id=\"anchor-ef5b9eee00548d41\" style=\"position: relative;\"><a href=\"#anchor-ef5b9eee00548d41\" aria-label=\"anchor ef5b9eee00548d41 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. Pitfalls</h2>\n<ul>\n<li>几个名词\n<ul>\n<li><strong>封装(encapsulation)</strong></li>\n<li><strong>继承(inheritance)</strong></li>\n<li><strong>多态(polymorphism)</strong></li>\n</ul>\n</li>\n<li><mark class=\"m-mark\">自己写的代码别和挖空之外的部分重复了</mark></li>\n<li>关注：权限，<mark class=\"m-mark\">是否有 const</mark>；从而讨论到底是 overriding 还是 name hiding</li>\n<li>构造函数先<mark class=\"m-mark\">父类</mark>再自己，析构函数先自己再<mark class=\"m-mark\">父类</mark>不要漏了。</li>\n<li>无论是自己写程序还是读他写的程序，注意一下用 <code class=\"language-text\">delete</code> 还是 <code class=\"language-text\">delete[]</code>\n<img src=\"https://img.memset0.cn/2025/01/11/e9RJGJIY.png\"alt=\"\" style=\"width: 490px; \" ></li>\n<li>Pitfall：\n<ul>\n<li>构造函数仔细看：继承、成员变量？全局变量？</li>\n<li>析构函数仔细看：除了 delete 外还有因生命周期结束导致的析构。\n<img src=\"https://img.memset0.cn/2025/01/11/WOpk6I1c.png\"alt=\"\" style=\"width: 214px; \" ></li>\n<li>const 的话用不了非 const 的方法；静态会和成员的函数一起重载，看哪个更匹配。\n<img src=\"https://img.memset0.cn/2025/01/11/YtDCfqcw.png\"alt=\"\" style=\"width: 427px; \" ></li>\n</ul>\n</li>\n<li><img src=\"https://img.memset0.cn/2025/01/10/223RecdN.png\"alt=\"\" style=\"width: 629px; \" ></li>\n<li><img src=\"https://img.memset0.cn/2025/01/10/37j2UAOz.png\"alt=\"\" style=\"width: 630px; \" ></li>\n<li><img src=\"https://img.memset0.cn/2025/01/10/3znSJrBg.png\"alt=\"\" style=\"width: 639px; \" ></li>\n<li>throw 如果带括号就是创建一个对象，\n<ul>\n<li>throw Type()//新建一个，结束后析构</li>\n<li>throw sth // 生命周期会保证维持到 catch 结束</li>\n</ul>\n</li>\n<li><img src=\"https://img.memset0.cn/2025/01/10/izN4l72t.png\"alt=\"\" style=\"width: 434px; \" ></li>\n</ul>","tableOfContents":"<ul>\n<li><a href=\"#anchor-7b2ab744793fff11\">1. C++ Features</a></li>\n<li><a href=\"#anchor-4fb7cd18153f97ef\">2. Class</a></li>\n<li><a href=\"#anchor-36821b170966d8f5\">3. Overload &#x26; Casting</a></li>\n<li><a href=\"#anchor-27c00742cbf9aeec\">4. Template</a></li>\n<li><a href=\"#anchor-252b5cba70c11726\">5. Exception</a></li>\n<li><a href=\"#anchor-899e6f132e37b694\">6. Others</a></li>\n<li><a href=\"#anchor-ef5b9eee00548d41\">7. Pitfalls</a></li>\n</ul>","frontmatter":{"title":"OOP 一站式速通笔记","date":"2025 年 01 月 11 日","description":null},"fields":{"cover":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#181818","images":{"fallback":{"src":"/static/3a5fa33f1f52e84b99284a1f17a1d679/46a76/TzVU22d8.png","srcSet":"/static/3a5fa33f1f52e84b99284a1f17a1d679/49843/TzVU22d8.png 330w,\n/static/3a5fa33f1f52e84b99284a1f17a1d679/6792d/TzVU22d8.png 660w,\n/static/3a5fa33f1f52e84b99284a1f17a1d679/46a76/TzVU22d8.png 1320w","sizes":"(min-width: 1320px) 1320px, 100vw"},"sources":[{"srcSet":"/static/3a5fa33f1f52e84b99284a1f17a1d679/105a1/TzVU22d8.webp 330w,\n/static/3a5fa33f1f52e84b99284a1f17a1d679/06f7b/TzVU22d8.webp 660w,\n/static/3a5fa33f1f52e84b99284a1f17a1d679/0d1c2/TzVU22d8.webp 1320w","type":"image/webp","sizes":"(min-width: 1320px) 1320px, 100vw"}]},"width":1320,"height":963}}},"slug":"/course/oop/review/","cssclasses":null,"isDoc":true,"category":"[{\"name\":\"课程笔记\",\"to\":\"/course/\"}]","propsJson":null}},"previous":{"fields":{"slug":"/course/ptms/note/8/"},"frontmatter":{"title":"VIII. 假设检验"}},"next":{"fields":{"slug":"/course/co/note/5/"},"frontmatter":{"title":"V. Memory"}}},"pageContext":{"id":"97ef5ad5-d0d0-5ed6-a167-e014ff5f8efe","previousPostId":"957bc106-d6f3-5c1b-8297-60ba5e66954d","nextPostId":"51807d27-808f-5640-a002-efe438a563d9","navJson":"[{\"slug\":\"/course/oop\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/oop/index.md\",\"title\":\"课程简介\"},{\"slug\":\"/course/oop/review\",\"file\":\"/home/runner/work/gatsby-blog/gatsby-blog/content/course/oop/review.md\",\"title\":\"速通笔记\"}]"}},"staticQueryHashes":[],"slicesMap":{}}