{"data":{"allMarkdownRemark":{"nodes":[{"id":"e344b850-3fbb-5382-ab77-03704c6a384e","fields":{"slug":"/travelogue/2023-nanjing/","plainText":"\n大一新生的第一次 ICPC 区域赛。\n\n选赛站的时候还不懂得避锋芒的道理，来了才发现这一站高手云集。故而赛前已经将期望拉到最低——稳住金牌就好。\n\n比赛过程虽然有不少遗憾，但结果竟出乎意料地不错，对于我们这支新生队伍来说，算是一个比较“华丽”的开局了（此处对应比赛 K 题名称——“华丽收场”）。\n\n<!-- more -->\n\n## Day -1\n\n从学校出发前往南京，临走前还在折腾这个新博客站。\n\n坐动车时在知乎上水到 chenjb 前辈的赛前毒奶，发现这场来了好多高手。不必说来自北京大学的“重生之我是菜狗”和清华大学的“有手有脚”的两支 World Finalist 强队，来自南京邮电大学的“Cirtus”、东北大学的“天狐座”、哈尔滨工业大学的“玩原神玩的”等等队伍都不容小觑。\n\n![听名字很上流的《国际酒店》|md](https://img.memset0.cn/2023/11/07/efYripY6.jpg)\n\n入住时和生病的 Sugar 哥哥分到了一个房间，我很关心他的身体状况，但有害怕自己被传染。（内心纠结 os）\n\n晚上约了一群人出去吃饭，选了家看起来有点上流的店，整了个大众点评的套餐。开局直接给我们端上来九只醉蟹，刚准备大快朵颐，却被告知上错了——正确的剧本是，我们六个人只能分三只。\n\n![早知道先拿一个吃了！|md](https://img.memset0.cn/2023/11/07/vZMR6bRh.jpeg)\n\n不过这个甜豆花味道是真的不错，我连干了三碗。\n\n![|md](https://img.memset0.cn/2023/11/07/9vtSDfPX.jpeg)\n\n还给 Sugar 哥哥打包了点吃的回去，叫外卖时又特意为他加了一份冰糖雪梨，希望 Sugar 哥哥能快点好起来。\n\n## Day 0\n\n早上起的比较晚，好在掐着 ddl 吃上了早饭。\n\n和队友胡乱谋划一番，决定前往总统府参观。门口卖的塑料小枪支非常有意思，不由花费 20 大洋给自己也整了一个。\n\n![|md](https://img.memset0.cn/2023/11/06/InXFjUWy.jpeg)\n\n进府以后，队友本想看点“走向共和”的历史资料，没想到横竖全是“红旗插上总统府”，一下子兴致全无。\n\n![吊古抚今|md](https://img.memset0.cn/2023/11/06/ATCwfcBL.jpeg)\n\n原计划打算再去中山陵参观，结果此时三个人都有点玩不动了，遂决定回宾馆睡大觉。在床上才想起来自己把早上买的小手枪落在中午吃饭的地方了 /大哭。\n\n![吃个午饭也逃不开原神|md](https://img.memset0.cn/2023/11/06/ihKHBl7U.jpeg)\n\n一起床发现热身赛已经开始，群里被学长和教练疯狂怒斥，匆忙赶往打了最后一小时。本以为能速通四题，没想到表演了一手三线卡题，直接位列倒数。\n\n![|md](https://img.memset0.cn/2023/11/06/6swKmcSb.jpeg)\n\n![什么叫“十发罚时”啊|md](https://img.memset0.cn/2023/11/06/qlwCnygw.jpeg)\n\n晚上照例是和群友面基，见到了好多先前不认识的大佬。\n\n![|md](https://img.memset0.cn/2023/11/07/Go2aQCX7.jpg)\n\n这时笔记本电脑突然坏了，急得要死。选手群里有个大哥自称会修，于是半夜打个车直达河海大学。\n\n![河海大学|md](https://img.memset0.cn/2023/11/07/6bU9Wk40.jpeg)\n\n不得不说，河海大学的宿舍环境非常的好，甚至还配备了电梯。\n\n![宿舍楼入口标语|md](https://img.memset0.cn/2023/11/07/qWPy5MIw.jpg)\n\n绝活哥拆机研究一番断言已经没救。好在他备有一个固态硬盘盒，可以把 SSD 直接插在里面，这样我周一要交的作业就先抢救出来了。\n\n![“你这里的螺丝呢？” × N|md](https://img.memset0.cn/2023/11/07/sEGuepBm.jpeg)\n\n## Day 1\n\n可惜晚上被蚊子频繁骚扰，只睡了四个小时。早上起床后在食堂疯狂灌早饭和咖啡，希望能恢复个八成的精神状态。\n\n![这样的一盘我连干三碗|md](https://img.memset0.cn/2024/04/04/6Ub9y8Iv.png)\n\n得知发的饭票可以在食堂二楼换饮料，一口气整了好多。\n\n![搞了整整十八瓶|lg](https://img.memset0.cn/2023/11/07/8mUDghqE.jpg)\n\n前期开签到题状态一直不错，排名稳在前三，甚至还短暂反超有手有脚。\n\n前 7 道签到题写完后一下子卡 D 不会（我脑抽把凸性否了，全责），于是开始大力搞 H（有点全错了！）。这时队友一看榜发现 E 也是签到题，就让 wh 先上去写 E。\n\n一段时间过后看了眼榜，发现 D 这个题不过不行，我和 xry 重新冷静一番，重新确认了凸的性质，我马上胡了个暴力 set 的做法一发入魂。\n\n这时队友的 E 还没调出来，我和 xry 讨论了一番，发现了 K 题的决策单调性。xry 很熟练的给出了一个 DP 的做法，一番思考后我决定“利用队长权利”把 wh 赶下来让出机时。\n\n此时差不多封榜，我们位列第三。确定了稳住 E、K 的战略方针，我便专心给他们两个打辅助。我一看发现 wh 的网络流板子错的离谱，主程序里的一个边界也写错了。（全错了！全错了！）\n\nxry 很稳地通过了 K，可 E 还是调不出来。等到最后十分钟，xry 终于发现我们的双向边竟然只连了一侧（红温了！！！）。同时这题还要输出方案！！！匆忙 rush，可惜最后只差几秒钟没能成功提交。\n\n比赛结束后因为前期罚时的巨大优势，发现只有南京邮电大学的“Cirtrus”队再通过一题可以反超我们。\n\n去问了下得知他们封榜后 E 题在 258（实际上是 285）分钟一发入魂。掐指一算发现季军没了，还是有些失落。\n\n本着旅游选手的初心，我拿着本题面到处找群友要签名 /舔一舔（）\n\n![非常感谢愿意给我签名的哥哥|md](https://img.memset0.cn/2023/11/06/5dJ6Qvwq.jpeg)\n\n过了一段时间被学长提醒乐观榜上我们是第三，才发现先前的罚时算错了，我们似乎能以微弱优势领先南邮。（这么刺激？🥵）\n\n煎熬地看完讲题和华子的广告，终于等到没有感情的滚榜机器人 mangoyang 滚到我们的队伍，确定拿下季军 ！😍\n\n由于沉迷于滚榜没有去领奖处，主办方还以为我们跑路了。我只得大喊一声我们队在这里$\\sim$，~~然后把已经走到一半的有手有脚赶了下来。~~\n\n![季杯也是杯|md](https://img.memset0.cn/2023/11/06/9aJmjRDK.jpeg)\n\n赛后速通了下南京航空航天大学的食堂，好吃是真的好吃（甚至有点后悔前两天怎么在外面而不是学校吃的了）。空心菜、猪蹄和小螃蟹都很入味，比我们学校是高到不知道哪里去了。😭\n\n![|md](https://img.memset0.cn/2023/11/06/cXTO3ltp.jpeg)\n\n最后因为堵车差点没赶上高铁，在匆忙中恋恋不舍地离开南京。\n\n![会再见的，南京！|md](https://img.memset0.cn/2023/11/06/q5Gkieb2.jpeg)\n\n## Day 2+\n\n把收集的徽章挂到宿舍遮光帘上，又回归到日常的学习生活中啦~\n\n![迄今为止收集到的徽章|md](https://img.memset0.cn/2023/11/06/LrRegqMR.jpeg)\n\n![紫金港的落日|md](https://img.memset0.cn/2023/11/06/uFqKlIHn.jpeg)\n\n<!--\n\n## 最后想说的\n\n作为一个三新生组成的队伍，能在区域赛获得两战两杯的成绩，感觉还是不太容易的。几场比赛下来，发现我们三人的默契与信任已经拉满了。能参与这样一个团结友爱的队伍真的很开心，也希望我们能一路走下去~\n\n-->\n","publishedTitle":"2023 ICPC 南京站游记"}},{"id":"028947ea-3e80-5478-9295-fb4553da761a","fields":{"slug":"/oi/algorithm/bipartite-graph-game/","plainText":"\n两人在一二分图上进行决策，初始状态为二分图的一个点，两人轮流沿边行动，不允许重复访问节点，无法移动者输。\n\n这样的问题称为二分图博弈。\n\n<!-- more -->\n\n## 二分图博弈\n\n> **结论 1**\n>\n> 起点 $v$ 是先手必胜的当且仅当其在所有最大匹配上。\n\n**必要性**：如果存在一个最大匹配 $M$ 使得 $v$ 不在其上，那么先手每次操作时，要么无路可走，要么走到了某个匹配点上（否则就找到了一条增广路），于是后手只需要每次走到 $M$ 中与之相匹配的节点即可。\n\n**充分性**：当 $v$ 在所有最大匹配上时，我们取任意最大匹配 $M$，将 $v$ 移动到对应匹配点。可以证明此时 $M$ 删去点 $v$ 和走的匹配后仍是最大匹配，就回到了证明必要性中的情况。\n\n有增广路定理的一下推论：对于无向图 $G$ 和任一最大匹配 $M$，点 $v$ 必定在最大匹配上当且仅当对于 $M$，$v$ 在匹配上且不存在以 $v$ 为一端的偶数长度交错路。（否则可以沿着偶数长度交错路平移匹配方案，就得到了一个 $v$ 不是匹配点的匹配 $M'$，矛盾）。\n\n所以移动并删除点 $v$ 的图中也不存在增广路，充分性得到证明。\n\n## Dinic 求解\n\n考虑用一般网络流算法求解此类问题，我们需要优化判断一个点 $v$ 是否必定在所有最大匹配中的算法。\n\n> **结论 2**\n>\n> 点 $v$ 必定在所有最大匹配中当且仅当在某个最大流中 $S$ 到 $v$ 的边有流量，且残量网络上不存在 $S$ 到 $i$ 的路径。\n\n**充分性**：$v$ 在最大匹配 $M$ 中当且仅当 $S$ 到 $v$ 的边有流量。若残量网络上存在 $S$ 到 $v$ 的路径，则将这条路径和 $S$ 到 $v$ 的边取反即可得到一个新的，$S$ 到 $v$ 无流量的最大流。\n\n**必要性**：假设存在一个 $S$ 到 $v$ 无流量的最大流，考虑该最大流与现在的最大流之差，每个点的流量必定平衡。于是由欧拉回路定理，该图必定可被分解为若干简单环的和，取其中包含 $S$ 到 $v$ 的边即可构造出一个残量网络上 $S$ 到 $v$ 的路径。\n\n## 参考代码\n\n```cpp\ntemplate <int N, int M> struct Dinic {\n  int tot, s, t, cur[N], hed[N], dep[N], to[M << 1], val[M << 1], nxt[M << 1];\n  Dinic() { tot = 0, memset(hed, -1, sizeof(hed)); }\n  inline void add(int u, int v, int w) {\n    nxt[tot] = hed[u], to[tot] = v, val[tot] = w, hed[u] = tot++;\n    nxt[tot] = hed[v], to[tot] = u, val[tot] = 0, hed[v] = tot++;\n  }\n  bool bfs() {\n    static int u, l, r, q[N];\n    memset(dep + 1, 0, t << 2), l = r = dep[s] = 1, q[1] = s;\n    while (l <= r && (u = q[l++]))\n      for (int i = hed[u]; ~i; i = nxt[i])\n        if (val[i] && !dep[to[i]]) {\n          dep[to[i]] = dep[u] + 1;\n          q[++r] = to[i];\n        }\n    return dep[t];\n  }\n  int dfs(int u, int d) {\n    if (u == t) return d;\n    int s = 0;\n    for (int &i = cur[u]; ~i; i = nxt[i])\n      if (val[i] && dep[to[i]] == dep[u] + 1)\n        if (int e = dfs(to[i], std::min(d - s, val[i]))) {\n          s += e, val[i] -= e, val[i ^ 1] += e;\n          if (s == d) return s;\n        }\n    return s ? s : dep[s] = 0;\n  }\n  int dinic() {\n    int r = 0;\n    while (bfs()) memcpy(cur + 1, hed + 1, t << 2), r += dfs(s, 1e9);\n    return r;\n  }\n};\n\ntemplate <int N, int M> struct Main : Dinic<N, M> {\n  bool vis[N];\n  void dfs(int u) {\n    vis[u] = 0;\n    for (int i = hed[u]; ~i; i = nxt[i])\n      if (val[i] && vis[to[i]]) vis[to[i]] = 1, dfs(to[i]);\n  }\n  void filter() {\n    dfs(s);\n    for (int i = hed[s]; ~i; i = nxt[i]) vis[to[i]] &= !val[i];\n  }\n};\n```\n\n\n\n","publishedTitle":"二分图博弈学习笔记"}},{"id":"99a493b6-88d3-5b41-b011-f8817a7adeda","fields":{"slug":"/oi/algorithm/rotational-symmetry/","plainText":"\n五边形数级数的生成函数即欧拉函数：\n\n$$\n\\varphi(x) = \\prod_{n=1}^\\infty (1 - x^n)\n$$\n\n<!-- more -->\n\n## 推导\n\n五边形数定理用来描述欧拉函数展开式的特性：\n\n$$\n\\varphi(x) = \\sum_{k=-\\infty}^{\\infty} (-1)^k x^{\\frac {k(3k+1)} 2} = \\sum_{k=0}^{\\infty} (-1)^k x^{\\frac {k(3k \\pm 1)} 2}\n$$\n\n> 这一部分的证明可以参见：https://blog.csdn.net/visit_world/article/details/52734860\n\n欧拉函数的倒数是划分数的生成函数：\n\n$$\n\\frac 1 {\\varphi(x)} = \\sum_{i=0}^\\infty p(i) x^i = \\prod_{i=0}^\\infty \\sum_{j=0}^\\infty x^{ij} = \\prod_{i=0}^\\infty \\frac 1 {1 - x^i}\n$$\n\n由定义我们可以得到：\n\n$$\n\\varphi(x) \\times \\frac 1 {\\varphi(x)} = 1 \\Leftrightarrow\n\\left( \\sum_{k=0}^{\\infty} (-1)^k x^{\\frac {k(3k \\pm 1)} 2} \\right) \\left( \\sum_{i=0}^\\infty p(i) x^i \\right) = 1\n$$\n\n通过这个我们可以得到划分数的递推式。\n\n同时发现五边形数生成函数的项数是 $O(\\sqrt n)$ 级别的，故我们可以在 $O(n \\sqrt n)$ 的时间复杂度内求出划分数前 $n$ 项。\n\n我们也可以通过这种方法求有限制时的划分数：现在限制划分的每个数的大小小于 $k$，则有\n\n$$\nF(x) = \\prod_{i=0}^\\infty \\sum_{j=0}^{k-1} x^{ij} = \\prod_{i=1}^\\infty \\frac {1-x^{ik}} {1 - x^i} = \\frac {\\varphi(x^k)} {\\varphi(x)}\n$$\n\n则\n\n$$\nF(x) = \\varphi(x^k) \\times P(x)\n$$\n\n在先求出划分数的生成函数之后，我们同样可以在 $O(\\sqrt n)$ 的时间复杂度内求出 $F(x)$ 的单项。\n\n## 实现\n\n### HDU4651\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10, mod = 1e9 + 7;\nint T, n, m, f[N], g[N];\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  f[0] = 1;\n  for (int i = 1; i * (3 * i - 1) / 2 <= 100000; i++) {\n    g[m++] = i * (3 * i - 1) / 2;\n    g[m++] = i * (3 * i + 1) / 2;\n  }\n  for (int n = 1; n <= 100000; n++)\n    for (int j = 0; j < m && g[j] <= n; j++) {\n      f[n] = (f[n] + (((j >> 1) & 1) ? mod - 1ll : 1ll) * f[n - g[j]]) % mod;\n    }\n  for (cin >> T; T--;) cin >> n, cout << f[n] << '\\n';\n}\n```\n\n### HDU4658\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e5 + 10, mod = 1e9 + 7;\nint T, n, m, k, f[N], g[N];\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  f[0] = 1;\n  for (int k = 1; k * (3 * k - 1) / 2 <= 100000; k++) {\n    g[m++] = k * (3 * k - 1) / 2;\n    g[m++] = k * (3 * k + 1) / 2;\n  }\n  for (int i = 1; i <= 100000; i++)\n    for (int j = 0; j < m && g[j] <= i; j++) {\n      f[i] = (f[i] + f[i - g[j]] * ((j >> 1) & 1 ? mod - 1ll : 1ll)) % mod;\n    }\n  for (cin >> T; T--;) {\n    cin >> n >> k;\n    int res = f[n];\n    for (int i = 0; i < m && g[i] * k <= n; i++) {\n      res = (res + f[n - g[i] * k] * ((i >> 1) & 1 ? 1ll : mod - 1ll)) % mod;\n    }\n    cout << res << '\\n';\n  }\n}\n```\n","publishedTitle":"五边形数定理学习笔记"}},{"id":"6e97ae4c-fe9c-5bc5-add6-16b05e72db95","fields":{"slug":"/oi/solution/cf1053e/","plainText":"\n> 给定一棵树的欧拉序，其中被若干位被删除。你可以在被删除的位置填数，要求构造任何一个合法的欧拉序。\n>\n> $n \\leq 5 \\times 10^5, |S| = 2n - 1$。\n\n<!-- more -->\n\n## 题解\n\n### 主体思路\n\n我们可以分治，$\\operatorname{solve}(l, r)$ 表示解决 $l$ 到 $r$ 这段区间其中 $a_l = a_r$。\n\n首先如果 $a_{(l + 1) \\cdots (r - 1)}$ 中有何 $a_l$ 相等的数，那么可以继续分治，否则的话中间没有和 $a_l$ 相等的数。\n\n对于所有满足 $l < p < q < r \\text{ and } a_p = a_q$，也可以递归，递归完后删除掉除了这段区间的根节点的点。这样的话 $a_{(l + 1) \\cdots (r - 1)}$ 除 $0$ 外互不相同。\n\n接下来考虑对于所有 $x, y, 0$ 或 $0, y, x$ 的，可以直接把空格处填成 $x$，然后缩掉。这样的话只会剩下连续的 $0$。\n\n对于连续的 $0$，依次补过去，每补上一个，如果存在 $x, y, 0$ 或 $0, y, x$ 就继续缩掉。\n\n最后只剩下一个点，也就完成了递归。\n\n### 对无解的判断\n\n1. 没有足够的点用来放\n2. $a_1 \\neq a_n$\n3. 对于 $\\operatorname{solve}(l, r)$，$r - l + 1$ 是 $2$ 的倍数\n4. 对于 $\\operatorname{solve}(l, r)$，递归完后 $0$ 的个数小于非 $0$ 个数 $-1$\n5. 存在 $p < q < r < s$ 满足 $a_p = a_r \\text{ and } a_q = a_s \\text{ and } a_p \\neq a_q \\text{ and } a_r \\neq a_s$\n\n### 对于 $a_1, a_{2n - 1}$ 的特殊处理\n\n1. 如果 $a_1 \\neq 0 \\text{ and } a_{2n-1} \\neq 0 \\text{ and } a_1 \\neq a_{2n-1}$，那么无解\n2. 如果 $(a_1 = 0 \\text{ and } a_{2n-1} \\neq 0) \\text{ or } (a_1 \\neq 0 \\text{ and } a_{2n-1} = 0)$，那么 $a_1 = a_{2n-1} = \\max(a_1, a_{2n-1})$ 即可\n3. 如果 $a_1 = a_{2n-1} = 0$ 那么需要给 $a_1, a_{2n-1}$ 分配一个标号。先枚举检查有没有可以从中间选出的可能，如果没有，就新分配一个点\n\n### 对于递归的复杂度保证\n\n直接实现的可能会超时，我把相同值的下标存到一起，然后根据「CTSC2018 青蕈领主」的方式建树，先把区间内与根节点不同色的递归处理掉，再来处理根节点同色的。\n\n### 对于扫描形如 $x, y, 0$ 和 $y, x, 0$ 的复杂度保证\n\n可以开一个栈暴力扫过去，用类似括号匹配的方式处理，这里不多讲。\n\n需要注意的是，我的实现是先把已有的 $x, y, 0$ 和 $y, x, 0$ 填掉，不然有可能不是最优方案。\n\n然后两端同时扫描，如果没有可以直接填的，但给两端中的 $0$ 的点分配标号可以配对的话，就分配掉。如果都没有，随便一端填个数即可。\n\n### 复杂度证明\n\n一个数只会在某一层被处理掉，对那一层的复杂度贡献是 $\\mathcal O(1)$ 的，所以这一部分的时间复杂度为 $\\mathcal O(n)$。\n\n由于需要判断无解等等情况，可以写一个支持区间查询最大值 / 最小值的线段树 / ST 表，时间复杂度 $\\mathcal O(n \\log n)$，其中 ST 表的空间复杂度为 $\\mathcal O(n \\log n)$，可能会导致 $\\text{MLE}$。\n\n综上，时间复杂度 $\\mathcal O(n \\log n)$，空间复杂度 $\\mathcal O(n)$，可以通过本题。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 9, L = 21;\nint n, m, a[N], del[N], use[N], lg[N];\nvector<int> v[N], G[N];\nstruct info {\n  int val, id;\n  inline info() {}\n  inline info(int k) { val = a[k], id = k; }\n  inline info(int a, int b) { val = a, id = b; }\n};\nvector<info> s, h, t, bkt[N];\npriority_queue<int, vector<int>, greater<int>> q;\nvoid noSolution() { puts(\"no\"), exit(0); }\nstruct minimax {\n  int min, max;\n  inline minimax operator^(const minimax &other) const { return {std::min(min, other.min), std::max(max, other.max)}; }\n} b[N];\nstruct segment {\n  int l, r, mid;\n  minimax x;\n} p[N << 2];\nvoid build(int u, int l, int r) {\n  p[u].l = l, p[u].r = r, p[u].mid = (l + r) >> 1;\n  if (l == r) {\n    p[u].x = b[l];\n    return;\n  }\n  build(u << 1, l, p[u].mid);\n  build(u << 1 | 1, p[u].mid + 1, r);\n  p[u].x = p[u << 1].x ^ p[u << 1 | 1].x;\n}\nminimax query(int u, int l, int r) {\n  if (p[u].l == l && p[u].r == r) return p[u].x;\n  if (r <= p[u].mid) return query(u << 1, l, r);\n  else if (l > p[u].mid)\n    return query(u << 1 | 1, l, r);\n  else\n    return query(u << 1, l, p[u].mid) ^ query(u << 1 | 1, p[u].mid + 1, r);\n}\nvoid init() {\n  static int tmp[N];\n  memset(tmp, 0, sizeof tmp);\n  for (int i = 1; i <= m; i++)\n    if (a[i]) {\n      if (!tmp[a[i]]) tmp[a[i]] = i;\n      b[i].min = tmp[a[i]];\n    } else {\n      b[i].min = i;\n    }\n  memset(tmp, 0, sizeof tmp);\n  for (int i = m; i >= 1; i--)\n    if (a[i]) {\n      if (!tmp[a[i]]) tmp[a[i]] = i;\n      b[i].max = tmp[a[i]];\n    } else {\n      b[i].max = i;\n    }\n  build(1, 1, m);\n}\nminimax query(int l, int r) { return query(1, l, r); }\ninline bool possible(int l, int r) {\n  if (!((r - l + 1) & 1)) return false;\n  if (l + 1 > r - 1) return true;\n  auto it = query(l + 1, r - 1);\n  return it.max <= r && it.min >= l;\n}\ninline int newNode() {\n  static int cur = 1;\n  while (use[cur]) cur++;\n  if (cur > n) cerr << \"[No enougth nodes] No solution.\\n\", noSolution();\n  return use[cur] = 1, cur;\n}\nvoid solve(int x) {\n  vector<pair<int, int>> jump;\n  for (auto y : G[x]) {\n    solve(y);\n    jump.push_back(make_pair(*v[y].begin(), *--v[y].end()));\n  }\n  reverse(jump.begin(), jump.end());\n  for (int i = 0, L, R, at = 0; i + 1 < v[x].size(); i++) {\n    L = v[x][i], R = v[x][i + 1];\n    if (!((R - L + 1) & 1)) noSolution(); // 要求每个这样的区间为奇数\n    s.clear(), s.push_back(info(L));\n    for (int i = L + 1; i <= R - 1; i++) {\n      s.push_back(info(i));\n      if (at < jump.size() && i == jump[at].first) i = jump[at++].second;\n    }\n    s.push_back(info(R));\n    int c0 = 0, c1 = 0;\n    for (int i = 1; i + 1 < s.size(); i++) s[i].val ? ++c1 : ++c0;\n    if (c0 < c1 - 1) noSolution();\n    int tl = 0, tr = s.size() - 1;\n    while (tl < s.size() && s[tl].val) tl++;\n    while (tr >= 0 && s[tr].val) tr--;\n    if (tl == s.size()) continue;\n    for (int i = tl; i <= tr; i++)\n      if (s[i].val) {\n        if (t.size() >= 2 && (--t.end())->val && !(-- --t.end())->val) {\n          a[(-- --t.end())->id] = s[i].val;\n          del[(-- --t.end())->id] = del[(--t.end())->id] = 1;\n          t.pop_back(), t.pop_back(), t.push_back(s[i]);\n        } else {\n          t.push_back(s[i]);\n        }\n      } else {\n        if (t.size() >= 2 && (--t.end())->val && (-- --t.end())->val) {\n          a[s[i].id] = (-- --t.end())->val;\n          del[s[i].id] = del[(--t.end())->id] = 1;\n          t.pop_back();\n        } else {\n          t.push_back(s[i]);\n        }\n      }\n    t.clear(), swap(t, s);\n    for (int i = 0; i < t.size(); i++)\n      if (del[t[i].id]) del[t[i].id] = false;\n      else\n        s.push_back(t[i]);\n    t.clear();\n    for (int i = 0, j = s.size() - 1; i <= j;) {\n      if (s[i].val) {\n        h.push_back(s[i++]);\n      } else if (s[j].val) {\n        t.push_back(s[j--]);\n      } else {\n        if (h.size() >= 2) {\n          a[s[i].id] = s[i].val = (-- --h.end())->val;\n          h.pop_back(), i++;\n        } else if (t.size() >= 2) {\n          a[s[j].id] = s[j].val = (-- --t.end())->val;\n          t.pop_back(), j--;\n        } else {\n          a[s[i].id] = s[i].val = newNode();\n          h.push_back(s[i++]);\n        }\n      }\n    }\n    h.clear(), t.clear(), s.clear();\n  }\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n;\n  m = (n << 1) - 1, lg[0] = -1;\n  for (int i = 1; i <= m; i++) lg[i] = lg[i >> 1] + 1;\n  for (int i = 1; i <= m; i++) {\n    cin >> a[i];\n    if (a[i]) use[a[i]] = 1;\n  }\n  if (a[1] && a[m] && a[1] != a[m]) noSolution();\n  else if (!a[1] && !a[m]) {\n    init();\n    int any = 0;\n    for (int i = 3; i <= m - 2; i++) {\n      if (a[i] && a[i] != a[2] && a[i] != a[m - 1] && possible(1, i) && possible(i, m)) any = max(any, a[i]);\n    }\n    a[1] = a[m] = any ? any : newNode();\n  } else\n    a[1] = a[m] = a[1] | a[m];\n  init();\n  for (int i = 1; i <= m; i++)\n    if (a[i]) v[a[i]].push_back(i);\n  for (int i = 1; i <= n; i++)\n    if (v[i].size() > 1) {\n      for (int j = 0; j + 1 < v[i].size(); j++)\n        if (!possible(v[i][j], v[i][j + 1])) {\n          cerr << \"[Impossible section] \" << v[i][j] << \" \" << v[i][j + 1] << endl;\n          noSolution();\n        }\n      bkt[*--v[i].end()].push_back({*v[i].begin(), i});\n    }\n  for (int i = 1; i <= m; i++) {\n    for (auto it : bkt[i]) {\n      while (s.size() && (--s.end())->val >= it.val) {\n        G[it.id].push_back((--s.end())->id);\n        s.pop_back();\n      }\n      s.push_back(it);\n    }\n  }\n  s.clear();\n  solve(a[1]);\n  cout << \"yes\" << endl;\n  for (int i = 1; i <= m; i++) cout << a[i] << \" \\n\"[i == m];\n}\n```\n","publishedTitle":"「CF1053E」Euler tour"}},{"id":"2e49aa6c-1819-522d-aef3-060a6fa9825b","fields":{"slug":"/oi/solution/cf1264f/","plainText":"\n> 用三元组 $(a,d,n)$ 表示长度为 $n$ 的递增等差正整数序列 $\\{a, a+d, a+2d \\ldots a+(n-1)d\\}$。给定 $(a,d,n)$，要求构造 $(b,e,n)$ 满足：\n>\n> - $b,e < 2^{64}$，且是正整数\n> - 对于所有 $0 \\leq i < n$，$a+id$ 的十进制表示是 $F_{b+ie}$ 的十进制表示的后 $18$ 位的子串（如果没有 $18$ 位自动补前导零）。其中 $F_i$ 是指斐波那契数列的第 $i$ 项。\n>\n> $1 \\leq a+(n-1)d \\leq 10^6$。\n\n<!-- more -->\n\n## 题解\n\n设 $P = 10^6$，则有 $\\pi(P) \\mid 6P$，尝试得取 $n = 3P$ 是 $\\bmod P$ 意义下的周期。\n\n则有 $F_{n} \\equiv 0 \\pmod P$，$F_{n+1} \\equiv 1 \\pmod P$。考虑：\n\n- $F_{2n+1} \\equiv F_n^2 + F_{n+1}^2 \\equiv F_{n+1}^2 \\pmod {P^2}$\n- $F_{3n+1} \\equiv F_n F_{2n} + F_{n+1} F_{2n+1} \\equiv F_{n+1}^3 \\pmod {P^2}$\n- $\\ldots$\n- $F_{kn+1} \\equiv F_{n+1}^k \\pmod {P^2}$\n\n此例中，我们有 $F_{n+1} \\equiv 2 t P + 1 \\pmod P^2$，其中 $t$ 是与 $P$ 互质的整数。\n\n则 $F_{kn+1} \\equiv F_{n+1}^k \\equiv 2kt P + 1$，取 $k = 5 k' t^{-1}$，则枚举 $1 \\leq k' < 10^6$ 即可解决本题。\n\n## 代码\n\n```py\ndef exgcd(a, b):\n    if b == 0:\n        return 1, 0\n    x, y = exgcd(b, a % b)\n    return y, x - y * (a // b)\n\n\ndef inv(a, p):\n    x, y = exgcd(a, p)\n    return (x % p + p) % p\n\n\ndef xmul(a, b):\n    c = [[0, 0], [0, 0]]\n    for i in range(0, 2):\n        for j in range(0, 2):\n            for k in range(0, 2):\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % (10**12)\n    return c\n\n\ndef xpow(a, b):\n    s = [[1, 0], [0, 1]]\n    while b:\n        if b % 2:\n            s = xmul(s, a)\n        a = xmul(a, a)\n        b //= 2\n    return s\n\n\ndef fib(n):\n    if n <= 1:\n        return n\n    return xmul([[1, 0], [0, 0]], xpow([[1, 1], [1, 0]], n - 1))[0][0]\n\n\nif __name__ == \"__main__\":\n    t = fib(3 * (10**6) + 1) // (10**6)\n    u = 15 * inv(t // 2, 10**6)\n    n, a, d = map(int, input().split())\n    b = a * u * (10**6) + 1\n    e = d * u * (10**6)\n    print(b, e)\n```\n","publishedTitle":"「CF1264F」Beautiful Fibonacci Problem"}},{"id":"e7ba81f8-555e-5b3e-8c89-86fe034b07fd","fields":{"slug":"/oi/solution/cf1336e2/","plainText":"\n> 给定 $n$ 个整数 $\\langle a_1, a_2 ... a_n \\rangle$，在 $[0; 2^m)$ 的范围内。对于 $k \\in [0; m]$，求选出一个子集使得异或和的二进制表示有 $k$ 个 $1$ 的方案数。\n>\n> $1 \\leq n \\leq 2 \\times 10^5,\\ 0 \\leq m \\leq 53$。\n\n<!-- more -->\n\n## 题解\n\n### 0x01\n\n定义：\n\n- $\\operatorname{popcount}(x)$ 表示 $x$ 的二进制表示下 $1$ 的个数\n- $\\langle i, j \\rangle = \\operatorname{popcount(i\\ \\&\\ j)}$\n\n对于线性基 $S$，定义：\n\n- $\\operatorname{span}(S)$ 表示 $S$ 张成的向量空间\n- $F(S) = \\sum_{x \\in \\operatorname{span}(S)} z^x$\n- $P(S) = \\sum_{x \\in \\operatorname{span}(S)} z^{\\operatorname{popcount}(x)}$\n\n对于此题，定义\n\n- $A$ 为由题中给定数得到的线性基\n\n首先你已经会了一个 $O(2^{\\operatorname{rank}(A)})$ 的暴力，下文我们介绍一种 $O(2^{m-\\operatorname{rank}(A)})$ 的算法，就可以通过分治在 $O(2^{m/2})$ 的时间复杂度内通过本题。\n\n### 0x02\n\n由线性基的基本性质，可以得到：\n\n$$\n(z^x) * F(A) = F(A)\n$$\n\n在此基础上枚举 $x \\in \\operatorname{span}(A)$ 有\n\n$$\n\\begin{aligned}\n\tF(A) * F(A) &= F(A) \\cdot 2^{\\operatorname{rank}(A)} \\\\\n\t\\operatorname{FWT}(F(A)) \\cdot \\operatorname{FWT}(F(A)) &= \\operatorname{FWT}(F(A)) \\cdot 2^{\\operatorname{rank}(A)}\n\\end{aligned}\n$$\n\n由于是按位相乘，考虑方程 $x^2=x+1$ 的实根仅有\n\n$$\n\\left\\{ \\begin{aligned} x_1 &= 0 \\\\ x_2 &= 2^{\\operatorname{rank}(A)} \\end{aligned} \\right.\n$$\n\n故 $[z^i] \\operatorname{FWT}(F(A))  \\in \\{0, 2^{\\operatorname{rank}(A)}\\}$。\n\n### 0x03\n\n让我们再回到 $\\operatorname{FWT}$ 运算本身的意义：\n\n$$\n\\begin{aligned}\n[z^i] \\operatorname{FWT}(F(A))\n&= \\sum_{x \\in \\operatorname{span}(A)} (-1)^{\\langle i,x \\rangle} \\\\\n&\\in \\{ 0, 2^{\\operatorname{rank}(A)} \\} \\\\\n\\end{aligned}\n$$\n\n如果存在 $x$ 使得 $(-1)^{\\langle i,x \\rangle} = -1$，则 $\\operatorname{FWT}(A)_i$ 只能为 $0$。\n\n$\\langle x,y \\rangle$ 和 $\\oplus$ 运算满足结合律：\n\n$$\n\\langle i,x \\rangle \\oplus \\langle j,x \\rangle = \\langle i \\oplus j, x \\rangle\n$$\n\n可以通过把 $\\&$ 理解为二进制按位乘法，$\\oplus$ 理解为二进制不进位加法来证明。\n\n故我们只需检验 $A$ 中的每个基底而非 $\\operatorname{span}(A)$ 即可判断这一位的值。\n\n### 0x04\n\n定义 $A$ 的正交线性基为 $B$，使得对于所有 $x \\in \\operatorname{span}(A), y \\in \\operatorname{span}(B)$，满足 $\\operatorname{popcount(x \\& y)}$ 是偶数，且 $\\operatorname{rank}(A) + \\operatorname{rank}(B) = m$。\n\n根据前面的引理，有\n\n$$\nB \\cdot 2^{\\operatorname{rank}(A)} = \\operatorname{FWT} (A) \\Leftrightarrow \\operatorname{IFWT}(B \\cdot 2^{\\operatorname{rank}(A)}) = A\n$$\n\n一种简单的正交线性基构造方式是\n\n<img src=\"https://i.loli.net/2020/04/26/wKc3le9s8vBzQYr.png\" style=\"margin: auto;\" />\n\n用高斯消元整理关键位，旋转右上角到左下角得到。\n\n<img src=\"https://i.loli.net/2020/04/26/QckSaT4BjewVXNE.png\" style=\"margin: auto;\" />\n\n证明可以考虑图中圈出矩形的左上角和右上角一定为 $1$，而两向量的异或的 $\\operatorname{popcount}$ 为偶数，那么左下角和右上角的数要么全为 $0$，要么全为 $1$。\n\n### 0x05\n\n知道了正交线性基怎么求，如何计算答案呢？\n\n考虑用 $\\operatorname{FWT}$ 表示答案统计：\n\n$$\n[z^c]P(A) = [z^0] (A * G^c) = [z^0] \\operatorname{IFWT}(\\operatorname{FWT}(F(A)) \\cdot \\operatorname{FWT}(G^c))\n$$\n\n其中 $G^c$ 表示 $\\sum_{x \\geq 0} z^x [\\operatorname{popcount}(x)=c]$。\n\n其中：\n\n$$\n[z^0] \\operatorname{IFWT}(X) = 2^{-m} [z^0] \\operatorname{FWT}(X) = 2^{-m} \\sum_{i \\geq 0} [z^i] X\n$$\n\n由于 $\\operatorname{FWT}(F(A)) = F(B) \\cdot 2^k$，而 $B$ 中的元素只有 $2^{\\operatorname{rank}(B)} = 2^{m - \\operatorname{rank}(A)}$ 个。故通过暴力得到 $P(B)$，即可通过组合数计算得 $P(A)$。\n\n$$\n[z^c]P(A) = 2^{k-m} \\sum_{d \\geq 0} [z^d] P(B) \\sum_{i \\geq 0} (-1)^i \\binom d i \\binom {m-d} {c-i}\n$$\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 60, mod = 998244353;\nint n, m, k, t, c[N];\nlong long f[N], g[N];\nstruct z {\n  int x;\n  z(int x = 0) : x(x) {}\n  friend inline z operator*(z a, z b) { return (long long)a.x * b.x % mod; }\n  friend inline z operator-(z a, z b) { return (a.x -= b.x) < 0 ? a.x + mod : a.x; }\n  friend inline z operator+(z a, z b) { return (a.x += b.x) >= mod ? a.x - mod : a.x; }\n} p[N], q[N], fac[N], ifac[N];\ninline z C(int n, int m) { return n < m ? 0 : fac[n] * ifac[m] * ifac[n - m]; }\ninline z fpow(z a, int b) {\n  z s = 1;\n  for (; b; b >>= 1, a = a * a)\n    if (b & 1) s = s * a;\n  return s;\n}\ninline void insert(long long x) {\n  for (int i = m - 1; i >= 0; i--)\n    if ((x >> i) & 1) {\n      if (f[i]) x ^= f[i];\n      else {\n        f[i] = x;\n        return;\n      }\n    }\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    long long x;\n    cin >> x, insert(x);\n  }\n  for (int i = 0; i < m; i++)\n    for (int j = i + 1; j < m; j++)\n      if ((f[j] >> i) & 1) f[j] ^= f[i];\n  for (int i = 0; i < m; i++)\n    if (f[i]) c[i] = k++;\n  for (int i = 0; i < m; i++)\n    if (!f[i]) c[i] = k + (t++);\n  for (int i = 0; i < m; i++)\n    if (f[i])\n      for (int j = 0; j < m; j++)\n        if ((f[i] >> j) & 1) g[c[i]] |= 1ll << c[j];\n  for (int i = 0; i < k; i++)\n    for (int j = k; j < m; j++)\n      if ((g[i] >> j) & 1) g[j] |= 1ll << i;\n  for (int i = k; i < m; i++) g[i] |= 1ll << i;\n  if (k <= ((m + 1) >> 1)) {\n    function<void(int, long long)> dfs = [&](int i, long long s) {\n      if (i >= k) {\n        p[__builtin_popcountll(s)].x++;\n        return;\n      }\n      dfs(i + 1, s), dfs(i + 1, s ^ g[i]);\n    };\n    dfs(0, 0ll);\n  } else {\n    function<void(int, long long)> dfs = [&](int i, long long s) {\n      if (i >= m) {\n        q[__builtin_popcountll(s)].x++;\n        return;\n      }\n      dfs(i + 1, s), dfs(i + 1, s ^ g[i]);\n    };\n    dfs(k, 0ll);\n    fac[0] = ifac[0] = ifac[1] = 1;\n    for (int i = 1; i <= m; i++) fac[i] = fac[i - 1] * i;\n    for (int i = 2; i <= m; i++) ifac[i] = (mod - mod / i) * ifac[mod % i];\n    for (int i = 1; i <= m; i++) ifac[i] = ifac[i - 1] * ifac[i];\n    for (int c = 0; c <= m; c++)\n      for (int d = 0; d <= m; d++)\n        for (int i = 0; i <= c; i++) {\n          p[c] = p[c] + fpow(2, mod - 1 + k - m) * q[d] * (i & 1 ? mod - 1 : 1) * C(d, i) * C(m - d, c - i);\n        }\n  }\n  for (int i = 0; i <= m; i++) cout << (p[i] * fpow(2, n - k)).x << \" \\n\"[i == m];\n}\n```\n","publishedTitle":"「CF1336E2」Chiori and Doll Picking (hard version)"}},{"id":"116c0a36-c6f0-59e3-8783-d4ceb6fef63e","fields":{"slug":"/oi/solution/cf1292f/","plainText":"\n> 一个大小为 $n$ 的集合 $\\{a_i\\}_{i=1}^n$，每次可以选择 $(i,j,k)$，若 $a_i \\mid a_j$ 且 $a_i \\mid a_k$，可以将 $a_k$ 删去。\n>\n> 求能删除最多数的删除序列数，删除序列定义为对于一个三元组 $(i,j,k)$，每次删数把 $a_k$ 加入到删除序列中。\n>\n> $1 \\leq a_i, n \\leq 60$，保证 $a_i$ 两两不同。\n\n<!-- more -->\n\n## 题解\n\n考虑如果 $a_i \\mid a_j$，就从 $i$ 到 $j$ 连一条边，这样形成的图是一个偏序集。不妨只考虑第一层的点，称为 $A$ 类点，其余的点称为 $B$ 类点。每次删除操作可以转化为，找到一个 $A$ 类点，存在 $\\geq 2$ 的出度，就可以删掉其中任意一条出边指向的点。\n\n对于任意一个由 $A$、$B$ 类点组成的非平凡弱联通块，一定存在一种删除方式使得是剩下其中的 $A$ 类点和某一个 $B$ 类点。这就是删除最多数的方案。\n\n那么怎么统计方案数呢，我们枚举最后剩下的点，然后把删除操作倒过来做，变成加入操作。那么我们可以状压一个状态，是一个 $A$ 类点的集合，此时这些 $A$ 类点有至少 $1$ 的出度。那么每次被反向「删除」回来的点一定和状态中的某一个 $A$ 类点有边，且会产生两种影响，即：要么增加后状态不变，要么增加后使得更多的 $A$ 类点变成「可用」。\n\n我们不妨在每次导致第二种影响的时候统计方案，就不会统计重复，这样的话可以得到一个 $O(2^{r} n^2)$ 的暴力 DP，其中 $r$ 是 $A$ 类点的个数。\n\n如果我们删除没有出度的点，容易证明 $r \\leq 15$（$[16,30] \\cup [46,60]$），可以通过本题。实际上如果特判出度为 $1$，能让 $r$ 做到更小。\n\n## 代码\n\n<!-- more -->\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 65, mod = 1e9 + 7;\nint n, m, tot, sum, ans, in[N], out[N], anc[N], val[N], tag[N], fac[N], ifac[N], S[1 << 15], dp[N][1 << 15];\nlong long T[1 << 15];\nint find(int x) { return anc[x] == x ? x : anc[x] = find(anc[x]); }\ninline int C(int n, int m) { return n < m ? 0 : (long long)fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  fac[0] = ifac[0] = ifac[1] = 1;\n  for (int i = 2; i < N; i++) ifac[i] = (long long)(mod - mod / i) * ifac[mod % i] % mod;\n  for (int i = 1; i < N; i++) fac[i] = (long long)fac[i - 1] * i % mod, ifac[i] = (long long)ifac[i - 1] * ifac[i] % mod;\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> val[i], tag[val[i]] = true;\n  m = *max_element(val + 1, val + n + 1);\n  for (int i = 1; i <= m; i++)\n    if (tag[i]) anc[i] = i;\n  for (int i = 1; i <= m; i++)\n    if (tag[i])\n      for (int j = (i << 1); j <= m; j += i)\n        if (tag[j]) {\n          out[i]++, in[j]++;\n          anc[find(i)] = find(j);\n        }\n  ans = 1;\n  for (int c = 1; c <= m; c++)\n    if (tag[c] && find(c) == c) {\n      vector<int> a, b;\n      vector<long long> A, B;\n      for (int i = 1; i <= m; i++)\n        if (tag[i] && find(i) == c) {\n          if (!in[i]) {\n            if (!out[i]) continue;\n            a.push_back(i);\n          } else {\n            b.push_back(i);\n          }\n        }\n      if (!b.size()) continue;\n      A.resize(a.size());\n      B.resize(b.size());\n      for (int i = 0; i < a.size(); i++)\n        for (int j = 0; j < b.size(); j++)\n          if (b[j] % a[i] == 0) {\n            A[i] |= 1ll << j;\n            B[j] |= 1ll << i;\n          }\n      for (int x = 0; x < (1 << a.size()); x++) {\n        long long s = 0, t = 0;\n        for (int i = 0; i < a.size(); i++)\n          if ((x >> i) & 1) t |= A[i];\n        for (int j = 0; j < b.size(); j++)\n          if (((t >> j) & 1) && (x & B[j]) == B[j]) s |= 1ll << j;\n        S[x] = __builtin_popcountll(s), T[x] = t;\n      }\n      sum = 0;\n      for (int i = 0; i < b.size(); i++) {\n        for (int i = 0; i <= b.size(); i++) memset(dp[i], 0, (1 << a.size()) << 2);\n        dp[1][B[i]] = fac[S[B[i]] - 1];\n        for (int x = B[i], y; x < (1 << a.size()); x++)\n          for (int t = 0; t < b.size(); t++)\n            if (((T[x] >> t) & 1) && (y = x | B[t]) != x)\n              for (int i = 1; i < b.size(); i++)\n                if (dp[i][x])\n                  for (int j = i + 1; j <= b.size(); j++) {\n                    dp[j][y] = (dp[j][y] + (long long)dp[i][x] * C(S[y] - j, S[y] - S[x] - 1) % mod * fac[S[y] - S[x] - 1]) % mod;\n                  }\n        for (int i = 0; i <= b.size(); i++) sum = (sum + dp[i][(1 << a.size()) - 1]) % mod;\n      }\n      tot += b.size() - 1;\n      ans = (long long)ans * sum % mod * C(tot, b.size() - 1) % mod;\n    }\n  cout << ans << endl;\n}\n```\n","publishedTitle":"「CF1292F」Nora's Toy Boxes"}},{"id":"c5f74b69-54f4-576a-b82c-46ce4bc7c5af","fields":{"slug":"/oi/solution/cf1349f2/","plainText":"\n> 定义一个排列 $p$ 是好的当且仅当对于每个 $k < \\max\\{p\\}$，存在 $1 \\leq i < j \\leq n$ 使得 $a_i = k-1$ 且 $a_j = k$。\n>\n> 定义 $f_a(k)$ 为序列 $a$ 中数值 $k$ 的出现次数，假设所有合法序列集合为 $S$，对于每个 $k \\in [1;n]$，求\n>\n> $$\n> \\left( \\sum_{a \\in S} f_a(k) \\right) \\bmod 998244353\n> $$\n>\n> $n \\leq 10^5$。\n\n<!-- more -->\n\n## 题解\n\n考虑由排列 $p$ 生成序列，在 $p_i$ 和 $p_{i+1}$ 之间填入大于或小于号，则 $a_{p_i}$ 的值为 $p_{1...i}$ 中的小于号个数 $+1$，不难验证合法序列集合和排列集合构成双射。\n\n注意到这是个欧拉数的形式，考虑容斥维护：\n\n$$\n\\newcommand{\\strling}[2]{\\left\\{\\begin{matrix}#1\\\\#2\\end{matrix}\\right\\}}\n\\begin{aligned}\nans_i\n&= \\sum_{m=0}^n \\frac {n!} {m!} \\sum_{j \\ge i} (m-j)! (-1)^{j-i}\\binom j i \\strling m {m-j} \\\\\n&= \\sum_{j \\ge i} n! (-1)^{j-i} \\binom j i \\sum_{m=j+1}^n \\strling m {m-j} \\frac {(m-j)!} {m!}\n\\end{aligned}\n$$\n\n> 第二类斯特林数的生成函数\n>\n> $$\\newcommand{\\strling}[2]{\\left\\{\\begin{matrix}#1\\\\#2\\end{matrix}\\right\\}} \\strling n k = n! [z^n] \\frac {(e^z-1)^k} {k!}$$\n\n设 $h$，先带上 $m=i$ 的情况计算，最后再令 $h_0$ 减 $1$。\n\n$$\n\\newcommand{\\strling}[2]{\\left\\{\\begin{matrix}#1\\\\#2\\end{matrix}\\right\\}}\n\\begin{aligned}\nh_i\n&= \\sum_{m=i}^n \\strling m {m-i} \\frac{(m-i)!} {m!} \\\\\n&= \\sum_{m=i}^n [z^m] (e^z-1)^{m-i}\\\\\n&= \\sum_{j=0}^{n-i} [z^{j+i}] (e^z-1)^j \\\\\n&= [z^i] \\sum_{j=0}^{n-i} \\left( \\frac{e^z-1} {z} \\right)^j \\\\\n\\end{aligned}\n$$\n\n令 $F(z) = (e^z-1)/z$，有\n\n$$\n\\begin{aligned}\nh_i\n&= [z^i] \\sum_{j=0}^{n-i} F^j(z) \\\\\n&= [z^i] \\frac{F^{n-i+1}(z)-1} {F(z)-1} \\\\\n&= [z^i] \\left( \\frac{-1}{F(z)-1} + \\frac{F^{n-i+1}(z)}{F(z)-1} \\right) \\\\\n\\end{aligned}\n$$\n\n前半部分容易直接多项式求逆处理，现在考虑后半部分\n\n$$\n[z^i] \\frac{F^{n-i+1}(z)}{F(z)-1} = [z^{n+1}] \\frac{(z F(z))^{n-i+1}}{F(z)-1}\n$$\n\n（开始在这里卡住了，不求甚解的从题解那里拉了个式子，第二天冷静了一下，为了行文连贯，把补充理解附在后面）\n\n设 $\\omega(z) = zF(z)$，$\\varphi(z)$ 满足 $\\dfrac{\\omega(z)}{\\varphi(\\omega(z))}=z$，则 $\\dfrac{zF(z)}{\\varphi(\\omega(z))}=z$，即 $F=\\varphi(\\omega)$\n\n> 拓展拉格朗日反演\n>\n> $f,g,h$ 是 $F[[x]]$ 上的多项式，已知 $f(g(x)) = g(f(x)) = x$，则\n>\n> $$[x^n] h(f(x)) = \\frac 1 n [x^{n-1}] h'(x) \\left( \\frac {x} {g(x)} \\right)^n$$\n\n考虑\n\n$$\n\\begin{aligned}\nf(x) &= \\omega(x) \\\\\ng(x) &= \\frac x {\\varphi(x)} \\\\\nh(x) &= \\frac 1 {(1-\\varphi(x)) (1 - ux)} \\\\\n\\end{aligned}\n$$\n\n则\n\n$$\n\\begin{aligned}\n & [u^{n-i+1} z^{n+1}] \\frac 1 {1-\\varphi (\\omega(z))} \\frac 1 {1-uw(z)} \\\\\n=& [u^{n-i+1}] \\frac 1 {n+1} [z^n] \\left(\\left(\\frac 1 {1-\\varphi(z)} \\frac 1 {1-uz}\\right)'\\cdot \\varphi(z)^{n+1}\\right) \\\\\n\\end{aligned}\n$$\n\n> $\\displaystyle \\frac 1 {(1-x)^k} = \\sum_{i=0}^{\\infty} \\binom {i+k-1} {k-1} x^i$\n>\n> 直接考虑系数组合意义就可以证明。\n\n其中\n\n$$\n\\begin{aligned}\n & \\left(\\frac 1 {1-\\varphi(z)} \\frac 1 {1-uz}\\right)' \\\\\n=& \\frac {\\varphi'(z)} {(1-uz) (1-\\varphi(z))^2} + \\frac {u} {(1-\\varphi(z))(1-uz)^2} \\\\\n=& \\frac {\\varphi'(z)} {(1-\\varphi(z))^2} \\sum_{i=0}^\\infty u^i z^i + \\frac {1} {1 - \\varphi(z)} \\sum_{i=0}^\\infty (i+1) u^{i+1} z^i \\\\\n\\end{aligned}\n$$\n\n代入到原式中有\n\n$$\n\\begin{aligned}\n & \\frac {[z^n] \\varphi^{n+1}(z)} {n+1} \\left( \\frac {z^{n-i+1} \\varphi'(z)} {(1-\\varphi(z))^2} + \\frac {(n-i+1) z^{n-i}} {1 - \\varphi(z)} \\right) \\\\\n=& [z^{i-1}] \\frac {\\varphi^{n+1}(z) \\varphi'(z)} {(n+1) (1-\\varphi(z))^2} + [z^i] \\frac {\\varphi^{n+1}(z) (n-i+1)} {(n+1) (1-\\varphi(z))} \\\\\n\\end{aligned}\n$$\n\n唯一的问题就是 $\\varphi(x)$ 怎么求了，注意到 $\\omega(x) = e^x-1$，构造得 $\\dfrac z {\\ln (1+z)}$。\n\n## 坑点\n\n1. $\\varphi(z) = \\dfrac {z} {\\ln(1+z)}$，注意到 $\\ln(1+z)$ 的常数项是 $0$，不能直接求逆；\n2. $1-\\varphi(z)$ 常数项也是 $0$，同样不能直接求逆，只能求出 $(1-\\varphi(z))/z$，上面的式子大概变成\n   $$\n    [z^{i+1}] \\frac {\\varphi^{n+1}(z) \\varphi'(z)} {(n+1) ((1-\\varphi(z))/z)^2} + [z^{i+1}] \\frac {\\varphi^{n+1}(z) (n-i+1)} {(n+1) ((1-\\varphi(z)/z))}\n   $$\n3. 上面两种情况的处理可能带来更多的多项式长度要求。\n4. $h_0$ 减 $1$。\n\n## 补充\n\n现在我们需要对 $i \\in [0;n]$，求出\n\n$$\n[z^{n+1}] \\frac{(z F(z))^{n-i+1}}{F(z)-1}\n$$\n\n考虑用二元生成函数表示\n\n$$\n\\begin{aligned}\n & [z^{n+1} u^{n-i+1}] \\frac 1 {F(z)-1} \\sum_{k=0}^\\infty (z u F(z))^{k} \\\\\n=& [z^{n+1} u^{n-i+1}] \\frac 1 {(F(z)-1) (1-zuF(z))} \\\\\n\\end{aligned}\n$$\n\n如果直接对着这个式子做，是没有办法拉格朗日反演的，因为本质上我们有两个关于 $z$ 的多项式：$F(z)$ 和 $zF(z)$。我们设法构造一个关于 $F$ 的多项式使其满足 $\\varphi(F(z)) = z F(z)$。\n\n形式化的，我们想要构造多项式 $\\varphi(z)$ 使得\n\n$$\n\\varphi(F(z)) = z F(z)\n$$\n\n同时，由该式我们也可以直接得到 $F$ 的复合逆形式：\n\n$$\n\\frac {\\varphi(F(z))} {F(z)} = z\n$$\n\n说回到 $\\varphi(x)$ 的构造，我们只能利用 $F(z)$ 本身的性质设法构造出 $z$：我们有\n\n$$\nF(z) = \\frac {e^{z} - 1} {z}\n$$\n\n相当于有\n\n$$\n\\ln(1 + zF(z)) = z\n$$\n\n不幸的是，这个式子本身还和 $z$ 有关，但启发我们改变方向，设 $\\omega(z) = z F(z)$，构造多项式 $\\varphi(z)$ 使得\n\n$$\n\\begin{cases}\n\\omega(z) = z F(z) \\\\\n\\varphi(\\omega(z)) = F(z) \\\\\n\\end{cases}\n$$\n\n有 $\\varphi(z) = \\dfrac {z} {\\ln(1 + z)}$，$\\dfrac {\\omega(z)} {\\varphi(\\omega(z))} = z$。即把原式转化为了：\n\n$$\n\\frac 1 {(1 - u \\omega(z)) \\left(\\dfrac {\\omega(z)} {\\ln(1 + \\omega(z))}-1\\right)}\n$$\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 9, mod = 998244353;\nstruct z {\n  int x;\n  z(int x = 0) : x(x) {}\n  friend inline z operator*(z a, z b) { return (long long)a.x * b.x % mod; }\n  friend inline z operator-(z a, z b) { return (a.x -= b.x) < 0 ? a.x + mod : a.x; }\n  friend inline z operator+(z a, z b) { return (a.x += b.x) >= mod ? a.x - mod : a.x; }\n} h[N], ans[N], inv[N], fac[N], ifac[N];\ninline z fpow(z a, int b) {\n  z s = 1;\n  for (; b; b >>= 1, a = a * a)\n    if (b & 1) s = s * a;\n  return s;\n}\nint len = 1, rev[N << 2];\nz w[N << 2];\nstruct vec : vector<z> {\n  using vector<z>::vector;\n  inline vec divx() {\n    vec res = *this;\n    return res.erase(res.begin()), res;\n  }\n  inline vec setl(size_t len) {\n    vec res = *this;\n    return res.resize(len), res;\n  }\n  inline vec fun1() {\n    vec res(this->begin() + 1, this->end());\n    for (int i = 0; i < res.size(); i++) res[i].x = mod - res[i].x;\n    return res;\n  }\n};\nint init(int n) {\n  int lim = 1, k = 0;\n  while (lim < n) lim <<= 1, ++k;\n  for (int i = 0; i < lim; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (k - 1));\n  for (; len < lim; len <<= 1) {\n    z wn = fpow(3, (mod - 1) / (len << 1));\n    w[len] = 1;\n    for (int i = 1; i < len; i++) w[i + len] = w[i + len - 1] * wn;\n  }\n  return lim;\n}\nvoid dft(vec &a, int lim) {\n  a.resize(lim);\n  for (int i = 0; i < lim; i++)\n    if (i < rev[i]) swap(a[i], a[rev[i]]);\n  for (int i = 0; i < lim; i += 2) {\n    z x = a[i], y = a[i + 1] * w[1];\n    a[i] = x + y, a[i + 1] = x - y;\n  }\n  for (int len = 2; len < lim; len <<= 1)\n    for (int i = 0; i < lim; i += (len << 1))\n      for (int j = 0; j < len; j++) {\n        z x = a[i + j], y = a[i + j + len] * w[j + len];\n        a[i + j] = x + y, a[i + j + len] = x - y;\n      }\n}\nvoid idft(vec &a, int lim) {\n  z inv = fpow(lim, mod - 2);\n  dft(a, lim), reverse(&a[1], &a[lim]);\n  for (int i = 0; i < lim; i++) a[i] = a[i] * inv;\n}\nvec operator+(vec a, const vec &b) {\n  a.resize(max(a.size(), b.size()));\n  for (int i = 0; i < b.size(); i++) a[i] = a[i] + b[i];\n  return a;\n}\nvec operator-(vec a, const vec &b) {\n  a.resize(max(a.size(), b.size()));\n  for (int i = 0; i < b.size(); i++) a[i] = a[i] - b[i];\n  return a;\n}\nvec operator*(vec a, vec b) {\n  if (a.size() < 20 || b.size() < 20 || (uint64_t)a.size() + b.size() < 400) {\n    vec c(a.size() + b.size() - 1);\n    for (int i = 0; i < a.size(); i++)\n      for (int j = 0; j < b.size(); j++) c[i + j] = c[i + j] + a[i] * b[j];\n    return c;\n  }\n  int len = a.size() + b.size() - 1, lim = init(len);\n  dft(a, lim), dft(b, lim);\n  for (int i = 0; i < lim; i++) a[i] = a[i] * b[i];\n  return idft(a, lim), a.resize(len), a;\n}\nvec inve(const vec &f, int len = -1) {\n  if ((len = ~len ? len : f.size()) == 1) return vec{fpow(f[0], mod - 2)};\n  vec a = inve(f, (len + 1) >> 1), b(&f[0], &f[len]);\n  int lim = init((len << 1) - 1);\n  dft(a, lim), dft(b, lim);\n  for (int i = 0; i < lim; i++) a[i] = a[i] * (2 - a[i] * b[i]);\n  return idft(a, lim), a.resize(len), a;\n}\nvec inte(vec a) {\n  for (int i = a.size() - 1; i; i--) a[i] = a[i - 1] * ::inv[i];\n  return *a.begin() = 0, a;\n}\nvec deri(vec a) {\n  for (int i = 0; i < a.size() - 1; i++) a[i] = a[i + 1] * (i + 1);\n  return *a.rbegin() = 0, a;\n}\nvec ln(const vec &f) { return inte((deri(f) * inve(f)).setl(f.size())); }\nvec exp(const vec &f, int len = -1) {\n  if ((len = ~len ? len : f.size()) == 1) return vec{1};\n  vec a = exp(f, (len + 1) >> 1), b = a;\n  b.resize(len), b = ln(b);\n  for (int i = 0; i < len; i++) b[i] = 0 - b[i];\n  b[0] = b[0] + 1;\n  for (int i = 0; i < len; i++) b[i] = b[i] + f[i];\n  return (a * b).setl(len);\n}\nvec pow(vec a, int b) {\n  a = ln(a);\n  for (int i = 0; i < a.size(); i++) a[i] = a[i] * b;\n  return exp(a);\n}\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  fac[0] = ifac[0] = inv[0] = inv[1] = 1;\n  for (int i = 2; i < N; i++) inv[i] = (mod - mod / i) * inv[mod % i];\n  for (int i = 1; i < N; i++) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * inv[i];\n  int n, len;\n  cin >> n, len = n + 5;\n  vec Finv = inve(vec(ifac + 1, ifac + len + 1).fun1());\n  for (int i = 0; i <= n; i++) h[i] = Finv[i + 1];\n  h[0] = h[0] - 1;\n  vec P(len);\n  for (int i = 0; i < len; i++) P[i] = (i & 1 ? mod - 1 : 1) * inv[i + 1];\n  P = inve(P);\n  vec Ppow = pow(P, n + 1);\n  vec Pinv = inve(P.fun1());\n  vec lpart = (Ppow * Pinv).setl(len);\n  vec rpart = ((deri(P) * Pinv).setl(len) * lpart).setl(len);\n  z tmp = fpow(n + 1, mod - 2);\n  for (int i = 0; i <= n; i++) h[i] = h[i] - tmp * (lpart[i + 1] * (n - i + 1) + rpart[i + 1]);\n  vec f(n + 1), g(n + 1);\n  for (int i = 0; i <= n; i++) f[i] = ((n - i) & 1 ? mod - 1 : 1) * ifac[n - i];\n  for (int i = 0; i <= n; i++) g[i] = fac[i] * h[i];\n  f = f * g;\n  for (int i = 0; i < n; i++) ans[i] = f[i + n] * fac[n] * ifac[i];\n  for (int i = 0; i < n; i++) cout << ans[i].x << \" \\n\"[i + 1 == n];\n}\n```\n","publishedTitle":"「CF1349F2」Slime and Sequences (Hard Version)"}},{"id":"e0cf573a-04e5-59ba-81a9-8c06bd8ead45","fields":{"slug":"/oi/solution/cometoj-round2-f/","plainText":"\n> 有 $n$ 种操作，第 $i$ 种操作使用后有 $p_i$ 的概率升级，$(1-p_i)$ 的概率不升级。\n>\n> 进行若干次操作后，如果主人公的等级为 $i$，就能产生 $a_i$ 的贡献。\n>\n> 对于每个 $i \\in [1;n]$ 求出，使用 $j \\neq i$ 的所有操作 $j$，主人公产生等级贡献的期望。\n>\n> $n \\leq 10^5$。\n\n<!-- more -->\n\n## 题解\n\n设 $C_i(x) = (1 - p_i + p_i x)$，$C(x) = \\prod_{i=0}^{n-1} C_i(x)$\n\n$$\nans_m = \\sum_{i=0}^{n-1} a_i [x^i] \\prod_{j \\neq m} C_j(x)\n$$\n\n这是一个线性算法，其转移矩阵为 $D_{m,i} = [x^i] \\prod_{j \\neq m} C_j(x)$\n\n考虑其转置 $D^T_{m,i} = [x^m] \\prod_{j \\neq i} C_j(x)$\n\n我们有做法\n\n$$\nans_m = \\prod_{i=0}^{n-1} a_i [x^m] \\prod_{j \\neq i} C_j(x)\n$$\n\n$$\nANS(x) = \\prod_{i=0}^n a_i \\prod_{j \\neq i} C_j(x)\n$$\n\n有类似 $k$ 次幂和的 $O(n \\log^2 n)$ 做法，可以改写成其转置。\n\n具体的，我们令 $A(x) = \\sum_{i \\ge 0} a_i x^i$，为线段树根节点，$\\operatorname{mul}^T$ 到叶子节点即可。\n\n一般做法可以参见 zsy 博客：https://www.cnblogs.com/zhoushuyu/p/10777808.html\n\n大概是利用多项式点乘的性质把贡献拆开然后多点求值（\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\ntemplate <class T> inline void read(T &x) {\n  x = 0;\n  register char c = getchar();\n  register bool f = 0;\n  while (!isdigit(c)) f ^= c == '-', c = getchar();\n  while (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n  if (f) x = -x;\n}\ntemplate <class T> inline void print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate <class T> inline void print(T x, char c) { print(x), putchar(c); }\nconst int N = 1e5 + 10, mod = 998244353;\nint n, m;\nstruct z {\n  int x;\n  z(int x = 0) : x(x) {}\n  friend inline z operator*(z a, z b) { return (long long)a.x * b.x % mod; }\n  friend inline z operator-(z a, z b) { return (a.x -= b.x) < 0 ? a.x + mod : a.x; }\n  friend inline z operator+(z a, z b) { return (a.x += b.x) >= mod ? a.x - mod : a.x; }\n} a[N], p[N], ans[N], fac[N], ifac[N], inv[N];\ninline z fpow(z a, int b) {\n  z s = 1;\n  for (; b; b >>= 1, a = a * a)\n    if (b & 1) s = s * a;\n  return s;\n}\nvoid init(int n) {\n  n += 5, inv[0] = inv[1] = fac[0] = ifac[0] = 1;\n  for (int i = 2; i < n; i++) inv[i] = (mod - mod / i) * inv[mod % i];\n  for (int i = 1; i < n; i++) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * inv[i];\n}\nnamespace poly { // polynomial\nint len = 1, rev[N << 2];\nz w[N << 2];\nstruct vec : std::vector<z> {\n  using std::vector<z>::vector;\n  inline void input(int n) {\n    resize(n);\n    for (int i = 0; i < n; i++) read(this->operator[](i).x);\n  }\n  inline void output() {\n    for (int i = 0; i < size(); i++) print(this->operator[](i).x, \" \\n\"[i + 1 == size()]);\n  }\n};\nint init(int n) {\n  int lim = 1, k = 0;\n  while (lim < n) lim <<= 1, ++k;\n  for (int i = 0; i < lim; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (k - 1));\n  for (; len < lim; len <<= 1) {\n    z wn = fpow(3, (mod - 1) / (len << 1));\n    w[len] = 1;\n    for (int i = 1; i < len; i++) w[i + len] = w[i + len - 1] * wn;\n  }\n  return lim;\n}\nvoid dft(vec &a, int lim) {\n  a.resize(lim);\n  for (int i = 0; i < lim; i++)\n    if (i < rev[i]) std::swap(a[i], a[rev[i]]);\n  for (int len = 1; len < lim; len <<= 1)\n    for (int i = 0; i < lim; i += (len << 1))\n      for (int j = 0; j < len; j++) {\n        z x = a[i + j], y = a[i + j + len] * w[j + len];\n        a[i + j] = x + y, a[i + j + len] = x - y;\n      }\n}\nvoid idft(vec &a, int lim) {\n  dft(a, lim), std::reverse(&a[1], &a[lim]);\n  z inv = fpow(lim, mod - 2);\n  for (int i = 0; i < lim; i++) a[i] = a[i] * inv;\n}\ninline vec mul(vec a, vec b, int l = -1) {\n  int len = ~l ? l : a.size() + b.size() - 1, lim = init(a.size() + b.size() - 1);\n  dft(a, lim), dft(b, lim);\n  for (int i = 0; i < lim; i++) a[i] = a[i] * b[i];\n  return idft(a, lim), a.resize(len), a;\n}\nnamespace extra {\nusing namespace poly;\nvec mulT(vec a, vec b) {\n  int al = a.size(), bl = b.size(), lim = init(al);\n  dft(a, lim), std::reverse(b.begin(), b.end()), dft(b, lim);\n  for (int i = 0; i < lim; i++) a[i] = a[i] * b[i];\n  return idft(a, lim), vec(&a[bl - 1], &a[al]);\n}\n} // namespace extra\n} // namespace poly\npoly::vec F[N << 2], G[N << 2];\nvoid dfs1(int u, int l, int r) {\n  if (l == r) {\n    F[u] = {1 - p[l], p[l]};\n    return;\n  }\n  dfs1(u << 1, l, (l + r) >> 1), dfs1(u << 1 | 1, ((l + r) >> 1) + 1, r);\n  F[u] = poly::mul(F[u << 1], F[u << 1 | 1]);\n}\nvoid dfs2(int u, int l, int r) {\n  if (l == r) {\n    ans[l] = G[u][0];\n    return;\n  }\n  G[u << 1] = poly::extra::mulT(G[u], F[u << 1 | 1]);\n  G[u << 1 | 1] = poly::extra::mulT(G[u], F[u << 1]);\n  dfs2(u << 1, l, (l + r) >> 1), dfs2(u << 1 | 1, ((l + r) >> 1) + 1, r);\n}\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  read(n);\n  for (int i = 0; i < n; i++) read((int &)a[i]);\n  for (int i = 0, x, y; i < n; i++) read(x), read(y), p[i] = x * fpow(y, mod - 2);\n  dfs1(1, 0, n - 1), G[1] = poly::vec(a, a + n), dfs2(1, 0, n - 1);\n  for (int i = 0; i < n; i++) print(ans[i].x, \" \\n\"[i == n]);\n}\n```\n","publishedTitle":"「CometOJ Round #2 F」真实无妄她们的人生之路"}},{"id":"f5617264-33aa-538c-8934-82f4aa12c0e0","fields":{"slug":"/oi/solution/cometoj-round7-f/","plainText":"\n> 维护序列 $a_{1\\ldots n}$，支持以下操作 $m$ 次：\n>\n> 1. 给 $x,y$，将 $x$ 位置的值修改为 $y$；\n> 2. 给 $l,r,x$，查询区间$[l,r]$中有多少子区间的最大值小于或等于 $x$。\n>\n> $n,m \\leq 3 \\times 10^5$。\n\n<!-- more -->\n\n## 题解\n\n对于询问 $\\{l,r,x\\}$，相当于转化为这样一个问题：\n\n序列 $b$ 满足 $b_i = [a_i \\leq x]$，然后询问 $b$ 的区间 $[l,r]$ 内，有多少子区间的均为 $1$。\n\n考虑一个分块，维护块内外的信息是平凡的，瓶颈在于如何优化离散化的复杂度。\n\n然后此处用到一个叫分散层叠的 trick，开一个每一个块作为叶子节点的线段树，叶子节点维护每个数的权值及排名，\n\n考虑 `maintain` 操作，每次只保留下标是 $3$ 的倍数的位置。\n\n- 对于修改操作，暴力 `maintain` 上去，时间复杂度 $O(\\sqrt n + \\frac 2 3 \\sqrt n + \\frac 4 9 \\sqrt n + \\cdots) = O(\\sqrt n)$。\n- 对于查询操作，DFS 遍历整棵树，递归到下一层的时候指针只会右移至多 $2$ 次，是常数级别的，故时间复杂度为总节点数，即 $O(\\sqrt n)$。\n\n## 卡常\n\n实现上由于分散层叠的常数有点大，我们需要一些卡常的小技巧。\n\n1. 内存连续，而且注意到直接开的话内存空余会很大，可以手动分配内存。\n2. 关于往后扫四次的这个操作，可以写成这样 `k+=arr[k+2]<=x?2:0,k+=arr[k+1]<=x`，然后在 `arr` 里多丢两个 $+\\infty$。这样可以少很多分支条件。\n\n## 代码\n\n### 二分查找版本\n\n时间复杂度：$O(n \\sqrt {n\\log n})$\n\n```cpp\n#include<bits/stdc++.h>\n\nnamespace mem{ //v2.1.2 => size: 14.19KiB\n  #define MEM_IO\n  #define MEM_MATH\n  #define MEM_UTILS\n  #define MEM_MODINT\n  #define MEM_RANDOM\n  #define MEM_STDVAL\n  #define MEM_LOGGER\n  #define MEM_CONTAINER\n  #ifdef memset0\n  #else\n    #define MEM_FASTIO\n  #endif\n\n  #ifdef __SIZEOF_INT128__\n    #define MEM_INT128\n  #endif\n\n  #define __integer_mapper(func)       \\\n        func(int)                      \\\n        func(unsigned int)             \\\n        func(long long int)            \\\n        func(unsigned long long int)\n  #define __float_mapper(func)         \\\n        func(float)                    \\\n        func(double)                   \\\n        func(long double)\n\n    namespace stdval{\n  #ifdef MEM_STDVAL\n      using i32=int;\n      using i64=long long int;\n      using u32=unsigned int;\n      using u64=unsigned long long int;\n      using f32=float;\n      using f64=double;\n      using f96=long double;\n    #ifdef MEM_INT128\n      using i128=__int128_t;\n      using u128=__uint128_t;\n    #endif\n  #endif\n    }\n\n    namespace utils{\n  #ifdef MEM_UTILS\n      using std::cin;\n      using std::tie;\n      using std::cout;\n      using std::cerr;\n      using std::endl;\n      using std::swap;\n      using std::sort;\n      using std::unique;\n      using std::reverse;\n      using std::shuffle;\n      using std::function;\n      using std::make_pair;\n      using std::make_tuple;\n      using std::accumulate;\n      using std::lower_bound;\n      using std::upper_bound;\n      using std::max_element;\n      using std::min_element;\n  #endif\n    }\n\n    namespace random{\n  #ifdef MEM_RANDOM\n      const int LuckyNumber=20040726; // Kanbe Kotori's Birthday\n      std::mt19937 rng(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n      std::mt19937_64 rng64(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n\n      template<class T> inline T rand(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n      template<class T> inline T rand64(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n  #endif\n    }\n\n    namespace modint{\n  #ifdef MEM_MODINT\n      template<const int mod> struct Z{\n        int x;\n        inline Z(){x=0;}\n        inline Z(int t){x=t;}\n\n        inline void operator-=(Z a){(x-=a.x)<0&&(x+=mod);}\n        inline void operator+=(Z a){(x+=a.x)>=mod&&(x-=mod);}\n        inline void operator*=(Z a){x=(long long)x*a.x%mod;}\n\n        friend inline Z operator*(Z a,Z b){return (long long)a.x*b.x%mod;}\n        friend inline Z operator-(Z a,Z b){return ((a.x-=b.x)<0&&(a.x+=mod)),a;}\n        friend inline Z operator+(Z a,Z b){return ((a.x+=b.x)>=mod&&(a.x-=mod)),a;}\n      };\n\n      template<const int mod> inline Z<mod> finv(Z<mod> x){\n        if(x.x<2)return x;\n        return (mod-mod/x.x)*finv(mod%x.x);\n      }\n      template<const int mod> inline Z<mod> fpow(Z<mod> a,int b){\n        Z <mod> s=1;\n        for(;b;b>>=1,a=a*a)\n          if(b&1)s=s*a;\n        return s;\n      }\n\n      template<const int mod> inline void init_inverse(int n,Z<mod> *inv){\n        inv[0]=inv[1]=1;\n        for(int i=2;i<n;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n      }\n      template<const int mod> inline void init_factorial(int n,Z<mod> *fac,Z<mod> *ifac){\n        fac[0]=1,init_inverse(n,ifac);\n        for(int i=1;i<n;i++)fac[i]=fac[i-1]*i,ifac[i]=ifac[i-1]*ifac[i];\n      }\n    }\n\n    namespace io{\n      template<const int mod> inline void read(modint::Z<mod> &x){read(x.x);}\n      template<const int mod> inline void print(modint::Z<mod> x){print(x.x);}\n  #endif\n    }\n\n    namespace math{\n  #ifdef MEM_MATH\n      using std::max;\n      using std::min;\n      template<class T> inline T abs(T x){return x<0?-x:x;}\n      template<class T> inline T gcd(T n,T m){return m?gcd(m,n%m):n;}\n      template<class T> inline T lcm(T n,T m){return n/gcd(n,m)*m;}\n\n      template<const stdval::u64 p> struct FastDiv{\n        stdval::u64 t,i;\n        inline FastDiv():t(stdval::u64(-1)/p),i(mul_inv(p)){}\n\n        inline bool divide(stdval::u64 n){return n*i<=t;}\n        inline bool divide(stdval::i64 n){return stdval::u64(n<0?-n:n)*i<=t;}\n        inline stdval::u64 mul_inv(stdval::u64 n){\n          stdval::u64 x=n;\n          for(int i=0;i<5;++i)x*=2-n*x;\n          return x;\n        }\n      };\n\n    #ifdef MEM_INT128\n      template<const stdval::u64 b> struct FastMod{\n        stdval::u64 m;\n        inline FastMod():m(stdval::u64((stdval::u128(1)<<64)/b)){}\n\n        inline stdval::u64 reduce(stdval::u64 a){\n          stdval::u64 q=(stdval::u64)((stdval::u128(m)*a)>>64);\n          stdval::u64 r=a-q*b;\n          return r>=b?r-b:r;\n        }\n      };\n    #endif\n  #endif\n    }\n\n    namespace container{\n  #ifdef MEM_CONTAINER\n      using std::pair;\n      using std::tuple;\n      using std::set;\n      using std::unordered_set;\n      using std::map;\n      using std::unordered_map;\n\n      using std::tie;\n      using std::make_pair;\n      using std::make_tuple;\n\n      template<class T> struct vector:std::vector<T>{\n        using std::vector<T>::vector;\n        vector():std::vector<T>(){}\n        vector(const std::vector<T> &plain):std::vector<T>(plain){}\n\n        inline void sort(){std::sort(this->begin(),this->end());}\n        inline void concat(const vector &rhs){this->insert(this->end(),rhs.begin(),rhs.end());}\n        inline bool includes(const T &x) const{return std::find(this->begin(),this->end(),x)!=this->end();}\n        template<class Function> inline void forEach(Function func){for(const auto &it:*this)func(it);}\n\n        inline vector slice(int l,int r) const{\n          if(l>r)return {};\n          if(r<this->size())return vector(this->begin()+l,this->begin()+r);\n          vector<int> rsp=(this->begin()+l,this->end());\n          return rsp.resize(r-l),rsp;\n        }\n\n        inline void from(const std::set<T> &src){\n          this->resize(src.size());\n          auto it=this->begin();\n          for(const T e:src)*it++=e;\n        }\n\n        template<class R,class Function> inline vector<R> _map(Function func) const{\n          vector <R> res(this->size());\n          for(size_t i=0;i<this->size();i++)\n            res[i]=func(this->operator[](i));\n          return res;\n        }\n        template<class R> inline vector<R> map(R func(T)) const{return this->_map<R>(func);}\n        template<class R> inline vector<R> map(const std::function<R(T)> &func) const{return this->_map<R>(func);}\n      };\n\n      struct string:std::string{\n        using std::string::string;\n        string():std::string(\"\"){}\n        string(const std::string &plain):std::string(plain){}\n\n        template<class T> inline string join(const vector<T> &vet) const;\n\n        vector<string> split(const string &dim) const{\n          if(this->empty())return {};\n          char *src=new char[this->length()+1];\n          strcpy(src,this->c_str());\n          char *tar=new char[dim.length()+1];\n          strcpy(tar,dim.c_str());\n          vector <string> rsp;\n          for(char *pos=strtok(src,tar);pos;pos=strtok(nullptr,tar))\n            rsp.push_back(string(pos));\n          delete[] src;\n          delete[] tar;\n          return rsp;\n        }\n\n        template<class... Args> static inline string format(const char *fm,Args... args){\n          int len=snprintf(nullptr,0,fm,args...);\n          char *buf=new char[len+1];\n          snprintf(buf,len+1,fm,args...);\n          string str(buf);\n          delete[] buf;\n          return str;\n        }\n        template<class... Args> static inline string format(const string &fm,Args... args){\n          return format(fm.c_str(),args...);\n        }\n      };\n\n    #define __to_string(T)                 \\\n      inline string to_string(const T &x){ \\\n        return std::to_string(x);          \\\n      }\n      __float_mapper(__to_string)\n      __integer_mapper(__to_string)\n    #undef __to_string\n\n      inline string to_string(const string &s){return s;}\n      inline string to_string(const char *s){return string(s);}\n      inline string to_string(const std::string &s){return string(s);}\n\n      template<const int mod> inline string to_string(const mem::modint::Z<mod> &v){return std::to_string(v.x);}\n\n      template<class T> inline string to_string(const vector<T> &ctn){return \"[\"+string(\",\").join(ctn)+\"]\";}\n      template<class T> inline string to_string(const set<T> &ctn){\n        string result=\"{\";\n        bool flag=false;\n        for(const auto &it:ctn){\n          if(flag)result+=\",\";\n          flag=true;\n          result+=to_string(it);\n        }\n        return result+\"}\";\n      }\n      template<class T1,class T2> inline string to_string(const map<T1,T2> &ctn){\n        string result=\"{\";\n        bool flag=false;\n        for(const auto &it:ctn){\n          if(flag)result+=\",\";\n          flag=true;\n          result+=to_string(it.first)+\":\"+to_string(it.second);\n        }\n        return result+\"}\";\n      }\n\n      template<class T> inline string string::join(const vector<T> &vet) const{\n        if(!vet.size())return \"\";\n        string res=to_string(vet[0]);\n        for(size_t i=1;i<vet.size();i++){\n          res+=*this;\n          res+=to_string(vet[i]);\n        }\n        return res;\n      }\n\n      inline string operator \"\" _s(const char *s){return string(s);}\n      inline string operator \"\" _s(const char *s,size_t len){return string(s,len);}\n      inline string operator \"\" _s(long double x){return to_string(x);}\n      inline string operator \"\" _s(unsigned long long int x){return to_string(x);}\n  #endif\n    }\n\n    namespace io{\n  #ifdef MEM_IO\n    #ifdef MEM_FASTIO\n      namespace fastio{\n        const int BUFFER=1<<18;\n        char ibuf[BUFFER],*iS,*iT;\n        inline int getc(){\n          if(iS==iT){\n            iT=(iS=ibuf)+fread(ibuf,1,BUFFER,stdin);\n            return iS==iT?EOF:*iS++;\n          }else{\n            return *iS++;\n          }\n        }\n        char obuf[BUFFER],*oS=obuf,*oT=oS+BUFFER-1;\n        inline void flush(){\n          fwrite(obuf,1,oS-obuf,stdout);\n          oS=obuf;\n        }\n        inline void putc(int x){\n          *oS++=x;\n          if(oS==oT)flush();\n        }\n        struct Flusher{~Flusher(){flush();}}flusher;\n      }\n      using fastio::getc;\n      using fastio::putc;\n    #else\n      inline int getc(){return getchar();}\n      inline void putc(int c){putchar(c);}\n    #endif\n\n      template<class T> inline void readDigit(T &x){\n        x=getc();\n        while(!isdigit(x))x=getc();\n      }\n      inline int readDigit(){\n        int x;\n        readDigit(x);\n        return x;\n      }\n      template<class T> inline void readAlpha(T &x){\n        x=getc();\n        while(!isalpha(x))x=getc();\n      }\n      inline int readAlpha(){\n        int x;\n        readAlpha(x);\n        return x;\n      }\n\n    #define __read(T)                             \\\n        inline void read(T &x) {                  \\\n          x=0; bool f=0; char c=getc();           \\\n          while(!isdigit(c))f^=c=='-',c=getc();   \\\n          while(isdigit(c))x=x*10+c-'0',c=getc(); \\\n          if(f)x=-x;                              \\\n        }\n      __integer_mapper(__read)\n    #undef __read\n\n      inline void read(char &x){x=getc();}\n      inline void read(char *s){\n        char c=getc();\n        while(~c&&!isspace(c))*s++=c,c=getc();\n        *s++='\\0';\n      }\n      inline void read(container::string &s){\n        char c=getc();\n        s=\"\";\n        while(~c&&!isspace(c))s+=c,c=getc();\n      }\n\n      template<class T=int> inline T read(){\n        T x;\n        read(x);\n        return x;\n      }\n      template<class T,class... Args> inline void read(T &x,Args &... args){\n        read(x),read(args...);\n      }\n\n    #define __print(T)           \\\n        inline void print(T x){  \\\n          if(x<0)putc('-'),x=-x; \\\n          if(x>9)print(x/10);    \\\n          putc('0'+x%10);        \\\n        }\n      __integer_mapper(__print)\n    #undef __print\n\n      inline void print(char x){putc(x);}\n      inline void print(const char *s){\n        int len=strlen(s);\n        for(int i=0;i<len;i++)putc(s[i]);\n      }\n      inline void print(const container::string &s){\n        for(int i=0;i<s.length();i++)putc(s[i]);\n      }\n\n      template<class T,class... Args> inline void print(const T &x,Args... args){\n        print(x),print(args...);\n      }\n      template<class... Args> inline void println(Args... args){\n        print(args...),putc('\\n');\n      }\n\n      template<class... Args> inline void printfm(const char *formatter,Args... arguments){\n        print(container::string().format(formatter,arguments...));\n      }\n      template<class... Args> inline void printfm(const container::string &formatter,Args... arguments){\n        print(container::string().format(formatter,arguments...));\n      }\n  #endif\n    }\n\n    namespace logger{\n  #ifdef MEM_LOGGER\n      enum ConsoleColor{\n        NOPE=-1,BLACK,RED,GREEN,YELLOW,BLUE,PURPLE,DEEPBLUE\n      };\n      template<const ConsoleColor color=NOPE,class... Args> inline void log(const char *formatter,Args... args){\n        if(~color){\n          fprintf(stderr,\"\\033[%dm\",30+color);\n          fprintf(stderr,formatter,args...);\n          fprintf(stderr,\"\\033[0m\");\n        }else{\n          fprintf(stderr,formatter,args...);\n        }\n      }\n      template<const ConsoleColor color=NOPE,class... Args> inline void logln(const char *formatter,Args... args){\n        if(~color){\n          fprintf(stderr,\"\\033[%dm\",30+color);\n          fprintf(stderr,formatter,args...);\n          fprintf(stderr,\"\\033[0m\\n\");\n        }else{\n          fprintf(stderr,formatter,args...);\n          fprintf(stderr,\"\\n\");\n        }\n      }\n      template<class T> inline void logs(const T &x){\n        fprintf(stderr,container::to_string(x).c_str());\n      }\n      template<class T,class... Args> inline void logs(const T &x,Args... args){\n        logs(x),logs(args...);\n      }\n      template<class... Args> inline void logsln(Args... args){\n        logs(args...);\n        fprintf(stderr,\"\\n\");\n      }\n  #endif\n    }\n\n  #undef __integer_mapper\n  #undef __float_mapper\n  #undef __string_mapper\n  #undef __string_join_mapper\n\n    using namespace io;\n    using namespace math;\n    using namespace utils;\n    using namespace modint;\n    using namespace random;\n    using namespace stdval;\n    using namespace logger;\n    using namespace container;\n} // namespace mem\n\nusing namespace mem::io;\nusing namespace mem::math;\nusing namespace mem::utils;\n\nconst int N=3e5+10,sqn=502,S=sqn+10;\nint n,m,a[N],bln[N];\n\nstruct atom{\n  int l,r,c;\n  long long s;\n};\ninline atom operator+(const atom &a,const atom &b){\n  if(a.l==a.c&&b.l==b.c){\n    return {a.l+b.l,a.r+b.r,a.c+b.c,a.s+b.s+a.c*b.c};\n  }else if(a.l==a.c){\n    return {a.l+b.l,b.r,a.c+b.c,a.s+b.s+a.c*b.l};\n  }else if(b.l==b.c){\n    return {a.l,a.r+b.r,a.c+b.c,a.s+b.s+a.r*b.c};\n  }else{\n    return {a.l,b.r,a.c+b.c,a.s+b.s+a.r*b.l};\n  }\n}\ninline atom calc(int l,int r,int x){\n  atom res{0,0,r-l+1,0};\n  while(res.l<res.c&&a[l+res.l]<=x)res.l++;\n  while(res.r<res.c&&a[r-res.r]<=x)res.r++;\n  int pre=0;\n  for(int i=l;i<=r;i++)if(a[i]<=x)res.s+=++pre; else pre=0;\n  return res;\n}\nconst atom c[2]={{0,0,1,0},{1,1,1,1}};\n\nint anc[S],siz[S],tag[S];\nint find(int x){return anc[x]==x?x:anc[x]=find(anc[x]);}\ninline void merge(int a,int b,long long &s){\n  a=find(a),b=find(b),s+=siz[a]*siz[b];\n  if(siz[a]>siz[b])swap(a,b);\n  anc[a]=b,siz[b]+=siz[a];\n}\nstruct block{\n  int l,r,n,val[S],pos[S];\n  atom pre[S];\n  inline int loc(int x){return upper_bound(val+1,val+n+1,x)-val-1;}\n  inline void init(){\n    n=r-l+1;\n    pre[0]={0,0,n,0};\n    pre[n]={n,n,n,(long long)n*(n-1)/2};\n    for(int i=1;i<n;i++)pre[i].c=n;\n    std::vector<std::pair<int,int>> t(n);\n    for(int i=0;i<n;i++)t[i]={a[i+l],i};\n    sort(t.begin(),t.end());\n    for(int i=1;i<=n;i++)val[i]=t[i-1].first,pos[i]=t[i-1].second;\n  }\n  inline void modify(int k){\n    for(int i=1;i<=n;i++)if(pos[i]==k){\n      val[i]=a[k+l];\n      while(i>1&&val[i]<val[i-1])swap(val[i],val[i-1]),swap(pos[i],pos[i-1]),i--;\n      while(i<n&&val[i]>val[i+1])swap(val[i],val[i+1]),swap(pos[i],pos[i+1]),i++;\n      return;\n    }\n  }\n  inline void build(){\n    for(int i=n-1;i>=1;i--){\n      pre[i].l=min(pre[i+1].l,pos[i+1]);\n      pre[i].r=min(pre[i+1].r,n-pos[i+1]-1);\n    }\n    for(int i=0;i<n;i++)anc[i]=i,siz[i]=1,tag[i]=0;\n    for(int i=1;i<=n;i++){\n      pre[i].s=i?pre[i-1].s+1:1;\n      tag[pos[i]]=1;\n      if(pos[i]&&tag[pos[i]-1])merge(pos[i]-1,pos[i],pre[i].s);\n      if(pos[i]<n-1&&tag[pos[i]+1])merge(pos[i]+1,pos[i],pre[i].s);\n    }\n  }\n}s[N/sqn+5];\n\nint main(){\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n  freopen(\"1.out\",\"w\",stdout);\n#endif\n  read(n,m);\n  for(int i=1;i<=n;i++)read(a[i]);\n  for(int i=1;i<=n;i++)bln[i]=(i-1)/sqn+1;\n  for(int i=1;i<=n;i++)s[bln[i]].r=i;\n  for(int i=n;i>=1;i--)s[bln[i]].l=i;\n  for(int i=1;i<=bln[n];i++)s[i].init(),s[i].build();\n  for(int o,l,r,x,y,i=1;i<=m;i++){\n    read(o);\n    if(o==1){\n      read(x,y);\n      a[x]=y;\n      s[bln[x]].modify(x-s[bln[x]].l);\n      s[bln[x]].build();\n    }else{\n      read(l,r,x);\n      atom ans;\n      if(bln[l]==bln[r]){\n        ans=calc(l,r,x);\n      }else{\n        ans=calc(l,s[bln[l]].r,x);\n        for(int i=bln[l]+1;i<=bln[r]-1;i++)ans=ans+s[i].pre[s[i].loc(x)];\n        ans=ans+calc(s[bln[r]].l,r,x);\n      }\n      print(ans.s,'\\n');\n    }\n  }\n  fprintf(stderr,\"clocks: %.4lf\\n\",clock()/(double)CLOCKS_PER_SEC);\n}\n```\n\n### 分散层叠版本\n\n时间复杂度：$O(n \\sqrt n)$\n\n```cpp\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,fma,tune=native\")\n#include<bits/stdc++.h>\n\nnamespace mem{ //v2.1.2 => size: 14.19KiB\n  #define MEM_IO\n  #define MEM_MATH\n  #define MEM_UTILS\n  #define MEM_MODINT\n  #define MEM_RANDOM\n  #define MEM_STDVAL\n  #define MEM_LOGGER\n  #define MEM_CONTAINER\n  #ifdef memset0\n  #else\n    #define MEM_FASTIO\n  #endif\n\n  #ifdef __SIZEOF_INT128__\n    #define MEM_INT128\n  #endif\n\n  #define __integer_mapper(func)       \\\n        func(int)                      \\\n        func(unsigned int)             \\\n        func(long long int)            \\\n        func(unsigned long long int)\n  #define __float_mapper(func)         \\\n        func(float)                    \\\n        func(double)                   \\\n        func(long double)\n\n    namespace stdval{\n  #ifdef MEM_STDVAL\n      using i32=int;\n      using i64=long long int;\n      using u32=unsigned int;\n      using u64=unsigned long long int;\n      using f32=float;\n      using f64=double;\n      using f96=long double;\n    #ifdef MEM_INT128\n      using i128=__int128_t;\n      using u128=__uint128_t;\n    #endif\n  #endif\n    }\n\n    namespace utils{\n  #ifdef MEM_UTILS\n      using std::cin;\n      using std::tie;\n      using std::cout;\n      using std::cerr;\n      using std::endl;\n      using std::swap;\n      using std::sort;\n      using std::unique;\n      using std::reverse;\n      using std::shuffle;\n      using std::function;\n      using std::make_pair;\n      using std::make_tuple;\n      using std::accumulate;\n      using std::lower_bound;\n      using std::upper_bound;\n      using std::max_element;\n      using std::min_element;\n  #endif\n    }\n\n    namespace random{\n  #ifdef MEM_RANDOM\n      const int LuckyNumber=20040726; // Kanbe Kotori's Birthday\n      std::mt19937 rng(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n      std::mt19937_64 rng64(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n\n      template<class T> inline T rand(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n      template<class T> inline T rand64(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n  #endif\n    }\n\n    namespace modint{\n  #ifdef MEM_MODINT\n      template<const int mod> struct Z{\n        int x;\n        inline Z(){x=0;}\n        inline Z(int t){x=t;}\n\n        inline void operator-=(Z a){(x-=a.x)<0&&(x+=mod);}\n        inline void operator+=(Z a){(x+=a.x)>=mod&&(x-=mod);}\n        inline void operator*=(Z a){x=(long long)x*a.x%mod;}\n\n        friend inline Z operator*(Z a,Z b){return (long long)a.x*b.x%mod;}\n        friend inline Z operator-(Z a,Z b){return ((a.x-=b.x)<0&&(a.x+=mod)),a;}\n        friend inline Z operator+(Z a,Z b){return ((a.x+=b.x)>=mod&&(a.x-=mod)),a;}\n      };\n\n      template<const int mod> inline Z<mod> finv(Z<mod> x){\n        if(x.x<2)return x;\n        return (mod-mod/x.x)*finv(mod%x.x);\n      }\n      template<const int mod> inline Z<mod> fpow(Z<mod> a,int b){\n        Z <mod> s=1;\n        for(;b;b>>=1,a=a*a)\n          if(b&1)s=s*a;\n        return s;\n      }\n\n      template<const int mod> inline void init_inverse(int n,Z<mod> *inv){\n        inv[0]=inv[1]=1;\n        for(int i=2;i<n;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n      }\n      template<const int mod> inline void init_factorial(int n,Z<mod> *fac,Z<mod> *ifac){\n        fac[0]=1,init_inverse(n,ifac);\n        for(int i=1;i<n;i++)fac[i]=fac[i-1]*i,ifac[i]=ifac[i-1]*ifac[i];\n      }\n    }\n\n    namespace io{\n      template<const int mod> inline void read(modint::Z<mod> &x){read(x.x);}\n      template<const int mod> inline void print(modint::Z<mod> x){print(x.x);}\n  #endif\n    }\n\n    namespace math{\n  #ifdef MEM_MATH\n      using std::max;\n      using std::min;\n      template<class T> inline T abs(T x){return x<0?-x:x;}\n      template<class T> inline T gcd(T n,T m){return m?gcd(m,n%m):n;}\n      template<class T> inline T lcm(T n,T m){return n/gcd(n,m)*m;}\n\n      template<const stdval::u64 p> struct FastDiv{\n        stdval::u64 t,i;\n        inline FastDiv():t(stdval::u64(-1)/p),i(mul_inv(p)){}\n\n        inline bool divide(stdval::u64 n){return n*i<=t;}\n        inline bool divide(stdval::i64 n){return stdval::u64(n<0?-n:n)*i<=t;}\n        inline stdval::u64 mul_inv(stdval::u64 n){\n          stdval::u64 x=n;\n          for(int i=0;i<5;++i)x*=2-n*x;\n          return x;\n        }\n      };\n\n    #ifdef MEM_INT128\n      template<const stdval::u64 b> struct FastMod{\n        stdval::u64 m;\n        inline FastMod():m(stdval::u64((stdval::u128(1)<<64)/b)){}\n\n        inline stdval::u64 reduce(stdval::u64 a){\n          stdval::u64 q=(stdval::u64)((stdval::u128(m)*a)>>64);\n          stdval::u64 r=a-q*b;\n          return r>=b?r-b:r;\n        }\n      };\n    #endif\n  #endif\n    }\n\n    namespace container{\n  #ifdef MEM_CONTAINER\n      using std::pair;\n      using std::tuple;\n      using std::set;\n      using std::unordered_set;\n      using std::map;\n      using std::unordered_map;\n\n      using std::tie;\n      using std::make_pair;\n      using std::make_tuple;\n\n      template<class T> struct vector:std::vector<T>{\n        using std::vector<T>::vector;\n        vector():std::vector<T>(){}\n        vector(const std::vector<T> &plain):std::vector<T>(plain){}\n\n        inline void sort(){std::sort(this->begin(),this->end());}\n        inline void concat(const vector &rhs){this->insert(this->end(),rhs.begin(),rhs.end());}\n        inline bool includes(const T &x) const{return std::find(this->begin(),this->end(),x)!=this->end();}\n        template<class Function> inline void forEach(Function func){for(const auto &it:*this)func(it);}\n\n        inline vector slice(int l,int r) const{\n          if(l>r)return {};\n          if(r<this->size())return vector(this->begin()+l,this->begin()+r);\n          vector<int> rsp=(this->begin()+l,this->end());\n          return rsp.resize(r-l),rsp;\n        }\n\n        inline void from(const std::set<T> &src){\n          this->resize(src.size());\n          auto it=this->begin();\n          for(const T e:src)*it++=e;\n        }\n\n        template<class R,class Function> inline vector<R> _map(Function func) const{\n          vector <R> res(this->size());\n          for(size_t i=0;i<this->size();i++)\n            res[i]=func(this->operator[](i));\n          return res;\n        }\n        template<class R> inline vector<R> map(R func(T)) const{return this->_map<R>(func);}\n        template<class R> inline vector<R> map(const std::function<R(T)> &func) const{return this->_map<R>(func);}\n      };\n\n      struct string:std::string{\n        using std::string::string;\n        string():std::string(\"\"){}\n        string(const std::string &plain):std::string(plain){}\n\n        template<class T> inline string join(const vector<T> &vet) const;\n\n        vector<string> split(const string &dim) const{\n          if(this->empty())return {};\n          char *src=new char[this->length()+1];\n          strcpy(src,this->c_str());\n          char *tar=new char[dim.length()+1];\n          strcpy(tar,dim.c_str());\n          vector <string> rsp;\n          for(char *pos=strtok(src,tar);pos;pos=strtok(nullptr,tar))\n            rsp.push_back(string(pos));\n          delete[] src;\n          delete[] tar;\n          return rsp;\n        }\n\n        template<class... Args> static inline string format(const char *fm,Args... args){\n          int len=snprintf(nullptr,0,fm,args...);\n          char *buf=new char[len+1];\n          snprintf(buf,len+1,fm,args...);\n          string str(buf);\n          delete[] buf;\n          return str;\n        }\n        template<class... Args> static inline string format(const string &fm,Args... args){\n          return format(fm.c_str(),args...);\n        }\n      };\n\n    #define __to_string(T)                 \\\n      inline string to_string(const T &x){ \\\n        return std::to_string(x);          \\\n      }\n      __float_mapper(__to_string)\n      __integer_mapper(__to_string)\n    #undef __to_string\n\n      inline string to_string(const string &s){return s;}\n      inline string to_string(const char *s){return string(s);}\n      inline string to_string(const std::string &s){return string(s);}\n\n      template<const int mod> inline string to_string(const mem::modint::Z<mod> &v){return std::to_string(v.x);}\n\n      template<class T> inline string to_string(const vector<T> &ctn){return \"[\"+string(\",\").join(ctn)+\"]\";}\n      template<class T> inline string to_string(const set<T> &ctn){\n        string result=\"{\";\n        bool flag=false;\n        for(const auto &it:ctn){\n          if(flag)result+=\",\";\n          flag=true;\n          result+=to_string(it);\n        }\n        return result+\"}\";\n      }\n      template<class T1,class T2> inline string to_string(const map<T1,T2> &ctn){\n        string result=\"{\";\n        bool flag=false;\n        for(const auto &it:ctn){\n          if(flag)result+=\",\";\n          flag=true;\n          result+=to_string(it.first)+\":\"+to_string(it.second);\n        }\n        return result+\"}\";\n      }\n\n      template<class T> inline string string::join(const vector<T> &vet) const{\n        if(!vet.size())return \"\";\n        string res=to_string(vet[0]);\n        for(size_t i=1;i<vet.size();i++){\n          res+=*this;\n          res+=to_string(vet[i]);\n        }\n        return res;\n      }\n\n      inline string operator \"\" _s(const char *s){return string(s);}\n      inline string operator \"\" _s(const char *s,size_t len){return string(s,len);}\n      inline string operator \"\" _s(long double x){return to_string(x);}\n      inline string operator \"\" _s(unsigned long long int x){return to_string(x);}\n  #endif\n    }\n\n    namespace io{\n  #ifdef MEM_IO\n    #ifdef MEM_FASTIO\n      namespace fastio{\n        const int BUFFER=1<<18;\n        char ibuf[BUFFER],*iS,*iT;\n        inline int getc(){\n          if(iS==iT){\n            iT=(iS=ibuf)+fread(ibuf,1,BUFFER,stdin);\n            return iS==iT?EOF:*iS++;\n          }else{\n            return *iS++;\n          }\n        }\n        char obuf[BUFFER],*oS=obuf,*oT=oS+BUFFER-1;\n        inline void flush(){\n          fwrite(obuf,1,oS-obuf,stdout);\n          oS=obuf;\n        }\n        inline void putc(int x){\n          *oS++=x;\n          if(oS==oT)flush();\n        }\n        struct Flusher{~Flusher(){flush();}}flusher;\n      }\n      using fastio::getc;\n      using fastio::putc;\n    #else\n      inline int getc(){return getchar();}\n      inline void putc(int c){putchar(c);}\n    #endif\n\n      template<class T> inline void readDigit(T &x){\n        x=getc();\n        while(!isdigit(x))x=getc();\n      }\n      inline int readDigit(){\n        int x;\n        readDigit(x);\n        return x;\n      }\n      template<class T> inline void readAlpha(T &x){\n        x=getc();\n        while(!isalpha(x))x=getc();\n      }\n      inline int readAlpha(){\n        int x;\n        readAlpha(x);\n        return x;\n      }\n\n    #define __read(T)                             \\\n        inline void read(T &x) {                  \\\n          x=0; bool f=0; char c=getc();           \\\n          while(!isdigit(c))f^=c=='-',c=getc();   \\\n          while(isdigit(c))x=x*10+c-'0',c=getc(); \\\n          if(f)x=-x;                              \\\n        }\n      __integer_mapper(__read)\n    #undef __read\n\n      inline void read(char &x){x=getc();}\n      inline void read(char *s){\n        char c=getc();\n        while(~c&&!isspace(c))*s++=c,c=getc();\n        *s++='\\0';\n      }\n      inline void read(container::string &s){\n        char c=getc();\n        s=\"\";\n        while(~c&&!isspace(c))s+=c,c=getc();\n      }\n\n      template<class T=int> inline T read(){\n        T x;\n        read(x);\n        return x;\n      }\n      template<class T,class... Args> inline void read(T &x,Args &... args){\n        read(x),read(args...);\n      }\n\n    #define __print(T)           \\\n        inline void print(T x){  \\\n          if(x<0)putc('-'),x=-x; \\\n          if(x>9)print(x/10);    \\\n          putc('0'+x%10);        \\\n        }\n      __integer_mapper(__print)\n    #undef __print\n\n      inline void print(char x){putc(x);}\n      inline void print(const char *s){\n        int len=strlen(s);\n        for(int i=0;i<len;i++)putc(s[i]);\n      }\n      inline void print(const container::string &s){\n        for(int i=0;i<s.length();i++)putc(s[i]);\n      }\n\n      template<class T,class... Args> inline void print(const T &x,Args... args){\n        print(x),print(args...);\n      }\n      template<class... Args> inline void println(Args... args){\n        print(args...),putc('\\n');\n      }\n\n      template<class... Args> inline void printfm(const char *formatter,Args... arguments){\n        print(container::string().format(formatter,arguments...));\n      }\n      template<class... Args> inline void printfm(const container::string &formatter,Args... arguments){\n        print(container::string().format(formatter,arguments...));\n      }\n  #endif\n    }\n\n    namespace logger{\n  #ifdef MEM_LOGGER\n      enum ConsoleColor{\n        NOPE=-1,BLACK,RED,GREEN,YELLOW,BLUE,PURPLE,DEEPBLUE\n      };\n      template<const ConsoleColor color=NOPE,class... Args> inline void log(const char *formatter,Args... args){\n        if(~color){\n          fprintf(stderr,\"\\033[%dm\",30+color);\n          fprintf(stderr,formatter,args...);\n          fprintf(stderr,\"\\033[0m\");\n        }else{\n          fprintf(stderr,formatter,args...);\n        }\n      }\n      template<const ConsoleColor color=NOPE,class... Args> inline void logln(const char *formatter,Args... args){\n        if(~color){\n          fprintf(stderr,\"\\033[%dm\",30+color);\n          fprintf(stderr,formatter,args...);\n          fprintf(stderr,\"\\033[0m\\n\");\n        }else{\n          fprintf(stderr,formatter,args...);\n          fprintf(stderr,\"\\n\");\n        }\n      }\n      template<class T> inline void logs(const T &x){\n        fprintf(stderr,container::to_string(x).c_str());\n      }\n      template<class T,class... Args> inline void logs(const T &x,Args... args){\n        logs(x),logs(args...);\n      }\n      template<class... Args> inline void logsln(Args... args){\n        logs(args...);\n        fprintf(stderr,\"\\n\");\n      }\n  #endif\n    }\n\n  #undef __integer_mapper\n  #undef __float_mapper\n  #undef __string_mapper\n  #undef __string_join_mapper\n\n    using namespace io;\n    using namespace math;\n    using namespace utils;\n    using namespace modint;\n    using namespace random;\n    using namespace stdval;\n    using namespace logger;\n    using namespace container;\n} // namespace mem\n\nusing namespace mem::io;\nusing namespace mem::math;\nusing namespace mem::utils;\nusing namespace mem::logger;\n\nconst int N=3e5+10,sqn=600,S=sqn+10;\nint n,m,bn,a[N],bln[N];\n\nstruct atom{\n  int l,r,c;\n  long long s;\n};\ninline atom operator+(const atom &a,const atom &b){\n  if(a.l==a.c&&b.l==b.c){\n    return {a.l+b.l,a.r+b.r,a.c+b.c,a.s+b.s+a.c*b.c};\n  }else if(a.l==a.c){\n    return {a.l+b.l,b.r,a.c+b.c,a.s+b.s+a.c*b.l};\n  }else if(b.l==b.c){\n    return {a.l,a.r+b.r,a.c+b.c,a.s+b.s+a.r*b.c};\n  }else{\n    return {a.l,b.r,a.c+b.c,a.s+b.s+a.r*b.l};\n  }\n}\ninline atom calc(int l,int r,int x){\n  atom res{0,0,r-l+1,0};\n  while(res.l<res.c&&a[l+res.l]<=x)res.l++;\n  while(res.r<res.c&&a[r-res.r]<=x)res.r++;\n  int pre=0;\n  for(int i=l;i<=r;i++)if(a[i]<=x)res.s+=++pre; else pre=0;\n  return res;\n}\nconst atom c[2]={{0,0,1,0},{1,1,1,1}};\n\nint anc[S],siz[S],tag[S];\nint find(int x){return anc[x]==x?x:anc[x]=find(anc[x]);}\ninline void merge(int a,int b,long long &s){\n  a=find(a),b=find(b),s+=siz[a]*siz[b];\n  if(siz[a]>siz[b])swap(a,b);\n  anc[a]=b,siz[b]+=siz[a];\n}\nstruct block{\n  int l,r,n,val[S],pos[S];\n  atom pre[S];\n  inline int loc(int x){return upper_bound(val+1,val+n+1,x)-val-1;}\n  inline void init(){\n    n=r-l+1;\n    pre[0]={0,0,n,0};\n    pre[n]={n,n,n,(long long)n*(n-1)/2};\n    for(int i=1;i<n;i++)pre[i].c=n;\n    std::vector<std::pair<int,int>> t(n);\n    for(int i=0;i<n;i++)t[i]={a[i+l],i};\n    sort(t.begin(),t.end());\n    for(int i=1;i<=n;i++)val[i]=t[i-1].first,pos[i]=t[i-1].second;\n  }\n  inline void modify(int k){\n    for(int i=1;i<=n;i++)if(pos[i]==k){\n      val[i]=a[k+l];\n      while(i>1&&val[i]<val[i-1])swap(val[i],val[i-1]),swap(pos[i],pos[i-1]),i--;\n      while(i<n&&val[i]>val[i+1])swap(val[i],val[i+1]),swap(pos[i],pos[i+1]),i++;\n      return;\n    }\n  }\n  inline void build(){\n    for(int i=n-1;i>=1;i--){\n      pre[i].l=min(pre[i+1].l,pos[i+1]);\n      pre[i].r=min(pre[i+1].r,n-pos[i+1]-1);\n    }\n    for(int i=0;i<n;i++)anc[i]=i,siz[i]=1,tag[i]=0;\n    for(int i=1;i<=n;i++){\n      pre[i].s=i?pre[i-1].s+1:1;\n      tag[pos[i]]=1;\n      if(pos[i]&&tag[pos[i]-1])merge(pos[i]-1,pos[i],pre[i].s);\n      if(pos[i]<n-1&&tag[pos[i]+1])merge(pos[i]+1,pos[i],pre[i].s);\n    }\n  }\n}s[N/sqn+5];\n\nint bas,_mem[N*12],*_p=_mem;\nstruct FC{\n  int n,*arr,*l,*r;\n  inline void source(int i){memcpy(arr+1,s[i].val+1,n<<2);}\n  inline void land(int n){if(n)this->n=n,arr=_p,_p+=n+3,l=_p,_p+=n+1,r=_p,_p+=n+1,arr[n+1]=arr[n+2]=1e9;}\n  inline void merge(const FC &a,const FC &b){\n    #define PushI {if(!c)arr[++n]=a.arr[i++],l[n]=i-1,r[n]=j-1; else ++i; c=(c+1)&3;}\n    #define PushJ {if(!c)arr[++n]=b.arr[j++],l[n]=i-1,r[n]=j-1; else ++j; c=(c+1)&3;}\n    int i=1,j=1,c=0;n=0;\n    while(i<=a.n&&j<=b.n)if(a.arr[i]<b.arr[j])PushI else PushJ;\n    while(i<=a.n)PushI;\n    while(j<=b.n)PushJ;\n  }\n  inline void out(){\n    log(\"n=%d\\n\",n);\n    for(int i=1;i<=n;i++)log<RED>(\"%d%c\",arr[i],\" \\n\"[i==n]);\n    for(int i=1;i<=n;i++)log<BLUE>(\"%d%c\",l[i],\" \\n\"[i==n]);\n    for(int i=1;i<=n;i++)log<GREEN>(\"%d%c\",r[i],\" \\n\"[i==n]);\n  }\n}tr[S<<1];\nint res[S<<1];\nbool use[S<<1];\nvoid locate(int x,int l,int r){\n  #define Loc res[i]+=tr[i].arr[res[i]+2]<=x?2:0,res[i]+=tr[i].arr[res[i]+1]<=x\n  for(int i=1;i<=bn;i++)use[bas+i]=l<=i&&i<=r;\n  for(int i=bas;i>=1;i--)use[i]=use[i<<1]||use[i<<1|1];\n  res[1]=0;\n  for(int i=1;i<=bas;i++)if(use[i]){\n    Loc;\n    res[i<<1]=tr[i].l[res[i]];\n    res[i<<1|1]=tr[i].r[res[i]];\n  }\n  for(int i=l+bas;i<=r+bas;i++)Loc;\n  // for(int i=l;i<=r;i++)log(\"%d%c\",tr[i+bas].k,\" \\n\"[i==r]);\n}\n\nint main(){\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n  freopen(\"1.out\",\"w\",stdout);\n#endif\n  read(n,m);\n  for(int i=1;i<=n;i++)read(a[i]);\n  for(int i=1;i<=n;i++)bln[i]=(i-1)/sqn+1;\n  bn=bln[n];\n  for(int i=1;i<=n;i++)s[bln[i]].r=i;\n  for(int i=n;i>=1;i--)s[bln[i]].l=i;\n  for(int i=1;i<=bn;i++)s[i].init(),s[i].build();\n  log<RED>(\"block=%d\\n\",bn);\n  for(bas=1;bas<=bn;bas<<=1);--bas;\n  for(int i=1;i<=bn;i++)tr[bas+i].land(s[i].n);\n  for(int i=bas;i>=1;i--)tr[i].land((tr[i<<1].n+tr[i<<1|1].n+3)>>2);\n  for(int i=1;i<=bn;i++)tr[bas+i].source(i);\n  for(int i=bas;i>=1;i--)tr[i].merge(tr[i<<1],tr[i<<1|1]);\n  // for(int i=1;i<=bas+n;i++)tr[i].out();\n  for(int o,l,r,x,y,i=1;i<=m;i++){\n    read(o);\n    if(o==1){\n      read(x,y);\n      a[x]=y;\n      s[bln[x]].modify(x-s[bln[x]].l);\n      s[bln[x]].build();\n      tr[bas+bln[x]].source(bln[x]);\n      for(int i=(bas+bln[x])>>1;i>=1;i>>=1)tr[i].merge(tr[i<<1],tr[i<<1|1]);\n    }else{\n      read(l,r,x);\n      atom ans;\n      if(bln[l]==bln[r]){\n        ans=calc(l,r,x);\n      }else{\n        ans=calc(l,s[bln[l]].r,x);\n        if(bln[l]+1<=bln[r]-1)locate(x,bln[l]+1,bln[r]-1);\n        for(int i=bln[l]+1;i<=bln[r]-1;i++)ans=ans+s[i].pre[res[i+bas]];\n        ans=ans+calc(s[bln[r]].l,r,x);\n      }\n      print(ans.s,'\\n');\n    }\n    // if(i%10000==0)fprintf(stderr,\"clocks: %.4lf\\n\",clock()/(double)CLOCKS_PER_SEC);\n  }\n  fprintf(stderr,\"clocks: %.4lf\\n\",clock()/(double)CLOCKS_PER_SEC);\n}\n```\n","publishedTitle":"「CometOJ Round #7 F」最简单的题"}},{"id":"00eb38f4-ded2-5ab2-98dd-9223d4c78a49","fields":{"slug":"/oi/solution/hdu6810/","plainText":"\n> 给定 $n$ 个点的树，定义 $m$ 个人的约会点 $x$ 为使得 $m$ 个人所在的点到 $x$ 的距离之和最小的点。\n>\n> $m$ 个人所在位置在 $n$ 个点中随机选择（即总方案数 $\\binom nm$），问所有方案到约会点距离之和的和。\n>\n> $n \\leq 10^6$，答案对 $10^9 + 7$ 取模。\n\n<!-- more -->\n\n## 题解\n\n考虑确定 $m$ 个点后，所有人到某个点的距离和是单调的，也就是说可能称为约会点的点一定是一个联通块。\n\n我们预处理出所有点到某个点的距离和，因为稍后我们选点时，（某一选点范围内）每个点被选中的概率是均等的。\n\n「Part1」一个点能够成为约会点当且仅当每棵子树内选的点个数都 $\\leq \\frac m 2$，我们枚举点 $u$ 和其一个子树 $v$，使得 $v$ 内选的点的个数 $> \\frac m 2$（对于一种方案和固定的 $u$，这样的 $v$ 至多只有一个）。贡献形如\n\n$$\n\\sum_{\\frac m 2 < i \\leq m} \\binom {siz_v} {i} \\binom {n - siz_v} {m - i} \\left( \\frac {i} {siz_v} \\cdot (sumsub_v + siz_v) + \\frac {m - i} {n - siz_v} \\cdot (sumall_u - sumsub_v - siz_v)\\right)\n$$\n\n这个分数可以合到组合数里，也就是瓶颈为\n\n$$\n\\sum_{\\frac m2 < i \\leq m} \\binom si \\binom {n-s} {m-i}\n$$\n\n这个东西我们考虑组合意义，容易从 $f_s$ 递推到 $f_{s-1}$。\n\n「Part2」一条边上的两个点能同时成为约会点当且仅当两侧被选中的点的个数都恰为 $\\frac m 2$，这一部分容易直接计算。\n\n于是点减边就做完了，时间复杂度 $O(n)$。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 9, mod = 1e9 + 7;\nint T, n, m, fa[N], siz[N];\nvector<int> G[N];\nstruct z {\n  int x;\n  z(int x = 0) : x(x) {}\n  friend inline z operator*(z a, z b) { return (long long)a.x * b.x % mod; }\n  friend inline z operator-(z a, z b) { return (a.x -= b.x) < 0 ? a.x + mod : a.x; }\n  friend inline z operator+(z a, z b) { return (a.x += b.x) >= mod ? a.x - mod : a.x; }\n} F0[N], F1[N], fac[N], inv[N], ifac[N], sumall[N], sumsub[N];\ninline z fpow(z a, int b) {\n  z s = 1;\n  for (; b; b >>= 1, a = a * a)\n    if (b & 1) s = s * a;\n  return s;\n}\ninline z finv(z a) { return fpow(a, mod - 2); }\ninline z C(int n, int m) { return n < m ? 0 : fac[n] * ifac[m] * ifac[n - m]; }\nstruct atom {\n  int siz;\n  z sum;\n};\nvector<atom> A[N];\nvoid dfs(int u) {\n  siz[u] = 1;\n  sumsub[u] = 0;\n  for (int v : G[u]) {\n    fa[v] = u, dfs(v), siz[u] += siz[v];\n    sumsub[u] = sumsub[u] + sumsub[v] + siz[v];\n  }\n}\nvoid dfs2(int u, z fr) {\n  sumall[u] = fr + sumsub[u], fr = fr + n;\n  for (int v : G[u]) {\n    fr = fr + sumsub[v] + siz[v];\n  }\n  for (int v : G[u]) {\n    dfs2(v, fr - sumsub[v] - siz[v] - siz[v]);\n  }\n}\nvoid sol0(int n, int m, int l, int r, z *F) {\n  if (l > m || l > r) {\n    memset(F, 0, (n + 1) << 2);\n  } else {\n    F[n] = C(n, m);\n    for (int i = n - 1; i >= 0; i--) F[i] = F[i + 1] - C(i, l - 1) * C(n - i - 1, m - l);\n    for (int j = m + 1; j <= r; j++)\n      for (int i = 0; i <= n; i++) F[i] = F[i] + C(i, j) * C(n - i, m - j);\n  }\n}\nz sol1() {\n  z res = 0;\n  for (int u = 1; u <= n; u++) {\n    res = res + C(n - 1, m - 1) * sumall[u];\n    for (auto &x : A[u]) {\n      res = res - F0[x.siz - 1] * (x.sum + x.siz) - F1[x.siz] * (sumall[u] - x.sum - x.siz);\n    }\n  }\n  return res;\n}\nz sol2() {\n  if (m & 1) return 0;\n  z res = 0;\n  for (int u = 1; u <= n; u++)\n    for (auto &x : A[u]) {\n      res = res + C(x.siz, m >> 1) * C(n - x.siz, m >> 1) * (inv[x.siz] * (x.sum + x.siz) + inv[n - x.siz] * (sumall[u] - x.sum - x.siz));\n    }\n  return res * (m >> 1) * finv(2);\n}\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  fac[0] = ifac[0] = inv[0] = inv[1] = 1;\n  for (int i = 1; i < N; i++) fac[i] = fac[i - 1] * i;\n  for (int i = 2; i < N; i++) inv[i] = (mod - mod / i) * inv[mod % i];\n  for (int i = 1; i < N; i++) ifac[i] = ifac[i - 1] * inv[i];\n  for (cin >> T; T--;) {\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) G[i].clear(), A[i].clear();\n    for (int fa, i = 2; i <= n; i++) {\n      cin >> fa;\n      G[fa].push_back(i);\n    }\n    dfs(1);\n    dfs2(1, 0);\n    for (int u = 1; u <= n; u++) {\n      for (int v : G[u]) A[u].push_back({siz[v], sumsub[v]});\n      A[u].push_back({n - siz[u], sumall[fa[u]] - sumsub[u] - siz[u]});\n    }\n    int l = (m >> 1) + 1;\n    sol0(n - 1, m - 1, l - 1, m - 1, F0);\n    sol0(n - 1, m - 1, l, m, F1);\n    cout << (sol1() - sol2()).x << '\\n';\n  }\n}\n```\n","publishedTitle":"「HDU6810」Imperative Meeting"}},{"id":"81c16de1-77a3-5387-8322-88fe3585f54c","fields":{"slug":"/oi/solution/loj2461/","plainText":"\n> 你有 $n$ 个队列，每个队列有 $a_i$ 的容量。\n>\n> $Q$ 次操作，每次给定队列的区间 $[l,r]$，push 一个 $x$。如果第 $i$ 个队列的元素个数 $>a_i$，会自动 pop。\n>\n> 要求每次操作后求出所有序列中本质不同的元素个数。\n>\n> $n,m,a_i,x \\leq 10^5$。\n\n<!-- more -->\n\n## 题解\n\n建出线段树，那么一个区间操作 $[l,r]$ 能恰好覆盖 $O(\\log n)$ 条线段。对于每条线段，考虑统计操作加入的点何时被完全移出该区间。\n\n由于我们只把完全覆盖该线段的操作丢入改线段处理，那么操作的进入和弹出符合单调队列的性质，我们通过一条线段维护。每次对线段进行修改后，我们不断判断并弹出队列头即可保证复杂度。\n\n那么如何判断呢，考虑一个操作插入一条线段 $[l;r]$ 时，初始的限制是形如这一段 $a_{l\\ldots r}$。进行别的操作经过这条线段时就是把限制的区间或整体 $-1$。如果限制全部 $\\leq 0$，这次操作添加的所有元素被完全弹出改线段对应的队列中。\n\n显然对于每一个（操作，线段）二元组开线段树维护限制，注意到前面说的单调队列性质，一个操作在固定线段上，影响限制的操作可以看做是经过该线段所形成的操作序列的一个区间。我们对线段开线段树（哎妈呀真绕），刚说的操作序列区间的左右端点都是单调增的，维护较为平凡。\n\n还有个复杂度上的小问题，对于每次操作，恰好覆盖一条线段的时候我们就 return 了，而对于该线段树节点的子树内单调队列，可能是有贡献的。需要维护单调队列距离下次弹出需要的懒标记个数，也是较为平凡的。\n\n## 代码\n\n```cpp\n// n log^2 n solution\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10, M = N * 40;\nint n, m, tot, nod, ans, a[N], col[N], lc[M], rc[M], val[M], tag[M];\ninline void up(int u, int x) { val[u] += x, tag[u] += x; }\ninline void down(int u) {\n  if (tag[u]) up(lc[u], tag[u]), up(rc[u], tag[u]), tag[u] = 0;\n}\nvoid build(int &u, int l, int r) {\n  u = ++tot;\n  if (l == r) {\n    val[u] = a[l];\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(lc[u], l, mid);\n  build(rc[u], mid + 1, r);\n  val[u] = max(val[lc[u]], val[rc[u]]);\n}\nvoid modify(int u, int ql, int qr, int x, int l, int r) {\n  down(u);\n  if (ql == l && qr == r) {\n    up(u, x);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  if (qr <= mid) {\n    modify(lc[u], ql, qr, x, l, mid);\n  } else if (ql > mid) {\n    modify(rc[u], ql, qr, x, mid + 1, r);\n  } else {\n    modify(lc[u], ql, mid, x, l, mid);\n    modify(rc[u], mid + 1, qr, x, mid + 1, r);\n  }\n  val[u] = max(val[lc[u]], val[rc[u]]);\n}\nstruct segment {\n  int l, r, mid, rt, d, k, tag, lc, rc;\n  pair<int, int> todo, item;\n  queue<tuple<int, int, int>> q;\n  vector<pair<int, int>> opt;\n} p[N << 1];\ninline void pushup(int u, int x) { p[u].d += x, p[u].tag += x, p[u].todo.first -= x; }\ninline void pushdown(int u) {\n  if (p[u].tag && p[u].l != p[u].r) {\n    pushup(p[u].lc, p[u].tag);\n    pushup(p[u].rc, p[u].tag);\n    p[u].tag = 0;\n  }\n}\ninline void maintain(int u) {\n  p[u].todo = p[u].item;\n  if (p[u].l != p[u].r) {\n    pushdown(u);\n    if (p[p[u].lc].todo.first < p[u].todo.first) p[u].todo = p[p[u].lc].todo;\n    if (p[p[u].rc].todo.first < p[u].todo.first) p[u].todo = p[p[u].rc].todo;\n  }\n}\nint build(int l, int r) {\n  int u = ++nod;\n  p[u].l = l, p[u].r = r, p[u].mid = (l + r) >> 1;\n  build(p[u].rt, l, r);\n  p[u].item = p[u].todo = {114514, u};\n  if (l != r) {\n    p[u].lc = build(l, p[u].mid);\n    p[u].rc = build(p[u].mid + 1, r);\n  }\n  return u;\n}\nvoid update(int u) {\n  static int c, k, d, l, r;\n  while (p[u].q.size()) {\n    tie(c, k, d) = p[u].q.front();\n    while (p[u].k < k) {\n      tie(l, r) = p[u].opt[p[u].k++];\n      modify(p[u].rt, l, r, 1, p[u].l, p[u].r);\n    }\n    if (p[u].d - d >= val[p[u].rt]) {\n      col[c]--, ans -= !col[c];\n      p[u].q.pop();\n    } else {\n      p[u].item = {val[p[u].rt] + d - p[u].d, u};\n      maintain(u);\n      return;\n    }\n  }\n  p[u].item = {114514, u};\n  maintain(u);\n}\nvoid modify(int u, int l, int r, int c) {\n  if (p[u].l == l && p[u].r == r) {\n    ans += !col[c], col[c]++;\n    pushup(u, 1);\n    p[u].q.push({c, (int)p[u].opt.size(), p[u].d});\n  } else {\n    pushdown(u);\n    p[u].opt.push_back({l, r});\n    modify(p[u].rt, l, r, -1, p[u].l, p[u].r);\n    if (r <= p[u].mid) modify(p[u].lc, l, r, c);\n    else if (l > p[u].mid)\n      modify(p[u].rc, l, r, c);\n    else\n      modify(p[u].lc, l, p[u].mid, c), modify(p[u].rc, p[u].mid + 1, r, c);\n    maintain(u);\n  }\n  update(u);\n}\nvoid resolve(int u, int v) {\n  pushdown(u);\n  if (u == v) {\n    update(u);\n    return;\n  }\n  resolve(p[v].r <= p[u].mid ? p[u].lc : p[u].rc, v);\n  update(u);\n  maintain(u);\n}\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  build(1, n);\n  for (int i = 1, l, r, x; i <= m; i++) {\n    cin >> l >> r >> x;\n    modify(1, l, r, x);\n    while (!p[1].todo.first) resolve(1, p[1].todo.second);\n    cout << ans << '\\n';\n  }\n}\n```\n","publishedTitle":"「集训队互测2018」完美的队列"}},{"id":"edb9ca8d-27d8-56cc-a8b3-8c9ed5494b35","fields":{"slug":"/oi/solution/loj3315/","plainText":"\n> 有 $m$ 张带编号卡牌，每次你可以随机抽取一张。抽中每张的概率均为 $\\frac 1 m$。当编号连续的 $k$ 张牌都被抽取过时，游戏结束。\n>\n> 问游戏结束的期望步数。\n>\n> $1 \\leq k \\leq m \\leq 2 \\times 10^5$。\n\n<!-- more -->\n\n## 题解\n\n### Part 1\n\n我们可以直接对每张牌第一次被抽中的操作序列计数。\n\n把牌的每一段编号连续区间分开考虑，每一段处理出选中连续区间长度不超过 $k$ 的方案数（同时容易得到超过的方案数），然后分治 + NTT 合并，这是平凡的。\n\n这个做法的时间复杂度是 $O(n^2＋n \\log^2 n)$ 的，瓶颈在于前半部分即处理出分成把 $n$ 个 $m=1...n$ 段满足每一段长度都不超过 $k$ 的方案数，更进一步的可以表示为：\n\n$$\nB(u) = [x^{n+1}] \\frac 1 {1 - u \\frac {x - x^{k+1}} {1 - x}}\n$$\n\n我们需要求出多项式 $B$。\n\n### Part2\n\n注意到这是一个拓展拉格朗日反演的形式，我们需要求出 $\\displaystyle{F(x) = \\frac{x - x^{k+1}} {1 - x}}$ 的复合逆。\n相当于我们要求 $G(x)$ 满足 $F(G(x)) = x$，根据多项式牛顿迭代，有\n\n$$\nT(G(x))\n= F(G(x)) - x\n= \\frac {G(x) - G^{k+1}(x)}{1 - G(x)} - x \\\\\n\\begin{aligned}\nT'(G(x))\n&= \\frac {(1 - (k+1)G^k(x))(1 - G(x)) + (G(x) - G^{k+1}(x))}{(1 - G(x))^2} \\\\\n&= \\frac {1 - (k+1)G^k(x) + kG^{k+1}(x)} {1 - 2G(x) + G^2(x)} \\\\\n\\end{aligned}\n$$\n\n由多项式牛顿迭代，我们可以倍增得到 $G(x)$。\n\n### Part3\n\n代入拓展拉格朗日反演的式子，令 $\\displaystyle{H(x) = \\frac 1 {1 - ux}}$ 我们可以得到\n\n$$\nS\n= [x^{n+1}] H(F(x))\n= \\frac 1 {n+1} [x^n] H'(x) \\left(\\frac x {G(x)}\\right)^{n+1}\n$$\n\n设 $\\displaystyle{T(x) = \\frac 1{n+1} \\left(\\frac x {G(x)}\\right)^{n+1}}$，则有\n\n$$\n\\begin{aligned}\nS\n&= [x^n] H'(x) T(x) = [x^n] T(x) \\frac {u} {(1-ux)^2} \\\\\n&= [x^n] T(x) u \\sum_{i=0}^\\infty (i+1) (ux)^i\n\\end{aligned}\n$$\n\n即可直接得到 $S(u)$。\n\n问题解决，总时间复杂度 $O(n\\log^2 n)$。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10, mod = 998244353;\nint n, m, k, a[N], b[N], rev[N << 2];\nstruct z {\n  int x;\n  inline z() : x(0) {}\n  inline z(int x) : x(x) {}\n  friend inline z operator*(z a, z b) { return (long long)a.x * b.x % mod; }\n  friend inline z operator-(z a, z b) { return (a.x -= b.x) < 0 ? a.x + mod : a.x; }\n  friend inline z operator+(z a, z b) { return (a.x += b.x) >= mod ? a.x - mod : a.x; }\n} ans, len[N], fac[N], ifac[N], w[N << 2], S[N];\nusing vec = vector<z>;\ninline z C(int n, int m) { return n < m ? 0 : fac[n] * ifac[m] * ifac[n - m]; }\ninline z fpow(z a, int b) {\n  z s = 1;\n  for (; b; b >>= 1, a = a * a)\n    if (b & 1) s = s * a;\n  return s;\n}\ninline vec resize(vec a, int n) {\n  a.resize(n);\n  return a;\n}\nvoid initfac(int n) {\n  fac[0] = fac[1] = ifac[0] = ifac[1] = 1;\n  for (int i = 2; i <= n; i++) fac[i] = fac[i - 1] * i;\n  for (int i = 2; i <= n; i++) ifac[i] = (mod - mod / i) * ifac[mod % i];\n  for (int i = 2; i <= n; i++) ifac[i] = ifac[i - 1] * ifac[i];\n}\nint init(int n) {\n  int lim = 1, k = 0;\n  while (lim < n) lim <<= 1, ++k;\n  for (int i = 0; i < lim; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (k - 1));\n  static int len = 1;\n  for (; len < lim; len <<= 1) {\n    z wn = fpow(3, (mod - 1) / (len << 1));\n    w[len] = 1;\n    for (int i = 1; i < len; i++) w[i + len] = w[i + len - 1] * wn;\n  }\n  return lim;\n}\nvoid dft(vec &a, int lim) {\n  a.resize(lim);\n  for (int i = 0; i < lim; i++)\n    if (i < rev[i]) swap(a[i], a[rev[i]]);\n  for (int len = 1; len < lim; len <<= 1)\n    for (int i = 0; i < lim; i += (len << 1))\n      for (int j = 0; j < len; j++) {\n        z x = a[i + j], y = a[i + j + len] * w[j + len];\n        a[i + j] = x + y, a[i + j + len] = x - y;\n      }\n}\nvoid idft(vec &a, int lim) {\n  dft(a, lim), reverse(&a[1], &a[lim]);\n  z inv = fpow(lim, mod - 2);\n  for (int i = 0; i < lim; i++) a[i] = a[i] * inv;\n}\ninline vec mul(vec a, vec b, int l) {\n  if (a.size() < 10 || b.size() < 10) {\n    vec c(a.size() + b.size() - 1);\n    for (int i = 0; i < a.size(); i++)\n      for (int j = 0; j < b.size(); j++) c[i + j] = c[i + j] + a[i] * b[j];\n    return c.resize(l), c;\n  }\n  int len = a.size() + b.size() - 1, lim = init(len);\n  dft(a, lim), dft(b, lim);\n  for (int i = 0; i < lim; i++) a[i] = a[i] * b[i];\n  return idft(a, lim), a.resize(l), a;\n}\ninline vec operator*(const vec &a, const vec &b) { return mul(a, b, a.size() + b.size() - 1); }\ninline vec operator+(vec a, const vec &b) {\n  a.resize(max(a.size(), b.size()));\n  for (int i = 0; i < b.size(); i++) a[i] = a[i] + b[i];\n  return a;\n}\ninline vec operator-(vec a, const vec &b) {\n  a.resize(max(a.size(), b.size()));\n  for (int i = 0; i < b.size(); i++) a[i] = a[i] - b[i];\n  return a;\n}\nvec inv(const vec &f, int len = -1) {\n  if ((len = ~len ? len : f.size()) == 1) return {fpow(f[0], mod - 2)};\n  vec a(&f[0], &f[len]), b = inv(f, (len + 1) >> 1);\n  int lim = init((len << 1) - 1);\n  dft(a, lim), dft(b, lim);\n  for (int i = 0; i < lim; i++) a[i] = b[i] * (2 - a[i] * b[i]);\n  return idft(a, lim), a.resize(len), a;\n}\nvec deri(vec f) {\n  for (int i = 0; i <= (int)f.size() - 2; i++) f[i] = f[i + 1] * (i + 1);\n  return f.back() = 0, f;\n}\nvec inte(vec f) {\n  for (int i = (int)f.size() - 1; i >= 1; i--) f[i] = f[i - 1] * fpow(i, mod - 2);\n  return f.front() = 0, f;\n}\nvec ln(const vec &f) { return inte(mul(inv(f), deri(f), f.size())); }\nvec exp(const vec &f, int len = -1) {\n  if ((len = ~len ? len : f.size()) == 1) return {1};\n  vec a(&f[0], &f[len]), b = exp(f, (len + 1) >> 1);\n  return b.resize(len), mul(b, a + vec{1} - ln(b), len);\n}\nvec fpow(vec a, int b) {\n  int n = a.size();\n  vec s;\n  for (int c = 0; c < n; c++)\n    if (a[c].x) {\n      int l = n - c * b;\n      if (l <= 0) return s.resize(n), s;\n      for (int i = 0; i < l; i++) a[i] = a[i + c];\n      a.resize(l);\n      a = ln(a);\n      for (int i = 0; i < l; i++) a[i] = a[i] * b;\n      a = exp(a), s.resize(c * b);\n      s.insert(s.end(), a.begin(), a.end());\n      return s;\n    }\n  return a;\n}\nvec complex(const vec &g) { // F(G(x))\n  vec s, c = {1};\n  for (int i = 1; i <= k; i++) c = mul(c, g, g.size()), s = s + c;\n  return s;\n}\nvec complex_inv(int len) { // G^{-1}(F(x))\n  if (len == 1) return {0};\n  vec g = resize(complex_inv((len + 1) >> 1), len), gk = fpow(g, k), gk1 = mul(gk, g, len);\n  vec res = g - mul(mul(g - gk1 - vec{0, 1} * (vec{1} - g), vec{1} - g, len), inv(vec{1} - vec{k + 1} * gk + vec{k} * gk1), len);\n  return res;\n}\ninline vec sol(int n) { //\tn+1个球，分m组，每组1~k个。\n  vec g = complex_inv(n + 1), res(n + 1);\n  g.erase(g.begin());\n  g = fpow(inv(g), n + 1) * vec{fpow(n + 1, mod - 2)};\n  for (int i = 1; i <= n; i++) res[i - 1] = (i + 1) * g[n - i];\n  reverse(&res[0], &res[n]), res[n] = n + 1 <= k;\n  return res;\n}\npair<vec, vec> solve(int l, int r) {\n  if (l == r) {\n    int n = b[l];\n    vec F(n + 1), G = sol(n);\n    for (int i = 0; i <= n; i++) {\n      F[i] = fac[n] * ifac[n - i] - G[i] * fac[i] - (i ? S[i - 1] : 0) * ifac[n - i];\n      S[i] = (i ? S[i - 1] : 0) + F[i] * fac[n - i];\n    }\n    for (int i = 0; i < n; i++) F[i] = F[i + 1] * ifac[i];\n    return F.pop_back(), pair<vec, vec>{F, G};\n  }\n  int mid = (l + r) >> 1;\n  auto L = solve(l, (l + r) >> 1), R = solve(((l + r) >> 1) + 1, r);\n  return {L.first * R.second + L.second * R.first, L.second * R.second};\n}\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin >> n >> k;\n  initfac(n + 5);\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  sort(a + 1, a + n + 1);\n  for (int i = 1, j; i <= n; i = j + 1) {\n    for (j = i; j < n && a[j + 1] == a[i] + j - i + 1; j++)\n      ;\n    b[++m] = j - i + 1;\n  }\n  auto res = solve(1, m);\n  for (int i = 1; i <= n; i++) {\n    len[i] = len[i - 1] + n * fpow(n - i + 1, mod - 2);\n    ans = ans + res.first[i - 1] * fac[i - 1] * fac[n - i] * len[i];\n  }\n  cout << (ans * ifac[n]).x << endl;\n}\n```\n","publishedTitle":"「ZJOI2020」抽卡"}},{"id":"b1b755e1-d06f-5dca-ace1-ea92af4c49a9","fields":{"slug":"/oi/solution/loj3397/","plainText":"\n> 一个长度为 $n$ 的排列是正确的，当且仅当他不存在非平凡的连续子序列，使得他的值也是连续的。 对于 $k\\in[1,n]$ 求出，有多少长度为 $k$ 的正确的排列。\n>\n> $n\\le 10^5$。\n\n<!-- more -->\n\n## 题解\n\n### Step 1\n\n定义 $F(x)=\\sum_{i\\ge 4}f_ix^i,\\ G(x)=\\sum_{i\\ge 2}g_ix^i,\\ H(x)=\\sum_{i\\ge 2}i!x^i$。\n\n其中 $f_i$ 表示有 $i$ 个叶子节点，根节点为析点且树高为 $2$ 的析合树数量，$g_i$ 表示有 $n$ 个叶子节点，根节点为合点，且孩子排列的相对大小关系是单调上升的析合树个数。注意到 $g_i$ 也同时表示孩子排列相对大小单调下降的析合树个数。\n\n考虑一个析合树是合法的，其本身节点的限制：\n\n- 如果一个点是析点，他的所有儿子都是析点。\n- 如果一个点是合点，且他的一个儿子也是合点，那么这两个点的单调性一定恰好相反。\n\n根据这两条我们可以得到关于上述生成函数的若干等式：\n\n$$\n\\begin{aligned}\n&G(x)=\\sum_{k\\ge 2}(H(x)-G(x))^k & (1)\\\\\n&F(H(x))=H(x)-2G(x)-x & (2)\\\\\n\\end{aligned}\n$$\n\n根据 $(1)$ 式我们可以解得 $G(x)=\\dfrac{H^2(x)}{H(x)+1}$。\n\n在 $(2)$ 式中带入 $H(x)$ 的复合逆 $I(x)$，有\n\n$$\n\\begin{aligned}\n&F(H(I(x)))=H(I(x))-2G(I(x))-I(x)\\\\\n\\Rightarrow\\ &F(x)=x-\\dfrac{2x^2}{x+1}-I(x)\n\\end{aligned}\n$$\n\n$x-\\dfrac{2x^2}{x+1}$ 部分对答案的贡献是容易计算的，故我们的瓶颈在于求出 $H(x)$ 的复合逆 $I(x)$。\n\n### Step 2\n\n现问题转化为，对于某函数 $\\displaystyle F(x)=\\sum_{i=1}^\\infty i!x^i$，计算其复合逆。\n\n考虑 $F(x)$ 满足如下微分方程（可以通过其递推式得到）\n\n$$\nF(x)=F'(x)\\cdot x^2+F(x)\\cdot x+x\n$$\n\n带入其复合逆 $G(x)$ 得到\n\n$$\n\\begin{aligned}\n&x=F'(G(x))\\cdot G^2(x)+ x\\cdot G(x)+G(x) \\\\\n\\Rightarrow\\ &x=\\frac{1}{G'(x)} G^2(x)+ x\\cdot G(x)+G(x) \\\\\n\\Rightarrow\\ &G^2(x)-G'(x)\\cdot x+(x+1)G(x)G'(x)=0\\\\\n\\end{aligned}\n$$\n\n考虑其中每一项都等于 $0$，得到递推式：\n\n$$\ng_n=\\begin{cases}\n0&(n=0)\\\\\n1&(n=1)\\\\\n-\\sum_{i=1}^{n-1}(i+1)g_ig_{n-i}-\\sum_{i=2}^{n-1}ig_ig_{n-i+1}&(n\\ge 2)\n\\end{cases}\n$$\n\n可以分治 NTT 或者半在线卷积。\n\n## 反思\n\n通过观察阶乘的递推公式，我们得到了关于其生成函数的一个一阶常微分方程，并用以解决多项式复合逆问题，从而提供了一种不同于拉格朗日反演的推导方式。\n\n想起之前做的“简单的普及组计数”，自己在这方面的水平仍需训练加强。\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nnamespace mem{ //v2.10.1 => size: 15.80KiB\n  #ifdef memset0\n  #else\n    #define MEM_FASTIO\n  #endif\n\n  #ifdef __SIZEOF_INT128__\n    #define MEM_INT128\n  #endif\n\n  #define __integer_mapper(func)    \\\n      func(int)                     \\\n      func(unsigned int)            \\\n      func(long long int)           \\\n      func(unsigned long long int)\n  #define __float_mapper(func)        \\\n      func(float)                     \\\n      func(double)                    \\\n      func(long double)\n\n  namespace stdval{\n    using i32=int;\n    using i64=long long;\n    using u32=unsigned;\n    using u64=unsigned long long;\n    using f32=float;\n    using f64=double;\n    using f96=long double;\n  #ifdef MEM_INT128\n    using i128=__int128_t;\n    using u128=__uint128_t;\n  #endif\n  }\n\n  namespace utils{\n    using std::cin;\n    using std::tie;\n    using std::get;\n    using std::cout;\n    using std::cerr;\n    using std::endl;\n    using std::swap;\n    using std::sort;\n    using std::find;\n    using std::copy;\n    using std::fill;\n    using std::unique;\n    using std::reverse;\n    using std::shuffle;\n    using std::function;\n    using std::make_pair;\n    using std::make_tuple;\n    using std::accumulate;\n    using std::lower_bound;\n    using std::upper_bound;\n    using std::max_element;\n    using std::min_element;\n    using std::next_permutation;\n  }\n\n  namespace random{\n    const int LuckyNumber=0726; // Kanbe Kotori's Birthday\n    std::mt19937 rng(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n    std::mt19937_64 rng64(LuckyNumber^std::chrono::steady_clock::now().time_since_epoch().count());\n\n    template<class T> inline T rand(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n    template<class T> inline T rand64(T l,T r){return std::uniform_int_distribution<T>(l,r)(rng);}\n  }\n\n  namespace modint{\n    template<const int mod> struct Z{\n      int x;\n      inline Z(){x=0;}\n      inline Z(int t){x=t;}\n      inline Z(long long t){x=t%mod,x<0&&(x+=mod);}\n\n      inline void operator-=(Z a){(x-=a.x)<0&&(x+=mod);}\n      inline void operator+=(Z a){(x+=a.x)>=mod&&(x-=mod);}\n      inline void operator*=(Z a){x=(long long)x*a.x%mod;}\n\n      friend inline Z operator*(Z a,Z b){return (long long)a.x*b.x%mod;}\n      friend inline Z operator-(Z a,Z b){return ((a.x-=b.x)<0&&(a.x+=mod)),a;}\n      friend inline Z operator+(Z a,Z b){return ((a.x+=b.x)>=mod&&(a.x-=mod)),a;}\n    };\n\n    template<const int mod> inline Z<mod> finv(Z<mod> x){\n      if(x.x<2)return x;\n      return (mod-mod/x.x)*finv(mod%x.x);\n    }\n    template<const int mod> inline Z<mod> fpow(Z<mod> a,int b){\n      Z<mod> s=1;\n      for(;b;b>>=1,a=a*a)\n        if(b&1)s=s*a;\n      return s;\n    }\n\n    template<const int mod> inline void init_inverse(int n,Z<mod> *inv){\n      inv[0]=inv[1]=1;\n      for(int i=2;i<n;i++)inv[i]=(mod-mod/i)*inv[mod%i];\n    }\n    template<const int mod> inline void init_factorial(int n,Z<mod> *fac,Z<mod> *ifac){\n      fac[0]=1,init_inverse(n,ifac);\n      for(int i=1;i<n;i++)fac[i]=fac[i-1]*i,ifac[i]=ifac[i-1]*ifac[i];\n    }\n  }\n\n  namespace math{\n    using namespace stdval;\n    using std::max;\n    using std::min;\n    template<class T> inline T abs(T x){return x<0?-x:x;}\n    template<class T> inline T gcd(T n,T m){return m?gcd(m,n%m):n;}\n    template<class T> inline T lcm(T n,T m){return n/gcd(n,m)*m;}\n\n    struct FastDiv{\n      u64 t,i;\n      inline FastDiv(u64 p):t(u64(-1)/p),i(mul_inv(p)){}\n\n      inline bool divide(u64 n){return n*i<=t;}\n      inline bool divide(i64 n){return u64(n<0?-n:n)*i<=t;}\n      inline u64 mul_inv(u64 n){\n        u64 x=n;\n        for(int i=0;i<5;++i)x*=2-n*x;\n        return x;\n      }\n    };\n\n  #ifdef MEM_INT128\n    struct FastMod{\n      u64 m,b;\n      inline FastMod(u64 b):m(u64((u128(1)<<64)/b)),b(b){}\n\n      inline u64 reduce(u64 a){\n        u64 q=(u64)((u128(m)*a)>>64);\n        u64 r=a-q*b;\n        return r>=b?r-b:r;\n      }\n    };\n  #endif\n  }\n\n  namespace container{\n    using std::pair;\n    using std::tuple;\n    using std::set;\n    using std::multiset;\n    using std::unordered_set;\n    using std::unordered_multiset;\n    using std::map;\n    using std::multimap;\n    using std::unordered_map;\n    using std::unordered_multimap;\n    using std::queue;\n    using std::stack;\n    using std::priority_queue;\n    using std::deque;\n    using std::bitset;\n\n    using std::tie;\n    using std::get;\n    using std::make_pair;\n    using std::make_tuple;\n\n    template<class T> struct vector:std::vector<T>{\n      using std::vector<T>::vector;\n      using iterator=typename std::vector<T>::iterator;\n      using const_iterator=typename std::vector<T>::const_iterator;\n      vector():std::vector<T>(){}\n      explicit vector(const std::vector<T> &plain):std::vector<T>(plain){}\n\n      inline void reverse(){std::reverse(this->begin(),this->end());}\n      inline void unique(){this->erase(std::unique(this->begin(),this->end()),this->end());}\n      inline void concat(const vector &rhs){this->insert(this->end(),rhs.begin(),rhs.end());}\n      inline bool includes(const T &x) const{return std::find(this->begin(),this->end(),x)!=this->end();}\n      template<class Function> inline void forEach(Function func){for(const auto &it:*this)func(it);}\n\n      inline iterator find(const T &x){return std::find(this->begin(),this->end(),x);}\n      inline iterator lower_bound(const T &x){return std::lower_bound(this->begin(),this->end(),x);}\n      inline iterator upper_bound(const T &x){return std::upper_bound(this->begin(),this->end(),x);}\n      inline const_iterator find(const T &x)const{return std::find(this->begin(),this->end(),x);}\n      inline const_iterator lower_bound(const T &x)const{return std::lower_bound(this->begin(),this->end(),x);}\n      inline const_iterator upper_bound(const T &x)const{return std::upper_bound(this->begin(),this->end(),x);}\n\n      inline void sort(){std::sort(this->begin(),this->end());}\n      template<class Function> inline void sort(Function func){std::sort(this->begin(),this->end(),func);}\n\n      inline vector slice(int l,int r) const{\n        if(l>r)return {};\n        if(r<this->size())return vector(this->begin()+l,this->begin()+r);\n        vector rsp(this->begin()+l,this->end());\n        return rsp.resize(r-l),rsp;\n      }\n\n      inline void from(const std::set<T> &src){\n        this->resize(src.size());\n        auto it=this->begin();\n        for(const T e:src)*it++=e;\n      }\n\n      template<class R,class Function> inline vector<R> _map(Function func) const{\n        vector<R> res(this->size());\n        for(size_t i=0;i<this->size();i++)\n          res[i]=func(this->operator[](i));\n        return res;\n      }\n      template<class R> inline vector<R> map(R func(T)) const{return this->_map<R>(func);}\n      template<class R> inline vector<R> map(const std::function<R(T)> &func) const{return this->_map<R>(func);}\n    };\n\n    struct string:std::string{\n      using std::string::string;\n      string():std::string(\"\"){}\n      string(const std::string &plain):std::string(plain){}\n\n      template<class T> inline string join(const vector<T> &vet) const;\n\n      inline string slice(int l,int r) const{\n        if(l>r)return {};\n        if(r<this->size())return string(this->begin()+l,this->begin()+r);\n        string rsp(this->begin()+l,this->end());\n        return rsp.resize(r-l),rsp;\n      }\n\n      vector<string> split(const string &dim) const{\n        if(this->empty())return {};\n        char *src=new char[this->length()+1];\n        strcpy(src,this->c_str());\n        char *tar=new char[dim.length()+1];\n        strcpy(tar,dim.c_str());\n        vector<string> rsp;\n        for(char *pos=strtok(src,tar);pos;pos=strtok(nullptr,tar))\n          rsp.push_back(string(pos));\n        delete[] src;\n        delete[] tar;\n        return rsp;\n      }\n\n      template<class... Args> static inline string format(const char *fm,Args... args){\n        int len=snprintf(nullptr,0,fm,args...);\n        char *buf=new char[len+1];\n        snprintf(buf,len+1,fm,args...);\n        string str(buf);\n        delete[] buf;\n        return str;\n      }\n      template<class... Args> static inline string format(const string &fm,Args... args){\n        return format(fm.c_str(),args...);\n      }\n    };\n\n  #define __to_string(T)                   \\\n      inline string to_string(const T &x){ \\\n        return std::to_string(x);          \\\n      }\n    __float_mapper(__to_string)\n    __integer_mapper(__to_string)\n  #undef __to_string\n\n    inline string to_string(const string &s){return s;}\n    inline string to_string(const char *s){return string(s);}\n    inline string to_string(const std::string &s){return string(s);}\n    template<const int mod> inline string to_string(const modint::Z<mod> &v){return std::to_string(v.x);}\n\n    template<class T> inline string to_string(const vector<T> &ctn){return \"[\"+string(\",\").join(ctn)+\"]\";}\n    template<class T> inline string to_string(const set<T> &ctn){\n      string result=\"{\";\n      bool flag=false;\n      for(const auto &it:ctn){\n        if(flag)result+=\",\";\n        flag=true;\n        result+=to_string(it);\n      }\n      return result+\"}\";\n    }\n    template<class T1,class T2> inline string to_string(const map<T1,T2> &ctn){\n      string result=\"{\";\n      bool flag=false;\n      for(const auto &it:ctn){\n        if(flag)result+=\",\";\n        flag=true;\n        result+=to_string(it.first)+\":\"+to_string(it.second);\n      }\n      return result+\"}\";\n    }\n\n    template<class T> inline string string::join(const vector<T> &vet) const{\n      if(!vet.size())return \"\";\n      string res=to_string(vet[0]);\n      for(size_t i=1;i<vet.size();i++){\n        res+=*this;\n        res+=to_string(vet[i]);\n      }\n      return res;\n    }\n\n    inline string operator \"\" _s(const char *s){return string(s);}\n    inline string operator \"\" _s(const char *s,size_t len){return string(s,len);}\n    inline string operator \"\" _s(long double x){return to_string(x);}\n    inline string operator \"\" _s(unsigned long long int x){return to_string(x);}\n  }\n\n  namespace io{\n  #ifdef MEM_FASTIO\n    namespace fastio{\n      const int BUFFER=1<<18;\n      char ibuf[BUFFER],*iS,*iT;\n      inline int getc(){\n        if(iS==iT){\n          iT=(iS=ibuf)+fread(ibuf,1,BUFFER,stdin);\n          return iS==iT?EOF:*iS++;\n        }else{\n          return *iS++;\n        }\n      }\n      char obuf[BUFFER],*oS=obuf,*oT=oS+BUFFER-1;\n      inline void flush(){\n        fwrite(obuf,1,oS-obuf,stdout);\n        oS=obuf;\n      }\n      inline void putc(int x){\n        *oS++=x;\n        if(oS==oT)flush();\n      }\n      struct Flusher{~Flusher(){flush();}}flusher;\n    }\n    using fastio::getc;\n    using fastio::putc;\n    inline void flush(){fastio::flush(),fflush(stdout);}\n  #else\n    inline int getc(){return getchar();}\n    inline void putc(int c){putchar(c);}\n    inline void flush(){fflush(stdout);}\n  #endif\n\n    template<class T> inline void read_digit(T &x){x=getc(); while(!isdigit(x))x=getc();}\n    template<class T> inline void read_alpha(T &x){x=getc(); while(!isalpha(x))x=getc();}\n    template<class T> inline void read_lower(T &x){x=getc(); while(!islower(x))x=getc();}\n    template<class T> inline void read_upper(T &x){x=getc(); while(!isupper(x))x=getc();}\n    inline int read_digit(){int x; read_digit(x); return x;}\n    inline int read_alpha(){int x; read_alpha(x); return x;}\n    inline int read_lower(){int x; read_lower(x); return x;}\n    inline int read_upper(){int x; read_upper(x); return x;}\n\n  #define __read(T)                             \\\n      inline void read(T &x) {                  \\\n        x=0; bool f=0; char c=getc();           \\\n        while(!isdigit(c))f^=c=='-',c=getc();   \\\n        while(isdigit(c))x=x*10+c-'0',c=getc(); \\\n        if(f)x=-x;                              \\\n      }\n    __integer_mapper(__read)\n    #ifdef MEM_INT128\n      __read(__int128_t)\n      __read(__uint128_t)\n    #endif\n  #undef __read\n\n    inline void read(char &x){x=getc();}\n    inline void read(char *s){\n      char c=getc();\n      while(~c&&!isspace(c))*s++=c,c=getc();\n      *s++='\\0';\n    }\n    inline void read(container::string &s){\n      char c=getc();\n      s=\"\";\n      while(~c&&!isspace(c))s+=c,c=getc();\n    }\n    template<const int mod> inline void read(const modint::Z<mod> &x){read(x.x);}\n\n    template<class T=int> inline T read(){T x; read(x); return x;}\n    template<class T,class... Args> inline void read(T &x,Args &... args){\n      read(x),read(args...);\n    }\n\n  #define __print(T)           \\\n      inline void print(T x){  \\\n        if(x<0)putc('-'),x=-x; \\\n        if(x>9)print(x/10);    \\\n        putc('0'+x%10);        \\\n      }\n    __integer_mapper(__print)\n    #ifdef MEM_INT128\n      __print(__int128_t)\n      __print(__uint128_t)\n    #endif\n  #undef __print\n\n    inline void print(char x){putc(x);}\n    inline void print(const char *s){\n      size_t len=strlen(s);\n      for(size_t i=0;i<len;i++)putc(s[i]);\n    }\n    inline void print(const container::string &s){\n      for(size_t i=0;i<s.length();i++)putc(s[i]);\n    }\n    template<const int mod> inline void print(const modint::Z<mod> &x){print(x.x);}\n\n    template<class T,class... Args> inline void print(const T &x,Args... args){\n      print(x),print(args...);\n    }\n    template<class... Args> inline void println(Args... args){\n      print(args...),putc('\\n');\n    }\n\n    template<class... Args> inline void printfm(const char *formatter,Args... arguments){\n      print(container::string().format(formatter,arguments...));\n    }\n    template<class... Args> inline void printfm(const container::string &formatter,Args... arguments){\n      print(container::string().format(formatter,arguments...));\n    }\n  }\n\n  namespace logger{\n    enum ConsoleColor{\n      NOPE=-1,BLACK,RED,GREEN,YELLOW,BLUE,PURPLE,DEEPBLUE\n    };\n    template<const ConsoleColor color=NOPE,class... Args> inline void log(const char *formatter,Args... args){\n  #ifdef memset0\n      if(~color){\n        fprintf(stderr,\"\\033[%dm\",30+color);\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,\"\\033[0m\");\n      }else{\n        fprintf(stderr,formatter,args...);\n      }\n  #endif\n    }\n    template<const ConsoleColor color=NOPE,class... Args> inline void logln(const char *formatter,Args... args){\n  #ifdef memset0\n      if(~color){\n        fprintf(stderr,\"\\033[%dm\",30+color);\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,\"\\033[0m\\n\");\n      }else{\n        fprintf(stderr,formatter,args...);\n        fprintf(stderr,\"\\n\");\n      }\n  #endif\n    }\n    template<class T> inline void logs(const T &x){\n  #ifdef memset0\n      fprintf(stderr,container::to_string(x).c_str());\n  #endif\n    }\n    template<class T,class... Args> inline void logs(const T &x,Args... args){\n      logs(x),logs(args...);\n    }\n    template<class... Args> inline void logsln(Args... args){\n      logs(args...);\n  #ifdef memset0\n      fprintf(stderr,\"\\n\");\n  #endif\n    }\n  }\n\n  namespace fileio{\n    inline void file_input(const char *dir){freopen(dir,\"r\",stdin);}\n    inline void file_output(const char *dir){freopen(dir,\"w\",stdout);}\n    inline void file_input(const std::string &dir){file_input(dir.c_str());}\n    inline void file_output(const std::string &dir){file_output(dir.c_str());}\n    inline void file_input(const container::string &dir){file_input(dir.c_str());}\n    inline void file_output(const container::string &dir){file_output(dir.c_str());}\n\n    template<class T> inline void file_io(const T name){\n      using namespace container;\n      file_input(name+\".in\"_s);\n      file_output(name+\".out\"_s);\n    }\n\n    inline void fast_cpp_io(){\n      std::ios::sync_with_stdio(0);\n      std::cin.tie(0);\n      std::cout.tie(0);\n    }\n  }\n\n  #undef __integer_mapper\n  #undef __float_mapper\n  #undef __string_mapper\n  #undef __string_join_mapper\n\n  using namespace io;\n  using namespace math;\n  using namespace utils;\n  using namespace modint;\n  using namespace random;\n  using namespace stdval;\n  using namespace fileio;\n  using namespace logger;\n  using namespace container;\n} // namespace mem\n\nconst int N=1<<19,mod=998244353;\n\nnamespace polynomial{\n  namespace full{\n    using u32=unsigned;\n    using u64=unsigned long long;\n    using z=mem::modint::Z<mod>;\n\n    const u32 mod=::mod;\n    z fac[N],ifac[N];\n\n    inline z fpow(z a,int b){z s=1;for(;b;b>>=1,a=a*a)if(b&1)s=s*a;return s;}\n\n    struct poly:mem::container::vector<z>{\n      using mem::container::vector<z>::vector;\n      inline void input(){\n        for(int i=0;i<this->size();i++){\n          mem::io::read(this->operator[](i).x);\n        }\n      }\n      inline void output()const{\n        for(int i=0;i<this->size();i++){\n          mem::io::print(this->operator[](i).x);\n          if(i+1!=this->size())mem::io::putc(' ');\n        }\n        mem::io::putc('\\n');\n      }\n    };\n\n    namespace SimpleNTT{\n      u32 lim,shift,rev[N],w[N];\n      u64 a[N];\n      void dft_base_init(int N){\n        for(int wn,len=1;len<N;len<<=1){\n          wn=fpow(3,(mod-1)/(len<<1)).x,w[len]=1;\n          for(int i=1;i<len;i++)w[i+len]=((u64)w[i+len-1]*wn)%mod;\n        }\n      }\n      void dft_init(int len){\n        lim=1,shift=0;\n        while(lim<len)lim<<=1,++shift;\n        for(int i=0;i<lim;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(shift-1));\n      }\n      void dft(u32 *f){\n        for(int i=0;i<lim;i++)a[rev[i]]=f[i];\n        for(int len=1;len<lim;len<<=1){\n          for(int i=0;i<lim;i+=(len<<1))\n            for(int j=0;j<len;j++){\n              u64 x=a[i+j],y=a[i+j+len]*w[j+len]%mod;\n              a[i+j]=x+y,a[i+j+len]=x+mod-y;\n            }\n          if(len==131072)for(int i=0;i<lim;i++)a[i]%=mod;\n        }\n        for(int i=0;i<lim;i++)f[i]=(u32)(a[i]%mod);\n      }\n      void idft(u32 *f){\n        dft(f);\n        std::reverse(f+1,f+lim);\n        u32 inv_lim=fpow((int)lim,mod-2).x;\n        for(int i=0;i<lim;i++)f[i]=(u64)f[i]*inv_lim%mod;\n      }\n    }\n\n    namespace FastNTT{ // source: skip2004, https://uoj.ac/submission/415571\n      const u32 mod2=mod<<1;\n      u32 lim,shift;\n      struct multi_integer{\n        u32 val,ival;\n        inline multi_integer(){}\n        inline explicit multi_integer(u32 v){val=v,ival=((u64)v<<32)/mod;}\n        inline u32 operator*(u32 x)const{return val*x-u32((u64)x*ival>>32)*mod;}\n      }wn[N|1],iwn[N|1];\n\n      inline u32 get(u32 x){return ((u64)x<<32)/mod;}\n      inline u32 norm1(u32 x){return x>=mod?x-mod:x;}\n      inline u32 norm2(u32 x){return x>=mod2?x-mod2:x;}\n      inline u32 pow(u32 a,u32 b,u32 ans=1){for(;b;b>>=1,a=(u64)a*a%mod)if(b&1)ans=(u64)ans*a%mod;return ans;}\n      inline u32 multi(u32 w,u32 idx){return wn[idx]*w;}\n      inline u32 div_lim(u32 x){return (x+(u64)(-x&lim-1)*mod)>>shift;}\n      inline void fold(u32 *a){for(int i=0;i<lim;i++)if(a[i]>=mod)a[i]-=mod;}\n\n      inline void dft_base_init(u32 len){\n        u32 N=1; for(;N<len;)N<<=1;\n        const u32 mid=N>>1,w=pow(3,mod/N),iw=pow((mod+1)/3,mod/N);\n        wn[mid]=iwn[mid]=multi_integer(1);\n        for(u32 i=1;i<mid;++i){\n          wn[mid+i]=multi_integer((u64)wn[mid+i-1].val*w%mod);\n          iwn[mid+i]=multi_integer((u64)iwn[mid+i-1].val*iw%mod);\n        }\n        for(u32 i=mid-1;(int)i>=0;--i)wn[i]=wn[i<<1],iwn[i]=iwn[i<<1];\n      }\n      inline void dft_init(u32 len){lim=1,shift=0;for(;lim<len;)lim<<=1,++shift;}\n\n      inline void dft(u32 *a){\n      #define trans(a,b,idx) { \\\n          const u32 A=norm2(a+b); \\\n          b=wn[idx]*(a+mod2-b),a=A; \\\n        }\n      #define trans2(a,b) { \\\n          const u32 A=norm2(a+b); \\\n          b=norm2(a+mod2-b),a=A; \\\n        }\n        if(lim==1)return;\n        if(lim==2){trans(a[0],a[1],1);return fold(a);}\n        if(lim==4){trans2(a[0],a[2])trans(a[1],a[3],3)trans(a[0],a[1],1)trans(a[2],a[3],1);return fold(a);}\n        for(int mid=lim>>1;mid>2;mid>>=1)\n          for(int j=0;j<lim;j+=mid+mid)\n            for(int k=0;k<mid;k+=4){\n              trans(a[j+k+0],a[mid+j+k+0],mid+k+0);\n              trans(a[j+k+1],a[mid+j+k+1],mid+k+1);\n              trans(a[j+k+2],a[mid+j+k+2],mid+k+2);\n              trans(a[j+k+3],a[mid+j+k+3],mid+k+3);\n            }\n        for(int j=0;j<lim;j+=8){\n          trans2(a[j+0],a[j+2])trans(a[j+1],a[j+3],3);\n          trans2(a[j+4],a[j+6])trans(a[j+5],a[j+7],3);\n        }\n        for(int j=0;j<lim;j+=8){\n          trans2(a[j+0],a[j+1])trans2(a[j+2],a[j+3]);\n          trans2(a[j+4],a[j+5])trans2(a[j+6],a[j+7]);\n        }\n        for(int i=0;i<lim;i++)if(a[i]>=mod)a[i]-=mod;\n        fold(a);\n      #undef trans\n      #undef trans2\n      }\n\n      inline void idft(u32 *a){\n      #define trans(a,b,idx) { \\\n          u32 _a=a,_b=b,A=norm2(_a),B=iwn[idx]*_b; \\\n          a=A+B,b=A+mod2-B; \\\n        }\n      #define trans2(a,b) { \\\n          const u32 A=norm2(a),B=norm2(b); \\\n          a=A+B,b=A+mod2-B; \\\n        }\n        if(lim==1)return;\n        if(lim==2){\n          const u32 A=a[0],B=a[1];\n          a[0]=div_lim(A+B),a[1]=div_lim(A+mod2-B);\n          return fold(a);\n        }\n        if(lim==4){\n          trans(a[0],a[1],1)trans(a[2],a[3],1)trans2(a[0],a[2])trans(a[1],a[3],3);\n          a[0]=div_lim(a[0]),a[1]=div_lim(a[1]),a[2]=div_lim(a[2]),a[3]=div_lim(a[3]);\n          return fold(a);\n        }\n        for(int j=0;j<lim;j+=8){\n          trans2(a[j+0],a[j+1])trans2(a[j+2],a[j+3]);\n          trans2(a[j+4],a[j+5])trans2(a[j+6],a[j+7]);\n        }\n        for(int j=0;j<lim;j+=8){\n          trans2(a[j+0],a[j+2])trans(a[j+1],a[j+3],3);\n          trans2(a[j+4],a[j+6])trans(a[j+5],a[j+7],3);\n        }\n        for(int mid=4;mid<lim;mid<<=1)\n          for(int j=0;j<lim;j+=mid+mid)\n            for(int k=0;k<mid;k+=4){\n              trans(a[j+k+0],a[mid+j+k+0],mid+k+0);\n              trans(a[j+k+1],a[mid+j+k+1],mid+k+1);\n              trans(a[j+k+2],a[mid+j+k+2],mid+k+2);\n              trans(a[j+k+3],a[mid+j+k+3],mid+k+3);\n            }\n        for(int i=0;i<lim;++i)a[i]=div_lim(a[i]);\n        fold(a);\n      #undef trans\n      #undef trans2\n      }\n    }\n\n    using namespace FastNTT;\n    inline void dft(z *a){dft((u32*)a);}\n    inline void idft(z *a){idft((u32*)a);}\n    inline void dft(poly &a){a.resize(lim),dft((u32*)&a[0]);}\n    inline void idft(poly &a){a.resize(lim),idft((u32*)&a[0]);}\n\n    inline poly mul(poly a,poly b,int len=-1){\n      if(!~len)len=(int)a.size()+(int)b.size()-1;\n      dft_init((int)a.size()+(int)b.size()-1);\n      dft(a),dft(b);\n      for(int i=0;i<lim;i++)a[i]*=b[i];\n      idft(a);\n      return a.resize(len),a;\n    }\n\n    inline poly operator+(poly a,const poly &b){\n      if(b.size()>a.size())a.resize(b.size());\n      for(int i=0;i<b.size();i++)a[i]+=b[i];\n      return a;\n    }\n    inline poly operator-(poly a,const poly &b){\n      if(b.size()>a.size())a.resize(b.size());\n      for(int i=0;i<b.size();i++)a[i]-=b[i];\n      return a;\n    }\n    inline poly operator*(const poly &a,const poly &b){\n      return mul(a,b,(int)a.size()+(int)b.size()-1);\n    }\n\n    struct PolynomialInit{PolynomialInit(){dft_base_init(N);}}_polynomial_initer;\n  }\n  using full::z;\n  using full::poly;\n  using full::dft_init;\n  using full::dft;\n  using full::idft;\n  using full::mul;\n}\n\nusing namespace mem;\nusing namespace polynomial;\n\nint type,n;\nz a[N],b[N],c[N],d[N],e[N],f[N],g[N];\n\nvoid solve(int l,int r){\n  if(l+1==r){\n    if(l==1)g[l]=1;\n//\t\tfor(int j=1;j<=l-1;j++)g[l]-=(j+1)*g[j]*g[l-j];\n//\t\tfor(int j=2;j<=l-1;j++)g[l]-=j*g[j]*g[l-j+1];\n    return;\n  }\n  int m=(l+r)>>1,n=(r-l)>>1;\n  solve(l,m);\n  using polynomial::full::lim;\n  if(l==0){\n    dft_init((n<<1)-1);\n    for(int i=0;i<n;i++)b[i]=g[i]*i;\n    memset(b+n,0,(lim-n)<<2),dft(b);\n    for(int i=0;i<n;i++)c[i]=g[i];\n    memset(c+n,0,(lim-n)<<2),dft(c);\n    for(int i=0;i<lim;i++)a[i]=b[i]+c[i];\n    for(int i=0;i<lim;i++)a[i]*=c[i],b[i]*=c[i];\n    idft(a);\n    idft(b);\n    for(int i=0;i<n;i++)g[m+i]-=a[n+i];\n    for(int i=0;i<n-1;i++)g[m+i]-=b[n+i+1];\n  }else{\n    dft_init(n*3);\n    for(int i=0;i<n;i++)b[i]=g[i+l]*(i+l);\n    memset(b+n,0,(lim-n)<<2),dft(b);\n    for(int i=0;i<n;i++)c[i]=g[i+l];\n    memset(c+n,0,(lim-n)<<2),dft(c);\n    for(int i=0;i<lim;i++)a[i]=b[i]+c[i];\n    for(int i=0;i<=(n<<1);i++)e[i]=g[i]*i;\n    memset(e+(n<<1)+1,0,(lim-(n<<1)-1)<<2),dft(e);\n    for(int i=0;i<=(n<<1);i++)f[i]=g[i];\n    memset(f+(n<<1)+1,0,(lim-(n<<1)-1)<<2),dft(f);\n    for(int i=0;i<lim;i++)d[i]=e[i]+f[i];\n    for(int i=0;i<lim;i++)a[i]*=f[i],b[i]*=f[i];\n    idft(a);\n    idft(b);\n    for(int i=0;i<lim;i++)d[i]*=c[i],e[i]*=c[i];\n    idft(d);\n    idft(e);\n    for(int i=0;i<n;i++)g[m+i]-=a[n+i]+d[n+i];\n    for(int i=0;i<n;i++)g[m+i]-=b[n+i+1]+e[n+i+1];\n    if((n<<1)==l)g[(l<<1)-1]+=g[l]*g[l]*l;\n  }\n//\tlog(\"solve(%d,%d)=>%d\\n\",l,r,g[5].x);\n  solve(m,r);\n}\n\nint main(){\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n#endif\n  read(type,n);\n  int lim=1;\n  while(lim<=n)lim<<=1;\n  solve(0,lim);\n//\tfor(int i=1;i<=n;i++)println(g[i]);\n  for(int i=1;i<=n;i++)f[i]=(i&1?2:mod-2)-g[i];\n  f[2]=2;\n  for(int i=1;i<=n;i++)if(type||i==n)println(f[i]);\n}\n```\n","publishedTitle":"「集训队作业2020」春天，在积雪下结一成形，抽枝发芽"}},{"id":"fb4e799b-deeb-572a-94b1-81d190be41ad","fields":{"slug":"/oi/solution/loj3401/","plainText":"\n> 给一个长度为 $n$ 的序列 $a_i$，和 $q$ 组询问 $(l,r,x)$，表示求 $\\displaystyle\\prod_{i=l}^r\\left(1-\\frac{a_i}{x}\\right)$ 的值。实数输出，精度要求 $10^{-6}$。\n>\n> $n,q\\le6\\times10^5,\\ 1\\leq a_i < x\\leq 10^9$。\n\n<!-- more -->\n\n## 题解\n\n按照 EI 的话说，这是一个误差分析题。\n\n首先需要注意到这个式子可以泰勒展开：\n\n$$\n\\begin{aligned}\n &\\exp\\left(\\ln\\left(\\prod_{i=l}^r\\left(1-\\frac{a_i}{x}\\right)\\right)\\right) \\\\\n=&\\exp\\left(\\sum_{i=l}^r\\ln\\left(1-\\frac{a_i}{x}\\right)\\right) \\\\\n=&\\exp\\left(-\\sum_{i=l}^r\\sum_{k=1}^{L}\\frac{a_i^k}{k\\cdot x^k}\\right) \\\\\n\\end{aligned}\n$$\n\n然而，如果直接泰勒展开，需要的 $L$ 是数十万级别的，无益于我们解决问题。\n\n考虑到导致泰勒展开精度损失的主要原因，是因为当 $a_i/x$ 较大时，我们对 $\\ln(1-a_i/x)$ 的精度要求很高。然而，$a_i/x$ 较大时，很容易导致答案小于我们要求的精度范围。\n\n故我们不妨设定一个阈值 $R=0.5$，当 $a_i/x\\le R$ 时，考虑线段树维护泰勒展开；否则，当 $a_i/x>R$ 时，优先找出这些位置并暴力计算。当答案小于精度要求时就退出。暴力计算的次数显然不会超过 $\\log_2 10^6$ 次。\n\n这样就得到了一个 $O(n\\log^2L)$ 的做法，实践得 $L$ 取 $20$ 左右即可。\n\n可以通过本题，但时间较大。实际上，线段树的部分可以直接换为前缀和。为什么精度还在接受范围内呢？注意到 $x>a_i$ 对于任意 $x$ 和任意 $i$ 都成立。如果前缀和的部分因为 $a_i$ 太小被省略，他本身对泰勒展开的影响也是被省略的级别。换句话说，对于泰勒展开的值，前缀和能保证的精度范围，恰为 `double` 本身的精度范围。\n\n所以，直接将上述做法中的线段树替换为前缀和就能在 $O(n\\log nL)$ 的时间复杂度内解决本题。~~三个 log 年轻人不讲武德。~~\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 6e5 + 10, K = 20;\nconst double eps = 1e-10;\nint n, m, x, a[N], lg[N], st[20][N];\ndouble sum, ans;\nmt19937 rng(20040725);\ninline int better(int i, int j) { return a[i] < a[j] ? j : i; }\ninline int query(int l, int r) {\n  if (l == r) return l;\n  int k = lg[r - l];\n  return better(st[k][l], st[k][r - (1 << k)]);\n}\nstruct segment {\n  int l, r, mid;\n  double s[K];\n} p[N << 2];\nvoid build(int u, int l, int r) {\n  p[u].l = l, p[u].r = r, p[u].mid = (l + r) >> 1;\n  if (l == r) {\n    p[u].s[0] = a[l];\n    for (int i = 1; i < K; i++) p[u].s[i] = p[u].s[i - 1] * a[l];\n    return;\n  }\n  build(u << 1, l, p[u].mid);\n  build(u << 1 | 1, p[u].mid + 1, r);\n  for (int i = 0; i < K; i++) {\n    p[u].s[i] = p[u << 1].s[i] + p[u << 1 | 1].s[i];\n  }\n}\ndouble query(int u, int l, int r) {\n  if (p[u].l == l && p[u].r == r) {\n    double sum = 0;\n    for (int i = K - 1; i >= 0; i--) {\n      sum = (sum + p[u].s[i] / (i + 1)) / x;\n    }\n    return sum;\n  }\n  if (r <= p[u].mid) return query(u << 1, l, r);\n  if (l > p[u].mid) return query(u << 1 | 1, l, r);\n  return query(u << 1, l, p[u].mid) + query(u << 1 | 1, p[u].mid + 1, r);\n}\nvoid solve(int l, int r) {\n  if (l > r || ans < eps) {\n    return;\n  }\n  int pos = query(l, r);\n  if (a[pos] < (x >> 1)) {\n    ans *= exp(-query(1, l, r));\n    return;\n  }\n  ans *= 1 - a[pos] / (double)x;\n  if (rng() & 1) {\n    solve(l, pos - 1);\n    solve(pos + 1, r);\n  } else {\n    solve(pos + 1, r);\n    solve(l, pos - 1);\n  }\n}\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  lg[0] = -1;\n  for (int i = 1; i < N; i++) lg[i] = lg[i >> 1] + 1;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  for (int i = 1; i < n; i++) {\n    st[0][i] = better(i, i + 1);\n  }\n  for (int i = 1; i < 20; i++)\n    for (int j = 1; j + (1 << i) <= n; j++) {\n      st[i][j] = better(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n    }\n  build(1, 1, n);\n  cout << fixed << setprecision(12);\n  for (int l, r, i = 1; i <= m; i++) {\n    cin >> l >> r >> x;\n    ans = 1;\n    solve(l, r);\n    cout << 1 - ans << endl;\n  }\n}\n```\n","publishedTitle":"「集训队作业2020」Old Problem"}},{"id":"670ee843-1d97-533a-8680-86318efcd54e","fields":{"slug":"/oi/solution/loj6051/","plainText":"\n> 给定长度为 $n$ 的序列 $\\{a_i\\}$，满足 $a_0 \\geq a_1 \\geq \\cdots \\geq a_{n - 1} \\geq 0$，求出在 $n$ 维空间中从点 $(0, 0, \\ldots, 0)$ 随机游走到点 $(a_0, a_1, \\ldots, a_{n - 1})$，满足经过的所有点 $(x_0, x_1, \\ldots, x_{n - 1})$ 都有 $x_0 \\geq x_1 \\geq \\cdots \\geq x_{n - 1}$ 的概率，随机方式是每一步均匀随机一个 $i\\in [1,n]\\cup \\mathbb N_+$ 并令 $x_i:=x_i+1$。\n>\n> $1\\le n, a_i \\leq 5\\times 10^5$。答案对 $1004535809$ 取模。\n\n<!-- more -->\n\n## 题解\n\n利用钩子定理相关知识我们可以直接得到\n\n$$\nans = \\frac { \\displaystyle \\frac {m!} { \\prod\\limits_{(i, j) \\in \\lambda} h(i, j)}} { \\displaystyle \\frac {m!} {\\prod\\limits_{i=1}^n a_i} }\n$$\n\n其中 $m = \\sum\\limits_{i=1}^n a_i$，$\\lambda$ 是第 $i$ 行长度为 $a_i$ 的杨表，$h_\\lambda(i, j)$ 表示杨表 $\\lambda$ 中第 $i$ 行第 $j$ 个元素的钩子长度。\n\n根据\n\n$$\n\\prod\\limits_{(i, j) \\in \\lambda} h_\\lambda(i, j)\n= \\frac { \\prod\\limits_{i=1}^n (a_i + n - i)! } { \\prod\\limits_{1 \\leq i < j \\leq n} \\left((a_i - i) - (a_j - j)\\right)}\n$$\n\n那么\n\n$$\n\\begin{aligned}\nans\n&= \\frac { \\displaystyle \\frac {m! \\prod\\limits_{1 \\leq i < j \\leq n} \\left((a_i - i) - (a_j - j)\\right)} { \\prod\\limits_{i=1}^n (a_i + n - i)! }} { \\displaystyle \\frac {m!} {\\prod\\limits_{i=1}^n a_i} } \\\\\n&= \\frac { \\prod\\limits_{i=1}^n a_i} { \\prod\\limits_{i=1}^n (a_i + n - i)! } \\times \\prod\\limits_{1 \\leq i < j \\leq n} \\left((a_i - i) - (a_j - j)\\right)\n\\end{aligned}\n$$\n\n发现处理的瓶颈在于右半部分。\n\n注意到 $\\{a_i\\}_{i=1}^n$ 为仅为 $O(n)$ 级别。并且由于 $\\forall i < j ,\\; a_i \\geq a_j$ ，可得 $\\forall i < j, (a_i - i) > (a_j - j)$ 。考虑卷积优化。\n\n可以开两个多项式，一个幂次为 $(a_i - i)$ 一个幂次为 $-(a_i - i)$ ，卷积一波只取幂次为整数的即可。（如果由 $i \\geq j$ 的贡献而成，一定满足幂次 $\\leq 0$）。\n\n时间复杂度 $O(n \\log n)$ 。\n\n<!-- more -->\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 4e6 + 10, mod = 1004535809;\nint n, l, tmp_n, tmp_m, ans = 1;\nint a[N], f[N], g[N], h[N], w[N], rev[N], fac[N], ifac[N];\nvoid setup(int *a, int &l, int n) { ++a[n], l = std::max(l, n); }\ninline int dec(int a, int b) {\n  a -= b;\n  return a < 0 ? a + mod : a;\n}\ninline int inc(int a, int b) {\n  a += b;\n  return a >= mod ? a - mod : a;\n}\ninline int mul(int a, int b) { return (ll)a * b - (ll)a * b / mod * mod; }\ninline int inv(int x) { return x < 2 ? 1 : mul(mod - mod / x, inv(mod % x)); }\ninline int fpow(int a, int b) {\n  int s = 1;\n  for (; b; b >>= 1, a = mul(a, a))\n    if (b & 1) s = mul(s, a);\n  return s;\n}\nvoid init_fac(int n) {\n  fac[0] = fac[1] = ifac[0] = ifac[1] = 1;\n  for (int i = 2; i <= n; i++) fac[i] = mul(fac[i - 1], i);\n  for (int i = 2; i <= n; i++) ifac[i] = mul(mod - mod / i, ifac[mod % i]);\n  for (int i = 2; i <= n; i++) ifac[i] = mul(ifac[i - 1], ifac[i]);\n}\nvoid ntt(int *a, int l) {\n  for (int i = 0; i < l; i++)\n    if (i < rev[i]) std::swap(a[i], a[rev[i]]);\n  for (int len = 1; len < l; len <<= 1)\n    for (int i = 0; i < l; i += (len << 1))\n      for (int j = 0; j < len; j++) {\n        int x = a[i + j], y = mul(a[i + j + len], w[j + len]);\n        a[i + j] = inc(x, y), a[i + j + len] = dec(x, y);\n      }\n}\nvoid mul(int *a, int *b, int *c, int n, int m, int &l) {\n  l = 1;\n  int k = 0;\n  while (l < n + m - 1) l <<= 1, ++k;\n  for (int i = 0; i < l; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (k - 1));\n  for (int wn, len = 1; len < l; len <<= 1) {\n    wn = fpow(3, (mod - 1) / (len << 1)), w[len] = 1;\n    for (int i = 1; i < len; i++) w[i + len] = mul(w[i + len - 1], wn);\n  }\n  int inv_l = inv(l);\n  ntt(a, l), ntt(b, l);\n  for (int i = 0; i < l; i++) c[i] = mul(a[i], b[i]);\n  std::reverse(c + 1, c + l), ntt(c, l);\n  for (int i = 0; i < l; i++) c[i] = mul(c[i], inv_l);\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  init_fac(n + a[1]);\n  for (int i = 1; i <= n; i++) {\n    ans = mul(ans, mul(fac[a[i]], ifac[a[i] + n - i]));\n    setup(f, tmp_n, a[i] - i + n);\n    setup(g, tmp_m, -a[i] + i + a[1]);\n  }\n  mul(f, g, h, tmp_n + 1, tmp_m + 1, l);\n  for (int i = 1, d = n + a[1]; i + d < l; i++) {\n    ans = mul(ans, fpow(i, h[i + d]));\n  }\n  cout << ans << endl;\n}\n```\n","publishedTitle":"「雅礼集训2017」PATH"}},{"id":"2a213b19-7b25-5667-bf3f-9bd2c712b1fa","fields":{"slug":"/oi/solution/loj6380/","plainText":"\n> 定义区间树为线段树的拓展，即每次断开的位置可以不是线段的中心。\n>\n> 给定一个 $[1, n]$ 的区间树和 $q$ 次询问，每次询问包含一个正整数 $k$, 你需要求出有多少区间的时间复杂度恰好等于 $k$。\n>\n> $n, q\\le 10^5,\\ k\\le 10^9$。\n\n<!-- more -->\n\n## 题解\n\n在线回答询问无意义，考虑利用生成函数处理出所有询问的答案。\n\n询问 $[l;r]$ 选中的线段（$ql=l \\land qr=r$ 的线段，而非经过的线段），LCA 往两侧深度单调减（且中间平的一段的长度至多为 $2$）。\n\n求出往两侧单调的生成函数合并，类似：\n\n$$\nL_u(x) = x (1 + L_l(x) + x (L_r(x) - x)) = x L_l(x) + x^2 L_r(x) + x - x^3 \\\\\nR_u(x) = x (1 + R_r(x) + x (R_l(x) - x)) = x R_r(x) + x^2 R_l(x) + x - x^3 \\\\\n$$\n\n其中 $L,R$ 分别表示左/右端点和当前线段的左/右端点相同的线段（不包括完全相同的情况）的生成函数，$u$ 是当前节点，$l$ 是左儿子，$r$ 是右儿子。\n\n处理一些平凡情况，在断点计算贡献：\n\n$$\nS_u(x) = x^{dep_u} (R_l(x) L_r(x) - x^2 + 1)\n$$\n\n就能做到 $\\text{polylog} \\times \\sum \\small{\\text{线段长度}}$ 复杂度。\n\n进一步优化复杂度，考虑边分治：假设当前处理子树 $u$，边分的子树 $v$。递归处理出 $u \\leftrightarrow v$ 的路径上的 $S,L,R$。下面考虑 $L_v,R_v$ 对路径上点的 $S$ 和 $u$ 的 $L,R$ 的贡献。\n\n前者可以分别考虑 $L_v,R_v$ 的贡献，通过两次卷积得到。后者则是路径上的 $L,R$ 通过一定位移得到。\n\n至于处理可以分别在两侧继续边分。复杂度 $O(n \\log^2 n)$。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10, mod = 998244353;\nint _, n, m, cnt, siz[N], vis[N], mid[N], ch[N][2], fa[N], l[N], r[N], dep[N], rev[N << 2];\nstruct z {\n  int x;\n  z(int x = 0) : x(x) {}\n  friend inline z operator*(z a, z b) { return (long long)a.x * b.x % mod; }\n  friend inline z operator-(z a, z b) { return (a.x -= b.x) < 0 ? a.x + mod : a.x; }\n  friend inline z operator+(z a, z b) { return (a.x += b.x) >= mod ? a.x - mod : a.x; }\n} w[N << 2];\nvector<z> ans;\ninline z fpow(z a, int b) {\n  z s = 1;\n  for (; b; b >>= 1, a = a * a)\n    if (b & 1) s = s * a;\n  return s;\n}\nvoid dft(vector<z> &a, int lim) {\n  a.resize(lim);\n  for (int i = 0; i < lim; i++)\n    if (i < rev[i]) swap(a[i], a[rev[i]]);\n  for (int len = 1; len < lim; len <<= 1)\n    for (int i = 0; i < lim; i += (len << 1))\n      for (int j = 0; j < len; j++) {\n        z x = a[i + j], y = a[i + j + len] * w[j + len];\n        a[i + j] = x + y, a[i + j + len] = x - y;\n      }\n}\nvector<z> operator+(vector<z> a, const vector<z> &b) {\n  a.resize(max(a.size(), b.size()));\n  for (int i = 0; i < b.size(); i++) a[i] = a[i] + b[i];\n  return a;\n}\nvector<z> operator-(vector<z> a, const vector<z> &b) {\n  a.resize(max(a.size(), b.size()));\n  for (int i = 0; i < b.size(); i++) a[i] = a[i] - b[i];\n  return a;\n}\nvector<z> operator*(vector<z> a, vector<z> b) {\n  int len = a.size() + b.size() - 1, lim = 1, k = 0;\n  while (lim < len) lim <<= 1, ++k;\n  for (int i = 0; i < lim; i++) rev[i] = rev[i >> 1] >> 1 | ((i & 1) << (k - 1));\n  dft(a, lim), dft(b, lim);\n  for (int i = 0; i < lim; i++) a[i] = a[i] * b[i];\n  dft(a, lim), reverse(&a[1], &a[lim]);\n  z inv = fpow(lim, mod - 2);\n  for (int i = 0; i < lim; i++) a[i] = a[i] * inv;\n  return a.resize(len), a;\n}\nvoid shift(z x, vector<z> &dst, size_t dta) {\n  dst.resize(max(dst.size(), dta + 1));\n  dst[dta] = dst[dta] + x;\n}\nvoid shift(const vector<z> &src, vector<z> &dst, size_t dta) {\n  dst.resize(max(dst.size(), src.size() + dta));\n  for (int i = 0; i < src.size(); i++) dst[i + dta] = dst[i + dta] + src[i];\n}\nvoid dfsInit(int &u, int l, int r, int dep) {\n  if (l == r) {\n    u = n - 1 + l;\n  } else {\n    u = ++cnt;\n    dfsInit(ch[u][0], l, mid[u], dep + 1), fa[ch[u][0]] = u;\n    dfsInit(ch[u][1], mid[u] + 1, r, dep + 1), fa[ch[u][1]] = u;\n  }\n  ::l[u] = l, ::r[u] = r, ::dep[u] = dep;\n}\nint calcSize(int u) {\n  if (!u || vis[u]) return 0;\n  return siz[u] = 1 + calcSize(ch[u][0]) + calcSize(ch[u][1]);\n}\npair<int, int> findSubTree(int u, int lim) {\n  if (!u || vis[u]) return {-1, -1};\n  if (siz[u] < lim) return {u, siz[u]};\n  pair<int, int> x = ch[u][0] ? findSubTree(ch[u][0], lim) : make_pair(-1, -1);\n  pair<int, int> y = ch[u][1] ? findSubTree(ch[u][1], lim) : make_pair(-1, -1);\n  return x.second > y.second ? x : y;\n}\nvoid calc(bool fl, int u, int mov, vector<z> &f) {\n  if (vis[u] || l[u] == r[u]) return shift(1, f, mov + 1);\n  shift(1, f, mov + 1);\n  shift(mod - 1, f, mov + 3);\n  calc(fl, ch[u][0], mov + (fl ? 2 : 1), f);\n  calc(fl, ch[u][1], mov + (fl ? 1 : 2), f);\n}\npair<vector<z>, vector<z>> fuck(int u) {\n  if (vis[u] || l[u] == r[u]) return {{0, 1}, {0, 1}};\n  vector<z> Ll, Lr, Rl, Rr, Lu, Ru;\n  Lu = Ru = vector<z>{0, 1, 0, mod - 1};\n  tie(Ll, Rl) = fuck(ch[u][0]);\n  tie(Lr, Rr) = fuck(ch[u][1]);\n  shift(Ll, Lu, 1), shift(Lr, Lu, 2);\n  shift(Rr, Ru, 1), shift(Rl, Ru, 2);\n  shift(Rl * Lr, ans, dep[u]);\n  return {Lu, Ru};\n}\npair<vector<z>, vector<z>> solve(int u) {\n  if (vis[u] || l[u] == r[u]) return {{0, 1}, {0, 1}};\n  int siz = calcSize(u);\n  int v = findSubTree(u, (siz * 2) / 4).first;\n  if (v == -1) return fuck(u);\n  vector<z> Lu, Ru, Lv, Rv, Lt, Rt, T;\n  tie(Lv, Rv) = solve(v);\n  vis[v] = 1;\n  tie(Lu, Ru) = solve(u);\n  vis[v] = 0;\n  int lmov = 0, rmov = 0;\n  for (int p = v; p != u; lmov += ch[fa[p]][0] == p ? 1 : 2, rmov += ch[fa[p]][0] == p ? 2 : 1, p = fa[p]) {\n    int f = fa[p], q = ch[f][0] == p ? ch[f][1] : ch[f][0];\n    if (ch[f][0] == p) {\n      T.clear(), calc(0, q, 0, T), shift(T, Lt, rmov + dep[f] - dep[u]);\n    } else {\n      T.clear(), calc(1, q, 0, T), shift(T, Rt, lmov + dep[f] - dep[u]);\n    }\n  }\n  shift(mod - 1, Lv, 1);\n  shift(mod - 1, Rv, 1);\n  shift(Lv * Rt, ans, dep[u]);\n  shift(Rv * Lt, ans, dep[u]);\n  shift(Lv, Lu, lmov);\n  shift(Rv, Ru, rmov);\n  return {Lu, Ru};\n}\nvoid solution() {\n  for (int i = 1; i < n; i++) cin >> mid[i];\n  dfsInit(_, 1, n, 1);\n  solve(1);\n  for (int i = 1; i < (n << 1); i++) shift(1, ans, dep[i]);\n  for (int i = 1; i < n; i++) shift(mod - 1, ans, dep[i] + 2);\n  for (int i = 1, q; i <= m; i++) {\n    cin >> q;\n    cout << (q < ans.size() ? ans[q].x : 0) << '\\n';\n  }\n}\nvoid recycle() {\n  cnt = 0;\n  ans.clear();\n  memset(ch, 0, sizeof(ch));\n  memset(fa, 0, sizeof(fa));\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  for (int len = 1; len < (N << 1); len <<= 1) {\n    z wn = fpow(3, (mod - 1) / (len << 1));\n    w[len] = 1;\n    for (int i = 1; i < len; i++) w[i + len] = w[i + len - 1] * wn;\n  }\n  while (cin >> n >> m) solution(), recycle();\n}\n```\n","publishedTitle":"「是男人就过8题——Pony.ai」IntervalTree"}},{"id":"4b4c831d-3036-5f17-a72c-78ae013d3c73","fields":{"slug":"/oi/solution/luogu6579/","plainText":"\n> 给数组 $A$ 和 $n$ 个节点的树，每个点有一个 $1$ 到 $x$ 颜色。\n>\n> $m$ 次查询，每次查询树上只保留 $[l,r]$ 内的所有节点，设一个极大连通块中出现奇数次数的颜色个数为 $t$，则其对答案的贡献为 $A_t$ ，即答案是所有连通块贡献的和，询问相互独立。\n>\n> $1\\leq n,m\\leq 10^5$，$1\\leq x,A_i \\leq 10^4$。\n\n<!-- more -->\n\n## 题解\n\n~~退役选手被 lxl 抓过来写题解~~\n\n考虑用单增莫队维护，想了想容易发现复杂度不对。\n\n莫队的端点移动需要启发式合并维护信息，而启发式合并的复杂度基于我们可以把势能均摊，如果我们在分块时基于势能呢？\n\n单增莫队的复杂度主要产生于以下两个部分（假设把询问分为 $S$ 块）：\n\n- 左端点左移：对于每个端点都会贡献 $O(S)$，故这一部分的总势能是 $O(S n \\sqrt n)$ 的\n- 右端点右移：每个块内的询问会对每个块内的端点贡献 $O(1)$ 次，可以通过构造询问分布，卡满这部分的势能和。\n- 回滚后缀的右端点右移操作：回滚操作于增加操作复杂度相同。\n\n~~有没有救呢？当然是有的。~~注意左端点的移动势能是只和块数相关的。瓶颈在于右端点的移动：对于一个区间 $[l,r]$，端点 $i$ 在右端点移动时贡献的势能为 $A_i$，则一次经过该区间的询问产生的势能至多为 $\\sum_{i=l+1}^r A_i$。\n\n理清思路后题解就很显然了，我们先处理出每个端点的势能 $B_i$（在 $1 \\ldots (i-1)$ 后插入 $i$ 贡献的势能，上文提到的势能 $A_i$ 是一定有 $A_i \\leq B_i$ 的）。然后从右到左对势能分块。\n\n如果加入当前端点后当前栈内端点的势能和大于 $\\sqrt {n} \\log n$ 就将栈内元素分为一块。由于所有被分配到这个块的询问都是经过块的不会贡献势能的左端点，而其余端点贡献的势能和是一定小于 $\\sqrt n \\log n$ 的。\n\n总时间复杂度 $O((n+Q)\\sqrt n \\log n)$。\n\n## 卡常技巧\n\n本题卡常的一比，毒瘤 lxl（（\n\n1. 手动调整块大小\n2. 作栈/队列功能的 `std::vector<T>` 换成手写（不知道为什么我做到这这步就过了）\n3. 手写 bitset（我鸽了）\n4. 手写可合并的 vector（然而我手写了一个还打不过 `std::vector<T>`，我已经报警了）\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC target(\"popcnt\")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#define log(...) fprintf(stderr, __VA_ARGS__)\n#define debug log(\"\\33[2mPassing [%s] in LINE %d\\33[0m\\n\", __FUNCTION__, __LINE__);\nconst int S = 1 << 21;\nchar ibuf[S], *iS, *iT, obuf[S], *oS = obuf, *oT = oS + S - 1;\n#define flush() (fwrite(obuf, 1, oS - obuf, stdout), oS = obuf, void())\n#define getchar() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, S, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define putchar(x) (*oS++ = (x), oS == oT ? flush() : void())\nstruct Flusher_ {\n  ~Flusher_() { flush(); }\n} flusher_;\ntemplate <class T> inline void read(T &x) {\n  x = 0;\n  int c = getchar(), f = 0;\n  while (!isdigit(c)) f ^= c == '-', c = getchar();\n  while (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n  if (f) x = -x;\n}\ntemplate <class T> inline void print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate <class T> inline void print(T x, char c) { print(x), putchar(c); }\nconst int N = 1e5 + 9, M = 1e4 + 9, S1 = 256, S2 = 4;\nint n, m, x, blocks, a[N], c[N], bln[N], anc[N], pre[N], siz[N], ans[N];\nvector<int> G[N];\ntemplate <class T, int N> struct static_vector {\n  T a[N];\n  size_t top;\n  inline T &operator[](size_t k) { return a[k]; }\n  inline T operator[](size_t k) const { return a[k]; }\n  inline T &back() { return a[top - 1]; }\n  inline T back() const { return a[top - 1]; }\n  inline void clear() { top = 0; }\n  inline void pop_back() { top--; }\n  inline void push_back(const T &e) { a[top++] = e; }\n  inline size_t size() { return top; }\n};\nstruct query {\n  int l, r, id;\n};\nvector<query> q;\nnamespace tree {\nint ans, delta, anc[N];\nbool roll, mrk[N];\nbitset<M> mem[N / S2 + 5];\nstatic_vector<size_t, (N / S2 + 5)> rub;\nstatic_vector<tuple<int, int, int>, (N << 1)> history;\nstruct unicom_block {\n  int id, cnt, bitset, key[S2];\n  vector<int> vec;\n  inline unicom_block() { bitset = -1, memset(key, -1, sizeof(key)); }\n  inline void clear() {\n    if (~bitset) mem[bitset].reset(), rub.push_back(bitset), bitset = -1;\n    cnt = 0, vec.clear(), memset(key, -1, sizeof(key));\n  }\n  inline void pushup(int k) {\n    ans -= a[cnt];\n    if (~bitset) {\n      if (mem[bitset][k]) {\n        mem[bitset][k] = 0, --cnt;\n      } else {\n        mem[bitset][k] = 1, ++cnt;\n      }\n    } else {\n      for (int i = 0; i < S2; i++)\n        if (key[i] == k) {\n          key[i] = -1, --cnt;\n          goto out;\n        }\n      for (int i = 0; i < S2; i++)\n        if (key[i] == -1) {\n          key[i] = k, ++cnt;\n          goto out;\n        }\n      bitset = rub.back(), rub.pop_back();\n      mem[bitset][k] = 1, ++cnt;\n      for (int i = 0; i < S2; i++) mem[bitset][key[i]] = 1;\n    }\n  out:\n    ans += a[cnt];\n  }\n} uni[N];\ninline void merge(unicom_block &u, unicom_block &v) {\n  for (int i : u.vec) v.pushup(i);\n}\nint find(int x) { return x == anc[x] ? x : find(anc[x]); }\nvoid reset() {\n  ans = roll = 0;\n  for (int i = 1; i <= n; i++) {\n    anc[i] = i;\n    if (mrk[i]) uni[i].clear(), mrk[i] = 0;\n  }\n}\nvoid add(int x) {\n  ans += a[0];\n  if (roll) delta += a[0];\n  if (roll) history.push_back({0, x, 0});\n  mrk[x] = 1;\n  uni[x].vec.push_back(c[x]), uni[x].pushup(c[x]);\n  for (int i = 0; i < G[x].size(); i++)\n    if (mrk[G[x][i]]) {\n      int y = G[x][i], u = find(x), v = find(y);\n      if (uni[u].vec.size() > uni[v].vec.size()) swap(u, v);\n      if (roll) history.push_back({u, v, anc[u]});\n      merge(uni[u], uni[v]);\n      uni[v].vec.insert(uni[v].vec.end(), uni[u].vec.begin(), uni[u].vec.end()), anc[u] = v;\n      ans -= a[uni[u].cnt];\n      if (roll) delta -= a[uni[u].cnt];\n    }\n}\nint query() { return ans; }\nvoid rollback() {\n  ans -= delta, delta = 0;\n  for (int u, v, t, i = (int)history.size() - 1; i >= 0; i--) {\n    tie(u, v, t) = history[i];\n    if (u) {\n      anc[u] = t;\n      for (int i : uni[u].vec) uni[v].vec.pop_back();\n      merge(uni[u], uni[v]);\n    } else {\n      mrk[v] = 0, uni[v].pushup(c[v]), uni[v].clear();\n    }\n  }\n  history.clear();\n}\n} // namespace tree\nstruct block {\n  int id, l, r;\n  vector<query> q;\n  void init() {\n    for (int i = l; i <= r; i++) bln[i] = id;\n  }\n  void solve() {\n    sort(q.begin(), q.end(), [](const query &a, const query &b) { return a.l > b.l; });\n    tree::reset();\n    int cur = l, i;\n    for (const auto &it : q) {\n      while (it.l <= cur) tree::add(cur--);\n      for (tree::roll ^= 1, i = l + 1; i <= it.r; i++) tree::add(i);\n      ans[it.id] = tree::query();\n      tree::roll ^= 1, tree::rollback();\n    }\n  }\n} block[S1 << 1];\nvoid build() {\n  function<int(int)> find = [&](int x) { return anc[x] == x ? x : anc[x] = find(anc[x]); };\n  for (int i = 1; i <= n; i++) anc[i] = i, siz[i] = 1;\n  for (int u = 1; u <= n; u++) {\n    for (int v : G[u])\n      if (v < u) {\n        int fu = find(u), fv = find(v);\n        if (fu == fv) continue;\n        if (siz[fu] > siz[fv]) swap(fu, fv);\n        pre[u] += siz[fu], anc[fu] = fv, siz[fv] += siz[fu];\n      }\n    pre[u] += G[u].size();\n  }\n  int S = accumulate(pre + 1, pre + n + 1, 0) / S1 + 1;\n  fprintf(stderr, \"> block limit = %d\\n\", S);\n  vector<tuple<int, int, int>> seq = {{n + 1, n, 0}};\n  for (int i = n; i >= 1; i--) {\n    get<0>(seq.back())--, get<2>(seq.back()) += pre[i];\n    if (i == 1 || get<2>(seq.back()) + pre[i] > S) seq.push_back({i, i - 1, 0});\n  }\n  seq.pop_back(), reverse(seq.begin(), seq.end()), blocks = seq.size();\n  for (int _, i = 0; i < blocks; i++) {\n    tie(block[i].l, block[i].r, _) = seq[i];\n    block[i].id = i, block[i].init();\n  }\n}\nvoid solve() {\n  for (int i = 1; i <= n; i++) tree::uni[i].id = i;\n  for (const auto &it : q)\n    if (bln[it.l] == bln[it.r]) {\n      tree::reset();\n      for (int i = it.l; i <= it.r; i++) tree::add(i);\n      ans[it.id] = tree::query();\n    } else {\n      block[bln[it.r]].q.push_back(it);\n    }\n  for (int i = 0; i < blocks; i++) block[i].solve();\n}\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n  freopen(\"1.out\", \"w\", stdout);\n#endif\n  for (int i = 0; i < N / S2 + 5; i++) tree::rub.push_back(i);\n  read(n), read(m), read(x);\n  for (int i = 1; i <= n; i++) read(c[i]), --c[i];\n  for (int u, v, i = 1; i < n; i++) {\n    read(u), read(v);\n    G[u].push_back(v), G[v].push_back(u);\n  }\n  for (int i = 0; i <= x; i++) read(a[i]);\n  build();\n  for (int l, r, i = 1; i <= m; i++) {\n    read(l), read(r);\n    q.push_back({l, r, i});\n  }\n  solve();\n  for (int i = 1; i <= m; i++) print(ans[i], '\\n');\n}\n```\n\n## 手写 vector 且没通过的代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC target(\"popcnt,tune=native\")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"inline-functions-called-once\")\nconst int S = 1 << 21;\nchar ibuf[S], *iS, *iT, obuf[S], *oS = obuf, *oT = oS + S - 1;\n#define flush() (fwrite(obuf, 1, oS - obuf, stdout), oS = obuf, void())\n#define getchar() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, S, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define putchar(x) (*oS++ = (x), oS == oT ? flush() : void())\nstruct Flusher_ {\n  ~Flusher_() { flush(); }\n} flusher_;\ntemplate <class T> inline void read(T &x) {\n  x = 0;\n  int c = getchar(), f = 0;\n  while (!isdigit(c)) f ^= c == '-', c = getchar();\n  while (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n  if (f) x = -x;\n}\ntemplate <class T> inline void print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate <class T> inline void print(T x, char c) { print(x), putchar(c); }\nconst int N = 1e5 + 9, M = 1e4 + 9, S1 = 256, S2 = 4;\nint n, m, x, blocks, a[N], c[N], bln[N], anc[N], pre[N], siz[N], ans[N];\nvector<int> G[N];\nstruct query {\n  int l, r, id;\n};\nvector<query> q;\ntemplate <class T, int N> struct static_vector {\n  T a[N];\n  size_t top;\n  inline T &operator[](size_t k) { return a[k]; }\n  inline T operator[](size_t k) const { return a[k]; }\n  inline T &back() { return a[top - 1]; }\n  inline T back() const { return a[top - 1]; }\n  inline void clear() { top = 0; }\n  inline void pop_back() { top--; }\n  inline void push_back(const T &e) { a[top++] = e; }\n  inline size_t size() { return top; }\n};\nint mempool[N << 5], *mempointer = mempool;\nint *memselect(int n) {\n  int *res = mempointer;\n  mempointer += n;\n  return res;\n}\nstruct combinable_vector {\n  int lim;\n  int *l, *r;\n  inline size_t size() const { return r - l; }\n  inline void clear() { r = l; }\n  inline void assign() { l = r = memselect(lim = 8); }\n  inline void re_assign() {\n    int *tl = l, *tr = r;\n    lim <<= 3, l = memselect(lim), r = l + (tr - tl);\n    memcpy(l, tl, size() << 2);\n  }\n  inline void push_back(int x) {\n    if (size() == lim) re_assign();\n    *(r++) = x;\n  }\n  inline void pop_back() { r--; }\n  inline void concat(const combinable_vector &rhs) {\n    if (size() + rhs.size() > lim) re_assign();\n    memcpy(r, rhs.l, rhs.size() << 2), r += rhs.size();\n  }\n  inline void concat_reverse(const combinable_vector &rhs) { r -= rhs.size(); }\n};\nnamespace tree {\nint ans, delta, anc[N];\nbool roll, mrk[N];\nbitset<M> mem[N / S2 + 5];\nstatic_vector<size_t, (N / S2 + 5)> rub;\nstatic_vector<tuple<int, int, int>, (N << 1)> history;\nstruct unicom_block {\n  int id, cnt, bitset, key[S2];\n  combinable_vector vec;\n  inline unicom_block() { bitset = -1, memset(key, -1, sizeof(key)), vec.assign(); }\n  inline void clear() {\n    if (~bitset) mem[bitset].reset(), rub.push_back(bitset), bitset = -1;\n    cnt = 0, vec.clear(), memset(key, -1, sizeof(key));\n  }\n  inline void pushup(int k) {\n    ans -= a[cnt];\n    if (~bitset) {\n      if (mem[bitset][k]) {\n        mem[bitset][k] = 0, --cnt;\n      } else {\n        mem[bitset][k] = 1, ++cnt;\n      }\n    } else {\n      for (int i = 0; i < S2; i++)\n        if (key[i] == k) {\n          key[i] = -1, --cnt;\n          goto out;\n        }\n      for (int i = 0; i < S2; i++)\n        if (key[i] == -1) {\n          key[i] = k, ++cnt;\n          goto out;\n        }\n      bitset = rub.back(), rub.pop_back();\n      mem[bitset][k] = 1, ++cnt;\n      for (int i = 0; i < S2; i++) mem[bitset][key[i]] = 1;\n    }\n  out:\n    ans += a[cnt];\n  }\n} uni[N];\ninline void merge(unicom_block &u, unicom_block &v) {\n  for (int *it = u.vec.l; it != u.vec.r; it++) v.pushup(*it);\n}\nint find(int x) { return x == anc[x] ? x : find(anc[x]); }\nvoid reset() {\n  ans = roll = 0;\n  for (int i = 1; i <= n; i++) {\n    anc[i] = i;\n    if (mrk[i]) uni[i].clear(), mrk[i] = 0;\n  }\n  mempointer = mempool;\n  for (int i = 1; i <= n; i++) uni[i].vec.assign();\n}\nvoid add(int x) {\n  ans += a[0];\n  if (roll) delta += a[0];\n  if (roll) history.push_back({0, x, 0});\n  mrk[x] = 1, uni[x].pushup(c[x]);\n  uni[x].vec.push_back(c[x]);\n  for (int i = 0; i < G[x].size(); i++)\n    if (mrk[G[x][i]]) {\n      int y = G[x][i], u = find(x), v = find(y);\n      if (uni[u].vec.size() > uni[v].vec.size()) swap(u, v);\n      if (roll) history.push_back({u, v, anc[u]});\n      merge(uni[u], uni[v]);\n      anc[u] = v;\n      uni[v].vec.concat(uni[u].vec);\n      ans -= a[uni[u].cnt];\n      if (roll) delta -= a[uni[u].cnt];\n    }\n}\nint query() { return ans; }\nvoid rollback() {\n  ans -= delta, delta = 0;\n  for (int u, v, t, i = (int)history.size() - 1; i >= 0; i--) {\n    tie(u, v, t) = history[i];\n    if (u) {\n      anc[u] = t;\n      merge(uni[u], uni[v]);\n      uni[v].vec.concat_reverse(uni[u].vec);\n    } else {\n      mrk[v] = 0, uni[v].pushup(c[v]), uni[v].clear();\n    }\n  }\n  history.clear();\n}\n} // namespace tree\nstruct block {\n  int id, l, r;\n  vector<query> q;\n  void init() {\n    for (int i = l; i <= r; i++) bln[i] = id;\n  }\n  void solve() {\n    sort(q.begin(), q.end(), [](const query &a, const query &b) { return a.l > b.l; });\n    tree::reset();\n    int cur = l, i;\n    for (const auto &it : q) {\n      while (it.l <= cur) tree::add(cur--);\n      for (tree::roll ^= 1, i = l + 1; i <= it.r; i++) tree::add(i);\n      ans[it.id] = tree::query();\n      tree::roll ^= 1, tree::rollback();\n    }\n  }\n} block[S1 << 1];\nvoid build() {\n  function<int(int)> find = [&](int x) { return anc[x] == x ? x : anc[x] = find(anc[x]); };\n  for (int i = 1; i <= n; i++) anc[i] = i, siz[i] = 1;\n  for (int u = 1; u <= n; u++) {\n    for (int v : G[u])\n      if (v < u) {\n        int fu = find(u), fv = find(v);\n        if (fu == fv) continue;\n        if (siz[fu] > siz[fv]) swap(fu, fv);\n        pre[u] += siz[fu], anc[fu] = fv, siz[fv] += siz[fu];\n      }\n    pre[u] += G[u].size();\n  }\n  int S = accumulate(pre + 1, pre + n + 1, 0) / S1 + 1;\n  fprintf(stderr, \"> block limit = %d\\n\", S);\n  vector<tuple<int, int, int>> seq = {{n + 1, n, 0}};\n  for (int i = n; i >= 1; i--) {\n    get<0>(seq.back())--, get<2>(seq.back()) += pre[i];\n    if (i == 1 || get<2>(seq.back()) + pre[i] > S) seq.push_back({i, i - 1, 0});\n  }\n  seq.pop_back(), reverse(seq.begin(), seq.end()), blocks = seq.size();\n  for (int _, i = 0; i < blocks; i++) {\n    tie(block[i].l, block[i].r, _) = seq[i];\n    block[i].id = i, block[i].init();\n  }\n}\nvoid solve() {\n  for (int i = 1; i <= n; i++) tree::uni[i].id = i;\n  for (const auto &it : q)\n    if (bln[it.l] == bln[it.r]) {\n      tree::reset();\n      for (int i = it.l; i <= it.r; i++) tree::add(i);\n      ans[it.id] = tree::query();\n    } else {\n      block[bln[it.r]].q.push_back(it);\n    }\n  for (int i = 0; i < blocks; i++) block[i].solve();\n}\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n  freopen(\"1.out\", \"w\", stdout);\n#endif\n  for (int i = 0; i < N / S2 + 5; i++) tree::rub.push_back(i);\n  read(n), read(m), read(x);\n  for (int i = 1; i <= n; i++) read(c[i]), --c[i];\n  for (int u, v, i = 1; i < n; i++) {\n    read(u), read(v);\n    G[u].push_back(v), G[v].push_back(u);\n  }\n  for (int i = 0; i <= x; i++) read(a[i]);\n  build();\n  for (int l, r, i = 1; i <= m; i++) {\n    read(l), read(r);\n    q.push_back({l, r, i});\n  }\n  solve();\n  for (int i = 1; i <= m; i++) print(ans[i], '\\n');\n}\n```\n","publishedTitle":"「Ynoi2019」美好的每一天~ 不连续的存在"}},{"id":"4c1ed000-9f57-5e29-b271-86948ba613e7","fields":{"slug":"/oi/solution/luogu5655/","plainText":"\n> 给定一个长度为 $n$ 的数组 $\\{a_i\\}_{i=1}^n$，$Q$ 次询问，每次给定 $l$ 和 $r$ 查询\n>\n> $$\\operatorname*{lcm}_{i=l}^r a_i$$\n>\n> 答案对 $10^9+7$ 取模，多组数据。\n>\n> $T,n,Q \\leq 300,\\ a_i \\leq 10^{18}$。\n\n<!-- more -->\n\n## 题解\n\n把 $< 10^{4.5}$ 的质数分开来处理，这样剩余每个数至多剩余 $3$ 个不同的质因子。考虑我们不需把每个数分解质因数，只需要能够构造一个等价的质数集合即可。构造方法如下：\n\n对于所有 $1 \\leq i < j \\leq n$，将 $\\gcd(a_i, a_j), a_i / \\gcd(a_i, a_j), a_j / \\gcd(a_i, a_j)$ 加入到集合 $S$ 中。将其中存在 $S$ 中的数作为因数的数删掉，剩下的集合就是一个合法的质数集合。\n\n接下来的一个朴素做法是莫队，需要一些精妙的实现使得那个 $\\log$ 是加上去的而不是乘上去的。\n\n1. 会用到质数的快速幂，这个可以预处理\n2. 相当于对于每个质数维护一个出现次数集合，支持加减和查询最大的出现次数。首先维护一个桶来去重，然后开一个 long long，并每次查询最高的 $1$ 出现的位置。\n\n时间复杂度近似于 $O(n^3 \\log n)$，需要一些精细的实现。\n\n## 代码\n\n> 一度获得 TLE 的好成绩，后来在 zx2003 哥哥的帮助下卡了半天终于卡进去了。\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define pair std::pair<int,int>\nconst int N=310,M=32000,L=5000,mod=1e9+7;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\tinline char gch(){\n\t\tchar c=gc();for(;isspace(c);c=gc());\n\t\treturn c;\n\t}\n\tinline void gs(char*c){\n\t\tchar x=gc();for(;isspace(x);x=gc());\n\t\tfor(;!isspace(x);x=gc())*c++=x;*c=0;\n\t}\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nstruct ExactDiv {\n  ExactDiv() {}\n  ExactDiv(ull n){\n  \tfor(z=0;!(n&1);++z,n>>=1);\n  \tt=((ull)-1) / n;\n\ti=mul_inv(n);\n  }\n  ull mul_inv(ull n) {\n    ull x = n;\n    for (int i = 0; i < 6; ++i) x *= 2 - n * x;\n    return x;\n  }\n  inline bool divide(const ull&n) { return ((n>>z<<z)==n) && (n>>z)*this->i<=this->t; }\n  inline bool ck(const ll&n){\n  \treturn n>=0 && divide(n);\n  }\n  ull t, i,z;\n}ediv[M],el[L];\nint T,n,m,l,tl,pc,sqn,p[L],ans[N],vis[M],bln[N],pri[M];ll a[N],ls[L],pw[L][65],ipw[L][65];\nstd::vector<ll> fac;\nstd::vector<pair> v[N];\nconst int Z=1005;\nint gg[Z][Z];\nint C;\ntemplate<class T> inline T gcd(T x,T y){++C;return x<Z && y<Z?gg[x][y]:(y?gcd(y,x%y):x);}\nstruct query{\n\tint l,r,id;\n\tinline bool operator<(const query &other)const{\n\t\treturn bln[l]==bln[other.l]?(r<other.r)==(bln[l]&1):l<other.l;\n//\t\treturn bln[l]==bln[other.l]?r<other.r:l<other.l;\n\t}\n}q[N];\ninline int fpow(int a,int b){\n\tint s=1;\n\tfor(;b;b>>=1,a=(ll)a*a%mod)if(b&1)s=(ll)s*a%mod;\n\treturn s;\n}\nint buc[L][65],mx[L];\nint tot=1,zcnt;\ninline void add(const std::vector<pair> &vet){\n\tfor(auto it:vet){\n\t\tif(mx[it.first]){\n\t\t\tif(ls[it.first])tot=tot*ipw[it.first][mx[it.first]]%mod;\n\t\t\t\telse --zcnt;\n\t\t}\n\t\t++buc[it.first][it.second];\n\t\tmx[it.first]=std::max(mx[it.first],it.second);\n\t\tif(mx[it.first]){\n\t\t\tif(ls[it.first])tot=tot*pw[it.first][mx[it.first]]%mod;\n\t\t\t\telse ++zcnt;\n\t\t}\n\t}\n}\ninline void del(const std::vector<pair> &vet){\n\tfor(auto it:vet){\n\t\tif(mx[it.first]){\n\t\t\tif(ls[it.first])tot=tot*ipw[it.first][mx[it.first]]%mod;\n\t\t\t\telse --zcnt;\n\t\t}\n\t\t--buc[it.first][it.second];\n\t\tfor(mx[it.first]=p[it.first];mx[it.first] && !buc[it.first][mx[it.first]];--mx[it.first]);\n\t\tif(mx[it.first]){\n\t\t\tif(ls[it.first])tot=tot*pw[it.first][mx[it.first]]%mod;\n\t\t\t\telse ++zcnt;\n\t\t}\n\t}\n}\ninline ll fpow2(ll x,ll y,ll mo){\n\tll ans=1;\n\tfor(;y;y>>=1,x=(__int128)x*x%mo)if(y&1)ans=(__int128)x*x%mo;\n\treturn ans;\n}\ninline bool ck(ll x){\n\tfor(int i=1;pri[i]<=10;++i)if(fpow2(pri[i],x-1,x)!=1)return 0;\n\treturn 1;\n}\nstruct hmp{\nstatic const int mo=1999;\nint h[mo],nxt[mo],xb;ll v[mo];\ninline void insert(ll x){\n\tif(x==1)return;\n\tint z=x%mo,i=h[z];\n\tfor(;i && v[i]!=x;i=nxt[i]);\n\tif(!i)nxt[++xb]=h[z],h[z]=xb,v[xb]=x;\n}\n}ss;\nint main(){\n\tfor(int i=2;i<M;i++){\n\t\tif(!vis[i])pri[++pc]=i;\n\t\tfor(int j=1;j<=pc&&i*pri[j]<M;j++){\n\t\t\tvis[i*pri[j]]=1;\n\t\t\tif(i%pri[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=pc;++i)ediv[i]=pri[i];\n\tfor(int i=0;i<Z;++i)for(int j=0;j<Z;++j)gg[i][j]=!i || !j?i+j:(i>j?gg[i-j][j]:gg[i][j-i]);\n\tfor(io::gi(T);T--;){\n\t\tio::gi(n),io::gi(m),sqn=sqrt(n),l=0,fac.clear();\n\t\tfor(int i=1;i<=n;i++)io::gi(a[i]),bln[i]=i/sqn,v[i].clear();\n\t\tfor(int i=1;i<=m;i++)io::gi(q[i].l),io::gi(q[i].r),q[i].id=i,ans[i]=1;\n\t\tstatic int id[M];memset(id+1,0,pc<<2);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1,cnt;j<=pc;j++)if(ediv[j].divide(a[i])){\n\t\t\t\tcnt=0;while(a[i]%pri[j]==0)++cnt,a[i]/=pri[j];\n\t\t\t\tif(!id[j])ls[id[j]=++l]=pri[j],el[l]=ls[l],p[l]=0;\n\t\t\t\tv[i].push_back(std::make_pair(id[j],cnt)),p[id[j]]=std::max(p[id[j]],cnt);\n\t\t\t}\n\t\tss.xb=0;memset(ss.h,0,sizeof ss.h);\n\t\tint step=8;\n\t\tstatic ll aa[N];int nn=0;\n\t\tfor(int i=1;i<=n;++i)if(a[i]>1)aa[++nn]=a[i];\n\t\tfor(int i=1;i<=nn;++i)ss.insert(aa[i]);\n\t\tfor(int i=1;i<=nn;i++){\n\t\t\tfor(int j=i+1;j<=nn;j+=step){\n\t\t\t\tll pi=1;\n\t\t\t\tfor(int k=0;k<step && j+k<=nn;++k)pi=(__int128)pi*aa[j+k]%aa[i];\n\t\t\t\tif(gcd(pi,aa[i])!=1)for(int k=0;k<step && j+k<=nn;++k){\n\t\t\t\t\tll x=gcd(aa[i],aa[j+k]);\n\t\t\t\t\tss.insert(x);ss.insert(aa[i]/x);ss.insert(aa[j+k]/x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfac=std::vector<ll>(ss.v+1,ss.v+ss.xb+1);\n\t\tstd::sort(fac.begin(),fac.end()),fac.erase(std::unique(fac.begin(),fac.end()),fac.end());\n\t\ttl=l;\n\t\tif(!fac.empty())for(int i=fac[0]==1?1:0,fl;fl=0,i<fac.size();i++){\n\t\t\tfl=1;\n\t\t\tif(fl)ls[++l]=fac[i],p[l]=0,el[l]=ls[l];\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=tl+1,cnt;j<=l;j++)if(el[j].divide(a[i])){\n\t\t\t\tcnt=0;while(a[i]%ls[j]==0)++cnt,a[i]/=ls[j];\n\t\t\t\tv[i].push_back(std::make_pair(j,cnt)),p[j]=std::max(p[j],cnt);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=l;i++)for(int j=0;j<=p[i];j++)ipw[i][j]=fpow(pw[i][j]=fpow(ls[i]%mod,j),mod-2);\n\t\tstd::stable_sort(q+1,q+m+1);\n\t\tint ul=1,ur=0;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\twhile(ul>q[i].l)add(v[--ul]);while(ur<q[i].r)add(v[++ur]);\n\t\t\twhile(ul<q[i].l)del(v[ul++]);while(ur>q[i].r)del(v[ur--]);\n\t\t\tans[q[i].id]=tot;\n\t\t}\n\t\twhile(ul<=ur)del(v[ur--]);\n\t\tfor(int i=1;i<=m;i++)io::print(ans[i]),io::putc('\\n');\n\t}\n\treturn 0;\n}\n```\n","publishedTitle":"「洛谷5655」基础数论函数练习题"}},{"id":"f84245e3-ec0a-5560-a365-8d62ecf29ff1","fields":{"slug":"/oi/solution/qoj1337/","plainText":"\n> 定义一个排列 $P$ 上的操作 $(t,S)$ 为：\n>\n> 1. 有两个空序列 $A$ 和 $B$；\n> 2. 枚举 $S_i=1$ 的每个 $i$：如果 $P_i$ 是偶数，则将其放到 $A$ 的末尾；否则放到 $B$ 的末尾；\n> 3. 如果 $t=0$ 则令 $C=\\overline{AB}$，否则令 $C=\\overline{BA}$；\n> 4. 枚举 $S_i=1$ 的每个 $i$：将 $P_i$ 替换为 $C$ 的开头元素，删去 $C$ 的开头元素。\n>\n> 现给定排列 $P$，要求使用至多 $30$ 次如上操作，使 $P$ 从小到大排序，注意你不需要最小化操作次数。\n>\n> $1\\le n\\le 15000$。\n\n<!-- more -->\n\n## 题意补充\n\n对于 $P=\\{0,4,2,3,6,5,1\\}$ 上的操作 $(1,\\texttt{1101101})$，有示意图如下\n\n![|24em](https://static.memset0.cn/img/v6/2024/02/11/bULc9hpa.png)\n\n## 题解\n\n由于 $30=2\\left(\\left\\lfloor\\log n\\right\\rfloor\\right)+1$，我们考虑 $t=0$ 和 $t=1$ 的操作交错执行。\n\n首先可以确定最后一次操作前，每个数的位置，如 $n=13$ 的时候，最后一次操作前的 $p$ 应为：\n\n```plain\n0 8 2 10 4 12 6 7 1 9 3 11 5\n```\n\n故对于每个数，我们求出此时期望的位置 $rk$，也就是说，现在我们要把每个 $p_i$，移动到 $rk_{p_i}$ 的位置上。\n\n考虑从低位到高位，每次把这一位是 $1$ 的数不改变相对顺序地丢到最后面，$\\log$ 次后即可完成排序。\n\n先进行一次 $(0,111\\ldots 1)$ 操作后，所有偶数都在奇数前面，我们可以认为是两个序列；把偶数中需要放后面的数和奇数中需要放前面的数执行 $t=1$ 操作即可。但 $n$ 时可能两侧的数字个数不同，这时候给偶数序列中多丢一个 $0$ 就好了。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1.5e5 + 9;\nint n, m, t, p[N], rk[N];\nstring s;\nvector<int> a, b, c;\nvector<pair<bool, string>> ans;\nvoid apply(bool t, const string &s) {\n  a.clear(), b.clear();\n  for (int i = 0; i < n; i++)\n    if (s[i] == '1') (p[i] & 1 ? b : a).push_back(p[i]);\n  if (t) swap(a, b);\n  c = a, c.insert(c.end(), b.begin(), b.end());\n  reverse(c.begin(), c.end());\n  for (int i = 0; i < n; i++)\n    if (s[i] == '1') p[i] = c.back(), c.pop_back();\n  ans.push_back(make_pair(t, s));\n}\nvoid solve() {\n  int s00 = ((n + 1) / 2 + 1) / 2, s01 = (n + 1) / 4, s10 = s01, s11 = n / 2 - s10;\n  assert(s00 + s01 + s10 + s11 == n);\n  for (int i = 0; i < s00; i++) rk[i << 1] = i << 1;\n  for (int i = 0; i < s10; i++) rk[(i + s00) << 1] = i << 1 | 1;\n  for (int i = 0; i < s01; i++) rk[i << 1 | 1] = (i + s00) << 1;\n  for (int i = 0; i < s11; i++) rk[(i + s10) << 1 | 1] = (i + s10) << 1 | 1;\n  for (int i = 1; i < n; i += 2) rk[i] = n - 1 - rk[i] + (n & 1);\n  for (int k = 0; k < 14; k++) {\n    apply(0, string(n, '1'));\n    s = string(n, '0');\n    int t = 0;\n    for (int i = 0; i < n; i++)\n      if (p[i] % 2 == 0 && (rk[p[i]] >> k) % 2 == 1) s[i] = '1';\n    for (int i = 0; i < n; i++)\n      if (p[i] % 2 == 1 && (rk[p[i]] >> k) % 2 == 1) s[i] = '1';\n    apply(1, s);\n  }\n  apply(0, string(n, '1'));\n  s = string(n, '0');\n  for (int i = 0; i < n; i++)\n    if (p[i] != i) s[i] = '1';\n  apply(1, s);\n  for (int i = 0; i < n; i++) assert(p[i] == i);\n}\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> p[i];\n  solve();\n  cout << ans.size() << endl;\n  for (const auto &it : ans) cout << (it.first ? 1 : 0) << \" \" << it.second << endl;\n}\n```\n","publishedTitle":"「Petrozavodsk Summer 2020」Parity Sort"}},{"id":"22e8f7d7-cbe6-5f39-ac9e-813c3f91d270","fields":{"slug":"/oi/solution/uoj120/","plainText":"\n> 给定 $n$ 和 $\\{c_{i}\\}_{i=0}^n$，表示 $n+1$ 条限制形如对于 $f(x)$ 满足 $1 \\leq f(i) \\leq c_i$ 对于所有 $0\\le i\\le n$。\n>\n> 其中 $f(x) = \\sum_{i=0}^{n} a_i x^i$，这里 $\\{a_i\\}_{i=0}^n$ 都是整数，即 $f(x)$ 是一个不超过 $n$ 次的整系数多项式。\n>\n> 问满足限制的 $f(x)$ 有多少个，答案对 $998244353$ 取模。\n>\n> $0\\le n\\le 6$，$1\\le c_i\\le 10^9$。\n\n<!-- more -->\n\n## 题解\n\n考虑把 $1 \\leq f(i) \\leq c_i$ 的限制转换为 $0 \\leq f(i) < c_i$，且将 $f(x)$ 转化为下降幂多项式。注意到这些转化不会影响到答案。\n\n我们令 $a_i = x_i (n-i)! + y_i$，考虑枚举 $y_i$ 后怎么计算答案。\n\n我们提出其中一项式子：\n\n$$\n0 \\leq a_0 + k a_1 + k^{\\underline 2}a_2 + k^{\\underline 3} a_3 + \\cdots + k! a_k < c_k\n$$\n\n把前半部分设为 $d_k$，则有：\n\n$$\n0 \\leq d_k + k!a_k < c_k\n$$\n\n代入 $a_k = x_k (n-k)! + y_k$ 得：\n\n$$\n0 \\leq d_k + k!(x_k (n-k)! + y_k) < c_k\n$$\n\n其中 $y_k$ 是我们已经枚举的整数，故只需要考虑对 $x_k$ 计数即可。\n\n$$\n-d_k - k! y_k \\leq k!(n-k)! x_k < c_k - d_k - k! y_k\n$$\n\n答案显然是在 $\\frac {c_k} {k!(n-k)!}$ 的级别，但是会有 $\\pm 1$ 的偏差，取决于不等式两边在模意义下的大小，具体地（令 $C=d_k+ k!y_k ,\\ M = k!(n-k)!$）：\n\n$$\n\\operatorname{count}(x_k)= \\begin{cases}\n\t\\lfloor \\frac {c_k} {M} \\rfloor & (C \\bmod M \\leq c_k + C \\bmod M) \\\\\n\t\\lfloor \\frac {c_k} {M} \\rfloor +1 & (C \\bmod M > c_k + C \\bmod M) \\\\\n\\end{cases}\n$$\n\n我们现在考察 $C\\bmod M$ 的关系，$k!y_k$ 的贡献是已知常数，考虑：\n\n$$\nd_k\n= \\sum_{i=0}^{k-1} a_i k^{\\underline i}\n= \\sum_{i=0}^{k-1} (x_i(n-i)! + y_i) k^{\\underline i}\n$$\n\n注意到 $(n-i)!k^{\\underline i}$ 是 $M$ 的倍数，故 $C \\bmod M$ 只和 $y_{0 \\ldots k}$ 有关。\n\n可以通过枚举 $y_{0 \\ldots n}$ 后计算，时间复杂度 $O(n \\times n! \\times (n-1)! \\times \\cdots \\times 1!)$。\n\n虽然理论上来说是不能过的但是可以通过巨大多常数优化草过去，实际表现还是跑的挺快的。（竟然比以小常数著名的 zx2003 学长快！）\n\n## 代码\n\n```cpp\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,fma,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 10, F = 10000, mod = 998244353;\nconst int fac[N] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\nconst int ifac[N] = {1, 1, 499122177, 166374059, 291154603, 856826403, 641926577, 376916469, 421456191, 712324701};\nconst int down[N][N] = {{1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 1, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 2, 2, 0, 0, 0, 0, 0, 0, 0}, {1, 3, 6, 6, 0, 0, 0, 0, 0, 0}, {1, 4, 12, 24, 24, 0, 0, 0, 0, 0}, {1, 5, 20, 60, 120, 120, 0, 0, 0, 0}, {1, 6, 30, 120, 360, 720, 720, 0, 0, 0}, {1, 7, 42, 210, 840, 2520, 5040, 5040, 0, 0}, {1, 8, 56, 336, 1680, 6720, 20160, 40320, 40320, 0}, {1, 9, 72, 504, 3024, 15120, 60480, 181440, 362880, 362880}};\nint n, q, c[N], d[N], y[N], fit[N][F];\nstruct z {\n  int x;\n  z(int x = 0) : x(x) {}\n  inline void operator*=(z r) { x = (long long)x * r.x % mod; }\n  inline void operator+=(z r) { (x += r.x) >= mod && (x -= mod); }\n  friend inline z operator*(z a, z b) { return (long long)a.x * b.x % mod; }\n  friend inline z operator-(z a, z b) { return (a.x -= b.x) < 0 ? a.x + mod : a.x; }\n  friend inline z operator+(z a, z b) { return (a.x += b.x) >= mod ? a.x - mod : a.x; }\n} ans, cur[1 << 7];\nvoid dfs(int u) {\n  if (u > n) {\n    int x = 0;\n    for (int i = 0; i <= n; i++) {\n      x |= fit[i][d[i]] << i;\n    }\n    ans += cur[x];\n    return;\n  }\n  for (int i = 0; i < fac[n - u]; i++) {\n    y[u] = i;\n    for (int i = u; i <= n; i++) d[i] += y[u] * down[i][u];\n    dfs(u + 1);\n    for (int i = u; i <= n; i++) d[i] -= y[u] * down[i][u];\n  }\n}\nvoid mainVI() {\n  long long ans = 0;\n  y[5] = y[6] = 0;\n  for (y[0] = 0; y[0] < fac[6]; y[0]++) {\n    for (int i = 0; i <= 6; i++) d[i] += y[0];\n    for (y[1] = 0; y[1] < fac[5]; y[1]++) {\n      for (int i = 1; i <= 6; i++) d[i] += y[1] * down[i][1];\n      for (y[2] = 0; y[2] < fac[4]; y[2]++) {\n        for (int i = 2; i <= 6; i++) d[i] += y[2] * down[i][2];\n        for (y[3] = 0; y[3] < fac[3]; y[3]++) {\n          for (int i = 3; i <= 6; i++) d[i] += y[3] * down[i][3];\n          for (y[4] = 0; y[4] < fac[2]; y[4]++) {\n            for (int i = 4; i <= 6; i++) d[i] += y[4] * down[i][4];\n            int x = 0;\n            for (int i = 0; i <= 6; i++) x |= fit[i][d[i]] << i;\n            ans += cur[x].x;\n            for (int i = 4; i <= 6; i++) d[i] -= y[4] * down[i][4];\n          }\n          for (int i = 3; i <= 6; i++) d[i] -= y[3] * down[i][3];\n        }\n        for (int i = 2; i <= 6; i++) d[i] -= y[2] * down[i][2];\n      }\n      for (int i = 1; i <= 6; i++) d[i] -= y[1] * down[i][1];\n    }\n    for (int i = 0; i <= 6; i++) d[i] -= y[0];\n  }\n  ::ans.x = ans % mod;\n}\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  for (cin >> q; q--; ans = 0) {\n    cin >> n;\n    for (int i = 0; i <= n; i++) cin >> c[i];\n    for (int i = 0; i <= n; i++)\n      for (int d = 0; d < F; d++) {\n        fit[i][d] = (c[i] + d) % (fac[i] * fac[n - i]) < d % (fac[i] * fac[n - i]);\n      }\n    for (int x = 0; x < (1 << (n + 1)); x++) {\n      cur[x] = 1;\n      for (int i = 0; i <= n; i++)\n        if ((x >> i) & 1) {\n          cur[x] *= c[i] / (fac[i] * fac[n - i]) + 1;\n        } else {\n          cur[x] *= c[i] / (fac[i] * fac[n - i]);\n        }\n    }\n    (n == 6) ? mainVI() : dfs(0);\n    cout << ans.x << endl;\n  }\n}\n```\n","publishedTitle":"「UR #8」宿命多项式"}},{"id":"2bfcaaa7-ab16-54d7-bf9f-748aa9a0c621","fields":{"slug":"/oi/solution/uoj172/","plainText":"\n> 给定一个字符串 $s$，假设其 border 集合为 $S$，则每次你可以在 $s$ 后面接上一个长度为 $|s| - x$ 的字符串，其中 $x \\in S$。问在总长度 $\\leq w$ 的情况下有多少种可能的本质不同的长度。\n>\n> $n \\leq 5 \\times 10^5,\\ w \\leq 10^{18}$。\n\n<!-- more -->\n\n## 题解\n\n> Update：这个做法已经被 lyx 老师 [Hack](https://uoj.ac/hack/9813)。\n\nborder 的贡献是若干端等差数列，不妨设其中一段为 $kx + b$，其中 $x \\in [0,l]$，考虑其产生的贡献整理后可以理解为三种：\n\n- 长度为 $b$ 的贡献，可以选择 $\\inf$ 次；\n- 长度为 $lk + b$ 的贡献，可以选择 $\\inf$ 次；\n- 长度为 $(0...l)k + b$ 的贡献，可以选择 $1$ 次。\n\n考虑前两种贡献，就是朴素的同余最短路问题。考虑先计算出他们的 dis 数组，再转移上第三类贡献。\n\n对于每一种等差数列分开处理，分模 $k$ 的余数讨论，容易发现可以直接用单调队列维护下转移。\n\n同余最短路跑 spfa 是线性的，可以直接用（。\n\n时间复杂度 $O(n \\log w)$。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e5 + 10;\nint T, n, fl, mod;\nchar s[N];\nlong long w, ans, t[N], dis[2][N];\nvector<int> key;\nstruct atom {\n  int b, k, l;\n};\nvector<atom> res;\nint nod;\nstruct node {\n  int pre, nxt, i;\n  long long x;\n} e[N << 1];\ninline void init() { nod = 0; }\nstruct myset {\n  int lim, hed, til;\n  inline void reset(int l) { hed = til = 0, lim = l; }\n  inline void pop_front() {\n    if (hed == til) hed = til = 0;\n    else {\n      e[e[til].pre].nxt = 0;\n      til = e[til].pre;\n    }\n  }\n  inline void pop_back() {\n    if (hed == til) hed = til = 0;\n    else {\n      e[e[hed].nxt].pre = 0;\n      hed = e[hed].nxt;\n    }\n  }\n  inline void push_back(int i, long long x) {\n    e[++nod].i = i, e[nod].x = x;\n    if (!hed) {\n      hed = til = nod;\n      e[nod].pre = e[nod].nxt = 0;\n    } else {\n      e[nod].nxt = hed, e[hed].pre = nod;\n      hed = nod;\n    }\n  }\n  inline void insert(int i, long long x) {\n    while (hed && e[hed].x > x) pop_back();\n    push_back(i, x);\n    while (e[til].i < i - lim) pop_front();\n  }\n  inline long long query() { return e[til].x; }\n};\nmyset st[N];\nnamespace h {\nconst int b = 131131, p1 = 998244353, p2 = 1e9 + 7;\nint f[N], g[N], pf[N], pg[N];\nvector<int> vet;\ninline int query(int l, int r, int *a, int *pa, int p) {\n  int res = (a[r] - (long long)a[l - 1] * pa[r - l + 1]) % p;\n  return res < 0 ? res + p : res;\n}\nvoid solve(int n) {\n  pf[0] = pg[0] = 1, vet.clear(), res.clear();\n  for (int i = 1; i <= n; i++) {\n    pf[i] = (long long)pf[i - 1] * b % p1;\n    pg[i] = (long long)pg[i - 1] * b % p2;\n    f[i] = ((long long)f[i - 1] * b + s[i] - 'a') % p1;\n    g[i] = ((long long)g[i - 1] * b + s[i] - 'a') % p2;\n  }\n  for (int i = n - 1; i >= 1; i--)\n    if (query(1, i, f, pf, p1) == query(n - i + 1, n, f, pf, p1) && query(1, i, g, pg, p2) == query(n - i + 1, n, g, pg, p2)) vet.push_back(n - i);\n  vet.push_back(n);\n  int first = vet[0], delta = 0, cnt = 0;\n  for (int i = 1; i < vet.size(); i++)\n    if (!delta) {\n      delta = vet[i] - vet[i - 1], cnt = 1;\n    } else {\n      if (vet[i] - vet[i - 1] == delta) ++cnt;\n      else {\n        res.push_back((atom){first, delta, cnt});\n        first = vet[i], delta = 0, cnt = 0;\n      }\n    }\n  res.push_back((atom){first, delta, cnt});\n}\n} // namespace h\nvoid spfa(vector<int> &key, long long *dis) {\n  static int l, r, q[N << 3];\n  static bool inq[N];\n  mod = *max_element(key.begin(), key.end());\n  memset(dis, 63, mod << 3);\n  q[l = r = 1] = dis[0] = 0;\n  while (l <= r) {\n    int u = q[l++];\n    inq[u] = 0;\n    for (int w : key) {\n      int c = (u + w) / mod;\n      int v = u + w - c * mod;\n      if (dis[u] + c < dis[v]) {\n        dis[v] = dis[u] + c;\n        if (!inq[v]) inq[v] = 1, q[++r] = v;\n      }\n    }\n  }\n}\nvoid trans(long long *f, long long *g, const atom &it) {\n  if (!it.l) {\n    for (int i = 0; i < mod; i++) {\n      g[i] = min(f[i], f[(i - it.b + mod) % mod]);\n    }\n    return;\n  }\n  memset(t, 63, mod << 3), init();\n  for (int i = 0; i < it.k; i++) st[i].reset(it.l);\n  for (int i = -mod; i < mod; i++) {\n    auto &st = ::st[(i + mod) % it.k];\n    st.insert((i + mod) / it.k, i < 0 ? f[i + mod] + 1 : f[i]);\n    if (i >= 0) t[i] = st.query();\n  }\n  for (int i = 0; i < mod; i++) {\n    g[i] = min(f[i], i < it.b ? t[i - it.b + mod] + 1 : t[i - it.b]);\n  }\n}\nint main() {\n  for (cin >> T; T--; ans = 0, key.clear()) {\n    scanf(\"%d%lld%s\", &n, &w, s + 1);\n    if (w < n) {\n      puts(\"0\");\n      continue;\n    }\n    h::solve(n);\n    for (auto x : res) {\n      key.push_back(x.b);\n      if (x.l) key.push_back(x.b + x.k * x.l);\n    }\n    spfa(key, dis[fl]);\n    for (auto x : res) {\n      trans(dis[fl], dis[fl ^ 1], x);\n      fl ^= 1;\n    }\n    for (int i = 0; i < mod; i++)\n      if (dis[fl][i] != 4557430888798830399) {\n        ans += max(0ll, (w - n - i) / mod + 1 - dis[fl][i]);\n      }\n    printf(\"%lld\\n\", ans);\n  }\n}\n```\n","publishedTitle":"「WC2016」论战捆竹竿"}},{"id":"ec58d998-a2d4-5cca-9b91-297a564d6062","fields":{"slug":"/oi/solution/uoj226/","plainText":"\n> 给定一张 $n$ 个点的树或基环树，树上的每条边 $(u_i, v_i, w_i)$ 代表 $(u_i, v_i)$ 间有 $w_i$ 道路相连。\n>\n> 你需要统计有多少种从任意点出发的本质不同路径，使得经过所有道路恰好一次。\n>\n> 路径可以认为是一个从某个点出发，由经过道路编号和方向组成的序列。两条路线被认为是相同的当且仅当两序列相同，或更换起始边后两序列相同。\n>\n> $n, w_i \\leq 1000$。\n\n<!-- more -->\n\n## 题解\n\nBEST 定理的简单应用。\n\n我们可以把这个问题转化为两部分：\n\n1. 为无向边定向\n2. 套用 BEST 定理计算（生成树形图计数）\n\n前一部分我们可以从树的情况推广。如果 $m=n-1$，那么显然两点之间的无向边，转化成有向边刚好一半一半。对于基环树的情况，我们枚举走整个环的次数，那么也可以计算出有向边。\n\n后一部分，我们考虑基环树可以枚举一条断边，然后就是把所有指向根的重边条数一次乘起来（选任意一条作为外向树的一部分）。实现中需要处理前缀和保证复杂度。\n\n## 坑\n\n1. 对于我的实现，需要保证环一路过去的端点依次按照经过顺序排序。也就是存无向边的数组可能需要把 $(u,v,w)$ swap 成 $(v,u,w)$。不过我倒是写的时候就注意到了。\n2. 这题预处理阶乘的范围有坑啊有坑（x\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e3 + 9, mod = 998244353, L = 1e4 + 9;\nint n, m, ans, tot, top, cir[N], w0[N], w1[N], deg[N], u[N], v[N], w[N], pre[N], suf[N], stk[N], hed[N], to[N << 1], val[N << 1], nxt[N << 1], fac[N * L], ifac[L];\nbool vis[N], onc[N], inc[N];\nvoid initgraph() {\n  tot = 0;\n  memset(hed, -1, sizeof(hed));\n}\nvoid initfac() {\n  fac[0] = ifac[0] = ifac[1] = 1;\n  for (int i = 1; i < N * L; i++) fac[i] = (long long)fac[i - 1] * i % mod;\n  for (int i = 2; i < L; i++) ifac[i] = (long long)(mod - mod / i) * ifac[mod % i] % mod;\n  for (int i = 1; i < L; i++) ifac[i] = (long long)ifac[i - 1] * ifac[i] % mod;\n}\ninline int C(int n, int m) { return n < m ? 0 : (long long)fac[n] * ifac[m] % mod * ifac[n - m] % mod; }\ninline void link(int u, int v, int w) { nxt[tot] = hed[u], to[tot] = v, val[tot] = w, hed[u] = tot++; }\ninline int calc_fac(int x) {\n  int res = 1;\n  for (int i = 1; i <= x; i++) res = (long long)res * i % mod;\n  return res;\n}\nvoid solve_tree() {\n  int ans = 1;\n  for (int u, v, w, i = 1; i <= m; i++) {\n    cin >> u >> v >> w;\n    if (w & 1) {\n      cout << 0 << endl;\n      return;\n    }\n    deg[u] += w >> 1, deg[v] += w >> 1;\n    ans = (long long)ans * C(w, w >> 1) % mod * (w >> 1) % mod;\n  }\n  for (int i = 1; i <= n; i++) ans = (long long)ans * fac[deg[i] - 1] % mod;\n  cout << ans << endl;\n}\nvoid dfs(int u, int fa) {\n  stk[++top] = u, vis[u] = 1;\n  for (int i = hed[u]; ~i; i = nxt[i])\n    if (to[i] != fa) {\n      if (vis[to[i]]) {\n        if (*cir) continue;\n        cir[++*cir] = val[i];\n        for (int x = u; x != to[i]; x = to[pre[x] ^ 1]) {\n          cir[++*cir] = val[pre[x]];\n        }\n      } else {\n        pre[to[i]] = i;\n        dfs(to[i], u);\n      }\n    }\n  --top;\n}\nvoid ordered_circle() {\n  int same = -1;\n  if (u[cir[1]] == u[cir[2]]) same = u[cir[1]];\n  if (u[cir[1]] == v[cir[2]]) same = u[cir[1]];\n  if (v[cir[1]] == u[cir[2]]) same = v[cir[1]];\n  if (v[cir[1]] == v[cir[2]]) same = v[cir[1]];\n  assert(~same);\n  int s = u[cir[1]] + v[cir[1]] - same;\n  for (int i = 1; i <= *cir; i++) {\n    if (u[cir[i]] != s) swap(u[cir[i]], v[cir[i]]);\n    s = v[cir[i]];\n  }\n}\nint calc(int cur) {\n  memset(deg, 0, sizeof(deg));\n  int ans = 1, sum = 0, ano = 1;\n  for (int i = 1; i <= m; i++) {\n    if (inc[i]) {\n      if ((w[i] + cur) & 1) return 0;\n      w0[i] = (w[i] + cur) >> 1;\n      w1[i] = (w[i] - cur) >> 1;\n    } else {\n      w0[i] = w1[i] = w[i] >> 1;\n    }\n    deg[u[i]] += w1[i];\n    deg[v[i]] += w0[i];\n    ans = (long long)ans * C(w[i], w0[i]) % mod;\n  }\n  for (int i = 1; i <= n; i++) ans = (long long)ans * fac[deg[i] - 1] % mod;\n  for (int i = 1; i <= m; i++)\n    if (!inc[i]) ano = (long long)ano * w0[i] % mod;\n  for (int k = 1; k <= *cir; k++) pre[k] = (long long)pre[k - 1] * w0[cir[k]] % mod;\n  for (int k = *cir; k >= 1; k--) suf[k] = (long long)suf[k + 1] * w1[cir[k]] % mod;\n  for (int k = 1; k <= *cir; k++) {\n    sum = (sum + (long long)pre[k - 1] * suf[k + 1] % mod * ano) % mod;\n  }\n  return (long long)sum * ans % mod;\n}\nint main() {\n#ifdef mmeset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  initfac();\n  initgraph();\n  cin >> n >> m;\n  if (n == m + 1) return solve_tree(), 0;\n  for (int i = 1; i <= m; i++) {\n    cin >> u[i] >> v[i] >> w[i];\n    link(u[i], v[i], i);\n    link(v[i], u[i], i);\n    deg[u[i]] += w[i];\n    deg[v[i]] += w[i];\n  }\n  for (int i = 1; i <= n; i++)\n    if (deg[i] & 1) {\n      cout << 0 << endl;\n      return 0;\n    }\n  dfs(1, 0);\n  ordered_circle();\n  int mn = INT_MAX;\n  for (int i = 1; i <= *cir; i++) {\n    inc[cir[i]] = onc[u[cir[i]]] = onc[v[cir[i]]] = true;\n    mn = min(mn, w[cir[i]]);\n  }\n  pre[0] = suf[0] = pre[*cir + 1] = suf[*cir + 1] = 1;\n  for (int d = -mn; d <= mn; d++) ans = (ans + calc(d)) % mod;\n  cout << ans << endl;\n}\n```\n","publishedTitle":"「UR #15」奥林匹克环城马拉松"}},{"id":"7b8ec711-07c9-5ff3-b9ea-fa53d79d1fab","fields":{"slug":"/oi/solution/uoj372/","plainText":"\n> 给定一个 $n$ 个点 $m$ 条边的无向图，其中每个点的点权是 $[0;1]$ 范围内生成的连续型随机变量，求：\n>\n> $$\n> \\max \\{ \\max_{i \\in V} x_i + \\max_{(u,v) \\in E} (x_u + x_v) \\}\n> $$\n>\n> 的期望，答案对 $998244353$ 取模。\n>\n> $n \\leq 25$。（实际上可以跑 $n \\leq 30$。。。\n\n<!-- more -->\n\n## 题解\n\n$$\nans = \\int_0^2 Pr[\\lambda = x] x \\text dx = 2 - \\int_0^2 Pr[\\lambda \\leq x] \\text dx\n$$\n\n考虑如何计算 $Pr[\\lambda \\leq x]$，设 $g(s,y,t)$ 表示对于点集 $s$，点权最大值 $\\leq y$，答案 $\\leq t$ 的概率。考虑其状态转义：\n\n- 如果生成的所有数都 $\\leq \\frac t 2$，则贡献为 $(\\frac t 2)^{|s|}$\n- 对于其他情况，考虑最大值点 $i$，并递归。\n\n$$\ng(s,y,t) = (\\tfrac t 2)^{|s|} + \\sum_{i \\in s} \\int_{\\tfrac t 2}^y g(s_i, x, t) (t - x)^{|s| - |s_i| - 1}\\text dx\n$$\n\n其中 $s_i$ 表示从 $s$ 中删除 $i$ 以及所有和 $i$ 相邻的点得到的点集。\n\n如果我们直接暴力状压维护二元多项式转移显然麻烦的一比，而且常数还贼他妈大，考虑理性一点的方式。\n\n首先，如果当前的状态是若干独立的联通块，可以直接把每个联通块的答案相乘，这可以大大减小状态数。\n\n另外，我们可以注意到，对于二元多项式的每一项 $y^i t^j$，都满足 $i+j$ 是定值，即二元多项式 $g(s)$ 每项的幂次和都是 $|s|$。由二项式定理的系数可以方便得到。\n\n最后，我们需要注意 $g(s,y,t)$ 的取值范围 $\\tfrac t 2 \\leq y \\leq \\min(1, t)$，所以答案是\n\n$$\nans = 2 - \\int_0^1 f(t,t) \\text dt  - \\int_1^2 f(1,t) \\text dt\n$$\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 30, mod = 998244353, inv2 = (mod + 1) >> 1;\nint n, m, tim, G[N], vis[N];\nstruct z {\n  int x;\n  z(int x = 0) : x(x) {}\n  friend inline z operator*(z a, z b) { return (long long)a.x * b.x % mod; }\n  friend inline z operator-(z a, z b) { return (a.x -= b.x) < 0 ? a.x + mod : a.x; }\n  friend inline z operator+(z a, z b) { return (a.x += b.x) >= mod ? a.x - mod : a.x; }\n} ans, inp[N], inv[N], C[N][N];\nunordered_map<int, vector<z>> mp;\ninline vector<z> operator*(const vector<z> &a, const vector<z> &b) {\n  vector<z> c(a.size() + b.size() - 1);\n  for (int i = 0; i < a.size(); i++)\n    for (int j = 0; j < b.size(); j++) c[i + j] = c[i + j] + a[i] * b[j];\n  return c;\n}\ninline vector<z> inte(vector<z> f) {\n  vector<z> g(f.size() + 1);\n  for (int i = 1; i <= f.size(); i++) g[i] = f[i - 1] * inv[i];\n  return g;\n}\ninline z eval(vector<z> a, int l, int r) {\n  a = inte(a);\n  z p, s;\n  int i;\n  for (p = 1, i = 0; i < a.size(); i++) s = s + a[i] * p, p = p * r;\n  for (p = 1, i = 0; i < a.size(); i++) s = s - a[i] * p, p = p * l;\n  return s;\n}\nvoid initfac(int n) {\n  inp[0] = inv[0] = inv[1] = 1;\n  for (int i = 2; i < n; i++) inv[i] = (mod - mod / i) * inv[mod % i];\n  for (int i = 1; i < n; i++) inp[i] = inp[i - 1] * inv2;\n  for (int i = 0; i < n; i++) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; j++) C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n  }\n}\nint dfs(int u, int s) {\n  int res = 1 << u;\n  vis[u] = tim;\n  for (int v = 0; v < n; v++)\n    if (((s >> v) & 1) && ((G[u] >> v) & 1) && vis[v] != tim) res |= dfs(v, s);\n  return res;\n}\nvoid update(vector<z> &s, vector<z> a, int k) {\n  vector<z> b(k + 1);\n  for (int i = 0; i <= k; i++) b[i] = C[k][i] * (i & 1 ? mod - 1 : 1);\n  a = inte(a * b);\n  for (int i = 0; i < a.size(); i++) s[i] = s[i] + a[i], s[0] = s[0] - inp[i] * a[i];\n}\nvector<z> solve(int s) {\n  if (mp.count(s)) return mp[s];\n  int l = __builtin_popcount(s);\n  vector<z> res;\n  vector<int> set;\n  for (int t, i = 0; i < n; i++)\n    if ((s >> i) & 1) {\n      ++tim;\n      t = dfs(i, s), s ^= t;\n      set.push_back(t);\n    }\n  for (int x : set) s |= x;\n  if (set.size() > 1) {\n    res = {1};\n    for (auto t : set) res = res * solve(t);\n  } else {\n    res.resize(l + 1), res[0] = inp[l];\n    for (int i = 0; i < n; i++)\n      if ((s >> i) & 1) {\n        int t = s ^ (s & (G[i] | (1 << i)));\n        update(res, solve(t), __builtin_popcount(s & G[i]));\n      }\n  }\n  return mp[s] = res;\n}\nint main() {\n  cin >> n >> m;\n  initfac(N), mp[0] = {1};\n  for (int u, v, i = 0; i < m; i++) {\n    cin >> u >> v, --u, --v;\n    G[u] |= 1 << v, G[v] |= 1 << u;\n  }\n  vector<z> s = solve((1 << n) - 1), a(n + 1);\n  for (int i = 0; i < s.size(); i++) a[n] = a[n] + s[i];\n  reverse(s.begin(), s.end());\n  cout << (2 - eval(s, 1, 2) - eval(a, 0, 1)).x << endl;\n}\n```\n","publishedTitle":"「UR #17」滑稽树前做游戏"}},{"id":"b2002f5d-fef2-5a62-ae93-b214126a1681","fields":{"slug":"/oi/solution/uoj498/","plainText":"\n> 定义两个简单无向图 $G_{1} =( V_{1} , E_{1}) , G_{2} =( V_{2} , E_{2})$ 的乘积为一个新的图 $G_{1} \\times G_{2} =\\left( V^{\\star} , E^{\\star} \\right)$，其中\n>\n> $$\n> \\begin{aligned}\n> V^{\\star} &= \\left\\{ {(a, b)| a \\in V_{1}, b \\in V_{2} }\\right\\},\\\\ E^{\\star} &=\\left\\{\\left(( u_{1} , v_{1}) , ( u_{2} , v_{2})\\right) \\mid ( u_{1} , u_{2}) \\in E_{1}, ( v_{1} , v_{2}) \\in E_{2}\\right\\}.\n> \\end{aligned}\n> $$\n>\n> 对于正整数 $n$ ，以及给定的图 $G_{1} , G_{2} , \\dotsc , G_{n}$ ，我们令\n>\n> $$\n> \\displaystyle{H = (((G_1 \\times G_2) \\times G_3) \\times \\cdots) \\times G_n}.\n> $$\n>\n> 若每个 $G_k$ 中每任意两点都有 $\\frac12$ 的概率有边，求 $H$ 的连通块个数的期望。\n>\n> $1\\le n, m_k\\le 10^5$ 。答案对 $998244353$ 取模。\n\n<!-- more -->\n\n## 题解\n\n大概是一个二合一状物，我们搞出生成函数以后逐个合并。\n\n考虑 $k=1$ 怎么做，假设 $G$ 为无标号无向图生成函数：\n\n$$\nG = \\sum_{i\\ge 0} \\frac {2^{\\binom i 2} x^i} {i!}\n$$\n\n则 $\\ln G$ 为无标号联通无向图生成函数， $n! [x^n] G \\ln G$ 即为答案。\n\n考虑 $k=2$ 怎么做，我们需要特判下孤立点的情况。合并的结果和两边的图是否为二分图（即题解所谓没有奇环）是有关的，当且仅当两侧都是二分图时会使得生成的图对应两个联通块。\n\n考虑无标号二分图生成函数 $B$ （可以卷积解决）：\n\n$$\nB = \\sum_{i \\ge 0} \\sum_{j \\ge 0} \\frac {2^{ij} x^{i+j}} {i! j!} = \\sum_{i \\ge 0} \\sum_{j \\ge 0} \\frac {2^{\\binom {i+j} 2 - \\binom  i 2 - \\binom j 2} x^{i+j}} {i! j!}\n$$\n\n故非平凡二分图联通块生成函数为 $G (\\frac {\\ln B} 2 - 1)$ ，非平凡非二分图联通块生成函数为 $G (\\ln G - \\frac {\\ln B} 2)$ ，非平凡联通块生成函数为 $G (\\ln G - 1)$ 。孤立点联通块生成函数为 $x G$ （这几个均为无标号\n\n考虑记录下期望点数，期望非平凡二分图联通块，期望非平凡非二分图联通块，期望孤立点个数，即可合并两个图的信息，做下去即可（\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10, mod = 998244353;\nint n, l, lim, m[N], rev[N << 2];\nstruct z {\n  int x;\n  z(int x = 0) : x(x) {}\n  inline int half() { return x & 1 ? (x + mod) >> 1 : x >> 1; }\n  friend inline z operator*(z a, z b) { return (long long)a.x * b.x % mod; }\n  friend inline z operator-(z a, z b) { return (a.x -= b.x) < 0 ? a.x + mod : a.x; }\n  friend inline z operator+(z a, z b) { return (a.x += b.x) >= mod ? a.x - mod : a.x; }\n} a[N], b[N], c[N], d[N], fac[N], inv[N], ifac[N], t1[N], w[N << 2];\nusing poly = vector<z>;\ninline z fpow(z a, int b) {\n  z s = 1;\n  for (; b; b >>= 1, a = a * a)\n    if (b & 1) s = s * a;\n  return s;\n}\nint polyInit(int l) {\n  int lim = 1, k = 0;\n  while (lim < l) lim <<= 1, ++k;\n  for (int i = 0; i < lim; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (k - 1));\n  static int len = 1;\n  for (; len < lim; len <<= 1) {\n    z wn = fpow(3, (mod - 1) / (len << 1));\n    w[len] = 1;\n    for (int i = 1; i < len; i++) w[i + len] = w[i + len - 1] * wn;\n  }\n  return lim;\n}\nvoid dft(poly &a, int lim) {\n  a.resize(lim);\n  for (int i = 0; i < lim; i++)\n    if (i < rev[i]) swap(a[i], a[rev[i]]);\n  for (int len = 1; len < lim; len <<= 1)\n    for (int i = 0; i < lim; i += (len << 1))\n      for (int j = 0; j < len; j++) {\n        z x = a[i + j], y = a[i + j + len] * w[j + len];\n        a[i + j] = x + y, a[i + j + len] = x - y;\n      }\n}\nvoid idft(poly &a, int lim) {\n  dft(a, lim), reverse(&a[1], &a[lim]);\n  z inv = fpow(lim, mod - 2);\n  for (int i = 0; i < lim; i++) a[i] = a[i] * inv;\n}\npoly polyInc(poly a, const poly &b) {\n  a.resize(max(a.size(), b.size()));\n  for (int i = 0; i < b.size(); i++) a[i] = a[i] + b[i];\n  return a;\n}\npoly polyDec(poly a, const poly &b) {\n  a.resize(max(a.size(), b.size()));\n  for (int i = 0; i < b.size(); i++) a[i] = a[i] - b[i];\n  return a;\n}\npoly polyMul(poly a, poly b) {\n  int lim = polyInit(a.size() + b.size() - 1);\n  dft(a, lim), dft(b, lim);\n  for (int i = 0; i < lim; i++) a[i] = a[i] * b[i];\n  idft(a, lim), a.resize(l);\n  return a;\n}\npoly polyInv(poly f, int len = -1) {\n  if ((len = ~len ? len : f.size()) == 1) return {fpow(f[0], mod - 2)};\n  poly a(&f[0], &f[len]), b = polyInv(f, (len + 1) >> 1);\n  int lim = polyInit((len << 1) - 1);\n  dft(a, lim), dft(b, lim);\n  for (int i = 0; i < lim; i++) a[i] = b[i] * (2 - a[i] * b[i]);\n  idft(a, lim), a.resize(len);\n  return a;\n}\npoly polyDer(poly f) {\n  for (int i = 0; i <= f.size() - 2; i++) f[i] = f[i + 1] * (i + 1);\n  *--f.end() = 0;\n  return f;\n}\npoly polyInt(poly f) {\n  for (int i = f.size() - 1; i >= 1; i--) f[i] = f[i - 1] * inv[i];\n  *f.begin() = 0;\n  return f;\n}\npoly polyLn(poly f) { return polyInt(polyMul(polyInv(f), polyDer(f))); }\npoly A, B, C, D, E, F, G, H;\nstruct info {\n  z n, a, b, c;\n  inline z dump() { return a + b + c; }\n  inline void load(int x) { n = G[x] * fac[x] * x, a = C[x] * fac[x], b = D[x] * fac[x], c = G[x - 1] * fac[x]; }\n  friend inline info operator^(const info &a, const info &b) {\n    static info s;\n    s.n = a.n * b.n;\n    s.a = 2 * a.a * b.a + a.a * b.b + a.b * b.a;\n    s.b = a.b * b.b;\n    s.c = a.c * b.c + a.c * (b.n - b.c) + b.c * (a.n - a.c);\n    return s;\n  }\n} ans, tmp;\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> m[i], l = max(l, m[i] + 1);\n  fac[0] = ifac[0] = inv[0] = inv[1] = 1;\n  for (int i = 1; i <= l; i++) fac[i] = fac[i - 1] * i;\n  for (int i = 2; i <= l; i++) inv[i] = (mod - mod / i) * inv[mod % i];\n  for (int i = 1; i <= l; i++) ifac[i] = ifac[i - 1] * inv[i];\n  G.resize(l), B.resize(l);\n  for (int i = 0; i < l; i++) t1[i] = fpow(2, (long long)i * (i - 1) / 2 % (mod - 1));\n  for (int i = 0; i < l; i++) G[i] = t1[i] * ifac[i];\n  for (int i = 0; i < l; i++) B[i] = ifac[i] * fpow(t1[i], mod - 2);\n  B = polyMul(B, B), B.resize(l);\n  for (int i = 0; i < l; i++) B[i] = B[i] * t1[i];\n  F = polyLn(G), H = G, F[1] = 0, A = polyLn(B), A[1] = 0;\n  for (int i = 0; i < l; i++) A[i] = A[i].half();\n  C = polyMul(G, A), C.resize(l), E = polyMul(G, F), E.resize(l), D = polyDec(E, C);\n  ans.load(m[1]);\n  for (int i = 2; i <= n; i++) ans = ans ^ (tmp.load(m[i]), tmp);\n  cout << ans.dump().x << endl;\n}\n```\n","publishedTitle":"「UOJ Goodbye Jihai」新年的追逐战"}},{"id":"2af2d579-aaab-5231-92af-540fe83541d4","fields":{"slug":"/oi/solution/uoj500/","plainText":"\n> 给定 $n$ 次多项式\n>\n> $$\n> f(x) = \\sum_{i=0}^n a_i x^i\n> $$\n>\n> $Q$ 次询问，第 $i$ 次询问 $f(q_i)$ 对 $998244353$ 取模的值。\n>\n> 其中 $q_i$ 是一个一阶线性递推，给定 $q_0, x, y$ ，满足\n>\n> $$\n> q_n = x q_{n-1} + y\n> $$\n>\n> $1 \\leq n \\leq 2.5 \\times 10^5, \\ 1 \\leq Q \\leq 10^6, \\ 2 \\leq x < 998244353, \\ 0 \\leq q_0, y < 998244353$ 。\n\n<!-- more -->\n\n## Solution Part1\n\n首先这玩意儿肯定没法两个 $\\log$ 多点求值，除非你是钱哥哥。\n\n![22em](https://static.memset0.cn/img/v6/2024/02/11/3Mgly16W.png)\n\n## Solution Part2\n\n虽然这东西好像小学生都会，但我自己推的时候怎么莫名搞到特征多项式那个方向去了，越学越傻逼了。。。\n\n$$\n\\left\\{ \\begin{aligned}\ng_{n+1} = x g_n + y \\\\\ng_n = x g_{n-1} + y \\\\\n\\end{aligned} \\right.\n$$\n\n两式相减得到\n\n$$\n(g_{n+1}-g_n) = x (g_n - g_{n-1})\n$$\n\n不妨设\n\n$$\nh_n = g_{n+1} - g_n\n$$\n\n可以得到 $h$ 的通项公式\n\n$$\nh_n = x^n h_0 = x^n ((x-1) g_0 + y)\n$$\n\n从而得到 $g$ 的通项公式\n\n$$\ng_n = g_0 + \\sum_{i=0}^{n-1} h_i = g_0 + \\frac {x^n-1} {x-1} ((x-1)g_0 + y)\n$$\n\n不妨表示成 $ax^n + b$ 的形式，其中\n\n$$\n\\begin{cases}\na = \\dfrac {(x-1) g_0 + y} {x-1} \\\\\nb = \\dfrac {y} {x-1} \\\\\n\\end{cases}\n$$\n\n## Solution Part3\n\n也就是说我们要对于所有 $i \\in [1, Q]$ 求出 $f(a x^i + b)$ 的值，不妨设多项式 $g(x) = f(ax + b)$ ，也就是一个多项式平移。\n\n$$\n\\begin{aligned}\ng(x)\n&= f(ax + b) \\\\\n&= \\sum_{i=0}^n a_i (ax + b)^i \\\\\n&= \\sum_{i=0}^n a_i \\sum_{j=0}^i \\frac {i!} {j! (i-j)!} (ax)^j b^{i-j} \\\\\n&= \\sum_{i=0}^n a_i i! \\sum_{j=0}^i \\frac {(ax)^j} {j!} \\cdot \\frac {b^{i-j}} {(i-j)!} \\\\\n\\end{aligned}\n$$\n\n容易发现可以卷积维护，需要反转一个多项式。\n\n## Solution Part4\n\n回到之前的式子，现在我们只需要对于所以 $i \\in [1, Q]$ 求出 $g(x^i)$ 的值，相当于求\n\n$$\n\\begin{aligned}\nG(z)\n&= \\sum_{i=0}^Q z^i \\sum_{j=0}^n a_j x^{ij} \\\\\n&= \\sum_{i=0}^Q z^i \\sum_{j=0}^n a_j x^{\\binom {i+j} 2 - \\binom i 2 - \\binom j 2} \\\\\n&= \\sum_{i=0}^Q z^i x^{-\\binom i2} \\sum_{j=0}^n a_j x^{-\\binom j2} \\cdot x^{\\binom {i+j} 2} \\\\\n\\end{aligned}\n$$\n\n容易发现可以卷积维护，需要反转一个多项式。\n\n> 题外话：\n>\n> 一开始想过把 $ij$ 拆成 $\\binom i 2 + \\binom j 2 - \\binom {i-j} 2$ ，结果 $i-j$ 的值域有正有负，反而难处理，尽量还是避免这种情况。\n\n## Code\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2.1e6 + 10, mod = 998244353;\nint n, q, rev[N];\nstruct z {\n  int x;\n  z(int x = 0) : x(x) {}\n  friend inline z operator*(z a, z b) { return (long long)a.x * b.x % mod; }\n  friend inline z operator-(z a, z b) { return (a.x -= b.x) < 0 ? a.x + mod : a.x; }\n  friend inline z operator+(z a, z b) { return (a.x += b.x) >= mod ? a.x - mod : a.x; }\n} q0, qx, qy, qc, w[N], f[N], g[N], t1[N], t2[N], t3[N], t4[N], fac[N], ifac[N];\ninline z fpow(z a, int b) {\n  z s = 1;\n  for (; b; b >>= 1, a = a * a)\n    if (b & 1) s = s * a;\n  return s;\n}\nvoid initFac(int n) {\n  fac[0] = ifac[0] = ifac[1] = 1;\n  for (int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i;\n  for (int i = 2; i <= n; i++) ifac[i] = (mod - mod / i) * ifac[mod % i];\n  for (int i = 2; i <= n; i++) ifac[i] = ifac[i - 1] * ifac[i];\n}\nvoid initPow(z c, int n, z *a, z *b) {\n  a[0] = b[0] = 1;\n  for (int i = 1; i < n; i++) a[i] = a[i - 1] * c;\n  for (int i = 1; i < n; i++) b[i] = b[i - 1] * a[i - 1];\n}\nint init(int n) {\n  static int wk = 1;\n  int k = -1, l = 1;\n  while (l < n) l <<= 1, ++k;\n  for (int i = 0; i < l; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << k);\n  for (int &k = wk; k < l; k <<= 1) {\n    z c = fpow(3, (mod - 1) / k / 2);\n    w[k] = 1;\n    for (int i = 1; i < k; i++) w[i + k] = w[i + k - 1] * c;\n  }\n  return l;\n}\nvoid ntt(z *a, z *b, int l) {\n  for (int i = 0; i < l; i++) b[rev[i]] = a[i];\n  for (int k = 1; k < l; k <<= 1)\n    for (int i = 0; i < l; i += (k << 1))\n      for (int j = 0; j < k; j++) {\n        z x = b[i + j], y = b[i + j + k] * w[j + k];\n        b[i + j] = x + y, b[i + j + k] = x - y;\n      }\n}\nvoid mul(z *a, z *b, z *c, int n, int m) {\n  static z t[N];\n  int l = init(n + m - 1);\n  z v = fpow(l, mod - 2);\n  ntt(a, c, l), ntt(b, t, l);\n  for (int i = 0; i < l; i++) t[i] = t[i] * c[i];\n  reverse(t + 1, t + l), ntt(t, c, l);\n  for (int i = 0; i < l; i++) c[i] = c[i] * v;\n}\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n >> q;\n  initFac(max(n, q));\n  for (int i = 0; i <= n; i++) cin >> f[i].x;\n  cin >> q0.x >> qx.x >> qy.x;\n  qc = (q0 * (qx - 1) + qy) * fpow(qx - 1, mod - 2);\n  const auto move = [&](z *a, z c, z k, int n) {\n    int i;\n    z t;\n    for (i = 0, t = 1; i < n; i++) t1[i] = a[i] * fac[i], t2[n - i - 1] = ifac[i] * t, t = t * c;\n    mul(t1, t2, t3, n, n);\n    for (i = 0, t = 1; i < n; i++) a[i] = t3[n - 1 + i] * ifac[i] * t, t = t * k;\n  };\n  memset(t1, 0, sizeof(t1)), memset(t2, 0, sizeof(t2));\n  move(f, q0 - qc, qc, n + 1);\n  memset(t1, 0, sizeof(t1)), memset(t2, 0, sizeof(t2));\n  const auto czt = [&](z *a, z *b, z c, int n, int q) {\n    initPow(c, n + q, t3, t1);\n    reverse(t1, t1 + n + q);\n    initPow(fpow(c, mod - 2), max(n, q), t3, t4);\n    for (int i = 0; i < n; i++) t2[i] = a[i] * t4[i];\n    mul(t1, t2, t3, n + q, n);\n    for (int i = 0; i < q; i++) b[i] = t3[n + q - 1 - i] * t4[i];\n  };\n  czt(f, g, qx, n + 1, q + 1);\n  cout << accumulate(g + 1, g + q + 1, 0, [](int a, z b) { return a ^ b.x; }) << endl;\n}\n```\n","publishedTitle":"「UOJ500」任意基DFT"}},{"id":"97ef5ad5-d0d0-5ed6-a167-e014ff5f8efe","fields":{"slug":"/course/oop/review/","plainText":"\n> 本篇笔记全面总结了面向对象程序设计课程的核心内容，包括 C++ 的基础特性（引用、常量、内存管理）、类的概念（构造、继承、多态）、运算符重载、模板编程和异常处理机制。笔记重点关注了一些易错细节，如构造顺序、虚函数机制、类型转换等，并提供了大量实用的代码示例和考试要点提示。适合有 C++ 基础的同学快速掌握 OOP 的核心概念和重要细节。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n> [!warning] 注意\n>\n> 仅推荐有一定 C++ 基础（但没有 OOP 基础）的同学阅读此笔记，否则你可能会错过一些语言细节。\n\n## 1. C++ Features\n\n- 引用&\n  - 必须立即进行初始化，不能声明完后再赋值。\n  - 引用不能重新赋值，即不能再把该引用名作为其他变量名的别名。\n  - 不能创建引用的引用\n  - 不能创建引用的指针（`int &*` illegal）\n  - 可以创建指针的引用（`int *&` ok）\n  - 不能创建“引用”的数组\n- 常量\n  - 常量的值（编译器确定）记录在符号表里\n    - 但 `extern` 的常量不会记到符号表里\n  - ==`*` 后的 `const` ,表示不能移动指向的位置（`std::string* const`）；`*` 前的 `const`，表示不能修改指向的对象的内容。（`const std::string *` 或 `std::string const *`）==\n  - String Literals\n    - `char *s = \"Hello World!\";` 可以移动，不能修改（因为实际上是 `const char*`）\n    - `char s[] = \"Hello World!\";` 不能移动，可以修改\n  - 对象的常量不是编译期常量\n    - `class Array{ const int size = 10; int array[size]; };` 不能通过编译\n    - 可以声明为 `static`：`static const int size = 10;`\n    - 可以使用 `enum`：`enum {size = 10};`\n  - 注意一下：![|410](https://img.memset0.cn/2025/01/10/P6qrYh1P.png)\n- `new` & `delete`\n  - 对空地址 `nullptr` 使用 `delete` 是安全的\n  - 对不是 `new` 分配的空间或已经 delete 的指针使用 `delete` 会引发错误。\n  - `new int[10]()` 或 `new int[10]{}` 这种写法会初始化（Pitfall：不能写成 `new int[10](0)`）\n- ![|647](https://img.memset0.cn/2025/01/11/Aof9NG9F.png)\n\n## 2. Class\n\n- 构造顺序：==静态成员、虚基类、基类、成员变量、（自己的）构造函数==\n- **代理构造(delegating constructor)**：可以在构造函数中调用另一个构造函数\n  - `clazz(int a, int b) : clazz(a) { }`\n  - 常量数据成员直接赋值或者在代理构造中进行初始化，之后不能修改，不能在构造函数中初始化\n- 静态成员变量：\n  - `static` 的静态成员变量不能直接赋初值，除非声明为 `static const` 的。\n  - 可以先声明然后在外面用 `int Class::size = 10;` 的语法例化。\n- 静态内容：\n  - 使用 `<class name>::<static member>` 或 `<object name>.<static member` 的方法访问静态方法或者静态成员变量\n- 重载\n  - overload 时==先考虑是否有完全匹配的函数，找不到再考虑模板，还是找不到再考虑隐式类型转换（其中先考虑提升再考虑强制类型转化）==。\n- 继承：\n  - 权限控制\n    - `private` 继承：只有子类可以调用父类方法；\n    - `protected` 继承：只有子类及其派生类可以调用父类方法；\n    - `public` 继承：子类、派生类、外部类可以调用父类方法。\n  - Constructors, Destructors 和 Assignment operation（=） 是不会继承的\n- **name hiding**：如果子类重载了父类函数，那么父类所有同名的重载均会失效。可以使用 `using Base::f` 引入父类的这些方法。\n- 虚函数 `virtual`\n  - 一个父类的成员函数被声明为虚函数后，所有子类的同名函数都被==隐式==地声明为虚函数。\n  - 虚析构函数：为了能调用子类的析构，理论上来说我们应该将父类的析构函数声明为虚函数，即所有的析构函数都应该声明为虚函数。\n    - 如果不这么做，`delete` 父类指针时就只会调用静态绑定的父类析构函数\n    - 如果这么做，会调用子类的析构函数，并在之后==自动==调用父类的析构函数。\n    - 进一步,所有的类都应该存在 vptr ,这是 RTTI 的基础。\n- 多继承：\n  - 菱形继承：A 同时被 B 、 C 继承, D 继承 B 和 C。 那么当我们把 A 的指针指向 D 的对象时,就不知道应该指向 B::A 还是 C::A ,出现冲突。 同理，如果 D 访问 A 的成员时,不知道应该访问 B::A 还是 C::A 。\n    - 重名的变量同时存在，通过 `B::a` 或者 `C::a` 访问，如果直接访问 `a` 会报错\n  - 虚继承：在继承时添加 `virtual` 关键字实现。虚继承时子类中不存在父类的对象,而是保有父类的指针。不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。\n- 拷贝构造\n  - 场景：函数传参（特例：构造函数传参：`Class a = c;`，注意 `Class a; a = c` 并不会拷贝构造）。\n  - 如果不需要拷贝构造，可以将其声明为 private，在外部调用时就会报错。这种情况下不需要函数实现（`private: Person(const Person &);`）\n\n## 3. Overload & Casting\n\n- 重载\n  - 不能被重载的运算符：`.`、`.*`、`::`、`?:`、`sizeof`、`typeid`、四种 cast（注意 `,` 是可以重载的）\n  - 只能作为成员重载而不能作为友元函数重载的：`=`、`()`、`[]`、`->`、`->*`\n  - 成员函数 VS 自由函数\n    - `=`、`()`（用于类型转换）、`[]`、`->`、`->*` 必须是成员\n  - 重载自增运算符和自减运算符：\n    ```cpp\n    const Integer& Integer::operator++() { // ++prefix\n      *this += 1; return *this; }\n    const Integer Integer::operator++(int/* unnamed */) { // postfix++\n      Integer old(*this); ++(*this); return old; }\n    ```\n  - 函数原型：\n    - `+ - * / % ^ & | ~`\n      - `const _Tp operator X(const _Tp& l, const _Tp& r);`\n    - `== != < > <= >= `\n      - `bool operator X(const _Tp& l, const _Tp& r);`\n    - `[]`\n      - `_Tp& operator X(int index); `\n    - `= += -= *= /= <<= >>=`\n      - `_Tp& operator X(_Tp& l, const _Tp& r);`\n- 类型转换\n  - 自定义类型转换：通过重载 `operator _Tp() const;`\n  - 自定义类的默认类型转换：\n    - `T => T& T& => T T => (const T)`\n    - `T[] => T* T* => T[] T* => void*`\n  - （隐式）转换的匹配规则（将 `A` 转化为 `B`）\n    - 精确的类型匹配（`A` 就是 `B`）\n    - 内置类型转换\n    - 自定义的类型转换\n      - 如果有 `B(A)` 的不为 `explicit` 的构造函数，则使用\n        - 注意语义：`explicit` 表明不能进行隐式类型转换\n        - 如果使用 `static_cast<B>`，那么明确使用构造函数（解决 `explicit` 的问题）\n      - 如果有 `A` 到 `B` 的自定义类型转换，则使用\n    - 对于模板函数的参数，如果上述条件均不满足，则编译器会考虑使用其他版本的函数。\n- cast\n  - `static_cast`：在相关类型之间转换，==编译时==。\n    - 基本类型的转换（遵循上面的规则）\n    - 子类指针/引用向父类指针/引用的转换（up-casting，安全）\n    - 父类指针/引用向子类指针/引用的转换（down-casting，不安全，可能导致 UB）\n    - `void*` 和其他类型指针的转换（安全，由开发者确保正确）\n    - 否则会在编译器报错。\n  - `dynamic_cast`：用于==多态类型==（有虚函数的类）的 down-casting，在运行时刻检查类型安全\n    - 父类指针/引用向子类指针/引用的转换。\n      - 引用类型转换失败：抛出 `std::bad_cast` 异常；\n      - 指针类型转换失败：返回 `nullptr`；\n    - 编译期错误：不是多态类型（基类没有虚函数，==除非==本身是 up-casting 这种编译器可确定的）、类型之间没有继承关系。\n  - `const_cast`：用于修改类型的 `const` 或 `volatile` 属性。\n    - 去除 `const` 属性，使变量可以修改（传给另一个指针来修改）`const int x = 0; const_cast<int*>(&x)`\n    - `volatile` 属性指的是变量不能被优化在寄存器中，每次修改必须访问内存\n  - `reinterpret_cast`：低级别的、无类型检查的转换。可以在几乎任何类型间转换，但是非常危险。\n\n## 4. Template\n\n- 模板可以从实例类继承，可以从类模板继承。实例类只能从实例类继承。\n- 对于静态成员变量，同样在类里只能先声明，然后使用 `template<typename T> int Derived<T>::size = 10;` 创建。这样实际调用时，会为每个不同的 `T` 生成一个 `size` 变量。\n- 模板函数和普通函数同时存在的情况：模板函数不能进行自动类型转换但普通函数可以。\n\n## 5. Exception\n\n- `catch` 的括号内 `ErrorType& e` 表示捕获 `ErrorType` 及其子类（如果是基本类型就不考虑子类）。使用 `...` 表示捕捉任何异常。\n  - ![|700](https://img.memset0.cn/2025/01/10/QZSWliuV.png)\n- 可以直接写 `throw` 表示再抛出。\n- 异常规范：声明函数可能返回何种异常\n  - `void print(Document& p) throw(PrintOffLine, BadDocument);`\n  - `void goodguy() throw();// throw no exceptions, until C++11`\n  - `void alloc() throw(...);// can throw any exception`\n  - `void abc() noexcept;// throw no exceptions, since C++11`\n  - (\\*) 如果在函数中返回了规范之外的异常，系统会调用 [`std::unexpected()`](https://en.cppreference.com/w/cpp/error/unexpected) 来处理。\n    - `std::unexpected()` 默认调用 `std::terminate()` 来终止程序。\n    - 可以用 `std::set_unexpected(func)`将 `std::unexpected()` 重载为 `func()`；\n    - 也可以用 `std::set_terminate(func)` 将 `std::terminate()` 重载为 `func()`。\n    - 如果 `std::unexpected()` 被调用后，抛出的异常仍然不符合异常规范，则会抛出 `std::bad_exception` 异常。\n    - C++17 之后，异常规范说明已被弃用。使用 `noexcept` 说明函数不会抛出任何异常时，若抛出了异常，则会直接调用 `std::terminate()`。\n- [`exception`](https://en.cppreference.com/w/cpp/error/exception)：所有异常的公共基类\n  - bad 系列\n    - `bad_alloc`：`new` 无法分配空间抛出的异常\n      - `malloc` 在未成功分配空间时会返回 `NULL`。\n    - `bad_cast`：`dynamic_cast` 对引用的类型检查出错，抛出的异常\n    - `bad_typeid`：对多态类型的空指针使用 `typeid` 抛出的异常\n    - `bad_exception`：当前抛出异常的拷贝构造出错时，抛出的异常\n  - `runtime_error`：事件超出程序范围抛出的异常\n    - `overflow_error`：算数上溢抛出的异常（STL 中仅 `std::bitset::to_ulong`）\n    - `range_error`：算数超界抛出的异常\n  - `logic_error`：程序逻辑错误引发的异常，并且可能是可以预防的\n    - `domain_error`：当输入超出了其类型的定义域时抛出的异常\n    - `length_error`：当对容器的操作使其超出了预定义的长度上限时抛出的异常\n    - `out_of_range`：当对容器的操作超出了其当前范围时抛出的异常\n    - `invalid_argument`：当传入参数不合法时抛出的异常\n- 空间安全：使用两步构造（不要直接在构造函数里申请空间，否则抛出异常时不会调用析构函数）\n  - 在构造函数内对基本变量赋值\n  - 任何需要申请资源和空间的操作，在显式的 `init()` 函数内执行\n\n## 6. Others\n\n- `class` 中的权限控制默认为 `private`、`struct` 中的权限控制默认为 `public`\n- 构造和析构的顺序是相反的。\n  - 无论是直接创建数组还是使用 `new` & `delete`，构造的顺序都是从小到大，析构的顺序都是从大到小\n- `malloc` 不执行类的构造函数，而 `new` 出新的对象的时候会执行对象的构造函数。\n- 在类内定义的方法都会被自动声明为 `inline`，但是是否会被内联由编译器决定。\n- `extern` 说明全局变量或函数会在另一个文件中有（并链接过来）；`static` 修饰的全局变量或函数只能在当前文件中使用。\n- volatile：表示变量或对象的值可能会在程序控制之外被改变，例如由硬件或操作系统修改。它用于告诉编译器不要对涉及 volatile 变量的代码进行优化，以确保每次访问 volatile 变量时都从内存中读取其值.\n\n## 7. Pitfalls\n\n- 几个名词\n  - **封装(encapsulation)**\n  - **继承(inheritance)**\n  - **多态(polymorphism)**\n- ==自己写的代码别和挖空之外的部分重复了==\n- 关注：权限，==是否有 const==；从而讨论到底是 overriding 还是 name hiding\n- 构造函数先==父类==再自己，析构函数先自己再==父类==不要漏了。\n- 无论是自己写程序还是读他写的程序，注意一下用 `delete` 还是 `delete[]`\n  ![|490](https://img.memset0.cn/2025/01/11/e9RJGJIY.png)\n- Pitfall：\n  - 构造函数仔细看：继承、成员变量？全局变量？\n  - 析构函数仔细看：除了 delete 外还有因生命周期结束导致的析构。\n    ![|214](https://img.memset0.cn/2025/01/11/WOpk6I1c.png)\n  - const 的话用不了非 const 的方法；静态会和成员的函数一起重载，看哪个更匹配。\n    ![|427](https://img.memset0.cn/2025/01/11/YtDCfqcw.png)\n- ![|629](https://img.memset0.cn/2025/01/10/223RecdN.png)\n- ![|630](https://img.memset0.cn/2025/01/10/37j2UAOz.png)\n- ![|639](https://img.memset0.cn/2025/01/10/3znSJrBg.png)\n- throw 如果带括号就是创建一个对象，\n  - throw Type()//新建一个，结束后析构\n  - throw sth // 生命周期会保证维持到 catch 结束\n- ![|434](https://img.memset0.cn/2025/01/10/izN4l72t.png)\n","publishedTitle":"「面向对象程序设计」期末复习"}},{"id":"f3bbe74f-5713-5ce2-bab0-d7c4385f182c","fields":{"slug":"/blog/high-school/math/approximants/","plainText":"\n> 本篇文章中，我们将从常用的切线放缩和泰勒展开出发，探讨一些在高中数学中常用的逼近与放缩方法，并简单介绍他们的应用。\n>\n> 2022 年新高考 I 卷中出现的比较 $a=0.1e^{0.1}$，$b=\\dfrac 19$，$c=-\\ln 0.9$ 三个数大小的选择题即为这种方法的典型例题。\n\n<!-- more -->\n\n## 1. 切线放缩\n\n高中阶段有一类常用的不等式：\n\n$$\n\\begin{aligned}\ne^x\\ge x+1 &\\Leftrightarrow \\ln(x+1) \\le x \\\\\n\\ln x\\le x-1 &\\Leftrightarrow e^x\\ge ex\n\\end{aligned}\n$$\n\n这些不等式都是由原式在某点的切线方程得到的，切线方程和原函数的在该点的值和一阶导都相同。通过泰勒展开，我们可以把这种思想从一阶推广到 $n$ 阶甚至任意阶。\n\n## 2. 泰勒展开\n\n对于多项式 $f(x)$，我们定义 $T_n(x)=\\sum\\limits_{i=0}^n\\dfrac{f^{(i)}(x_0)(x-x_0)^i}{i!}$ 为其 $n$ 阶泰勒级数（Taylor Series）。$T_n(x)$ 与原函数在 $x_0$ 处有相同的 $n$ 阶导数，即对于任意 $k\\in [0,n]$，$f^{(k)}(x_0) = T_n^{(k)}(x_0)$。特别地，当 $x_0=0$ 时，该级数又称作原函数的麦克劳林级数（Maclaurin Series）。\n\n#### 2.1.1. 应用：得到常用不等式\n\n对一些函数进行泰勒展开，我们可以得到一些常用的不等式，如：\n\n由 $e^x=1+x+\\dfrac{x^2}{2!}+\\dfrac{x^3}{3!}+\\dfrac{x^4}{4!}+\\cdots$ 我们可以得到 $e^x\\ge x+1,\\quad e^x\\ge \\dfrac{x^2}{2} +x+1$ 等不等式。\n\n类似的，由 $\\ln (x+1)=x-\\dfrac{x^2}{2}+\\dfrac{x^3}{3}-\\cdots$ 可以得到 $\\ln(x+1)\\ge x-\\dfrac{x^2}2(x\\ge 0)$，$\\ln(x+1)\\le x-\\dfrac{x^2}2(x\\le 0)$ 等，注意在 $0$ 的两侧不等号的方向是相反的。\n\n简单三角函数也可通过泰勒展开得到一些常用的不等式，由 $\\sin x = x-\\dfrac{x^3}{6}+\\dfrac{x^5}{120}+\\cdots$ 可以得到 $\\sin x \\leq x(x\\ge 0)$，$\\sin x\\geq x(x\\le0)$，$\\sin x \\ge x - \\dfrac {x^3}{6}(x\\ge 0)$，$\\sin x\\ge x-\\dfrac{x^3}{6}(x\\le 0)$ 等。类似的，由 $\\cos x = 1-\\dfrac{x^2}{2}+\\dfrac{x^4}{24}-\\cdots$ 可以得到 $\\cos x \\ge 1 - \\dfrac{x^2}2$ 等。\n\n这种方法并不总能成功，我们需要另外验证不等式成立的范围。\n\n## 3. 帕德逼近\n\n帕德逼近与泰勒展开的想法类似，对于函数 $f(x)$，我们构造一个分式 $R_{n,m}(x)=\\dfrac{p_n(x)}{q_m(x)}$，其中 $p_n(x),\\;q_m(x)$ 分别为 $n$、$m$ 次多项式。我们需要找到这样的分式，满足在 $x_0$ 处与原函数有相同的 $n+m$ 阶导数，即对于任意 $k\\in [0,n+m]$，$f^{(k)}(x_0) = R_{n,m}^{(n+m)}(x_0)$。这样的 $R_{n,m}(x)$ 就是原函数在 $x_0$ 处的 $[n,m]$ 阶帕德逼近。\n\n常见函数的帕德逼近参见下表，可由代码 [pade.py](https://github.com/memset0/naive-toys/blob/master/pade-approximants/pade.py) 验证。\n\n| $e^x$ | $m=0$                                      | $m=1$                                             | $m=2$                                              |\n| ----- | ------------------------------------------ | ------------------------------------------------- | -------------------------------------------------- |\n| $n=0$ | $1$                                        | $\\dfrac{x+1}{1}$<small>（恒小于）</small>         | $\\dfrac{x^2+2x+2}{2}$                              |\n| $n=1$ | $\\dfrac{1}{-x+1}$<small>（恒大于）</small> | $\\dfrac{x+2}{-x+2}$                               | $\\dfrac{x^2+4x+6}{-2x+6}$<small>（恒大于）</small> |\n| $n=2$ | $\\dfrac{2}{x^2-2x+2}$                      | $\\dfrac{2x+6}{x^2-4x+6}$<small>（恒小于）</small> | $\\dfrac{x^2+6x+12}{x^2-6x+12}$                     |\n\n| $\\ln(x+1)$ | $m=1$                                      | $m=2$                                           |\n| ---------- | ------------------------------------------ | ----------------------------------------------- |\n| $n=0$      | $x$<small>（恒小于）</small>               | $\\dfrac{2x-x^2}{2}$                             |\n| $n=1$      | $\\dfrac{2x}{x+2}$                          | $\\dfrac{x^2+6x}{4x+6}$<small>（恒大于）</small> |\n| $n=2$      | $\\dfrac{2x}{x+2}$<small>（恒大于）</small> | $\\dfrac{3x^2+6x}{x^2+6x+6}$                     |\n\n#### 3.1.1. 应用：一类“比大小”问题\n\n> [!example] 例：2022 年新高考全国 I 卷 7.\n>\n> 设 $a=0.1e^{0.1}$，$b=\\dfrac 19$，$c=-\\ln 0.9$，则（$\\quad$）\n>\n> A. $a<b<c\\quad$ B. $c<b<a\\quad$ C. $c<a<b\\quad$ D.$a<c<b\\quad$\n\n一般的做法肯定是构造函数，但这里我们试图用 $[2,2]$ 阶帕德逼近的结果代入一下：\n\n$$\n\\left\\{\\begin{aligned}\n10\\cdot a &= \\frac{0.01+0.6+12}{0.01-0.6+12} = \\frac{12.61}{11.41} \\\\\n10\\cdot b &= \\frac{10}{9} \\\\\n10\\cdot c &= \\frac{0.6-0.03}{0.01-0.6+6} = \\frac{5.7}{5.41} \\\\\n\\end{aligned}\\right.\n$$\n\n先比较简单的两个，发现 $a<b$ 且 $c<b$，还需要一个三位数乘四位数的乘法就可以得到答案，相比直接构造还是能省下不少时间。\n\n下图由 Geogebra 绘制，可以发现我们的精度在 $x=0.1$ 处可谓绰绰有余。\n\n![](https://img.memset0.cn/2024/02/11/mx5MafKR.png)\n\n#### 3.1.2. 应用：手算 $\\ln(x)$ 的值\n\n将 $x$ 拆分成 $x=2\\cdot \\dfrac{c_1+1}{c_1}\\cdot \\dfrac{c_2+1}{c_2}\\cdot \\dfrac{c_3+1}{c_3} \\cdots$ 的形式，然后代入 $\\ln 2=0.693$，$\\ln\\left(\\dfrac{n+1}{n}\\right)\\sim\\dfrac{2}{2n+1}\\quad (n\\ge 3)$ 得近似值。\n\n> [!example] 例：求 ln(11)\n>\n> $$\n> \\begin{aligned}\n> \\ln 11\n> &= \\ln \\dfrac {11}{10} + \\ln 5 + \\ln 2 \\\\\n> &= \\ln \\dfrac {11}{10} + \\ln {5}{4} + 3\\ln 2 \\\\\n> &\\approx \\frac {2}{21} +\\frac {2}{9}+3\\times 0.693 \\approx 2.3964)\n> \\end{aligned}\n> $$\n>\n> 计算结果与真实值 $\\ln (11) = 2.397895\\ldots$ 较为接近。\n\n注意到 $\\ln\\left(\\dfrac{n+1}{n}\\right)\\sim\\dfrac{2}{2n+1}$ 这一近似实际上就是 $\\ln(x+1)$ 的 $[1,1]$ 阶帕德逼近。\n\n这种方法一般情况下可精确到 $2$ 至 $3$ 位，$x\\le 1000$ 时最大误差约为 $0.0071$（参考代码：[ln-x.py](https://github.com/memset0/naive-toys/blob/master/pade-approximants/ln-x.py)）。比直接使用帕德逼近精度更高，且计算量较小，适合笔头计算。\n\n> [!quote] 参考资料\n>\n> - [泰勒级数 - Wikipedia](https://zh.wikipedia.org/wiki/%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0)\n> - [帕德近似 - Wikipedia](https://zh.m.wikipedia.org/zh-hans/%E5%B8%95%E5%BE%B7%E8%BF%91%E4%BC%BC)\n> - [帕德逼近 (Padé approximation) - 数值分析大巴](https://numanal.com/pade-approximants/)\n> - [三步手撕任意 lnx - 火星课堂, bilibili.com](https://www.bilibili.com/video/BV1Hr4y1Q7Zf)\n> - [帕德逼近（Pade’s Approximant) - 玺之, zhihu.com](https://zhuanlan.zhihu.com/p/92873681)\n> - [帕德近似如何操作？ - 枍倾尘, zhihu.com](https://www.zhihu.com/question/465913059/answer/1948539534)\n> - [【导数问题】函数逼近的一些方法 - 零号的鬼, zhihu.com](https://zhuanlan.zhihu.com/p/123329716)\n> - [第二章 : 函数放缩问题 ● 实洛朗级数 - 高考数学呆哥, zhihu.com](https://zhuanlan.zhihu.com/p/339473156)\n> - [【升级の高中数学／导数】函数逼近的三种方法——泰勒展开、帕德逼近与洛朗级数 - 霜夏, zhihu.com](https://zhuanlan.zhihu.com/p/530933700)\n","publishedTitle":"浅谈高中数学中常用的逼近方法"}},{"id":"de10309d-7f7d-5a0f-a800-67d0afe764f6","fields":{"slug":"/course/co/note/3/","plainText":"\n> 本篇笔记围绕 RISC-V 架构介绍了计算机指令系统的基本概念。首先介绍了 RISC-V 的 32 个通用寄存器及其约定用途，包括零寄存器、返回地址寄存器、堆栈指针等。接着讨论了内存系统的特点，包括字节寻址、小端存储等概念。重点阐述了 RISC-V 的指令格式(R/I/S/B/U/J 型)及其编码方式，详细介绍了分支指令、过程调用指令、数据加载存储指令、跳转指令等常用指令的使用方法和实现细节。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n我们的课程和教材围绕 RISC-V 架构编写，因而本章也将围绕 RISC-V 中的设计展开。\n\n> [!faq] Why RISC-V Architecture?\n>\n> - 开放。\n> - 具有现代 **指令集架构(Instruction Set Architecture, ISA)** 的特征。\n> - 类似的 ISA 在市场上占据很大份额。\n\n## 1. Register\n\nRISC-V 架构提供 ==32 个== 数据寄存器，每个寄存器的大小是 ==64 位==。（_设计原则：smaller is faster_，寄存器的空间远小于内存）\n\nRISC-V 中对寄存器的约定如下（不过，对于其中的一些寄存器，我们在自己做题的时候也不是不能混用）：\n\n- $\\texttt{x0}$ ($\\texttt{zero}$) 常量 0。这一寄存器的值一直是 0。\n- $\\texttt{x1}$ ($\\texttt{ra}$) 保存 **返回地址(return address)**，即完成过程调用后 PC 需要回到的位置。\n  - 所以说伪指令 `ret` 其实就是 `jalr x0, 0(x1)`。\n- $\\texttt{x2}$ ($\\texttt{sp}$) 是 **堆栈指针(stack pointer)**，始终指向==栈顶元素==。\n  - 栈==从高地址向低地址增长==，例：`addi sp, sp, -24` , `sd x5, 16(sp)` , `sd x6, 8(sp)` , `sd x20, 0(sp)`  可以实现将 x5, x6, x20 压栈。\n- $\\texttt{x5} \\sim \\texttt{x7}$ ($\\texttt{t0} \\sim \\texttt{t2}$) - $\\texttt{x7}$($\\texttt{t2}$) 和 $\\texttt{x28} \\sim \\texttt{x31}$ ($\\texttt{t3} \\sim \\texttt{t6}$) 是 **临时寄存器(temporary register)**，不保证在经过过程调用之后临时寄存器的值不变，需要的话应由 caller 保存。\n- $\\texttt{x8} \\sim \\texttt{x9}$ ($\\texttt{s0} \\sim \\texttt{s1}$) 和 $\\texttt{x18} \\sim \\texttt{x27}$ ($\\texttt{s2} \\sim \\texttt{s11}$) 是 **保留寄存器(saved register)**，保证过程调用前后这些寄存器的值不变。如果 callee 需要修改这些寄存器，就需要再堆栈中保存一份，以便在返回前恢复。\n- $\\texttt{x10} \\sim \\texttt{x17}$ ($\\texttt{a0} \\sim \\texttt{a7}$) 用于存储过程参数或者数返回值。\n  - 函数调用的前 8 个参数会放在这些寄存器中；如果参数超过 8 个则需要放到栈上（例：放在  $\\texttt{fp}$  上方， $\\texttt{fp} + 8$  是第 9 个参数， $\\texttt{fp} + 16$  的第 10 个……）。\n  - 在过程调用结束后，过程的返回值也应被放在这些寄存器中。像 C 语言一般来说只有一个，就放在 $\\texttt{x10}$ ($\\texttt{a0}$) 寄存器中。\n\n> [!note]- Read More\n>\n> - 一些 RISC-V 编译器保留寄存器  `x3`  用来指向静态变量区，称为 global pointer `gp` 。\n> - 一些 RISC-V 编译器使用  `x8`  指向 activation record 的第一个 dword，方便访问局部变量；因此  `x8`  也称为 frame pointer `fp` 。在进入函数时，用  `sp`  将  `fp`  初始化。\n>   - `fp`  的方便性在于在整个程中对局部变量过的所有引用相对于  `fp`  的偏移都是固定的，但是对  `sp`  不一定。当然，如果过程中没有什么栈的变化或者根本没有局部变量，那就没有必要用  `fp`  了。\n> - RISC-V 架构还提供一系列浮点数寄存器 `f0` ~ `f31`，不过这并不是这里我们讨论的重点。\n\n> [!summary] Cheetsheet\n>\n> ![|538](https://img.memset0.cn/2024/11/04/HVDSFt0e.png)\n\n## 2. Memory\n\nRISC-V 结构的内存按照 ==8 位== 为一个 **字节(byte)** 存储，地址宽度为 ==64 位==。此外，一个 word 为 32 位，一个 **双字(doubleword)** 为 64 位。也就是说，RISC-V 架构的指令总共可以寻址 $2^{64}$ 个字节，也即 $2^{67}$ 个 bit 或者 $2^{61}$ 个 dword。\n\nRISC-V 架构使用 **小端存储(Little Endian)**，即最低有效位放在内存最低处。按照小端存储的方式存储 0x12345678 得：(low) 78 56 34 12 (high)（如果按照一般逻辑，从左到右进行书写，实际上是是对应 **大端存储(Big Endian)**）。\n\n> [!info] Memort Alignment\n>\n> CPU 一次只能读出 4 字节内存中的一行，所以为了一次性读出下图结构体中的 `float e`，需要使用 **内存对齐(memory alignment)** 的技术。\n>\n> ![|280](https://img.memset0.cn/2024/11/11/LrRHT6l4.png)\n\n> [!info] Constant vs Immediate Operands？\n> 编译器可以通过从指定地址取值的方式来实现 **常量(constant)**，为了让操作更快，我们希望引入 **立即数(immediate operands)**，从而省掉寻址的时间。（_设计原则：make common case fast_）\n\nRISC-V 支持四种 **寻址(addressing)** 方式：\n\n- **立即数寻址(immediate addressing)**\n- **寄存器寻址(register addressing)**\n- **基址寻址(base addressing)**：例：`8(sp)`\n- **PC-relative 寻址(PC-relative addressing)**\n\n![|684](https://img.memset0.cn/2024/11/12/cKPQXFYu.png)\n\n> [!info] Memory Layout\n>\n> ![|457](https://img.memset0.cn/2024/11/12/HgSNu9rL.png)\n\n## 3. Instructions\n\n根据存储程序原理，我们二进制对每一条指令编码表示，叫作 **机器码(machine code)**。\n\n> [!note] Note\n>\n> （精简指令集的）一条指令只用来实现一个运算。（_设计原则：Simplicity favors regularity_）\n\n### 3.1. Instruction Formats\n\n在 RISC-V 架构中，所有指令的长度都固定为 32 位。（_设计原则：good design demands good compromises_）\n\n这里每种指令 format 的空间分布需要记忆，部分需要用到的指令的 opcode 和 funct 会在考试时给出。\n\n![|737](https://img.memset0.cn/2024/11/12/KcGbrnLp.png)\n\n缩写解释：\n\n- rs：**源寄存器(register source)**\n- rd：**目标寄存器(register destination)**\n- imm：**立即数(immediate operands)**\n- opcode：**操作编码(operation code)**\n- funct：**函数编码(function code)**，用来和 `opcode` 共同表示运算。\n\n指令类型：\n\n- **R-type**：使用寄存器进行数字逻辑运算的指令格式，具体运算 op 由 opcode funct3 funct7  共同决定，功能为：`rd = rs1 op rs2`。\n- **I-type**：寄存器与立即数的运算，或者 load 类指令等只需要用到一个源寄存器的指令，功能为：`rd = rs1 op imm`。这里虽然立即数 `imm` 只有 12 位，但会先符号扩充到 64 位再参与运算，故立即数实际上为：`{{52{inst[31]}}, inst[31:20]}`。\n  - 立即数 **移位(shift)** 操作（`slli`、`srai` 等）是一类特殊的 I 型指令，因为对一个 64 位数进行 $\\ge 64$ 位的移位操作没有意义，所以将其 imm 的 12 位分成 6 位的 funct6 和 6 位的立即数 immed，其中 immed 用来表示移位位数。\n- **S-type**：store 类指令。这里 `rs1` 存储 **基址(base address)** 寄存器编号，`rs2` 存储源操作数寄存器编号。\n  - `sd` 指令例：`sd x9, 64(x22)`，则 `rs1` 为 22、`rs2` 为 9、`imm` 为 64。\n- **U-type**：\n\n> [!hint] 为什么 `SB` 和 `UJ` 类型指令都不存储立即数的最低位（`imm[0]`）呢？\n>\n> 因为这两种指令的立即数都是指偏移，而我们的地址是 2 字节对齐的，因此最后一位一定是 $0$，不需要存储。\n\n> [!summary] Cheatsheet\n>\n> ![|800](https://img.memset0.cn/2024/11/12/Iygimvey.png)\n>\n> ![Pesudo Instructions|468](https://img.memset0.cn/2024/11/12/ABLaJ0cn.png)\n\n### 3.2. Branch & Loop\n\n**基于相等的跳转语句**：\n\n- $\\texttt{\\color{blue}beq {\\color{blue}rs1}, {\\color{blue}rs2}, {\\color{blue}label}}$ (B-type)：相等则跳转。\n- $\\texttt{\\color{blue}bne {\\color{blue}rs1}, {\\color{blue}rs2}, {\\color{blue}label}}$ (B-type)：不相等则跳转。\n\n**基于比较的跳转语句**：注意这里的比较都是==有符号数==的比较，如果需要无符号数的比较，请使用 `bltu`、`bgeu` 等指令。\n\n- $\\texttt{\\color{blue}blt rs1, rs2, label}$ (B-type)：$\\text{if (}\\texttt{rs1} < \\texttt{rs2}\\text{) branch to instruction labeled }\\texttt{label}\\text{.}$\n- $\\texttt{\\color{blue}bgt rs1, rs2, label}$ (B-type)：$\\text{if (}\\texttt{rs1} > \\texttt{rs2}\\text{) branch to instruction labeled }\\texttt{label}\\text{.}$\n- $\\texttt{\\color{blue}ble rs1, rs2, label}$ (B-type)：$\\text{if (}\\texttt{rs1} \\leq \\texttt{rs2}\\text{) branch to instruction labeled }\\texttt{label}\\text{.}$\n- $\\texttt{\\color{blue}bge rs1, rs2, label}$ (B-type)：$\\text{if (}\\texttt{rs1} \\geq \\texttt{rs2}\\text{) branch to instruction labeled }\\texttt{label}\\text{.}$\n\n> [!note] 最热门的比较运算\n>\n> - $\\texttt{\\color{blue}slt {\\color{blue}rd}, {\\color{blue}rs1}, {\\color{blue}rs2}}$：set on less then，当 $\\texttt{rs1} < \\texttt{rs2}$ 时令 $\\texttt{rd}=1$。\n>   - 可以将比较结果搭配 `beq` 或 `bne` 语句使用。\n\n如果分支体/循环体比较长，我们可能需要 branching 到一个比较远的位置，这时需要使用 `jal` 或 `jalr` 指令，必要时可以反转条件，如下面这个例子：\n\n![|456](https://img.memset0.cn/2024/11/12/bUcump8l.png)\n\n### 3.3. Procedure\n\n一些约定：\n\n- 用 $\\texttt{a0} \\sim \\texttt{a7}\\text{ }(\\texttt{x10} \\sim \\texttt{x17})$ 这八个参数寄存器保存 **过程参数(procedure parameter)** 和 **返回值(return value)**。\n- 用 $\\texttt{ra}\\text{ }(\\texttt{x1})$ 来存储返回地址。\n  - 通过 $\\texttt{jal x1, label}$ 指令进入函数体；在过程最后用 $\\texttt{jalr x0, 0(x1)}$ 指令（等价于伪指令 `ret`）返回。\n  - 如果过程体中还需要调用其他过程，记得把 $\\texttt{ra}$ 保存到堆栈中。\n- 在过程体中，最好使用 $\\texttt{t0} \\sim \\texttt{t6}$ 这 7 个临时寄存器；尽量不要使用 $\\texttt{s0} \\sim \\texttt{s11}$ 这些保留寄存器。如果非要使用，需要手动压栈出栈保证保留寄存器的值在过程调用前后保持不变。\n\n我们可以通过对栈指针寄存器 $\\texttt{sp}$ 的控制实现 push 和 pop 功能。\n\n- **push**：$\\texttt{addi sp, sp, -8; sd ..., 8(sp)}$\n- **pop**：$\\texttt{ld ..., 8(sp); addi sp, sp, 8}$\n\n![|208](https://img.memset0.cn/2024/11/12/sFba4Dmg.png)\n\n而帧指针寄存器 $\\texttt{fp}$ 则始终指向栈顶，其在函数调用过程中保持不变（一些 RISC-V 编译器在进入过程时会自动用 $\\texttt{sp}$ 初始化 $\\texttt{fp}$），可以通过 $\\texttt{fp}$ 寄存器方便地访问局部变量、保存的参数等。\n\n![|524](https://img.memset0.cn/2024/11/12/ut3O9gGP.png)\n\n> [!example]- Example: Compile a recursive factorial function\n> ![|580](https://img.memset0.cn/2024/11/12/XYw3FYUD.png)\n\n### 3.4. Load & Store Instructions\n\nload 和 store 是唯二两个在寄存器和内存之间进行 **数据传输(data transfer)** 的指令。\n\n我们的寄存器是 64 位的（dword），但有时我们需要从内存/堆栈中读取小于 64 位的（byte/halfword/word）数据，这时候就会涉及到扩充的问题，以下 load 指令都是 **符号扩充(sign extend)** 的，\n\n- $\\texttt{\\color{blue}lb rd, offset(rs1)}$：load byte，从 $\\texttt{offset(rs1)}$ 地址开始读取 8 位并符号扩充到 64 位后保存到 $\\texttt{rd}$ 中。\n- $\\texttt{\\color{blue}lh rd, offset(rs1)}$：load halfword，从 $\\texttt{offset(rs1)}$ 地址开始读取 16 位并符号扩充到 64 位后保存到 $\\texttt{rd}$ 中。\n- $\\texttt{\\color{blue}lw rd, offset(rs1)}$：load word，从 $\\texttt{offset(rs1)}$ 地址开始读取 32 位并符号扩充到 64 位后保存到 $\\texttt{rd}$ 中。\n- $\\texttt{\\color{blue}ld rd, offset(rs1)}$：load dword，从 $\\texttt{offset(rs1)}$ 地址开始读取 64 位并保存到 $\\texttt{rd}$ 中。\n\n下面这些 load 指令则是遵循 **零扩充(0 extend)** 的：\n\n- $\\texttt{\\color{blue}lbu rd, offset(rs1)}$：load byte unsigned，从 $\\texttt{offset(rs1)}$ 地址开始读取 8 位并零扩充到 64 位后保存到 $\\texttt{rd}$ 中，常用于读取 ASCII 字符。\n- $\\texttt{\\color{blue}lhu rd, offset(rs1)}$：load halfword unsigned，从 $\\texttt{offset(rs1)}$ 地址开始读取 16 位并零扩充到 64 位后保存到 $\\texttt{rd}$ 中。\n- $\\texttt{\\color{blue}lwu rd, offset(rs1)}$：load word unsigned，从 $\\texttt{offset(rs1)}$ 地址开始读取 32 位并零扩充到 64 位后保存到 $\\texttt{rd}$ 中。\n\nstore 指令的话就是保存寄存器 ==最右边== 的（最低的）若干位。\n\n- $\\texttt{\\color{blue}sb rs2, offset(rs1)}$：store byte，保存 $\\texttt{rs2}$ 寄存器的最右 8 位到 $\\texttt{offset(rs1)}$ 地址。\n- $\\texttt{\\color{blue}sh rs2, offset(rs1)}$：store halfword，保存 $\\texttt{rs2}$ 寄存器的最右 16 位到 $\\texttt{offset(rs1)}$ 地址。\n- $\\texttt{\\color{blue}sw rs2, offset(rs1)}$：store word，保存 $\\texttt{rs2}$ 寄存器的最右 32 位到 $\\texttt{offset(rs1)}$ 地址。\n- $\\texttt{\\color{blue}sd rs2, offset(rs1)}$：store dword，保存 $\\texttt{rs2}$ 寄存器的最右 64 位到 $\\texttt{offset(rs1)}$ 地址。\n\n> [!example]- Example: String copy\n>\n> ![|500](https://img.memset0.cn/2024/11/12/607BHJlv.png)\n\n### 3.5. Jump Instructions\n\n- $\\texttt{\\color{blue}jal rd, label}$ (UJ-type)：jump and link，保存下一语句地址（$\\texttt{pc + 4}$）到寄存器 $\\texttt{rd}$ 并跳转到 $\\texttt{label}$ 处。\n  - 实现：$\\texttt{rd = pc + 4, pc = pc + imm}$。\n- $\\texttt{\\color{blue}jalr rd, imm(rs1)}$ (I-type)：jump and link register，保存下一语句地址到寄存器 $\\texttt{rd}$ 并跳转到 $\\texttt{imm + rs1}$ 地址的指令。\n  - 实现：`rd = pc + 4, pc = (imm + rs1) & 0xFFFFFFFE`，注意 $\\texttt{pc}$ 的最低位一定会被设为 $0$。\n\n> [!example]- Example: Jump address table\n>\n> - C code:\n>\n>   ```cpp\n>   switch (k) {\n>       case 0: f = i + j; break;\n>       case 1: f = g + h; break;\n>       case 2: f = g - h; break;\n>       case 3: f = i - j; break;\n>   }\n>   ```\n>\n> - assembly:\n>\n>   ![|400](https://img.memset0.cn/2024/11/13/cYBpIP5o.png)\n\n> [!note] Conception: Basic Blocks\n>\n> 一段（除了开头外）没有分支标签且（除了结尾外）没有跳转语句的指令称为一个 **基本块(basic block)**，编辑器可以识别基本块并进行优化。\n\n我们的 label 在转化为机器码时需要换算成具体的 offset。考虑一条指令的长度为 32 位 / 4 字节，故 offset 即目标地址减当前地址应刚好是相差指令数的 4 倍，但是注意 PC-relative 寻址是根据半字长（16 位 / 2 字节）为单位的，所以我们强制 offset 的最低位为 0，且这一最低位也不会表示到机器码中（SB 类型和 UJ 类型指令的特性）。\n\n> [!example] Example: Calculate offset\n>\n> - C language:\n>\n>   ```cpp\n>   while (save[i] == k) i = i + 1;\n>   ```\n>\n> - RISC-V assembler code:\n>\n>   ![|450](https://img.memset0.cn/2024/11/12/cPr6MSEe.png)\n>\n> - Machine code:\n>\n>   ![|640](https://img.memset0.cn/2024/11/12/jjYmiuAy.png)\n\n- $\\texttt{\\color{blue}lui rd, imm}$ (U-type)：load upper immediate\n  - 实现：`rd = imm << 12`。\n\n大立即数的获取：通过 `lui` 指令设置立即数的高 20 位，然后用 `addi` 指令设置立即数的低 12 位。注意：由于 `addi` 指令是 signed 的，第 12 位会被当作符号位；如果我们需要将这一位也置成 $1$ 的话，使用 `lui` 设置高 20 位的值时需先 $+1$。\n\n任意 32 位地址跳转：可以通过 $\\texttt{lui t0, address[31:12]; jalr x0, address[11:0](t0)}$ 实现任意位置跳转，如果不需要保存下一条语句地址则使用 $\\texttt{x0}$ 作为 $\\texttt{rd}$ 即可。\n\n## 4. References\n\n- [2 Instructions - 咸鱼暄的代码空间 (xuan-insr.github.io)](https://xuan-insr.github.io/computer_organization/2_instructions/)\n- [指令：计算机的语言 - HobbitQia 的笔记本](https://note.hobbitqia.cc/CO/co2/)\n- [计算机组成 | fufu 酱の NoteBook](https://csfufu.life/en/article/58dd7e69-4fe8-4936-948d-5eb7e492f78e)\n- [RISC-V 手册](http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf)\n- [RISC-V 非特权级 ISA - 鹤翔万里的笔记本](https://note.tonycrane.cc/cs/pl/riscv/unprivileged/)\n- [2.Instructions - Wu-wu-u's Notebooks](https://wu-wu-u.github.io/Notebooks/cs/systems/CO/instruction/)\n","publishedTitle":"「计算机组成」III. Instructions"}},{"id":"04a4dfb8-7594-5d94-8e09-a5f2e8b182e3","fields":{"slug":"/course/co/note/4/","plainText":"\n> 本篇笔记详细介绍了处理器的两种主要实现方式：单周期 CPU 和流水线 CPU。对于单周期 CPU，讲解了指令执行的五个阶段（IF、ID、EX、MEM、WB）、数据通路的设计以及控制单元的实现，包括一级译码和二级译码的过程。在流水线 CPU 部分，重点讨论了三种冒险（hazard）及其解决方案：结构冒险（通过分离指令和数据内存解决）、数据冒险（通过前递技术和处理 load-use hazards）以及控制冒险（通过分支预测处理）。通过对比这两种实现方式，深入理解了处理器的工作原理、性能优化方法以及各种设计权衡。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. Single-Cycle CPU\n\n### 1.1. Prelude\n\n- 单周期 CPU：每条指令都在一个时钟周期内完成，故 $\\text{CPI}=1$。时钟周期的长度取决于花费时间最长的指令。\n\n- 内存需要被分成 **指令内存(instruction memory)** 和 **数据内存(data memory)** 两个部分，分开进行读写。因为我们在这里默认的 memory 实现是只能在一个时钟周期内读或写一个位置的，所以需要把对 data memory 的访问和从 instruction memory 取出指令这两个部分分开到两块内存中进行。\n\n![|515](https://img.memset0.cn/2024/11/16/8m8KK7Ar.png)\n\n- 注意：不能简单地把线连在一起，需要用 MUX 实现选择功能。——控制信号\n\n### 1.2. Instruction Execution Overview\n\nCPU 执行指令一般分为以下五个阶段：\n\n- **取址(Instruction Fetch, IF)**：根据 $\\texttt{PC}$ 所给地址，从存储器中取出指令。  \n   ![|524](https://img.memset0.cn/2024/11/16/amfocLym.png)\n- **译码(Instruction Decode, ID)**：分析指令字段，从寄存器堆中读取一个或两个寄存器的值。\n- **执行(Execute, EX)**：实验中需要实现的指令只需要用到 ALU。\n  - 对于 R 型指令：ALU 执行相应的算数逻辑运算，并输出结果；\n  - 对于访存指令：ALU 计算基地址和立即数的和，得到数据的真正地址；\n  - 对于分支指令：ALU 将两源操作数相减，根据结果是否为 0，判断两数是否相等。\n- **访存(Memory, MEM)**：从数据内存中读或写数据，用于 load / store 指令中。（注意：不同于 x86 指令集架构，Risc-V 指令集中没有一条指令既从内存中读数据有对读出来的数据进行操作。）\n- **写回(Write Back, WB)**：将结果写回寄存器堆中。\n\n除了前两个阶段是所有指令所共有的，其他阶段根据具体指令而定，部分指令就不需要 MEM 或 WB 阶段。\n\n### 1.3. Imm Gen\n\nImm Gen 是 ID 阶段中的一个模块，用于将指令中的立即数进行 ==符号拓展== 到 32 位或 64 位以进行后续运算。\n\n- branch 指令的立即数需要补 0（Shift left 1 部分），这是因为 branch 指令的立即数最低位的 0 是省略的，需要补上。\n\n### 1.4. Datapath\n\n![|644](https://img.memset0.cn/2024/11/16/nfSQAg0L.png)\n\n全数据通路如下，实现了基本都 R 型指令和 I 型指令，以及 `ld`、`sd` 和 `beq` 指令。\n\n![|625](https://img.memset0.cn/2024/11/16/w8O0EH27.png)\n\n> [!example]- Example: 在全 datapath 中画出所用到的部分\n>\n> - R-type  \n>   ![|400](https://img.memset0.cn/2025/01/16/JuhnbDJd.png)\n> - `ld`  \n>    ![|400](https://img.memset0.cn/2025/01/16/969YtfxS.png)\n> - `sd`  \n>    ![|400](https://img.memset0.cn/2025/01/16/Gttikens.png)\n> - `beq`  \n>    ![|400](https://img.memset0.cn/2025/01/16/KfSeaeqM.png)\n> - `jal`  \n>    ![|400](https://img.memset0.cn/2025/01/16/hMLEOOVs.png)\n\n### 1.5. Control Unit\n\n通过不同的 **控制信号(control signal)** 控制多个 MUX，可以让在同一条数据通路上实现不同功能的指令，上一小节的途中蓝色的部分就是控制信号。而生成这些控制信号的原件就是 **控制单元(control unit)**。\n\n| **Signal name**                | **Effect When deasserted (=0)**                                    | **Effect when asserted (=1)**                                                                                                                               |\n| ------------------------------ | ------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| RegWrite                       | -                                                                  | 寄存器写入：将寄存器组 Write data 的输入写入到 Write register ($\\texttt{rd}$) 中                                                                            |\n| ALUSrc                         | ALU 的第二个操作数从寄存器第二个输出（Read data 2）中来            | ALU 的第二个操作数从符号拓展后的立即数（Imm Gen 生成）                                                                                                      |\n| PCSrc (Branch)                 | $\\texttt{PC}$ 的下一个值是 $\\texttt{PC+4}$                         | $\\texttt{PC}$ 的下一个值为分治语句的运算结果                                                                                                                |\n| Jump                           | $\\texttt{PC}$ 的下一个值是 $\\texttt{PC+4}$                         | $\\texttt{PC}$ 的下一个值为计算出来的跳跃地址                                                                                                                |\n| MemRead                        | -                                                                  | 数据会从数据内存的 Read data 输出，然后交由 MemtoReg 所控制的 MUX                                                                                           |\n| MemWrite                       | -                                                                  | 在数据内存 Write data 输入的数据会被写入 address 输入对应的内存                                                                                             |\n| MemtoReg<br>==(2 位)==<br><br> | 00：ALU 的计算结果会被交给寄存器堆的 Write data 输入（R 型、I 型） | 01：交给寄存器堆的数据为从数据内存中的 Write data 输出（load 指令）<br>10：交给内存器堆的数据为 $\\texttt{PC+4}$（$\\texttt{jal}$、$\\texttt{jalr}$ 指令）<br> |\n\n#### 1.5.1. ALU Control\n\n多种指令中需要用到 ALU。我们可以进行 **二级解码(2-level decode)**。在一级译码后，我们得到 $4+3$ 个控制信号，和 2 位的 `ALU_op`。\n\n![|416](https://img.memset0.cn/2024/11/16/xeXC6k5s.png)\n\n![|665](https://img.memset0.cn/2024/11/16/EAWXD06S.png)\n\n在二级译码时，我们通过上一级的 `ALU_op` 和指令中的 `func7`、`func3` 共同决定 ALU 所需操作。\n\n![|670](https://img.memset0.cn/2024/11/16/swLHYXUw.png)\n\n二级译码的方式不是唯一的，这里主要起到一个抛砖引玉的作用。\n\n> [!example] Example: 粗略估计周期时间\n> Calculate cycle time assuming negligible delays except:\n>\n> - memory (200ps), ALU and adders (200ps), register file access (100ps)\n>\n> > [!quote]- Answer\n> >\n> > ![|558](https://img.memset0.cn/2024/11/16/NwWf9hns.png)\n\n## 2. Pipeline CPU\n\n我们以小学就学过的洗衣服为例，引出流水线技术的核心思想：\n\n![|425](https://img.memset0.cn/2024/11/04/gXlLw0vr.png)\n\n流水线技术并没有减少所有工作的总时间，甚至单个工作的时间还会增加，但是我们可以让多个工作的不同阶段并行执行，从而提升指令的 **吞吐率(throughput)**，从而减少了完成所有工作的时间。\n\n- 流水线的平衡性：指不同阶段的操作所需要的时间是否一致。可以通过对指令阶段的适当划分让流水线更为平衡。\n- 流水线的级数（深度）：流水线的级数并不是越大越好，因为流水线寄存器会有一个固定延迟。\n\n所以说，流水线的级数是一个 trade-off 的设计。\n\n> [!note] RISC-V 架构是为流水线设计的\n>\n> - 所有指令都是 32 位的。\n> - Few and regular instruction formats\n>   - 源寄存器和目标寄存器的字段相同，可以在同一步进行译码和读寄存器的操作。\n> - Load/store addressing\n>   - 只在 EX 阶段计算地址，只在 MEM 阶段访问内存。\n\n对于流水线 CPU，$\\text{CPI} \\approx 1$，因为在每个时钟周期我们将一条指令送入 IF 阶段；而在下面会讲到，因为 **冒险(hazard)** 的问题，有时我们必须要插入一些 bubble。\n\n### 2.1. Pipelined Datapath\n\n![|766](https://img.memset0.cn/2024/11/04/MN5uM6ID.png)\n\n- 从右到左的流容易导致 **冒险(hazard)**，也就是这里标出的 WB 和 Branch 部分。\n\n### 2.2. Structure Hazards\n\n**结构冒险(structure hazard)**：需要的资源正忙。\n\n- 我们必须将内存拆分为指令内存和数据内存两个部分，不然在同一时刻，分别处于 IF 和 MEM 阶段的两条指令需要对内存进行操作，只能被迫暂停其中一条。\n  - 所以我们将内存分为了 inst memory 和 data memory 两个部分。\n\n### 2.3. Data Hazards\n\n**数据冒险(data hazard)**：一条指令依赖前面指令所得到的数据。在本课程介绍的五级流水线架构中，我们只需要考虑当前指令和前两条指令是否会产生 data hazards 即可；另一方面，在没有进行任何实现任何优化（如 forwarding）的流水线 CPU 中，出现 data hazards 时只需要 stall 至多两个周期。\n\n> [!question] 为什么只用考虑上两条指令的影响？\n>\n> 这其实关乎到我们实现的一个细节：对寄存器组的读写：WB 阶段的写入发生在时钟上边沿，ID 阶段的读取发生在时钟下边沿。允许我们把相互关联的两条指令的 WB 和 ID 放在同一个时钟周期进行。如果没有实现这一优化，上面的 2 就要改为 3。\n>\n> 观察下一小节 forwarding 中的配图，阴影区域的位置不同正表现了这一点。\n\n#### 2.3.1. Forwarding\n\n![|607](https://img.memset0.cn/2024/11/04/RK45A20K.png)\n\n考察这个例子，第二条指令的源寄存器是上一条指令的目标寄存器 $\\texttt{x1}$，我们可以提前把数据取出来给到第二条指令，也就是蓝色的这条通路，这种技术被称为 **前递(forwarding)** 或 **旁传(bypassing)**。如果不这样做，则需要等两个时钟周期，这样 EX 阶段得到的数据才是对的。\n\n通过以下条件实现对 data hazards 的判断从而提供 forwarding：\n\n![|460](https://img.memset0.cn/2024/11/04/mDBaG3zn.png)\n\n- 这里是因为像 `add` 这种指令在 EX 阶段结束后就能得到结果，但是像 `load` 这种指令要到 MEM 阶段结束后才能得到。\n- 具体判断时，还要注意两个附加条件（即上面截图的这段判断条件是不完整的）：\n  - 对应的 EX/MEM.RegWrite 信号或 MEM/WB.RegWrite 信号为真，即真的写入了那个目标寄存器。\n  - 对应的 EX/MEM.RegisterRd 目标寄存器或 MEM/WB.RegisterRd 目标寄存器不为 `x0`。\n\n我们使用 MUX 来实现对 forwarding 的数据通路控制。在哪个阶段可以得到结果的数据，就从那个阶段直接 forwarding 过来。\n\n![|491](https://img.memset0.cn/2024/11/04/er4z1aL3.png)\n\n还需要注意 double data hazard 的问题，考虑以下示例：\n\n$$\n\\begin{aligned}\n&\\texttt{add {\\color{blue}x1}, x1, x2}\\\\\n&\\texttt{add {\\color{blue}x1}, {\\color{blue}x1}, x3}\\\\\n&\\texttt{add x1, {\\color{blue}x1}, x4}\n\\end{aligned}\n$$\n\n在第三条语句执行到 EX 阶段时，同时存在与第一条指令的 MEM Hazard 和与第二条指令的 EX Hazard，我们需要使用最新的（most recent）结果。即，在这两者同时存在时，应处理 EX Hazard 的 forwarding；也就是说，进行对 MEM Hazard 的 forwarding 当且仅当不能进行对 EX Hazard 的 forwarding 时。\n\n最后得到的判断条件如下：\n\n```cpp\n// EX hazard\nif (EX/MEM.RegWrite and (EX/MEM.RegisterRd != 0)\n    and (EX/MEM.RegisterRd == ID/EX.RegisterRs1))\n        ForwardA = 10\n\nif (EX/MEM.RegWrite and (EX/MEM.RegisterRd != 0)\n    and (EX/MEM.RegisterRd == ID/EX.RegisterRs2))\n        ForwardB = 10\n\n// MEM hazard\nif (MEM/WB.RegWrite and (MEM/WB.RegisterRd != 0)\n    and not(EX/MEM.RegWrite and (EX/MEM.RegisterRd != 0)\n        and (EX/MEM.RegisterRd == ID/EX.RegisterRs1))\n    and (MEM/WB.RegisterRd == ID/EX.RegisterRs1))\n        ForwardA = 01\n\nif (MEM/WB.RegWrite and (MEM/WB.RegisterRd != 0)\n    and not(EX/MEM.RegWrite and (EX/MEM.RegisterRd != 0)\n        and (EX/MEM.RegisterRd == ID/EX.RegisterRs2))\n    and (MEM/WB.RegisterRd == ID/EX.RegisterRs2))\n        ForwardB = 01\n```\n\n![|591](https://img.memset0.cn/2024/11/04/A1p7bxI7.png)\n\n加入 forwarding 后得到的数据通路如下：\n\n![|692](https://img.memset0.cn/2024/11/04/jtKJEetu.png)\n\n#### 2.3.2. Load-Use Hazards Detection\n\n![|585](https://img.memset0.cn/2024/11/04/ubBcnr9y.png)\n\n考察这个例子，当前指令用到了上一条 load 指令读取出的数据。这种情况被称为 **载入-使用型数据冒险(Load-Use Data Hazard)**。即使使用了 forwarding 的技术，也必须插入一个 bubble——因为我们要到 MEM 阶段才能得到结果（而不是 EX 阶段）并 forwarding 给下一个 EX。因此，我们不光需要控制 forwarding，还需要控制 stall 一个周期。\n\n> [!example]- 考虑数据冒险的场景下计算时钟周期数\n>\n> 如果不考虑数据冒险的问题，只需要 $7+(5-1)=11$ 个时钟周期，这里 $5$ 是因为我们的 RISC-V 架构是五级流水线。但是因为数据冒险的问题，我们必须要 stall 两个周期。可以通过打乱指令顺序的方式，在指令结果相同的情况下，规避掉 Load-Use Data Hazrad 必须 stall 一个周期的问题。\n>\n> ![|600](https://img.memset0.cn/2024/11/04/msWVpgrK.png)\n\n通过以下条件判断是否存在 load-use hazard，如果确实存在，则插入一个 bubble。为什么考察的是 ID/EX.RegisterRd？因为在检测 load-use hazard 时，对应的目标寄存器编号刚好传递到这一阶段。\n\n$$\n\\begin{aligned}\n\\text{ID/EX.MemRead}\\ \\&\\&\\ ((\\text{ID/EX.RegisterRd} &= \\text{IF/ID.RegisterRs1})\\ ||\\ \\\\\\\n(\\text{ID/EX.RegisterRd} &= \\text{IF/ID.RegisterRs2}))\n\\end{aligned}\n$$\n\n通过将指令转变为 `nop` 的方式实现 stall，从而将这一指令的剩余阶段转化为 bubble（可以看做是将其包裹起来，不让其产生影响），具体可以参见实验课的课件。\n\n#### 2.3.3. Code Scheduling to Avoid Stalls\n\n前面提到了遇到 load-use hazards 时即使实现了 forwarding 也必须插入一个 stall，这显然是我们不乐意见到的，一种方法是进行 **指令重排(code scheduling)**：在不改变指令执行结果的情况下调整指令顺序，从而避免发生 load-use hazards。\n\n![|487](https://img.memset0.cn/2025/01/16/juukFftc.png)\n\n### 2.4. Control Hazards\n\n**控制冒险(control hazard)**：在有分支语句时，下一条执行的指令是什么必须依赖于上一条指令的计算结果。也因此，控制冒险也被叫做 **分支冒险(branch hazard)**。\n\n![|574](https://img.memset0.cn/2024/11/04/lcqgxCgf.png)\n\n解决 control hazard 的方法是使用 **分支预测(branch prediction)**，即提前预读一条指令过来处理的。当然预测可能有错误的时候，这时则需要把错误指令带来的影响 flush 掉，此时必须 stall 并重新获取正确的指令。\n\n**静态的(static)** 分支预测方法比如基于典型分支行为（循环大概率会跳回去接着循环）；**动态的(dynamic)** 分支预测方法比如通过硬件测量实际分支行为（记录跳转指令是否跳转的次数），这一部分将在《计算机体系结构》课程中进一步讨论。\n\n> [!question] 发生 control hazards 时需要插入几个 bubble？\n>\n> 类似于对 data hazards 的处理，发生 control hazards 时需要插入几个 stall 和控制语句的跳转在哪个阶段决定是有关的。观察下面课本给出的 datapath 可以发现，默认认为对 branch 的决策（即决定是否需要跳转）是在 MEM 阶段处理的。这种时候，一般认为需要添加 stall 使得下一条指令的 IF 阶段在这条指令的 MEM 阶段之后进行，即需要插入 3 个 bubble。\n>\n> 但容易发现，我们其实可以更早地知道跳转结果，比如在 EX 阶段，我们根据 ALU 的 Zero 输出就已经知道是否需要跳转。甚至，我们可以通过添加一个 ALU 的方式将这一判断提前到 ID 阶段进行。相关的内容在书上有专门的一小节作介绍，感兴趣的读者可以自行阅读。所以严谨的题目应该给出跳转发生的阶段，我们据此才能推定需要插入的 bubble 数。\n\n### 2.5. Pipelined Datapath & Control\n\n控制信号在 ID 阶段全部译出，随后逐级传递下去。当一个信号在之后不再用到时就不需要传递了。\n\n![|850](https://img.memset0.cn/2024/11/04/NIrsoPGm.png)\n\n## 3. References\n\n- 感谢 514imb 同学提供帮助。\n- [4 Processor - 咸鱼暄的代码空间 (xuan-insr.github.io)](https://xuan-insr.github.io/computer_organization/4_processor/)\n- [Chap 4: The Processor - NoughtQ 的笔记本](https://note.noughtq.top/system/co/4)\n","publishedTitle":"「计算机组成」IV. Processor"}},{"id":"51807d27-808f-5640-a002-efe438a563d9","fields":{"slug":"/course/co/note/5/","plainText":"\n> 本篇笔记介绍了计算机系统中的内存层次结构及其关键技术。首先讨论了 SRAM 和 DRAM 两种基本的内存技术，并引入内存层次的概念。随后详细阐述了 Cache 的工作原理，包括直接映射、全相连和组相连三种映射策略，以及处理 Cache 命中与缺失的各种策略。最后介绍了虚拟内存技术，重点讨论了页表的概念和 TLB 的应用，以及它们在地址转换过程中的作用。通过这些技术的结合，计算机系统得以在保证性能的同时有效管理内存资源。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. Memory Hierarchy\n\n在前文中，我们将 instruction 和 data 存储在内存中，而内存的读写也有快慢之分，这里介绍两种常用的内存技术：\n\n- **静态随机访问存储器(Static Random Access Memory, SRAM)**：\n  - 数据存储在晶体管中（通常用 6-8 个晶体管表示一个位），无需刷新。\n  - 读写速度快，但是空间（指占用的物理空间）占用高。\n- **动态随机访问存储器(Dynamic Random Access Memory, DRAM)**：\n  - 数据存储在电容中，需要定期刷新。\n  - 读写速度慢（一般是 SRAM 的 5-10 倍），但是空间占用低。\n\n显然，我们不可能把所有内存数据都用 SRAM 存储，只能将其中一小部分放在 SRAM 中（**一般是缓存(cache)**），而大部分放在 DRAM 中（一般是 **主存(main memory)**），这就是 **内存层级(memory hierarchy)** 的概念。\n\n![|517](https://img.memset0.cn/2024/12/09/ZcczK4K0.png)\n\n## 2. Cache\n\n由于 CPU 的执行速度远快于主存（使用了 DRAM）的速度，如果直接从 DRAM 中读写数据，CPU 就必须为了等待主存而暂停若干个时钟周期，这就是 CPU 与主存速度不匹配产生的矛盾。为此我们需要引入 cache 技术。可以关注到程序对内存的访问有如下特点：\n\n- **时间局部性(temporal locality)**，即近期访问的项目很有可能会在短时间内再次被访问。例如循环中的指令、induction variables (循环中用来计数的变量) 等。\n- **空间局部性(spatial locality)**，即近期访问项目附近的项目也有可能会在短时间内再次被访问。例如连续的指令执行，或者数组变量等。\n\n利用好这些性质，我们可以设计 cache 来在合理成本的代价下大幅优化对内存的读写速度。\n\n### 2.1. Cache Mapping Strategies\n\n![|522](https://img.memset0.cn/2024/12/09/XQHOmHlB.png)\n\n| **问题**                     | **直接映射**                                              | **全相连**                                                  | **组相连**                                                                           |\n| ---------------------------- | --------------------------------------------------------- | ----------------------------------------------------------- | ------------------------------------------------------------------------------------ |\n| **Q1: Block Placement**      | 每个块只能映射到缓存中的==一个位置==：地址 MOD 缓存块数量 | 块可以放置在缓存中的==任意位置==                            | 块可以放置在一个组中的任意位置，地址 MOD 组数量；$n$-路组相连缓存中，每组有 $n$ 个块 |\n| **Q2: Block Identification** | 使用索引字段选择块（直接映射）                            | 使用标签字段匹配块地址                                      | 使用索引字段选择组，使用标签字段匹配组内块地址                                       |\n| **Q3: Block Replacement**    | 不存在替换问题，因为每个块只能映射到一个固定位置          | 替换策略包括随机替换、LRU（最近最少使用）、FIFO（先进先出） | 在组内进行替换，替换策略包括随机替换、LRU（最近最少使用）、FIFO（先进先出）          |\n\n#### 2.1.1. Direct Map\n\n> [!note] Block\n>\n> 将相邻的若干个 byte 合并为一个 **块(block)**，下文关于 cache 的讨论都是以 block 作为基本单元进行的。我们将 byte address 的低若干位（称为 **块内偏移(byte offset)**）拿掉，就可以得到对应的 block address。则一个 block 中包含 $2^{\\text{\\#(byte offset)}}$ 个 bytes。\n\n**直接映射(direct map)** 的策略是将每个内存中的 block 唯一映射到一个缓存的 block 中。\n\n![|582](https://img.memset0.cn/2024/12/09/PCNbpY7S.png)\n\n如上图所示：memory 有 $2^{5} = 32$ 个 block，cache 有 $2^{3}=8$ 个 block，直接根据 memory 地址的低 3 位作为 cache 地址。我们将这个低 3 位称为 **索引(index)**。\n\n为了知道 cache 中实际存放的到底是 memory 中的哪个 block，我们在 cache 中还需要存储 memory 地址的高几位（上图中就是高 2 位）。我们将这个高 2 位成为 **标签(tag)**。\n\n另外，我们需要一个 **有效位(valid bit)** 来判断 cache 中存储的这个 block 是否是有效的。初始时全部无效，valid bit 为 0；当从内存中取出一个 block 后，就变成有效的了，valid bit 为 1。cache hit 当且仅当 valid bit 为 1 且 tag 与目标地址一致。\n\n![|398](https://img.memset0.cn/2024/12/09/PTUhlfoQ.png)\n\n- tag：用于标识对应内存块的唯一性\n- index：用于定位缓存中块的位置\n- offset / byte offset：用于定位块内具体的数据\n\n> [!tip] Tip: direct map cache 相关计算题\n>\n> 1.  根据一个 block 有多少个 byte/word 算出 offset；\n> 2.  根据 cache 包含多少个 block（或者叫做 cache 行）算出 index；\n> 3.  地址剩下的位为 tag；\n> 4.  不要忘了 cache 中还需要 valid bit、data bits、tag bit、dirty bit（可选），注意 index bit 并不在 cache 里面。\n\n#### 2.1.2. Fully Associative\n\n**全相连(fully associative)** 策略简单来说就是 block 可能存放到 cache 中的每一个位置（因为它们都有连线），但坏处是我们在判断 hit 时的复杂度大大增加（需要一次跟所有 cache 中的 block 比较看是否 hit）。\n\n- ==注意，全相连的实现中没有 index==，无论在地址划分还是在 cache 空间中。\n\n![|455](https://img.memset0.cn/2024/12/16/jYFHq6QI.png)\n\n另外，在替换 cache block 时也有多种策略可以采用：\n\n- **随机替换(random replacement)**：随机一个 cache 中的 block 进行替换（需要实现一个随机数生成算法）。\n- **先进先出(first in first out, FIFO)**：即选择进入时间最少的 block 覆盖掉。\n- **最近最少使用(least recently used, LRU)**：选择上一次使用时间距离现在最远的 block 覆盖掉（需要一些额外的位记录信息）。\n\n#### 2.1.3. Set Associative\n\n**组相连(set associative)** 策略是一种介于直接映射策略和全相连策略的策略。即每个 block 根据其 block address 可以对应到一组 cache blocks 中。其中每一组中都采用全相连中介绍过的替换算法。\n\n![|612](https://img.memset0.cn/2024/12/16/tVrBA8zf.png)\n\n像上图就是一个 2-way set associative 的示意图，展示了数据在 set-associative 的 cache 中的去向。更严谨的，我们可以画出其原理图，以 4-way set associative 的 cache 为例（见下图），我们用一行表示一个组，并使用 MUX 在组中选择匹配的 line。\n\n![|563](https://img.memset0.cn/2025/01/16/HTghKphL.png)\n\n特别地，我们称组的大小为 **associativity**，则判断 hit 时需要比较的次数就等于 associativity。\n\n### 2.2. Handling Hits & Misses\n\n我们根据 read / write、hit / miss、inst / data 的情况进行分类讨论，这一部分的理解会在后文关系到性能计算。\n\n- Read\n  - Hit：直接就从 cache 里读就好了\n  - Miss\n    - Data：从 memory 里把对应 block 拿到 cache，再读取相应内容。\n    - Inst：暂停 CPU 运行，从 memory 里把对应的 block 拿到 cache，从第一个 step 开始重新运行当前这条指令。\n- Write\n  - Hit\n    - **写穿(write-through)** 策略：每次写数据时既写在 cache 中，也写到 main memory 中。好处是 cache 和 main memory 始终是一致的。\n      - 一个常见的改进是引入 **write buffer**——即需要写入 main memory 时先加入到缓冲队列中，并允许 CPU 继续运行了。当 write buffer 满了的时候，也需要暂停处理器来做写入 main memory 的工作，直到 buffer 中有空闲的 entry。（因此，如果 main memory 的写入速率低于 CPU 产生写操作的速率，多大的缓冲都无济于事。）\n    - **写回(write-back)** 策略：只将要修改的内容写在 cache 里，当这个 block 要被替换掉的时候才将对应的修改写回 main memory。这种情况需要在 cache 中额外创建一个 **脏位(dirty bit)** 用于记录该 block 是否发生或修改。这对于在同一个 block 中连续有多次修改情况优化是巨大的。\n  - Miss\n    - **write-around** 策略：直接在 main memory 中进行修改，不用拿到 cache 里了。一般搭配 write-through 策略。\n    - **write-allocate** 策略：先将对应 block 拿到 cache 中再写入。==对于 write-back 策略，必须搭配这一策略。==\n\n![|667](https://img.memset0.cn/2025/01/02/kBa9D2g0.png)\n\n### 2.3. Cache Performance\n\n注意到无论我们采用什么策略，都不能保证 cache 的每次访问都 hit。而一旦 miss，就需要等待若干时钟周期去访问主存，这一代价成为 **miss penalty**。在计算 cache 性能时，必须要考虑这一部分。\n\n**平均内存访问时间(average memory access time)** 定义为：\n\n$$\n\\text{Average Memory Access Time} = \\text{Hit Time} + \\text{Miss Rate} \\times \\text{Memory Time}\n$$\n\n一般用 CPU 时间来衡量 cache 性能，即在 CPU 执行时间的基础上加上因为 cache miss 而惩罚的时间：\n\n$$\n\\begin{aligned}\n\\text{CPU Time} = (\\text{CPU execution clock cycles} + \\text{memory-stall clock cycles}) \\times \\text{clock cycle time}\\\\\n\\end{aligned}\n$$\n\n- 读延迟周期：$\\displaystyle{\\text{Read-stall cycles} = \\frac{\\text{Read}}{\\text{Program}} \\times \\text{Read Miss Rate} \\times \\text{Read Miss Penalty}}$\n- 写延迟周期：$\\displaystyle{\\text{Write-stall cycles} = \\frac{\\text{Write}}{\\text{Program}} \\times \\text{Write Miss Rate} \\times \\text{Write Miss Penalty} + \\text{Write Buffer Stalls}}$\n  - 如果 write buffer penalty 很小，可以忽略不计。\n  - 如果 block size 为 $1$，则 write miss penalty 近乎于 $0$。\n- 在 write-through 的 cache 中，read penalty 和 write penalty 可近似为相同的，由此得到：$\\displaystyle{\\text{Memory-stall clock cycles} = \\frac{\\text{Memory Accesses}}{\\text{Program}} \\times \\text{Miss Rate} \\times \\text{Miss Penalty} }$。\n\n## 3. Virtual Memory\n\n为了让多个程序可以共用一个地址，同时提高内存寻址空间，我们可以引入 **虚拟内存(virtual memory)** 的概念，这是相对于 **物理内存(physical memory)** 的而言的。当然，（需要用到的）数据还是需要被加载到物理内存中，本小节主要关注的是 **虚拟地址(virtual address)** 和 **物理地址(physical address)** 进行==转换==的技术。\n\n### 3.1. Page Table\n\n**页(page)** 是虚拟内存和物理内存的基本单元，可以类比 cache 中 block / line 的概念。一方面，我们利用了内存访问的连续性；另一方面，我们可以减少对页表大小的要求，因为虚拟地址和物理地址的 page offset 部分是相同的，不需要转换。\n\n通过虚拟内存技术，我们可以让程序访问超过物理内存本身限制的内存，这是通过和磁盘 的交互得到的，这其实比较类似于操作系统中 swap 内存的概念（但其实是两个东西）。也就是说，程序所需要的内存数据一开始在磁盘中，并通过虚拟地址的方式索引。等到程序用到时才从磁盘中取出加载到物理内存里，由于这一物理内存地址是实时分配的，我们需要通过一个 **页表(page table)** 记录虚拟内存到底被对应到了物理内存的哪一地址，根据这一物理地址我们才能在主存中查找数据。\n\n![|407](https://img.memset0.cn/2024/12/16/yyoQ90oT.png)\n\n当我们在 page table 中 miss 时，实际上就是发生了 **页错误(page fault)**，即我们请求的页并不在主存中，而在 disk 中。当 page fault 发生时，一般由操作系统负责将对应页从磁盘中取出，并载入到主存中。这也是为什么使用虚拟内存技术时，一般只能使用 write back 策略而不能使用 write through 策略，因为对 disk 的写是极慢的，不能接受一旦 miss 就只能等待 disk 写。\n\n> [!question] Page table 是 DRAM 到 disk 的缓存？\n>\n> 有人把 cache 理解成 SRAM 层和主存（DRAM 层）的缓存，而把 page table 理解成 DRAM 层和 disk 的缓存。这种说法大体上是说得通的，但并不是很严谨。就比如，在 page table 中我们并不实际存储数据，而是只存放虚拟地址和物理地址的转换关系，数据仍是存储在物理内存（主存；DRAM 层）中。\n\n> [!question] Page table 是 fully-associative 还是 direct mapped？\n>\n> 因为 page table 中的每一个位置都可以存放任意一个物理地址（即每个虚拟地址都可能对应任一个物理地址），而课件把 page table 看成一种 DRAM 层到外部存储的 cache，从而说 page table 是 fully-associative 的。但这种全相连的实现方法是通过地址转换+根据物理地址寻址实现的，而不是 cache 的那种直接连线，两者还是有不小的区别的。不过共同点是我们都可以实现 LRU 策略等等（取决于在 page faults 发生时怎么操作）。\n>\n> 而如果换一个理解，把 page table 看作是虚拟地址到物理地址的转换函数（假装是另一种定义地不太严谨的 cache？），那又可以说 page table 是 direct mapped 的。因为我们其实是直接根据虚拟地址在 page table 中查表，这和 direct mapped cache 的实现类似。\n>\n> 因此我觉得这个怎么说取决于具体语境，取决于你怎么理解。个人认为不必太纠结这个。\n\n### 3.2. Translation-lookahead Buffer\n\n注意到 page table 很大，需要存储在 DRAM 中。即和主存一样，对 page table 的访问其实是较慢的，那有没有什么办法给 page table 再实现一个缓存呢？这就是 **快表(Translation-lookahead Buffer, TLB)** 扮演的工作。TLB 放在 SRAM 中，一般采用组相连的策略（也可以是其他两种），作为 page table 的 cache。当 TLB 命中时，能直接返回 physical address，否则才需要在 page table 中重新查找。\n\n如果把 TLB 和 page table 结合起来，并且考虑根据物理地址从 cache 和主存中找数据的步骤，就可以得到下面这张流程图，据此也很好分析课件中给出的 possible / impossible 判断。\n\n![|621](https://img.memset0.cn/2025/01/03/VT7hwrqh.png)\n\n- 如果 page table 中 miss，则不可能在 TLB 中 hit。因为 TLB 中的数据是从 page table 中取出并放入的。\n- 如果在 page table 和 tlb 中 miss，则不可能在 cache 中 hit，因为页如果在 cache 中说明其有被分配物理地址，这种情况下一定能在 page table 中查到。\n\n![|654](https://img.memset0.cn/2025/01/16/IwvSuBr8.png)\n\n一般在组相连的 TLB 中使用 LRU 策略，但完整的 LRU 策略实现开销较大，一般采用一种近似的 LRU 策略。即在 TLB 中加入一个 rel bit。CPU 每隔一段时间将 rel bit 置 0，如果进行了访问就将 rel bit 置 1。当需要从 TLB 中移出 line 时，选择一个 rel bit 为 0 的行即可。\n\n> [!question] TLB 需要 dirty bit 吗？\n>\n> 如果要实现写操作，我们在 TLB 中也需要实现 dirty bit。这是因为根据 write-back 策略，我们如果对一个页进行了修改，就必须把其 dirty bit 设置为 1。而根据 write-back 策略，这个页肯定已经被加载到 TLB 中，所以我们只需要在 TLB 中讲其 dirty bit 设置为 1，并且在这个页被移出 TLB 时把修改应用到 page table 中即可。\n>\n> 设想如果我们没有在 TLB 中实现 dirty bit，则每次标记 dirty bit 都需要对 page table 进行操作，这显然会带来额外的时间开销；而如果不操作的话，数据一致性就不能保证。\n\n## 4. References\n\n- 感谢 514imb 同学提供帮助。\n- [5 Cache - 咸鱼暄的代码空间 (xuan-insr.github.io)](https://xuan-insr.github.io/computer_organization/5_cache/)\n- [5 Memory - 时雨的笔记本](https://birchtree2.github.io/%E5%A4%A7%E4%BA%8C%E4%B8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/5_Memory.html)\n- [Chap 5: Memory Hierarchy - NoughtQ 的笔记本](https://note.noughtq.top/system/co/5)\n","publishedTitle":"「计算机组成」V. Memory"}},{"id":"18032122-3ba7-5f89-9a2f-896fbea22a7d","fields":{"slug":"/course/dd/note/1/","plainText":"\n> 本篇笔记概述了数字系统和信息的基本概念，包括数字电路、数字信号与模拟信号的区别，逻辑系统的分类（组合电路与时序电路），以及数字计算机和嵌入式系统的结构与设计过程。此外，还介绍了数字系统中的进制、编码方式（如 BCD 码、格雷码和奇偶校验码）等内容，帮助读者理解数字逻辑设计的基础知识。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n> [!quote]- Word Table\n>\n> - 数字电路(digital circuit)\n> - 数字系统(digital system)\n> - **模拟信号(analog signal)**\n> - **逻辑运算(logical operator)**\n> - **波形图(waveform)**\n> - 中央处理单元(Central Processing Unit, CPU)\n> - 数字信号处理器(Digital Signal Processor, DSP)\n> - **嵌入式系统(embedded system)**\n> - 处理器(processor)\n> - **最高有效位(most significant digit, MSD)**\n\n## 1. 数字系统 Digital Systems\n\n### 1.1. 信息表达 Information Representation\n\n![|450](https://img.memset0.cn/2024/02/29/EKlm3n1t.png)\n\n- **模拟信号(analog signal)**：取值是**连续(continous)** 的。\n- **数字信号(digital signal)**：取值是**离散(discrete)** 的。\n  - **异步(asynchronous)**：在变化的时间点上是**连续**的。\n  - **同步(synchronous)**：在变化的时间点上也是**离散**的；由**时钟脉冲**控制。\n\n![|500](https://img.memset0.cn/2024/02/29/iwTGPXzI.png)\n\n- HIGH 和 LOW 是噪声容限。\n- 图中 HIGH 和 LOW 的接受范围内存在一段阈值区间，落在这一部分的电平是**未定义(undefined)**  的，也被称为是**浮动(floating)**  的。如果输出的电平是在浮动区间的，那么其认定值将是随机的。\n- 硬件层面上，将模拟信号转化为数字信号的工作一般通过**晶体管(transistors)**  实现。\n\n> [!important] “宽进严出”规则\n> ==输出时的接受范围会比输入时的略小一些==。其目的是为了进一步提高电路在噪音等异常影响下也能正常表现的能力。\n\n> [!quote]- Positive Logic\n> 事实上，在信息的对应上，虽然将高低电平同 HIGH/LOW 联系是很自然的，但是将他们同 true/false 或者 1/0 联系其实并不唯一。但是在一般情况下（我们称之为 positive logic），我们都认为 HIGH ~ true ~ 1， LOW ~ false ~ 0。\n\n### 1.2. 逻辑系统 Logic System\n\n![|292](https://img.memset0.cn/2024/02/29/9GqTsPkI.png)\n\n- 组合电路和时序电路的主要区别在于有没有**系统状态(system state)**。\n\n#### 1.2.1. 组合电路 Combinational Logic System\n\n- 没有状态 No state present\n- 只需要推导出一个函数即可 Output Function: Output = Function(Input)\n\n#### 1.2.2. 时序电路 Sequential Logic System\n\n- 存在状态 State present\n  - Synchronous Sequential System <=> State updated at discrete times\n  - Asynchronous Sequential System <=> State updated at any time\n- **次态方程** State Equation: Next State = Function(Current State, Input)\n- **输出方程** Output Function: Output = Function(State, Input(optional))\n\n### 1.3. 数字计算机 Digital Computer\n\n**数字计算机(digital computer)**：A general-purpose system used to process the discrete values\n\n**嵌入式系统(embedded system)**：Computers as integral parts of other products\n\n![|498](https://img.memset0.cn/2024/02/29/p6SvckWy.png)\n\n- 是典型的 **Synchronous** Sequential System。\n\n#### 1.3.1. 计算机系统结构\n\n![|471](https://img.memset0.cn/2024/02/29/1OmqXAwc.png)\n\n- Algorithm\n- Programming Language\n- Operation System\n- **指令集结构** Instruction Set Architecture (ISA)\n- Microarchitecture\n- Register Transfer\n- Logic Circuit\n- Transistor Circuit\n\n#### 1.3.2. 设计过程 Design Procedure\n\n如何设计一个程序？\n\n1. Specification\n2. Formulation\n3. Optimization\n   - Apply 2-level and multiple-level optimization\n   - Draw a logic diagram or provide a netlist for the resulting circuit using ANDs, ORs, and inverters\n4. Technology Mapping\n   - 用已有的原件实现功能（eg. 实现 XOR Gate\n5. Verification\n   - 验证结果是否正确\n\n## 2. 数字系统 Number System\n\n### 2.1. 进制 Base\n\n| Decimal | Binary | Octal  | Hexadecimal |\n| :-----: | :----: | :----: | :---------: |\n| base 10 | base 2 | base 8 |   base 16   |\n\n- **进制(radix/base)**：collection of numberal symbols used to represent numbers in number system\n- 权重(digit weight): the counting unit value of basic digital symbols in different position. ie, weight $W$\n- **表示(representation)**：digits of a number $N$ are listed From left to right, length $n+m$（有整数部分和小数部分）\n  - String of Digits: $(N)_R = (A_{n-1} A_{n-2} \\ldots A_1 A_0 \\cdot A_{-1} A_{-2} \\ldots A_{-m+1} A_{-m})_R$\n  - **全展开式(Power Series)**: $(N)_R = \\left(\\displaystyle\\sum_{i=-m}^{n-1} A_i R^i\\right)_R$\n\n![|408](https://img.memset0.cn/2024/02/29/W6SstT31.png)\n\n### 2.2. 进制转换\n\n略。\n\n- 别忘了小数怎么搞。\n- **舍入(rounding)** 的问题。\n\n## 3. 编码 Coding\n\n### 3.1. 独冷码 & 独热码 One-Hot & One-Cold Code\n\n**独热码(one-hot)**  要求比特向量中只有一位是  `1`，例如  `0001`，`0010`，`0100`，`1000`  等；对应的还有**独冷码(one-cold)**。\n\n使用这种编码的好处是，决定或改变状态机目前的状态的成本相对较低，容易设计也容易检测非法行为等。\n\n但是相对应的，缺点是信息表示率较低，非法状态非常多而有效状态很少。\n\n### 3.2. BCD 码 Binary Coded Decimal Code\n\n#### 3.2.1. 8421 Code\n\n最经典的 BCD 码是 8421 码，用 4 位二进制表示一个**十进制**位，weight 分别为 8421，所以 BCD 码也叫做 8421 码。\n\n- BCD 码在做加法时，类比十进制加法一样按 4 位一组计算。\n- 当两位相加的结果大于 10 时需要做一个 +6 的修正。\n\n![|300](https://img.memset0.cn/2024/02/29/WFiHh2bR.png)\n\n#### 3.2.2. Excess3 Code\n\n**余三码(Excess3)** 是 BCD 码的一个改进，其核心思路是在 BCD 码的基础上，**增加一个大小为 3 的偏移量**。（每一位都是先 +3 再转化成二进制）\n\n- **进位检测**：注意到 $3=\\dfrac{16-10}{2}$，这样十进制下能进位的两个数位，在余三码下也刚好能进位。\n\n#### 3.2.3. 2421 Code\n\n2421 码与 8421 码类似，但是每一位的权值分别为 2421。$0\\sim 9$ 中的每一个数都对应一个唯一的 2421 码，但将不在这一对应表中的二进制编码转换回十进制时也能对应到 $0\\sim 9$ 中的数字。\n\n- 2421 码的一个特性是 $x$ 和 $9-x$ 的 2421 码互补，其中 $x=0 \\sim 4$ 时的 2421 码就是其二进制，而 $x=5\\sim 9$ 的 2421 码就是 $9-x$ 与 $1111_{(2)}$ 异或后的结果。\n\n### 3.3. 格雷码 Gray Code\n\n**格雷码(gray code)** 是一种**可靠性编码(reliable code)**。相邻的两个数字的格雷码只有一个 bit 上的 0/1 不同。\n\n> [!info] 可靠性编码\n> Reliable codes are codes that can reduce error, detect error and correct error are called reliable code.\n\n![从光学透镜的角度理解格雷码|252](https://img.memset0.cn/2024/03/07/stANosFs.png)\n\n> [!important] 二进制反射格雷码(Binary Reflected Gray Code, BRGC)\n>\n> 数字 $x$ 对应的格雷码为：\n> $$x \\text{ XOR } (x \\text{ SHR } 1)$$\n\n### 3.4. 奇偶校验码 Parity Code\n\n**奇偶校验码(parity code)** 也是一种可靠性编码，分为偶校验码和奇校验码两种。**偶校验码(even parity code)** 保证数据中为 1 的 bit 数为偶数，**奇校验码(odd parity code)** 保证为奇数。\n\n![奇偶校验码示例|398](https://img.memset0.cn/2024/03/07/ffltccLq.png)\n\n- 需要注意是奇校验还是偶校验\n- 需要注意是补在最高位还是最低位\n","publishedTitle":"「数字逻辑设计」Chapter 1. Digital Systems and Information"}},{"id":"d0d34f16-85d9-5b53-843a-655a0df4f58e","fields":{"slug":"/course/dd/note/2/","plainText":"\n> 本篇笔记主要介绍了组合逻辑电路的基本概念，包括逻辑运算、逻辑门的类型及其特性、布尔代数的基本法则、规范形式以及卡诺图的使用方法。此外，还探讨了电路优化的目标和方法，帮助读者理解如何在设计中实现高效的逻辑电路。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n> [!quote]- Word Table\n>\n> - 集成电路(integreated circuit)\n> - 逻辑门(logic gate)\n> - 取反(complement)\n\n## 1. 逻辑和逻辑门 Binary Logic and Gates\n\n### 1.1. Logical Operators\n\n三种基本的**逻辑运算(logical operator)**：\n\n- **和(and)** is denoted by $\\cdot$ or $\\land$；\n- **或(or)** is denoted by $+$ or $\\lor$；\n- **非(not)** is denoted by $\\overline{\\,\\,}$ or $\\sim$。\n\n![认识基本的逻辑门|717](https://img.memset0.cn/2024/03/07/V0JNs4Cc.png)\n\n- 在与门和或门与线连接处画小圆圈可以表达非的意思。\n- 逻辑门在从 01 直接跃迁时需要时间，在设计时序电路时可能需要考虑。\n\n![用电路表示的逻辑运算|551](https://img.memset0.cn/2024/03/07/HD2quX1U.png)\n\n### 1.2. Logic Gates\n\n**逻辑门(logic gate)** 是在硬件层面上实现布尔代数的逻辑单元。其操作对象为高低电平。但是由于是物理层面的实现，所以会有一些逻辑运算层面不会出现的问题，比如  **延时(delay)**。\n\n| CMOS   | TTL    |\n| ------ | ------ |\n| 功耗小 | 效率高 |\n\n### 1.3. Universal Gates\n\nNAND 和 NOR 门是**通用门(universal gate)**。\n\n## 2. Additional Gates and Circuits\n\n### 2.1. NAND Gates\n\nPROS:\n\n- 是实现起来最简单最快的电路门。The NAND gate is the natural implementation for the simplest and fastest electronic circuits\n- 是通用门——可以通过与非门的组合表示任意布尔运算。Universal gate - a gate type that can implement any Boolean function.\n\n### 2.2. Buffer\n\n**缓冲器(buffer)**：\n\n![oOztBCsR.png|642](https://img.memset0.cn/2024/03/14/oOztBCsR.png)\n\nPROS:\n\n- 可以抬高电路电压。A buffer is an electronic amplifier used to improve circuit voltage levels\n- 可以加速电路操作。To increase the speed of circuit operation.\n\n### 2.3. 3-State Buffer\n\n**三向缓冲器(3-state buffer)**：除了输入和输出，它还有一个**使能端(enable)** 来控制输出。\n\n![OMyeNuBx.png|674](https://img.memset0.cn/2024/03/14/OMyeNuBx.png)\n\n- Hi-Z 高阻态（可以理解为悬空）\n\n## 3. 布尔代数 Boolean Algebra\n\n### 3.1. 基本法则 Basic Laws\n\n| Law               | Formulas                                                                                                                |\n| ----------------- | ----------------------------------------------------------------------------------------------------------------------- |\n| 0-1 Law           | $\\begin{aligned}&X+0=X\\quad X\\cdot 1=X\\\\ &X+1=1\\quad X \\cdot 0 = 0\\end{aligned}$                                        |\n| Overlapping Law   | $X+X=X\\quad X \\cdot X = X$                                                                                              |\n| Complementary Law | $X+\\overline{X}=1\\quad X\\cdot \\overline{X} = 0$                                                                         |\n| Involution Law    | $\\overline{\\overline{X}}=X$                                                                                             |\n| Commutative Law   | $X+Y=Y+X \\quad XY=YX$                                                                                                   |\n| Associative Law   | $X+(Y+Z)=(X+Y)+Z\\quad X(YZ)=(XY)Z$                                                                                      |\n| Distributive Law  | $X(Y+Z)=XY+XZ\\quad X+YZ=(X+Y)(X+Z)$                                                                                     |\n| DeMorgan's Law    | $\\overline{X+Y}=\\overline{X}\\cdot\\overline{Y}\\quad \\overline{X \\cdot Y}=\\overline{X}\\cdot \\overline{Y}$                 |\n| Absorptive Law    | $\\begin{aligned}&A(A+B)=A\\quad A+AB=A\\\\ &A(\\overline{A}+B)=AB\\quad A+\\overline{A}B=A+B\\end{aligned}$                    |\n| Including Law     | $\\begin{aligned}&(A+B)(\\overline{A}+C)(B+C)=(A+B)(\\overline{A}+C)\\\\ &AB+\\overline{A}C+BC=AB+\\overline{A}C\\end{aligned}$ |\n\n> 也可以考虑使用**亦或(xor)** 进行化简，因为亦或运算有很好的结合律。\n\n#### 3.1.1. Merge Terms\n\nApplying formula: $\\color{blue}A+\\overline{A}=1$.\n\n$$\n\\begin{aligned}\nF & =ABC+A\\overline{BC}+AB\\overline{C}+A\\overline{BC}\\\\\n & =AB(C+\\overline{C})+A\\overline{B}(C+\\overline{C}) \\\\\n & =AB+A\\overline{B}=A(B+\\overline{B})=A\n\\end{aligned}\n$$\n\n#### 3.1.2. Absorb Terms\n\nApplying Absorptive law: $\\color{blue}A+AB=A$.\n\n$$\n\\begin{aligned}\nL & =A\\overline{B}+A\\overline{B}C+A\\overline{B}DE \\\\\n & =A\\overline{B}(1+C+DE)=A\\overline{B}\n\\end{aligned}\n$$\n\n#### 3.1.3. Match Terms\n\nApplying formula: $\\color{blue}A+\\overline{A}=1$, $\\color{blue}A\\overline{A}=0$, add new terms.\n\n$$\n\\begin{aligned}\nL &=AB+\\overline{A}C+BCD=AB+\\overline{A}C+BCD(A+\\overline{A}) \\\\\n & =AB+\\overline{A}C+ABCD+\\overline{A}BCD=AB+\\overline{A}C\n\\end{aligned}\n$$\n\n#### 3.1.4. Eliminate Terms\n\nApplying Absorptive law: $\\color{blue}A+\\overline{A}B=A+B$.\n\n$$\n\\begin{aligned}\nL &=\\overline{A}+AB+\\overline{B}E=\\overline{A}+B+\\overline{B}E=\\overline{A}+B+E\n\\end{aligned}\n$$\n\n### 3.2. 规范形式 Canonical Form\n\n对于一个逻辑变量 $X_i$，我们称 $X_i$ 为它的 true form，$\\overline{X_i}$ 为它的 complemented form。\n\n**最小项(minterm)**：Minterms are **AND** terms with every variable present just once in either true or complemented form.\n\n- 所有 $n$ 个变量都需要出现在最小项中，一个最小项与真值表的一行相对应。\n- 用 $m_i$ 表示第 $i$ 个最小项，如 $n=3$ 时 $m_0=\\overline{ABC}$，$m_4=A\\overline{BC}$。\n- 对于一组变量的取值，只有一个最小项为 $1$。\n- 任意两个最小项的积一定是 $0$：$m_i \\cdot m_j = 0 \\quad(i\\neq j)$。\n- 所有最小项的和为 $1$：$\\displaystyle{\\sum_{i=0}^{2^n-1} m_i} = 1$。\n- 对于任意一个逻辑函数 $F$，$m_i$ 要么在 $F$ 的 DNF 中要么在 $\\overline{F}$ 的 DNF 中。\n\n**最大项(maxterm)**：Maxterms are **OR** terms with every variable\nappearing just once in true or complemented form.\n\n- 用 $M_i$ 表示第 $i$ 个最小项，如 $n=3$ 时 $M_4 = \\overline{A} + B + C$（注意这里对应 literal 的方式和最小项是相反的）。\n- 对于一组变量的取值，只有一个最大项为 $0$。\n- 任意两个最大项的和一定是 $1$：$M_i+M_j = 1 \\quad (i\\neq j)$。\n- 所有最大项的积为 $0$：$\\displaystyle{\\prod_{i=0}^{2^n-1} M_i= 0}$。\n- 对于任意一个逻辑函数 $F$，$M_i$ 要么在 $F$ 的 CNF 中要么在 $\\overline{F}$ 的 CNF 中。\n\n**最小项之和(sum of minterm, SOM)** 也被称为 DNF，**最大项之积(product of maxterm, POM)** 也被称为 CNF。所有命题函数都可以被化简成这种形式，这两种形式被称为**规范形式(canonical form)**。\n\n> [!note] Comment\n>\n> - 要学会 DNF/CNF 的化简，前者可以直接从真值表中扣出来，后者先取反做然后用德摩根定律得到。具体参见离散数学笔记。\n>\n> - 要注意最小项和最大项的编号顺序，他们之中对应项的单个 literal 恰好是**相反的**。\n\n![YgHQXOr3.png|651](https://img.memset0.cn/2024/05/11/YgHQXOr3.png)\n\n### 3.3. 标准形式 Normal Form\n\n可以通过卡诺图化简得到**积之和(sum-of-product, SOP)** 或**和之积(product-of-sum)**。\n\n基于 SOP/POS（或者退一步的 SOM/POM）的电路被称为二级电路。二级电路与多级电路相比，好处是时延少，代价是使用的逻辑门多。\n\n更多简化方法：\n\n- “AND - OR” Simplification\n- “OR - AND” Simplification\n\n## 4. 卡诺图 Karnaugh Maps\n\n### 4.1. 使用卡诺图化简 Simplifying using Karnaugh Maps\n\n以利用三变量**卡诺图(karnaugh map, K-map)** 求 SOP 为例：将 F 所有为 1 的最小项填入表中，可以得到对应的卡诺图。如果要求 POS，则可先求 SOP，再应用一次德摩根定律转为 POS。\n\n![dcN7g5ue.png|588](https://img.memset0.cn/2024/03/14/dcN7g5ue.png)\n\n画完卡诺图后，我们需要分析其主蕴含项，即就是画尽可能大的框。\n\n- **蕴含项(implicant)**：对每一个最小项取值都为 1 的乘积项。对应卡诺图中全为 1 方格且大小为 2 的幂次的方框。\n- **主蕴含项(prime implicant)**：如果从蕴含项中移去任意一个变量，所得的乘积项就不是蕴含项，则称为质蕴含项。对应卡诺图中一个不能再向任何方向拓展的方框。\n- **质主蕴含项(essential prime implicant)**：如一个 1 方格仅存在于某个质蕴含项内，则称这样的主蕴含项是**必要(essential)** 的，称为质主蕴含项或必要主蕴含项。\n\n![JgNKlCkA.png|547](https://img.memset0.cn/2024/03/14/JgNKlCkA.png)\n\n在使用卡诺图找到布尔函数的主蕴含项后，可以利用主蕴含项进行化简。可以先选择所有的质主蕴含项，再使用一些主蕴含项来覆盖未被覆盖的方格 1。所以优化后的最优结果可能不是唯一的。有一些细节需要注意：\n\n- 找主蕴含项时，不要忘了考虑跨越边界而联通的情况。如果最后选到了一个非主蕴含项，那么这一优化结果一定不是最优的。\n- 选择多个主蕴含项时，相互之间可以重叠，注意电路优化的目标减少代价。\n\n> [!important] 卡诺图的简略画法\n>\n> 标记出 $X$ 的两个位置，$\\overline{X}$ 的记号可忽略。\n>\n> ![|260](https://img.memset0.cn/2024/03/28/vMIr8Pwp.png)\n\n### 4.2. 不定项 Don’t Care Conditions\n\n**不定项(don't-care condition)** 是指电路优化过程中，没有给出定义的项，他们可能是：\n\n- 输入组合不会出现；\n- 输入组合的输出不被使用；\n\n对于这种项，在卡诺图中用 X 来表示，在最小项之和中用 $\\sum d(\\ldots)$ 表示。我们可以随意定义它们的输出，此时就可以利用这些项来方便我们的优化——当我们画出来的极大矩阵越大，成本就越低。\n\n> [!example] 例：当 BCD 码数值大于等于 5 时返回 1\n> 可以通过进行如下方法优化：\n>\n> ![|260](https://img.memset0.cn/2024/03/14/Pry8PSNZ.png)\n>\n> 根据结果，写出优化后的表达式为：$F(W,X,Y,Z) = W+XY+XZ$。\n\n## 5. 电路优化 Circuit Optimization\n\n**电路优化(circuit optimization)** 的目标是在找到给定成本计算方式下的最优电路。\n\n- **Literal Cost**(L)：the number of literal appearances in a Boolean expression corresponding to the logic circuit diagram\n- **门输入代价(gate input cost)**(G)：the number of inputs to the gates in the implementation corresponding exactly to the given equation or equations.\n- **带非门的门输入代价(gate input cost with NOTs, GN)**: G with inverters counted\n\n$$\nF = BD + A \\overline{B}C + A\\overline{C}\\overline{D}\n\\quad\\Rightarrow\\quad\n\\text{L} = 8,\\ \\text{G} = 11,\\ \\text{GN} = 14\n$$\n\n一般来说，成本函数是一个关于 $\\text{L, G, GN}$ 的函数。\n\n> [!note] Comments\n>\n> 门输入代价需要学会计算，重要！\n","publishedTitle":"「数字逻辑设计」Chapter 2. Combinational Logic Circuits"}},{"id":"c6e4dedc-dd7f-5022-9faf-e7fae9d393ef","fields":{"slug":"/course/dd/note/3/","plainText":"\n> 本篇笔记概述了组合逻辑设计的基本概念与自动化过程，包括逻辑表示方法、设计过程、工艺映射、集成电路的分类、基本逻辑函数、译码器与编码器的功能，以及加法器和减法器的实现。通过分层设计和不同的设计方法，笔记详细探讨了如何优化和验证逻辑设计，确保其在实际应用中的有效性和效率。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n> [!quote]- Word Table\n>\n> - **组合逻辑(combinational logic)**\n> - **理由(justification)**\n\n## 1. 设计概念与自动化 Design Concepts and Automation\n\n### 1.1. 表示逻辑的方法\n\n- 真值表\n- 布尔函数\n- 卡诺图\n- **时序图(timing diagram)**\n- **逻辑电路图(logic circuit)**\n\n## 2. 设计过程 Design Procedure\n\n1. **系统描述(specification)**: 指定所需的行为。\n2. **形式化(formalization)**：以布尔方程或真值表的方式对系统的输入输出关系进行形式化\n3. **优化(optimization)**：优化逻辑的表示，减少成本。\n4. **工艺映射(technology mapping)**：将优化后的逻辑设计工艺映射到可以实现的工艺上。\n5. **验证(verification)**：验证设计的正确性。\n\n> [!quote]- **芯片定制(chip design)**\n>\n> - **全定制设计(full customized)**: 价格贵，性能高，密度高，适合大规模生产。the entire design of the chip down to the details of the layout is finished\n>   - Expensive\n>   - Justifiable only for dense, fast chips with high sales volume\n> - **标准单元设计(standard cell design)**: blocks have been designed ahead of time or as part of previous designs\n>   - Intermediate cost\n>   - Less density and speed compared to full customized\n> - **门阵列设计(gate array design)**: 密度低，性能低，价格便宜。regular patterns of gate and transistors that can be used in many designs built into chip - only the interconnections between gates are specific to a design\n>   - Lowest cost\n>   - Less **密度(density)** compared to full customized and standard cell\n\n### 2.1. 分层设计 Hierarchical Design\n\n对于复杂的数字系统，一种典型的设计方法为**分层设计(hierarchical design)**，即将复杂问题模块化分解为若干层次，然后逐个抽象解决。\n\n- 最小层的**模块(block)** 叫做**原子模块(primitive block)**。Any block that cannot be further decomposed is called a primitive block.\n- 由不同层级的基本块组成的集合叫做**层次结构(hierarchy)**。The collection of all blocks including the decomposed ones is a hierarchy.\n\n> [!quote]- 例：Hierarchy for 9-Input Parity Checker\n> ![|600](https://img.memset0.cn/2024/03/21/xyn98LEW.png)\n\n分层设计的设计方法可以分为\n\n- **自顶向下的设计(top-down design)**：分解功能设计。A top-down design proceeds from an abstract, high-level specification to a more and more detailed design by decomposition and successive refinement. Top-down design answers: What are we building?\n- **自底向上的设计(bottom-up design)**：根据现有的元件去组合成目标功能。A bottom-up design starts with detailed primitive blocks and combines them into larger and more complex functional blocks. Bottom-up design answers: How do we build it?\n\n一般从两个方向同时进行设计。一般 top-down 设计控制复杂度，bottom-up 设计聚焦于细节。\n\n### 2.2. 工艺映射 Technology Mapping\n\n工艺映射是指将优化后的逻辑设计工艺映射到有限的工艺上。\n\n比如：因为 NAND 门和 NOR 门是**通用门(universal gate)**，我们可以将任意逻辑电路映射到仅使用 NAND 门或仅使用 NOR 门的电路上。\n\n#### 2.2.1. 无传播延迟子电路 Fan-out Free Subcircuit\n\n**传播延迟(fan-out)**：一个逻辑门的输出连接到多个其他逻辑门的输入时，负载增加将导致的延迟增加。\n\n**无传播延迟子电路(fan-out free subcircuit)**：寄存器的输出不直接连接到其他逻辑门的输入，而是通过一个专门的数据总线或信号线连接到其他部分。a circuit in which a single output cell drives only one other cell.\n\n> 课件 P38，还没太懂这一部分想干嘛\n\n## 3. 集成电路 Integrated Circuits\n\n**集成电路(integrated circuit)**，即**芯片(chip)**，分为如下若干等级：\n\n- 小规模集成电路(small-scale integrated, SSI)：内含不到 10 个门；\n- 中等规模集成电路(medium-scale integrated, MSI)：内含 10 ~ 100 个门；\n- **大规模集成电路(large-scale integrated, LSI)**：内含成百上千个门；\n- **超大规模集成电路(very large-scale integrated, VLSI)**：内含成千上亿个门。\n\n## 4. 基本逻辑函数 Rudimentary Logic Functions\n\n四个初等组合逻辑函数：\n\n- **定值函数(value-fixing function)**：$F=1$ or $F=0$, no Boolean operator. 可以表示接电源或接地。\n- **(transfering)**：$F=X$, no Boolean operator.\n- **(inverting)**：$F=\\overline{X}$, involves one logical gate.\n- **使能函数(enabling function)**：$F=X\\cdot EN$ or $F=X+\\overline{EN}$, involves one or two logic gates.这里 $F=X\\cdot EN$ 在使能信号 $EN$ 为 $1$ 是被激活，否则恒为 $0$。$F=X+\\overline{EN}$ 同样需要使能信号 $EN$ 为 $1$ 来激活，但未激活时恒为 $1$。\n\n## 5. 译码器 Decoder\n\n**译码(decoding)**：把 $n$ 位二进制输入转化到 $m$ 位二进制输出的过程。保证 $n\\le m\\le 2^n$ 使得每一个合法输入都有一个不同的输出。\n\n### 5.1. 二进制译码器 Binary Decoder\n\n给定 $n$ 位二进制代码，将 decode 为其对应的最小项。\n\n![m7rSGsWc.png|620](https://img.memset0.cn/2024/03/28/m7rSGsWc.png)\n\n因为任意组合逻辑函数都可以写成 sum of minterms 的形式，我们可以用二进制译码器+或门来表示**任意**组合逻辑\n\n![B3baxDn9.png|631](https://img.memset0.cn/2024/06/19/B3baxDn9.png)\n\n### 5.2. 译码器与使能结合 Decoder with Enable\n\n在普通译码器的基础上多一个**使能信号(enable)** EN 来控制，当 EN 为 0 时无论 $A_{0}\\sim A_{n-1}$ 什么值都输出全零，否则输出对应的最小项。\n\n### 5.3. 多路分配器 Demultiplexer\n\n> cm：不考。\n\n我们可以通过带使能信号的译码器，将来自一条输入线上的信息传送到 $2^n$ 条输入线中的指定一条，实现**分配(distribution)** 功能。\n\n实现这一功能的电路称为**多路分配器(demultiplexer = demux)**。一个带使能的 $n$-$2^n$ 译码器又是一个 1-$2^n$ 多路分配器。其中 1 指的是输入信号的**位宽(bit width)** 是 1，这一输入直接接到 EN 输入处。\n\n### 5.4. 7 位数码管译码器 BCD-to-Segment Decoder\n\n实现 7 位数码管译码器，可以通过逻辑门实现布尔函数，也可以直接用上面实现多路分配器。\n\n关于 7 位数码管内部构造，可采用**共阳极(common anode)** 接法或**共阴极(common cathode)** 接法，其中前者是 0 触发，后者是 1 触发。参见下图：\n\n![e3eZevAk.png|487](https://img.memset0.cn/2024/03/28/e3eZevAk.png)\n\n## 6. 编码器 Encoder\n\n**编码(encoding)**：the conversion of an $m$-bit input code to a $n$-bit output code with $n\\le m\\le 2^n$ such that each valid code word produces a unique output code.\n\n### 6.1. 优先编码器 Priority Encoder\n\n**优先编码器(priority encoder)** 的作用是的当多个输入同时为 1 时，优先级最高的输入需要被优先处理。所以我们需要实现一个编码器，输出优先级最高的为 1 的输入是多少。其真值表如下：\n\n![0zpC1tD1.png|526](https://img.memset0.cn/2024/03/28/0zpC1tD1.png)\n\n可以提供不少无关项用于化简。\n\n> [!tip] 别忘了怎么化简\n> e.g. $A_0 = \\overline{D_4} D_3 + \\overline{D_4 D_3 D_2} D_1 = \\overline{D_4} (D_3 + \\overline{D_2} D_1)$。\n\n### 6.2. 多路选择器 Multiplexer\n\n用一组 $n$ 位的输入信号（称为**选择输入(selection input)**）选择 $2^n$ 位的输入信号中的一路到输出，实现这一功能的电路称为**多路选择器(multiplexer = mux)**，也被叫作多路分配器。\n\n![|385](https://img.memset0.cn/2025/01/17/XmTxHOMI.png)\n\n一般来说，一个 $2^{n}$-to-$1$ line MUX 需要有 $n$-to-$2^{n}$ line decoder 和 $2^n$ 个 AND 以及一个 OR：\n\n![|420](https://img.memset0.cn/2025/01/17/qMcBWS5s.png)\n\n这里介绍的 MUX 还是 1bit 的，我们也可以一次性做多位，这样的话只需要一个选择模块。下面以 4bits 4-to-1 MUX 为例：\n\n![|355](https://img.memset0.cn/2025/01/17/7wPsLVxs.png)\n\n## 7. 二进制加法器 Adder\n\n### 7.1. 半加器 Half-Adder\n\n**半加器(half-adder)**：实现两位相加的组合电路。\n\n![2OCFQL2p.png|527](https://img.memset0.cn/2024/04/11/2OCFQL2p.png)\n\n|                             真值表                             |                         卡诺图                         |                          逻辑函数                          |\n| :------------------------------------------------------------: | :----------------------------------------------------: | :--------------------------------------------------------: |\n| ![150](https://img.memset0.cn/2024/04/11/KI1OCXix.png)<br><br> | ![300](https://img.memset0.cn/2024/04/11/WG7ps2LP.png) | ![300](https://img.memset0.cn/2024/04/11/oR6fZIVR.png)<br> |\n\n如果我们选用不同的逻辑函数，就可以有不同的电路实现。其中，最常见的半加器实现如下：\n\n![|400](https://img.memset0.cn/2024/04/11/aBytdNoi.png)\n\n一个只使用 NAND 门的半加器实现如下：\n\n![|400](https://img.memset0.cn/2024/04/11/bBxUeuql.png)\n\n### 7.2. 全加器 Full-Adder\n\n**全加器(full-adder)**：实现三位相加（两位及一位**进位(carry-in bit)**）的组合电路。\n\n|                           真值表                           |                                                          卡诺图                                                          |\n| :--------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------: |\n| ![200](https://img.memset0.cn/2024/04/11/zYMENIav.png)<br> | ![200](https://img.memset0.cn/2024/04/11/MyU5i2Na.png)<br><br>![200](https://img.memset0.cn/2024/04/11/Bb7xCh5R.png)<br> |\n\n![7gbovvlo.png|587](https://img.memset0.cn/2024/04/11/7gbovvlo.png)\n\n- **进位产生函数(carry generate function)** - $X\\cdot Y$：当 $X$ 和 $Y$ 都是 $1$ 时就会发生进位。一般简写成 $G$。\n\n- **进位传递函数(carry propagate function)** - $X \\oplus Y$：当 $X$ 和 $Y$ 中恰有一个是 $1$ 的话，如果收到一个来自低位的进位，就一定会传递给高位。一般简写成 $P$。\n\n![yEVXwpWi.png|184](https://img.memset0.cn/2024/04/11/yEVXwpWi.png)\n\n一个全加器相当于由两个半加器组成，因为实际上你就是把 $X,Y,C$ 三个数加起来，用了两个半加：\n\n![3HSMTGfd.png|483](https://img.memset0.cn/2024/04/11/3HSMTGfd.png)\n\n### 7.3. 行波加法器 Ripple-Carry Binary Adders\n\n![6RdC6Rmk.png|519](https://img.memset0.cn/2024/04/11/6RdC6Rmk.png)\n\n### 7.4. 超前进位加法器 Carry Lookahead Adder\n\n> 这里仅做了解，在《计算机组成》课程中会进一步介绍。\n\n通过把进位展开，我们直接计算最后产生的进位，这里以 4bit 的超前进位加法器为例：\n\n![JDRTsfRU.png|496](https://img.memset0.cn/2024/04/11/JDRTsfRU.png)\n\n其电路实现如下：\n\n![|751](https://img.memset0.cn/2024/04/11/ZyGVEkTZ.png)\n\n考察超前进位加法器的性能：\n\n- 全加器部分：从 $A_i,B_i$ 变成 $G_i$，只需要经过一个异或门，消耗 3 单位时间。\n- CLA 部分：虽然看起来有很多个 AND、看起来电路很复杂，但是注意到与门可以多输入同时做，故实际信号只经过了一个与门和一个或门，消耗 2 单位时间。\n- 再回到全加器部分：像 $C_1,C_2,C_3$ 信号，不像 $C_4$ 可以直接输出，需要回到全加器部分再经过一个异或门，消耗 $3$ 单位时间。\n\n这样我们就得到了一个最大延迟只有 $3+2+3=8$ 个单位的 4bit 超前进位加法器。\n\n那如果我们需要 16-bit 的超前进位加法器呢？注意到中间门电路的输入数量是 $O(n^2)$ 级别的，如果一味增大 CLA，消耗的成本太高。实际上，只需要把上面电路图中的全加器替换成 CLA，就是一个 16 位的超前进位加法器。（4-bit：全加器 $\\rightarrow$ CLA；16-bit：全加器 $\\rightarrow$ CLA $\\rightarrow$ CLA）\n\n计算此实现下的 16-bit 超前进位的性能：\n\n$$\n\\text{Longest Delay} = 3 + 3 \\times 2 + 3 = 12 \\sim O(\\log n)\n$$\n\n![1PadKTUQ.png|353](https://img.memset0.cn/2024/04/11/1PadKTUQ.png)\n\n## 8. 二进制减法器 Subtractor\n\n- **被减数(minuend)**\n- **减数(subtrahend)**\n\n> [!info]- **反码(one's complement)**\n>\n> 可以通过二进制按位取反得到。\n>\n> ![|500](https://img.memset0.cn/2024/04/11/iuE11HK5.png)\n\n> [!info] **补码(two's complement)**\n>\n> 可以通过反码加 1 得到。一般来说，我们直接用补码来存储负数，相当于是一个硬件层面的约定。\n>\n> ![|500](https://img.memset0.cn/2024/04/11/WtUbWMe7.png)\n\n### 8.1. 无符号减法 Unsigned Subtraction\n\n方法如下：\n\n![|540](https://img.memset0.cn/2024/04/11/oenJ08il.png)\n\n![mnJGRsj4.png|745](https://img.memset0.cn/2024/06/19/mnJGRsj4.png)\n\n> [!warning] Clarification\n> 这里无符号减法的说法其实比较迷糊，我们暂且不承认符号位（也就是用补码表示负数）这一事实。以 4-bit 为例，相当于处理两个 $[0,15]$ 值域的数 $M,N$ 的 $M-N$。如果结果是负数（在值域外），就应得到负数取反的结果，然后再“手动”填上一个负号。即计算 $3-5$ 时我们希望得到 $2$ 和一个负号，而不是直接得到 $-2$，这就是为什么上文 $M<N$ 时需要多取一次补码。\n\n### 8.2. 有符号减法 Signed Subtraction\n\n> [!info] **有符号整数(signed integer)** 的表示方法\n>\n> 最高位都是符号位，然后：\n>\n> - Signed-Magnitude：负数时，低 $n-1$ 位表示其绝对值\n> - Signed 1's Complement：负数时，低 $n-1$ 位表示其绝对值的反码\n> - Signed 2's Complement：负数时，低 $n-1$ 位表示其绝对值的补码\n>\n> 使用前两种方法会出现 $+0$ 和 $-0$ 的两种表示。一般来说，前两种方法比大小时比较方便，第三种方法做加减法比较方便，这也是我们要介绍的。\n>\n> ![|360](https://img.memset0.cn/2024/04/11/qg5AekT2.png)\n\n### 8.3. 溢出检测 Overflow Detection\n\n在同符号数字相加、异符号数相减时可能发生溢出。\n","publishedTitle":"「数字逻辑设计」Chapter 3. Combinational Logic Design"}},{"id":"6d747d89-5423-51f9-8806-986d76ccb97a","fields":{"slug":"/course/dd/note/4/","plainText":"\n> 本篇笔记介绍了时序电路的基本概念和分析方法，包括时序电路的分类（Mealy 型和 Moore 型）、离散事件模拟、锁存器和触发器的工作原理及其时序参数。详细讨论了锁存器的时序问题及其解决方案，触发器的标准符号和描述方法，以及时序电路的设计步骤和状态赋值方法。通过状态表和状态图的形式，帮助理解时序电路的行为和设计过程。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 时序电路分析 Sequential Circuit Analysis\n\n### 1.1. 时序电路介绍 Introduction to Sequential Circuit\n\n我们将某一时刻存储**存储元件(storage element)** 中的二进制信息称为该时刻时序电路的**状态(state)**。\n\n![gyONWRkQ.png|515](https://img.memset0.cn/2024/04/18/gyONWRkQ.png)\n\n按照输出除了基于当前状态之外是否依赖于输入，可以将视时序电路分为：\n\n- **Mealy 型电路(Mealy model circuit)**：输出只和前一个状态有关\n- **Moore 型电路(Moore model circuit)**：输出和输入及当前输入有关\n\n根据输入信号的时间和内部状态改变的时间，可以将时序电路分为：\n\n- **同步时序电路(synchronous sequential circuit)**：\n  - 同步时序电路是通过**时钟发生器(clock generator)** 产生周期性的**时钟脉冲(clock pulse)** 来实现的。\n  - 把时钟脉冲作为存储元件输入信号的同步时序电路称为**钟控时序电路(clocked sequential circuit)**。\n- **异步时序电路(asynchronous sequential circuit)**：\n  - Behavior defined by knowledge of inputs at any instant of time and the order in continuous time in which inputs change\n  - If clock is regarded as another input, all circuits are asynchronous!\n  - Nevertheless, the synchronous abstraction makes complex designs tractable!\n\n### 1.2. 离散事件模拟 Discrete Event Simulation\n\n可以通过**离散事件模拟(discrete event simulation)** 来更好的理解时序电路的时间行为。离散事件模拟的规则如下：\n\n![fal07yxB.png|397](https://img.memset0.cn/2024/04/18/fal07yxB.png)\n\n我们以一个二路选择器为例：\n\n![nYKitFyS.png|429](https://img.memset0.cn/2024/04/18/nYKitFyS.png)\n\n- **毛刺(glitch)**：或称瞬态错误。当 $S$ 从 $1$ 变为 $0$ 时，由于非门有 0.2ns 的延迟，由 $A \\overline{S}$\n\n如果把选择器的输出 $Y$ 直接连到输入 $A$ 上呢？\n\n![JR6iiTsg.png|489](https://img.memset0.cn/2024/04/18/JR6iiTsg.png)\n\n- 这里的 Y 不仅是输出，还可以记忆电路的**状态(state)**。\n\n如果再多加一个**反相器(inverter)** 呢？\n\n时钟发生器\n\n## 2. 锁存器 Latchs\n\n### 2.1. SR 锁存器与 S'R'锁存器 S-R Latch and $\\overline{S}$-$\\overline{R}$ Latch\n\nSR 锁存器通过两个或非门实现。\n\n![bwbO3cDX.png|576](https://img.memset0.cn/2024/06/12/bwbO3cDX.png)\n\n在 SR 锁存器中，$S=1,\\ R=1$ 的输入是**禁止的(forbidden)** 或者说**未定义的(undefined)**，此时输出端 $Q=0$ 和 $\\overline{Q}=0$ 同时成立。一般不使用这种状态。\n\nS'R' 锁存器通过两个与非门实现。\n\n![n2u8p5CN.png|537](https://img.memset0.cn/2024/06/12/n2u8p5CN.png)\n\n- S'R' 锁存器是 $0$ 触发的，即 $\\overline{S}=0$ 时将 $Q$ 置 $1$；而 SR 锁存器哈斯 $1$ 触发的，即 $S= 1$ 时将 $Q$ 置 $1$。不过从结果上来说，置为时 $Q$ 的值与 $S$ 的值应相同。\n\n- 如果 $R$ 和 $S$ 同时从 0 变成 1，则输出是**不稳定的(unstable)**。如果两个与非门的时延完全相同，则输出会在 01 之间震荡，否则会稳定在 $Q=0$ 或 $Q=1$ 中的一个状态，取决于两个与非门的时延。\n\n### 2.2. 带时钟信号的 SR 锁存器 Clocked S-R Latch\n\n多输入一路信号 $C$ 与 $S,R$ 信号作与或，这里 $C$ 可以理解为 **控制(control)** 或**时钟(clock)**。只有 $C=1$ 时输入才被接受；$C=0$ 时无论输入如何改变锁存器都为保持状态。\n\n![BkfC3qgA.png|291](https://img.memset0.cn/2024/04/18/BkfC3qgA.png)\n\n### 2.3. D 锁存器 D Latch\n\n给 Clocked S-R Latch 添加一个反相器可以得到 **D 锁存器(D latch)**，这样 $S$ 的值和 $R$ 的值一定相反，而我们通过控制信号 $C$ 来控制是否应处于保持状态。当控制输入信号有效（$C=1$）时输出 $Q$ 会根据输入 $D$ 的改变而改变，从这种意义上来讲，锁存器是**透明(transparent)** 的。\n\n> [!warning] 透明的问题——**空翻(the latch timing problem)**\n>\n> 如果直接把输出 $\\overline{Q}$ 接到 $D$ 上时，若 $C=1$，则 D 锁存器的值将不断跳变，这就是空翻问题。这主要是因为 D 锁存器的输入和输出是同时允许变化的（不是同时变化，是指在输出可以变化的时候输出也能变）\n>\n> 空翻的问题不光在 D 锁存器中存在，而是锁存器的普遍问题。\n\n![BBAcru61.png|593](https://img.memset0.cn/2024/06/12/BBAcru61.png)\n\n| $C$ | $D$ | $Q_{t+1}$ | 描述       |\n| --- | --- | --------- | ---------- |\n| 0   | X   | $Q_{t}$   | 输出不改变 |\n| 1   | 0   | 0         | 复位       |\n| 1   | 1   | 1         | 置位       |\n\n### 2.4. 锁存器的时序问题 The Latch Timing Problem\n\n锁存器存在**锁存器的时序问题(the latch timing problem)**：在时钟脉冲有效（$C=1$）时，输入信号的改变随时会引起输出的改变，即上文所说的透明性。那么当时钟脉冲保持为 1 时，锁存器的输入信号可能因为其余锁存器的输出信号的改变而改变，从而在一个时钟周期内发多次变化，这是我们要引入触发器的原因。\n\n如考虑这一电路中，$C=1$ 的时间内 $Y$ 的值会反复振荡，且最后结果不确定。而我们期望的功能时，一整段 $C=1$ 只会导致 $Y$ 的值改变一次。\n\n![bHO3VS6o.png|493](https://img.memset0.cn/2024/05/10/bHO3VS6o.png)\n\n一种可行的解决方案是：$C=1$ 时（输入的时候）先不改变输出，等到 $C=0$ 时在改变，这就是主从触发器的原理。\n\n### 2.5. 锁存器的标准符号 Standard Symbols for Latches\n\n![iFJ7MCYp.png|490](https://img.memset0.cn/2024/04/18/iFJ7MCYp.png)\n\n## 3. 触发器 Flip-Flop\n\n### 3.1. 主从触发器 Master-Slave Flip-Flop\n\n![2ksxJEq7.png|313](https://img.memset0.cn/2024/04/18/2ksxJEq7.png)\n\n**主从触发器(master-slave flip-flop)** 一般通过将两个 SR 锁存器先后连接起来所得到，其中前者称为**主锁存器(master latch)**，后者称为**从锁存器(slave latch)**，两者的控制信号是相反的。\n\n> [!warning] 主从触发器的缺憾——**一次性采样问题(1s catching problem)**：\n>\n> 如果 $C=0$ 时触发器的输入是 $S=0$，$R=0$，但是由于电路问题出现了 $S=1$ 或 $R=1$ 的**毛刺(glitch)**，就会改变主锁存器的值（而不是像期望的那样处于保持状态），并将这一有问题的修改在下一个时钟上升沿到来时传递给从锁存器。\n>\n> ![WoIhiZRM.png|569](https://img.memset0.cn/2024/04/18/WoIhiZRM.png)\n>\n> 为了避免发生一次性采样问题，主从触发器要求其的输入信号在半个时钟周期内不能改变（即 $C=0$ 的时间内）。\n\n### 3.2. 边缘触发式触发器 Edge-Triggered Filp-Flop\n\n**边缘触发式(edge-triggered)** 触发器忽略了保持阶段的时钟脉冲，只有在时钟信号发生跳变时（正边沿到来时或负边沿到来时）触发。\n\n其逻辑结构可以看作把主从触发器中的主锁存器换成 D 锁存器，\n\n### 3.3. JK 触发器 J-K Flip-Flop\n\n| $J$ | $K$ | $Q_{t+1}$        | 描述 |\n| --- | --- | ---------------- | ---- |\n| 0   | 0   | $Q_t$            | 保持 |\n| 0   | 1   | 0                | 复位 |\n| 1   | 0   | 1                | 设定 |\n| 1   | 1   | $\\overline{Q_t}$ | 翻转 |\n\n### 3.4. T 触发器 T Flip-Flop\n\n| $T$ | $Q_{t+1}$        | 描述 |\n| --- | ---------------- | ---- |\n| 0   | $Q_t$            | 保持 |\n| 1   | $\\overline{Q_t}$ | 翻转 |\n\n### 3.5. 触发器的时序参数 Flip-Flop Timing Parameters\n\n$t_s$ - **建立时间(setup time)**：输入数据在时钟信号的上升沿或下降沿到来之前，需要保持稳定的时间。\n\n- 对于主从触发器，为了避免一次性采样问题，其 setup time 应为半个时钟周期。即对于高电平激活的电路，其在时钟信号维持高电平期间不能改变输出。\n- 对于边缘触发器，其所需要的 setup time 比主从触发器小很多，但也并不是 $0$。\n\n$t_h$ - **保持时间(hold time)**：输入数据在时钟信号的上升沿或下降沿到来之后，需要保持稳定的时间。\n\n- 经常等于 $0$，即时钟脉冲之后对输入信号是否保持没有要求。\n\n![hsbdV5kX.png|501](https://img.memset0.cn/2024/06/12/hsbdV5kX.png)\n\n$t_w$ - **时钟脉冲宽度(clock pulse width)**：一个时钟周期中，时钟信号为高电平（$t_{wh}$）或低电平（$t_{wl}$）的时间。取决于触发器是在时钟信号的上升沿触发还是在时钟信号的下降沿触发。\n\n$t_{pd}$ - **传播延迟(propagation delay)**：从时钟信号的上升沿或下降沿（注意这里和组合电路中的定义略有不同）到触发器输出稳定，所需要的时间。其中\n\n- 输出信号从高到低所需要的传播延迟定义为 $t_{\\text{PHL}}$；\n- 输出信号从低到高所需要的传播延迟定义为 $t_{\\text{PLH}}$。\n\n两者可能不同。对触发器传播延迟的定义可取两者的最大值或平均值，如 $t_{pd} = \\max\\{t_{\\text{PHL}}, t_{\\text{PLH}}\\}$\n\n![wJh7VPNa.png|612](https://img.memset0.cn/2024/06/12/wJh7VPNa.png)\n\n### 3.6. 触发器的标准符号 Standard Symbols for Flip-Flops\n\n![uiJvlAgB.png|559](https://img.memset0.cn/2024/04/18/uiJvlAgB.png)\n\n![EfG4e0AK.png|275](https://img.memset0.cn/2024/04/18/EfG4e0AK.png)\n\n### 3.7. 触发器的描述方法\n\n常用于分析（从当前状态和输入中得到下一状态）：\n\n- **特征表(characteristic table)**：定义了下一状态与当前状态和输入的关系。\n- **特征方程(characteristic equation)**：用布尔函数来表示下一状态与当前状态和输入的关系。\n\n常用于设计（从状态中得到输入）：\n\n- **激励表(excitation table)**：列出所有可能的当前状态和下一状态，从而确定输入。\n\n## 4. 时序电路分析 Sequential Circuit Analysis\n\n### 4.1. 整体模型 General Model\n\n![整体模型|287](https://img.memset0.cn/2024/05/10/k6yAYzTF.png)\n\n对于一个输入为 $X$，输出为 $Y$，状态为 $(A,B)$ 的时序电路可以这样定义其：\n\n- **输出方程(output function)**：$y = \\overline X (B + A)$。\n- **触发器输入方程(flip-flop input equation)**：$D_A = AX+BX,\\quad D_B=\\overline AX$。\n- **次态方程(next state function)**：$A_{t+1} = D_A,\\quad B_{t+1} = D_B$。\n\n![来自课本 Figure 5-15|254](https://img.memset0.cn/2024/05/10/YOevSc7d.png)\n\n![时序电路分析过程|433](https://img.memset0.cn/2024/06/12/Ulem2F8x.png)\n\n### 4.2. 状态表 State Table\n\n**状态表(state table)** 由四部分组成：**当前状态(present state)**、**输入(input)**、**下一状态(next state)** 和**输出(output)**。\n\n这里我们不妨假设共有 $n$ 个输入和 $m$ 个触发器，则 Mealy 型电路的状态图可表示如下，共 $2^{m+n}$ 行，对应着可能的所有输出。\n\n![Mealy 型电路的状态表|390](https://img.memset0.cn/2024/06/12/yRaU412F.png)\n\n由于 Moore 型电路的输出只和当前状态有关，所以只需要 $2^m$ 行即可，可以把 $2^n$ 种不同输出所转移到的下一状态写到列上。\n\n![Moore 型电路的状态表|488](https://img.memset0.cn/2024/06/12/3t59xjur.png)\n\n### 4.3. 激励表 Excitation Table\n\n用当前状态和下一状态来描述输入（展示从当前状态转移到下一状态所需要的输入）。\n\n### 4.4. 激励方程 Excitation Equation\n\n### 4.5. 状态图 State Diagram\n\n![Mealy 型电路的状态图](https://img.memset0.cn/2024/06/12/u56B5gQY.png)\n\n- 节点表示状态，边表示输入/输出（这一输入下会转移到的状态及对应的输出）\n\n![Moore 型电路的状态图](https://img.memset0.cn/2024/06/12/ghfAK4R8.png)\n\n- 节点表示状态/输出，边表示输入（这一输入下会转移到的状态）\n\n我们称呼两个状态是**等价(equivalent)** 的，当且仅当对于任意的输入序列，其输出序列都是相同的。如下面这个例子，\n\n### 4.6. 状态机 State Machine Diagram\n\n对于更复杂的逻辑，我们可能需要用**状态机(state-maching diagram)** 来表示。\n\n> 听说考试没有考过？咕了咕了。\n\n![dv7sfKyn.png|502](https://img.memset0.cn/2024/06/12/dv7sfKyn.png)\n\n## 5. 延迟分析 Delay Analysis\n\n注意 $t_\\text{PLH} = t_\\text{PHL}$ 区分的是输出而不是输入。\n\n## 6. 时序电路设计 Sequential Circuit Design\n\n### 6.1. 设计步骤 The Design Procedure\n\n1. 确定系统的行为；\n   1. 描述系统行为过程中，要注意状态的复用（不过并非状态越少成本就越小，这里有触发器数量和组合逻辑电路的 trade-off）；\n   2. 确定电路的初始状态（**复位状态(reset state)**，通过给定复位(reset)信号实现）；\n      - 复位一般可以是异步的；\n2. 阐述输入和输出之间的逻辑关系，并用真值表或逻辑表达式表达出来；\n3. 给设计好的状态编码赋值，得到具体的状态表；\n   1. 我们可以使用 按计数顺序、 按格雷码、用独热码 来给状态赋值，更系统的方法比较复杂，不做讨论；\n   2. 其中还有一种情况是所需要的状态不能完整填充  2𝑛2n  种情况，需要设计无效状态，这种时候可以不考虑它们；\n4. 根据状态表确定使用的触发器及其输入方程；\n5. 根据状态表确定输出方程；\n6. 优化输入方程和输出方程；\n7. 将优化后的逻辑设计工艺映射到硬件实现上；\n8. 验证正确性（在仿真环境中）；\n   - 主要就是看能不能复现状态图；\n\n![|416](https://img.memset0.cn/2024/05/09/Urf7XFN3.png)\n\n### 6.2. 状态赋值 State Assignment\n\n用 $n$ 位二进制给 $m$ 种状态各自分配一个不同的编码，需要使用 $n$ 个触发器。剩余 $2^n-m$ 个状态未使用，可视为不定项。\n\n常见的状态赋值方法如下：\n\n| 赋值方法                                 | 特性                                     |\n| ---------------------------------------- | ---------------------------------------- |\n| 按照**计数的顺序(counting order)** 分配  |                                          |\n| 按照**格雷码顺序(Gray code order)** 分配 | 在使用卡诺图作化简时非常方便             |\n| **单热点(one-hot)** 赋值                 | 每个状态对应一个触发器，跳变最少效率最高 |\n","publishedTitle":"「数字逻辑设计」Chapter 4. Sequential Circuits"}},{"id":"81dd95b1-55f3-56d9-9a8c-8ce51495fde0","fields":{"slug":"/course/dd/note/6/","plainText":"\n> 本篇笔记详细介绍了寄存器及其传输操作的基本概念，包括寄存器的结构、控制信号的作用、寄存器传输语言（RTL）的使用，以及不同类型的寄存器和计数器的设计方法。内容涵盖了并行加载、双向移位、计数器的工作原理及其设计注意事项，最后探讨了基于多路选择器的设计方法和时序电路的设计方法。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 寄存器 Registers\n\n一个 $n$ 位的寄存器包含 $n$ 个触发器，还有若干组合电路来实现特定功能，如移位、计数等。\n\n一般通过一个 $Load$ 信号来控制寄存器，$Load$ 信号一般通过更高阶的电路控制。可以把 $Load$ 信号和 $Clock$ 信号的 AND 来作为触发器的控制信号：\n\n- $Load=1$ 表示 **载入(load)**，新数据被写入寄存器。\n- $Load=0$ 表示 **储存(store)**，寄存器保持已经写入的数据。\n\n![SFJK7MOd.png|481](https://img.memset0.cn/2024/06/13/SFJK7MOd.png)\n\n> [!warning] **时钟偏斜(clock skew)**\n>\n> 如果给时钟信号加上一个非门，那么不同触发器的控制信号的时间存在一个非门的延时。\n>\n> 一种解决方案是时钟信号直接接到所有触发器的控制信号上，但触发器的输入信号接一个 2-to-1 MUX，根据控制信号选择是加载触发器的输出，还是从输入流中加载。\n>\n> ![|550](https://img.memset0.cn/2024/06/13/PZ5h7mei.png)\n\n如果载入操作在同一个时钟脉冲中完成，我们称之是**并行(parallel)** 的。\n\n## 2. 寄存器传输操作 Register Transfer Operations\n\n**寄存器传输操作(register transfer operation)**：处理存储在寄存器中的数据的操作。\n\n![CPBN1eDH.png|517](https://img.memset0.cn/2024/05/16/CPBN1eDH.png)\n\n**微操作(microoperation)**：关于寄存器传输的初级操作，包括 load/count/shift/add/bitwise OR 等等。\n\n### 2.1. 寄存器传输语言 Register Transfer Language\n\n**寄存器传输语言(register transfer language, RTL)** 用来表述寄存器传输操作。\n\n- 字母和数字：表示寄存器\n- 小括号：表示位的范围（如 `R(1)`、`PC(7:0)`）\n- 箭头：表示数据的传输（如 `R1 <- R2`)\n- 逗号：用于分开多次操作\n- 方括号：（可通过寄存器）指定内存地址（如 `R0 <- M[AR]`）\n- **条件传输(conditional transfer)**：如 `K1: (R2 <- R1)` 表示当 `K1` 寄存器的值为 1 时执行 `R2 <- R1`。\n\n> [!note]- 关于寄存器传输操作的硬件描述语言的比较\n>\n> ![|600](https://img.memset0.cn/2024/05/16/cOaKwRmC.png)\n\n如用 RTL 来描述一个加减法器的行为（$\\text X=0$ 时加法，$\\text X= 1$ 时减法）：\n\n$$\n\\begin{aligned}\n\\overline{\\text{X}}\\ \\text{K1}&: \\text{R1} \\leftarrow \\text{R1} + \\text{R2}\\\\\n\\text{X}\\ \\text{K1} &: \\text{R1} \\leftarrow \\text{R1} + \\overline{\\text{R2}} + 1\n\\end{aligned}\n$$\n\n### 2.2. 数据传输结构 Register Transfer Structures\n\n#### 2.2.1. 基于多路选择器的传输 Multiplexer-Based Transfers\n\n多个输入通过一个多路选择器进行选择，从而给到目标寄存器中。\n\n![YWD6lMjz.png|415](https://img.memset0.cn/2024/06/13/YWD6lMjz.png)\n\n#### 2.2.2. 基于专有的多路选择器的传输 Dedicated MUX-Based Transfers\n\n这里**专有的(dedicated)** 的 MUX 的意思是说，每个寄存器的输入都通过一个独立的 MUX 进行选择。\n\n![SXBI8Gww.png|344](https://img.memset0.cn/2024/06/13/SXBI8Gww.png)\n\n- PROS：可以实现在一个时钟节拍中同时的数据传输。\n- CONS：门输入代价高。\n  - GN 的计算：MUX 的反相器是可以共享的，每一个 MUX 里需要两个 2 输入与门和一个 2 输入或门，共 $GN = 3 \\times 6 + 3 = 21$。\n\n#### 2.2.3. 多路选择器总线 Multiplexer Bus\n\n**总线(bus)** 的主要思想在于让多个寄存器共享一个多路选择器和数据传输路径，把这个多路选择器称作是**共享的(shared)**。\n![vmPTRYOb.png|426](https://img.memset0.cn/2024/06/13/vmPTRYOb.png)\n\n![dWamWDYH.png|321](https://img.memset0.cn/2024/06/13/dWamWDYH.png)\n\n#### 2.2.4. 三态门总线 Three-State Bus\n\n三台总线的实现需要用到**三态门(tri-state gate)**，因为其可以输出高阻态，从而使得来自多个寄存器的输出可以直接连起来而不需要逻辑门或 MUX 的控制。\n\n![MhJmWI1e.png|458](https://img.memset0.cn/2024/05/16/MhJmWI1e.png)\n\n## 3. 移位寄存器 Shift Registers\n\n一个普通的**移位寄存器(shift register)** 如下：\n\n![GWS45J0I.png|425](https://img.memset0.cn/2024/05/16/GWS45J0I.png)\n\n- **串行输入(serial input)**：$\\text{In}$。\n- **串行输出(serial output)**：$\\text{Out}$。\n- **并行输出(parallel output)**：$\\text A$、$\\text B$、$\\text C$、$\\text{Out}$。\n\n### 3.1. 并行加载移位寄存器 Parallel Load Shift Register\n\n![yE3R4xpn.png|406](https://img.memset0.cn/2024/05/16/yE3R4xpn.png)\n\n通过给输入信号加一个 2-to-1 MUX 可以实现并行加载功能，这样在 SHIFT 为 0 时，移位寄存器 $\\{A,B\\}$ 会直接从 $\\{D_A, D_B\\}$ 加载数据，并且这一加载过程在同一时间发生（是并行的）。\n\n![aUweTYxa.png|499](https://img.memset0.cn/2024/05/16/aUweTYxa.png)\n\n如果需要支持**保持(hold)** 功能，可以换成 3-to-1 MUX，并接一路从自己这来的输出，功能表如下：\n\n| Shift | Load | Operation       |\n| ----- | ---- | --------------- |\n| 0     | 0    | 保持 no change  |\n| 0     | 1    | 加载 load       |\n| 1     | x    | 移位 shift down |\n\n注意，实现保持功能时，我们不能直接给时钟信号 CP 加一个与门，这样的话与门的延迟同样会导致上文提到过的**时钟歪斜(clock skew)** 问题。\n\n### 3.2. 双向移位寄存器 Bidirectional Shift Registers\n\n再换用 4-to-1 MUX 可以让我们的移位寄存器同时支持两个方向的移位操作，电路的一部分如下图所示。\n\n![r45GWNkA.png|307](https://img.memset0.cn/2024/05/16/r45GWNkA.png)\n\n其功能表如下（$S_1,S_0$ 为控制信号）：\n\n| $S_1$ | $S_0$ | Operation              |\n| ----- | ----- | ---------------------- |\n| 0     | 0     | 保持 no change         |\n| 0     | 1     | 向下移位 shift down    |\n| 1     | 0     | 向上移位 shift up      |\n| 1     | 1     | 平行加载 parallel load |\n\n如果需要让移位寄存器支持更多功能，更换 MUX 并设计相应电路即可。\n\n## 4. 计数器 Counters\n\n![zNJtJh5M.png|453](https://img.memset0.cn/2024/06/13/zNJtJh5M.png)\n\n### 4.1. 纹波计数器 Ripple Counter\n\n触发器 $D_A$ 把时钟信号作为控制信号 $C_R$，其反转频率是时钟信号的一半；$D_B$ 把 $D_A$ 的输出作为控制信号，其反转频率是 $D_A$ 的一半，是时钟信号的四分之一。从而实现计数器的功能。\n\n- **最低有效位(LSB)**\n- **最高有效位(MSB)**\n\n从最低有效位开始计数，低位触发器的输出作为更高一位触发器的控制信号。\n\n![q5pDrDSj.png|298](https://img.memset0.cn/2024/05/16/q5pDrDSj.png)\n\n时延计算：分析是上升沿还是下降沿，或者直接 $t_{pd}$。\n\n![4BXhdNoW.png|498](https://img.memset0.cn/2024/06/13/4BXhdNoW.png)\n\n### 4.2. 同步计数器 Synchronous Counters\n\n触发器只用来保存状态，计数的功能用组合电路（$n$ 位计数器只需要 $n$ 个半加器）实现。所有触发器同步改变。\n\n- **计数使能(count enable = CE)**：控制是否进行计数，当 $\\text{CE} = 1$ 且边沿到来时进行一次计数，当 $\\text{CE} = 0$ 时处于保持状态。\n- **进位输出(carry output = CO)**：给出最高的进位作为输出，可以指示计数器是否达到上界。\n\n![HkSwHtKj.png|547](https://img.memset0.cn/2024/06/13/HkSwHtKj.png)\n\n类似于加法器，我们也可以在并行计数器中实现提前进位：\n\n![p1gE6i6d.png|482](https://img.memset0.cn/2024/06/13/p1gE6i6d.png)\n\n### 4.3. 支持平行加载的计数器 Counter with Parallel Load\n\n通过一个 2-to-1 MUX 控制是从 $\\text D$ 中并行加载还是从组合逻辑中加载。\n\n![k3YE7pPN.png|499](https://img.memset0.cn/2024/06/13/k3YE7pPN.png)\n\n### 4.4. 模 N 的计数器 Counting Modulo N\n\n我们以设计模 10 的计数器（BCD 计数器为例），那么只有 $0$ 到 $9$ 是**有效的(valid)**，剩下的 6 个状态都是未使用的状态。\n\n![5yHkPXH1.png|398](https://img.memset0.cn/2024/06/13/5yHkPXH1.png)\n\n写出状态转移的激励方程，并通过卡诺图化简，可以得到我们需要的组合逻辑。\n\n![j0dWfJp0.png|446](https://img.memset0.cn/2024/06/13/j0dWfJp0.png)\n\n需要注意的是，虽然剩余 6 个状态是未使用状态，但是如果计数器因为意外处于未使用状态时，他的下一状态是确定的，画图可知我们设计的这一计数器在有限步后又会回到有效状态（称为自恢复能力；并非对于所有计数器都成立后，最好设计成这样的）。我们也可以设计一个 $\\text{Error}$ 输出，用于指示是否进入了未使用状态，同样可用卡诺图进行化简。\n\n不推荐的设计（自杀式计数器）：让模 $n$ 的计数器在输出变成 $n$ 时直接给所有寄存器异步清零。如果异步清零过程的时延不同，可能“卡在”中间的任意有效状态，非常不稳定。\n\n## 5. 寄存器单元设计\n\n### 5.1. 基于 MUX 的设计方法 Multiplexer Approach\n\n- **寄存器功能(register functions)**：可以通过寄存器传输语言 RTL 来描述。\n\n- **控制输入(control inputs)**：输入控制信号，控制信号的可以是**编码的(encoded)** 或未编码的。\n\n![btfn5DDT.png|428](https://img.memset0.cn/2024/06/13/btfn5DDT.png)\n\n- **数据输入(date inputs)**：从寄存器中输入。\n\n![](https://img.memset0.cn/2024/06/13/Ds1gYGUj.png)\n\n> [!quote] Example\n>\n> ![cQwlfOFm.png|464](https://img.memset0.cn/2024/06/13/cQwlfOFm.png)\n\n### 5.2. 基于时序电路的设计方法 Sequential Circuit Design Approach\n\n这里状态本身就是输出，所以一定是摩尔型电路。使用时序电路的相关方法进行设计，虽然结果更优但设计过程非常麻烦。\n\n> [!quote] Example\n>\n> ![|430](https://img.memset0.cn/2024/06/13/35GGfbrf.png)\n","publishedTitle":"「数字逻辑设计」Chapter 6. Registers & Register Transfers"}},{"id":"25cb9085-132a-5ad5-814a-4ae9bb394663","fields":{"slug":"/course/dm/note/1/","plainText":"\n> 本篇笔记介绍了命题逻辑的基本概念，包括命题、逻辑运算符、条件语句、真值表及其应用等内容。接着，讨论了逻辑等值式、逻辑定律、全功能集和标准式等重要主题。最后，笔记还涵盖了谓词逻辑、嵌套量词、推理准则和证明方法等内容，提供了对逻辑推理和证明的深入理解。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n> [!note] Word Table\n>\n> - **有理数(rational)**\n> - **反例(counterexample)**\n> - **前提(premise)**\n\n## 1. 命题逻辑 Propositional Logic\n\n### 1.1. 命题 Propositions\n\n**命题(proposition)**：A proposition is a **declarative sentence** that is either `true` or `false`, but not both.\n\n- **悖论(paradox)** 不属于命题（e.g. _This statement is false._ or _I'm lying._）\n\n**命题逻辑(propositional logic)**：The area of logic that deals with propositions.\n\n**命题变量(propositional variable)**：Small letters such as $p,q,r,s,\\ldots$ used to present propositions.\n\n**真值(truth value)**：T (true proposition), or F (false proposition)\n\nWe call a series of propositions **consistent(一致的)** if they can possibly be satisfied at the same time.\n\n### 1.2. 逻辑运算符 Logical Operators\n\n**逻辑运算符(logical operator)** or **逻辑连接词(logical connective)**: be used to form compound propositions from existing propositions\n\n| Connectives                           |      Expression      | Note         |\n| ------------------------------------- | :------------------: | ------------ |\n| Negation (NOT)                        |      $\\lnot p$       |              |\n| 和取 Conjunction (AND)                |     $p \\land q$      |              |\n| 析取 Disjunction (OR)                 |      $p\\lor q$       |              |\n| 亦或 Exclusive Or (XOR)               |     $p\\oplus q$      |              |\n| 条件 Conditional (IF-THEN)            |   $p\\rightarrow q$   |              |\n| 双条件 Biconditional (IF AND ONLY IF) | $p\\leftrightarrow q$ | 参见下节介绍 |\n\n- 英语中的单词 or 既可以表示 inclusive or 也可以表示 exclusive or（e.g. _George was born in 1956 or 1957._），取决于具体语境。\n\n逻辑运算符的**优先级(precedence)** 如下：\n\n| $($ and $)$ | $\\lnot$ | $\\land$ | $\\lor$ | $\\rightarrow$ | $\\leftrightarrow$ |\n| :---------: | :-----: | :-----: | :----: | :-----------: | :---------------: |\n|      0      |    1    |    2    |   3    |       4       |         5         |\n\n### 1.3. 条件语句 Conditional Statements\n\n**推断(implication)** or **条件语句(conditional statement)**：$p\\rightarrow q$, false when $p$ is true and $q$ is false. $p$ 为假时推出什么都是真的，$p$ 为真时必须推出真的才为真。\n\n> [!warning] 注意 $p$ only if $q$\n>\n> 只有在 $q$ 成立的时候 $p$ 成立，即 $\\lnot q \\rightarrow \\lnot p$，实际上等价于 $p\\rightarrow q$。\n>\n> > [!important]- More Equivalent Forms\n> >\n> > - If $p$, then $q$\n> > - $p$ implies $q$\n> > - If $p$, $q$\n> > - $q$ if $p$\n> > - $q$ when $p$\n> > - $q$ follows from $p$\n> > - $q$ whenever $p$\n> > - $p$ is a sufficient condition for $q$\n> > - $q$ is a necessary condition for $p$\n> > - $q$ unless $\\lnot p$\n\n- **假设(hypothesis = antecedent = premise)**：$p$\n- **结论(conclusion = consequence)**: $q$\n\n对于推断 $p\\rightarrow q$ 我们可以定义以下条件语句：\n\n- **逆命题(converse)**：$q\\rightarrow p$\n- **否命题(inverse)**：$\\lnot p\\rightarrow \\lnot q$\n- **逆否命题(contrapositive)**：$\\lnot q\\rightarrow \\lnot p$\n\n> [!important] 逆否命题与原命题等价\n>\n> The contrapositive has **the same truth values** as the original implication.\n\n**双条件语句(biconditional statement)**：The biconditional statement $p\\leftrightarrow q$ is the propostion “$p$ if and only if $q$.” The biconditonal statemnt\n\n### 1.4. 真值表 Truth Table\n\n要学会画**真值表(truth table)**。\n\n- $n$ 个不同的布尔变量所画的真值表应有 $2^n$ 行。\n\n> [!example]- 例：$n$ 个不同的布尔变量可以构成多少个不等价的逻辑表达式？\n> 可以从真值表的角度入手考虑，$n$ 个布尔变量有 $2^n$ 个取值，而这其中的每一个取值在代入逻辑表达式后都可以得到一个 $0$ 或 $1$，故共有 $2^{2^n}$ 种可能，也就是有 $2^{2^n}$ 种不同的逻辑表达式。\n\n### 1.5. 命题逻辑的应用 Applications of Propositional Logic\n\n#### 1.5.1. 翻译句子 Translating Sentences\n\n- 将英语句子翻译成逻辑表达式，来减少自然语言的**不准确(inaccuracy)** 和**模糊(ambiguous)**。\n\n#### 1.5.2. 系统描述 System Specification\n\n可以用于精确地描述系统需求、解决一些逻辑谜题等。\n\n#### 1.5.3. 逻辑谜题 Logical Puzzles\n\n> [!example] 例：宝箱谜题\n> As a reward for saving his daughter from pirates, the King has given you the opportunity to win a treasure hidden inside one of three trunks. The two trunks that do not hold the treasure are empty. To win, you must select the correct trunk. Trunks 1 and 2 are each inscribed with the message “This trunk is empty,” and Trunk 3 is inscribed with the message “The treasure is in Trunk 2.” The Queen, who never lies, tells you that only one of these inscriptions is true, while the other two are wrong. Which trunk should you select to win?\n>\n> > [!quote]- Answer\n> >\n> > ![|width: 100%](https://img.memset0.cn/2024/03/01/9iCFuaLe.png)\n\n## 2. 逻辑等值式 Propositional Equivalences\n\n### 2.1. 导论 Introduction\n\n先定义以下基本概念：\n\n- **永真(tautology)**：A proposition which is always true. (e.g. $p \\lor \\lnot p$)\n- **永假(contradiction)**：A proposition which is always false. (e.g. $p \\land \\lnot p$)\n- **可能式(contingency)**：A proposition which is neither a tautology nor a contradiction. (e.g. $p$)\n\n命题 $p$ 和 $q$ 是**逻辑等值(logically equivalent)** 的，当且仅当命题 $p\\leftrightarrow q$ 是永真的。可被表示为：$p\\Leftrightarrow q$ 或 $p\\equiv q$。\n\n- 一个复合命题是**可满足的(satisfiable)**：if there is an assignment of truth values to its variables that makes it true. 称这组赋值为该复合命题的解。\n- 一个复合命题是**不可满足的(unsatisfiable)**：when it is false for all assignments of truth values to its variables.\n\n### 2.2. 逻辑定律 Logical Laws\n\n- 可以用真值表来证明一些基本的逻辑定律：对于涉及到 $n$ 个变量的两个命题，画出 $2^n$ 种可能的变量取值下的真值表，若两个命题的值都相同则说明这两个命题是逻辑等值的。\n\n|              Name              |                                                Expression                                                | Note                   |\n| :----------------------------: | :------------------------------------------------------------------------------------------------------: | ---------------------- |\n|      统一律 Identity Laws      |                       $p\\land \\text{T}\\equiv p \\quad\\quad p\\lor \\text{F} \\equiv p$                       |                        |\n|     零一律 Domination Laws     |                 $p\\lor \\text{T}\\equiv \\text{T}\\quad\\quad p\\land \\text{F}\\equiv \\text{F}$                 |                        |\n|     幂等律 Idempotent Laws     |                             $p\\land p \\equiv p \\quad\\quad p\\lor p \\equiv p$                              |                        |\n|   对合律 Double Negation Law   |                                         $\\lnot \\lnot p \\equiv p$                                         |                        |\n|    交换律 Commutative Laws     |                       $p\\lor q \\equiv q \\lor p\\quad\\quad p\\land q\\equiv q\\land p$                        |                        |\n|    结合律 Associative Laws     |         $(p\\lor q)\\lor r\\equiv p\\lor (q\\lor r)$ <br > $(p\\land q)\\land r\\equiv p\\land(q\\land r)$         |                        |\n|    分配律 Distributive Laws    | $p\\lor (q\\land r)\\equiv(p\\lor q)\\land (p\\lor r)$ <br> $p\\land (q\\lor r)\\equiv (p\\land q)\\lor (p\\land r)$ |                        |\n| **德·摩根律 De Morgan's Laws** |          $\\lnot(p\\lor q)\\equiv \\lnot p\\land \\lnot q$ <br> $\\lnot(p\\land q)=\\lnot p\\lor\\lnot q$           | **重要**               |\n|      否定律 Negation Laws      |                  $p\\lor \\lnot p\\equiv \\text{T}\\quad\\quad p\\land \\lnot p\\equiv \\text{F}$                  |                        |\n|     吸收律 Absorption Laws     |                      $p\\lor (p\\land q)\\equiv p\\quad\\quad p\\land (p\\lor q) \\equiv p$                      |                        |\n|   逆否律 Contrapositive Law    |                            $p\\rightarrow q \\equiv \\lnot q\\rightarrow \\lnot p$                            | 命题与它的逆否命题等价 |\n|   **导出律 Exportation Law**   |                      $(p\\land q)\\rightarrow r\\equiv p\\rightarrow (q\\rightarrow r)$                       |                        |\n|         Absurdity Law          |                       $(p\\rightarrow q)\\land (p\\rightarrow \\lnot q)\\equiv \\lnot p$                       |                        |\n|   **蕴含律 Implication Law**   |                                  $p\\rightarrow q \\equiv \\lnot p \\lor q$                                  | 用于去掉箭头           |\n|        Equivalence Law         |                    $p\\leftrightarrow q\\equiv (p\\rightarrow q)\\land (q\\rightarrow p)$                     |                        |\n\n### 2.3. 全功能集 Functionally Complete Collection of Logical Operators\n\n只需要部分运算符就可以表示出所有可能的运算，称这样的一个运算符集合为**全功能集(Functionally Complete Collection)**。\n\n**极小全功能集**：$\\{\\lnot, \\lor\\}$, $\\{\\lnot, \\land\\}$, $\\{|\\}$, $\\{\\downarrow\\}$ 等。\n\n### 2.4. 标准式 Propositional Normal Forms\n\n#### 2.4.1. DNF/CNF\n\n先给出以下基本定义：\n\n- A **字面量(literal)** is a variable or its negation.\n- Conjunctions with literals as conjuncts are called **合取子句(conjunctive clauses)** (clauses). 通过 AND 连接起来的一组字面量。\n\n**标准式(Propositional Normal Forms)** 有以下两种：\n\n- **析取范式(Disjunctive Normal Form, DNF)**：A formula is said to be in disjunctive normal form if it is written as a disjunction, in which all the terms are conjunctions of literals. (e.g. $(p\\land q)\\lor(p\\land \\lnot q)$.)\n  - 最外面一层的运算符都是析取 $\\lor$；\n  - 括号内的运算符都是合取 $\\land$；\n  - 括号不能嵌套；\n  - $\\lnot$ 只能出现在变量前。\n- **合取范式(Conjunctive Normal Form, CNF)**：和 DNF 的定义相反；把 $\\land$ 和 $\\lor$ 互换。\n\n> [!important] Theorem\n>\n> Any formula $A$ is tautologically equivalent to **some** formula in DNF (CNF).\n>\n> > [!quote]- Proof\n> >\n> > 可以通过真值表构造，详见下面的 get the Full DNF of any formula 部分。\n> >\n> > Construct the truth table for the proposition. Then an equivalent proposition is the disjunction with n disjuncts (where n is the number of rows for which the formula evaluates to T). Each disjunct has m conjuncts where m is the number of distinct propositional variables. Each conjunct includes the positive form of the propositional variable if the variable is assigned T in that row and the negated form if the variable is assigned F in that row. This proposition is in disjunctive normal from.\n\n#### 2.4.2. Full DNF/CNF\n\n- A **极小项(minterm)** is a conjunctive of literals in which each variable is represented exactly once.\n- A **极大项(maxterm)** is a disjunctive of literals in which each variable is represented exactly once.\n\n可以从真值表中得到**主析取范式(Full Disjunctive Normal Form)**：\n\n- 每个最小项对应真值表中 $f=\\text{T}$ 的恰好一行。\n\n![|530](https://img.memset0.cn/2024/03/05/BOX63rJu.png)\n\n利用 De Morgan's Laws，也可以从真值表中得到**主合取范式(Full Conjuctive Normal Form)**：\n\n- 取出所有真值表为中为 $\\text{F}$ 的位置，写出 $\\lnot f$。\n- 对 $\\lnot f$ 应用 De Morgan's Laws，可以将式子中的合取析取互换，从而求得 FCNF。\n\n![|540](https://img.memset0.cn/2024/03/05/A8SVjPb0.png)\n\n## 3. 谓词逻辑 Predicate Logic\n\n### 3.1. 谓词 Predicates\n\n> 考虑 $x>0$，可以被表示为**命题函数(propositional function)** $P(x)$，这里 $P$ 表示 $\\text{is greater than } 0$ 且 $x$ 是一个变量。\n\n- Propositional functions become propositions (and have truth\n  values) when their variables are each replaced by a value from\n  the domain or bound by a quantifier.\n- A statement of the form $P(x_1,x_2,\\ldots, x_n)$ is the value of the propositional function P at the $n$-tuple $(x_1,x_2,\\ldots, x_n)$ and $P$ is called a $n$-ary predicate.\n\n我们可以用命题函数来描述**前提条件(preconditions)** 和**后置条件(postconditions)** ，这可以用于约束一段程序的输入和输出。\n\n### 3.2. 量词 Quantifiers\n\n- **全称量词(universal quantifier)** $\\forall$：都是真才为真，存在一个为假就为假。可以转化为合取。\n- **存在量词(existential quantifier)** $\\exists$：都是假才为假，存在一个为真就为真。可以转化为析取。\n- **唯一量词(uniqueless quantifier)** $\\exists !$：有且仅有一个为真时才为真。\n\n我们在使用量词时，可能只要求对于某一范围内的 $x$ 成立，我们把此时 $x$ 的取值范围称为 **讨论域(domain of discourse = universe of discourse)**，一般简写为 domain。\n\n> [!important] **量词的优先级(precedence of quantifiers)**\n> 量词的优先级高于所有逻辑运算。The quantifiers $\\forall$ and $\\exists$ have higher precedence than all the logical operators.\n>\n> 所以平时我们再说，对于所有 $x$，满足 $p(x)$ 和 $q(x)$ 时可能会表示为 $\\forall x p(x)\\land q(x)$，但正确的做法应该是 $\\forall x (p(x) \\land q(x))$。\n\n### 3.3. 谓词逻辑的等值 Equivalences in Predicate Logic\n\nStatements involving predicates and quantifiers are logically equivalent if and only if they have the same truth value no matter\n\n- 代入了什么谓词选择 which predicates are substituted into these statements and\n- 使用了什么讨论域 which domain of discourse is used for the variables in these\n  propositional functions\n\n同样使用 $\\equiv$ 符号来表示谓词逻辑中的等值。\n\n**德摩根定律(De Morgan’s laws)** 在谓词逻辑中也适用：\n\n$$\n\\begin{aligned}\n\\lnot \\forall x P(x) &\\equiv \\exists x \\lnot P(x)\\\\\n\\lnot \\exists x P(x) &\\equiv \\forall x \\lnot P(x)\n\\end{aligned}\n$$\n\n只有在 $A(x)$ 和 $B(x)$ 都输出真时，$A(x) \\land B(x)$ 才为真，此时第一个等式的两侧都为真，否则两侧都为假。类似的可以证明第二个等式。\n\n$$\n\\begin{aligned}\n\\forall x (A(x) \\land B(x)) &\\equiv \\forall x A(x) \\land \\forall x B(x)\\\\\n\\exists x (A(x) \\lor B(x)) &\\equiv \\exists x A(x) \\lor \\exists x B(x)\n\\end{aligned}\n$$\n\n但是如果把上面的等式的 $\\land$ 和 $\\lor$ 互换则==不成立==。容易举出反例。\n\n$$\n\\begin{aligned}\n\\forall x (A(x) \\lor B(x)) &\\not\\equiv \\forall x A(x) \\lor \\forall x B(x)\\\\\n\\exists x (A(x) \\land B(x)) &\\not\\equiv \\exists x A(x) \\land \\exists x B(x)\n\\end{aligned}\n$$\n\n但这两个命题在其中一个方向上是正确的。\n\n$$\n\\begin{aligned}\n\\forall x A(x) \\lor \\forall x B(x) &\\Rightarrow \\forall x (A(x) \\lor B(x))\\\\\n\\exists x (A(x) \\land B(x)) &\\Rightarrow \\exists x A(x) \\land \\exists x B(x)\\\\\n\\end{aligned}\n$$\n\n此外，还有：\n\n$$\n\\begin{aligned}\nx \\text{ is not occurring in } P.\\\\\n\\forall x A(x) \\lor P &\\equiv \\forall x (A(x) \\lor P)\\\\\n\\forall x A(x) \\land P &\\equiv \\forall x (A(x) \\land P)\\\\\n\\exists x A(x) \\lor P &\\equiv \\exists x (A(x) \\lor P)\\\\\n\\exists x A(x) \\land P &\\equiv \\exists x (A(x) \\land P)\\\\\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\nx \\text{ is not occurring in } B.\\\\\n\\forall x (B \\rightarrow A(x)) &\\equiv B \\rightarrow \\forall x A(x)\\\\\n\\exists x (B \\rightarrow A(x)) &\\equiv B \\rightarrow \\exists x A(x)\\\\\n\\forall x (A(x) \\rightarrow B) &\\equiv \\exists x A(x) \\rightarrow B\\\\\n\\exists x (A(x) \\rightarrow B) &\\equiv \\forall x A(x) \\rightarrow B\\\\\n\\end{aligned}\n$$\n\n## 4. 嵌套量词 Nested Quantifiers\n\n**嵌套量词(nested quantifier)**：出现在另一个量词的辖域下的量词。Nest quantifiers are quantfiers that occur within the scope of other quantifiers.\n\n### 4.1. 量词的顺序 Order of Quantifiers\n\n除非所有量词都是 $\\forall$ 或所有量词都是 $\\exists$，否则量词的顺序是有意义的。The order of nested quantifiers _matters_ if quantifiers are of different types\n\nE.g.:\n\n- $\\forall x\\ \\exists y\\ L(x,y)$：_Everybody loves somebody._\n- $\\exists y\\ \\forall x\\ L(x,y)$：_There is someone who is loved by everyone._\n\n可以用循环来理解量词的顺序。\n\n### 4.2. 前缀范式 Prenex Normal Form\n\n任意表达式都可以被转化为**前缀范式(prenex normal form)**。\n\n如何得到 PNF？可以遵循一下步骤：\n\n1. 消除所有的 $\\rightarrow$ 和 $\\leftrightarrow$。Eliminate all occurrences of $\\rightarrow$ and $\\leftrightarrow$ from the formula in question.\n2. 向内移动否定符号，注意应用德摩根定律。Move all negations inward such that, in the end, negation only appear as part of literals.\n3. 对变量进行重命名，确定不同部分的变量不会冲突。Standardize the variables a part (when necessary).\n4. 最后，将所有量词移动到最前面。The prenex normal form can now be obtained by moving all quantifiers to the front of the formula.\n\n## 5. 推理准则 Rules of Inference\n\n- An **论据(argument)** is a sequence of statements that end with a conclusion\n- By **有效的(valid)**, we mean the conclusion must follow from the truth of the preceding statements (premises)\n- We use **推理准则(rules of inference)** to construct valid arguments\n\n![|600](https://img.memset0.cn/2024/03/18/HwtaO11F.png)\n\n![|440](https://img.memset0.cn/2024/03/18/FPFiquBv.png)\n\n> [!warning] Caution\n>\n> 在结论前别忘了加 $\\therefore$ 和一条横线，这才是标准格式。\n\n## 6. 证明 Proof\n\n### 6.1. 一些术语 Some Terminology\n\n- A **证明(proof)** is a valid argument that establishes the truth of a mathematical statement.\n- A **定理(theorem)** (or **命题(proposition)**/fact/result) is a statement that can be shown to be true.\n  - **公理(axioms)** (or **假设(postulates)**) are statements we assume to be true\n- A **引理(lemma)** is a less important theorem that is helpful in the proof of other results\n- A **推论(corollary)** is a theorem that can be established directly from a theorem that has been proved.\n- A **猜想(conjecture)** is a statement that is being proposed to be a true statement\n  - A conjecture becomes a theorem once it has been proved to be true.\n\n### 6.2. 形式化证明 Formal Proofs\n\n**形式化证明(formal proof)** v.s. **非形式化证明(informal proof)**：\n\n- Formal Proofs：\n  - Can be extremely long;\n  - May be hard to follow.\n- Informal Proofs:\n  - Each step may involve multiple rules of inference;\n  - Steps may be skipped;\n  - The axioms being assumed and the rules of inference used are not explicitly stated.\n\n### 6.3. 证明方法 Proof Methods\n\n#### 6.3.1. 直接证明法 Direct Proof\n\n通过**直接证明法(direct proof)** 证明 $p\\rightarrow q$ 的方法是：\n\n- 通过**推理规则(rules of inference)**、公理、**逻辑恒等式(logical equivalences)** 等推出 $q$ 也为真。\n\n其余的证明方法都是**间接证明法(indirect proof)**。\n\n#### 6.3.2. 空证明和平凡证明 Vacuous and Trivial Proof\n\n- **空证明(vacuous proof)**：当 $p$ 为假时 $p\\rightarrow q$ 为真，所以我们可以通过证明 $p$ 为假来证明 $p\\rightarrow q$ 为真。\n- **平凡证明(trivial proof)**：当 $q$ 为真时 $p\\rightarrow q$ 为真，所以我们也可以通过证明 $q$ 为真来证明 $p\\rightarrow q$ 为真。\n\n#### 6.3.3. 反证法 Proof by Contraposition\n\n**反证法(proof by contraposition)** 可以看做对原命题的逆否命题的直接证明，根据逻辑恒等式：\n\n$$\np\\rightarrow q \\equiv \\lnot q\\rightarrow \\lnot p\n$$\n\n- 假设 $\\lnot q$ 为真；\n- 推出 $\\lnot p$ 也为真（or 推出 $p$ 为假），从而证明原命题。\n\n#### 6.3.4. 归谬证明法 Proof by Contradiciton\n\nProof $p$ by contradiction:\n\n- assumes $p$ is false.\n- deduces that $\\lnot p \\rightarrow (q \\land \\lnot q)$, which $q \\land \\lnot q$ is a contradiction.\n- $p$ follows from the above\n\nProof $p\\rightarrow q$ by contradiction:\n\n- assumes that both $\\lnot q$ and $p$ are true.\n- show that $(p \\land \\lnot q) \\rightarrow \\text{F}$.\n\n> [!warning] 注意区分 Proof by Contraposition 和 Proof by Contradiction\n>\n> Proof by Contradiction 相比于 Proof by Contraposition 多假设了一个 $p$ is true，并且只需要最后将其归谬即可。\n\n### 6.4. 证明策略 Proof Strategies\n\n#### 6.4.1. 分类讨论 Proof by Cases\n\n- Convince the reader that the cases are inclusive (i.e. they exhaust all possibilities)\n- Establish all implications\n\n#### 6.4.2. 穷举法 Exhausitve Proof\n\nAn **穷举法(exhaustive proof)** is a special type of proof by cases where each case involves checking a single example.\n\n#### 6.4.3. 不失一般性地 Without Loss of Generality\n\n**不失一般性地(without loss of generality)**，常用于证明过程中，可以缩写为 WLOG。比如：我们想要证明 $|xy|=|x|\\cdot |y|$，若已经证明了 $x\\ge 0,\\ y<0$ 的情况下成立，则可以不是一般性的得到 $x<0,\\ y\\ge 0$ 时也成立，因为这就是把 $x'=y,\\ y'=x$ 代入后运用一次乘法交换律的情况。\n\n合理运用 WLOG 可以帮助我们在分类讨论的过程中省略一些重复的证明，从而使证明过程更为简洁。\n\n#### 6.4.4. 存在性证明 Existence Proof\n\n- **构造存在性证明(constructive existence proof)**：\n  - 证明 $P(c)$ 对于定义域中的某一个 $c$ 成立。\n  - 然后 $\\exists x P(x)$ 就成立，根据**存在性推广规则(existential generalization = EG)**。\n- **非构造存在性证明(inconstructive existence proof)**：\n  - 假设不存在 $c$ 使得 $P(c)$ 成立。\n  - 然后推出一个矛盾，这可以说明原命题成立。\n\n#### 6.4.5. 唯一性证明 Uniqueness Proof\n\n**唯一性证明(uniqueness proof)** To show that a theorem assert the existence of a unique element with a particular property.\n\n$$\n\\exists x (P(x) \\land \\forall y (y\\neq x \\rightarrow \\lnot P(y)))\n$$\n\n唯一性证明可以分为证明其存在性和唯一性两部分。\n\n- **存在性(existence)**：We show that an element $x$ with the desired property exists.\n- **唯一性(uniqueness)**：We show that if $y\\neq x$, then $y$ does not have the desired property. Equivalently, we can also show that if $x$ and $y$ both have the desired property, then $x=y$.\n","publishedTitle":"「离散数学及其应用」Chapter 1. Logic & Proofs"}},{"id":"c85987b3-cc31-5295-b459-547eff7bb2eb","fields":{"slug":"/course/dm/note/2/","plainText":"\n> 本篇笔记介绍了集合的基本概念，包括集合的定义、表示方法、集合之间的关系、集合的操作以及函数的基本性质。我们探讨了集合的基数、可数性以及康托定理等重要主题。通过这些内容，读者将能够理解离散数学中集合和函数的基本结构和性质。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n> [!quote]- Word Table\n>\n> - **符号(notation)**\n> - 省略号(ellipse)\n> - 括号(brace)\n\n## 1. 集合 Sets\n\n### 1.1. 引言 Introduction\n\n**集合(set)**：A set is an unordered collection of objects.\n\n- The objects in a set are call the **元素(elements)**，or members, of the set.\n- A set is said to **包含(contain)** its elements.\n  - $a \\in A$：$a$ is the member of the set $A$.\n  - $a \\not\\in A$：$a$ is not the member of the set $A$.\n- **空集(empty set)**：$\\varnothing$.\n\n集合的表示方式：The descriptions of a set\n\n- Roster method: listing all its members between braces, e.g. $S=\\{1,3,5,7,9\\}$.\n- Brace notation with ellipses: e.g. $S=\\{1,2,\\ldots,99\\}$.\n- Specification using set builder: $S=\\{x\\mid P(x)\\}$, which means $S$ contains all the elements from $U$ (**全集(universal set)**) which have the property $P$.\n- **维恩图(Venn diagrams)**\n\n> [!example]- 罗素悖论 Russell Paradox\n> Suppose there is a town with just one male barber; and that every man in the town keeps himself clean-shaven: some by shaving themselves, some by attending the barber. The barber obeys the following rule: he shaves all and only those men in town who do not shave themselves. Does the barber shave himself?\n\n### 1.2. 集合之间的关系 Relations between Sets\n\n#### 1.2.1. Subset\n\n$A\\subseteq B$: $A$ is a **子集(subset)** of the set $B$.\n\n$$\nA \\subseteq B \\Leftrightarrow \\forall x (x \\in A \\rightarrow x \\in B)\n$$\n\n#### 1.2.2. Equal\n\n$A=B$: $A$ is **等于(equal)** to $B$.\n\n$$\nA=B \\Leftrightarrow A \\subseteq B \\land B \\subseteq A\n$$\n\n#### 1.2.3. Proper Subset\n\n$A\\subset B$: A is a **真子集(proper subset)** of the set $B$.\n\n$$\nA \\subset B \\Leftrightarrow A \\subseteq B \\land A \\neq B \\Leftrightarrow \\forall x (x \\in A \\rightarrow x \\in B) \\land \\exists (x \\in B \\land  x\\not\\in A)\n$$\n\n#### 1.2.4. The Size of Sets\n\nLet $S$ be a set. If there are exactly $n$ distinct elements in $S$ where $n$ is a nonnegative integer, we say that $S$ is a **有限集(finite set)** and that $n$ is the cardinality of $S$.\n\n#### 1.2.5. Power Sets\n\nGiven a set S, the **幂集(power set)** of S is the set of all subsets of the set S. $\\mathcal{P}(x)$ denotes the power set of $S$.\n\n> [!example]- 证明：$\\mathcal{P}(A) \\in \\mathcal{P}(B) \\Rightarrow A\\in B$.\n\n#### 1.2.6. Cartesian Products\n\nThe **有序 $n$ 元组(ordered $n$-tuple)** $(a_1,a_2,\\cdots ,a_n)$ is the ordered collection that has $a_1$ as its first element, $a_2$ as its second element, … , and $a_n$ as its nth element.\n\n$A_1,A_2,\\cdots,A_n$ 的**笛卡尔积(cartesian product)** 定义为\n\n$$\nA_1 \\times A_2 \\times \\cdots A_n = \\{(a_1,a_2,\\cdots,a_n) \\mid a_i \\in A_i \\quad\\text{for }i=1,2,\\cdots n\\}\n$$\n\n- If $|A|=m,\\ |B|=n$, then $|A\\times B|=|B\\times A|=mn$.\n- $A\\times B\\neq B\\times A$\n- $A\\times \\varnothing = \\varnothing \\times A= \\varnothing$\n\n#### 1.2.7. Truth Sets of Quantifiers\n\nGiven a predicate $P$ and a domain $D$. The **真集(truth set)** of $P$ is $P$ is the set of elements $x$ in $D$ for which $P(x)$ is true. Namely, the power set of $P$ is $\\{x \\in D\\mid P(x)\\}$\n\n### 1.3. 集合操作 Set Operations\n\n#### 1.3.1. Union\n\n$A\\cup B = \\{x \\mid x \\in A \\lor x \\in B\\}$\n\n#### 1.3.2. Intersection\n\n$A\\cap B = \\{x \\mid x \\in A \\land x\\in B\\}$\n\n#### 1.3.3. Difference\n\n$A-B = \\{x \\mid x\\in A \\land x \\not\\in B\\}$: The difference of $A$ and $B$.\n\n#### 1.3.4. Complement\n\n$\\overline{A} = \\{x \\mid x \\not\\in A \\land x\\in U\\}$: $\\overline{A}$ is the **补集(complement)** of the set $A$.\n\n#### 1.3.5. Symmetric difference\n\n$$\nA\\oplus B = (A\\cup B) - (A\\cap B)\n$$\n\n按出现与否统计的话就类似于异或操作。\n\n### 1.4. 集合恒等式 Set Indentities\n\n更多**集合恒等式(set indentities)** 可以参考逻辑恒等式。\n\n![|480](https://img.memset0.cn/2024/04/02/8BUTQs6T.png)\n\n> [!important] 证明集合相等的一些方法 Ways to Prove Set Identities\n>\n> - 将证明恒等式转化为证两次子集。Show that $A\\subseteq B$ and that $B\\subseteq A$.\n> - 转化为 set builder 的形式，然后用逻辑恒等式证明。Use logical equivalences to prove equivalent set definitions.\n> - 类似于真值表的做法。Use a membership table.\n> - 从已有的恒等式中推演。Use previously proven identities.\n\n## 2. 函数 Functions\n\n### 2.1. 引言 Introduction\n\nLet $A$ and $B$ be _nonempty_ sets. A **函数(function)** (mapping or transformations) $f$ from $A$ to $B$:\n\n$$\nf:A\\rightarrow B\n$$\n\n$$\n\\forall a (a \\in A \\rightarrow \\exists ! b  (b \\in B \\land f(a) = b))\n$$\n\n- $A$ is called the **定义域(domain)** of $f$\n- $B$ is called the **值域(codomain)** of $f$\n\nIf $f(a) = b$,\n\n- $b$ is called the image of $a$ under $f$.\n- $a$ is called a preimage of $b$.\n\nLet $f$ be a function from the set $A$ to the set $B$. The **图(graph)** of the function $f$ is the _set_ of ordered pairs\n\n$$\n\\{(a,b) \\mid a \\in A \\land f(a) = b\\}\n$$\n\n### 2.2. 单射与满射 One-to-One and Onto Functions\n\nA function f is **单射函数(one-to-one function = injection)** (denoted 1-1), or **单射的(injective)** if\n\n$$\n\\forall a \\forall b (f(a) = f(b) \\rightarrow a = b)\n$$\n\nA function $f$ from $A$ to $B$ is called **满射函数(onto function = surjection)**, or **满射的(surjective)** if\n\n$$\n\\forall b \\in B \\exists a \\in A (f(a) = b)\n$$\n\nThe function f is a **一一对应的(one-to-one correspondence)**, or a **双射(bijection)**, if it is both _one-to-one_ and _onto_.\n\n> [!note] Showing that $f$ is one-to-one or onto\n>\n> ![|640](https://img.memset0.cn/2024/03/19/OoeOyjuL.png)\n\n### 2.3. 反函数 Inverse Functions\n\nLet $f$ be a bijection from $A$ to $B$. Then the **反函数(inverse function)** of $f$, denoted as $f^{-1}$, is the function from $B$ to $A$ defined as\n\n$$\nf^{-1} (y) = x \\text{ iff } f(x) = y\n$$\n\n- 函数 $f$ 的反函数存在当且仅当函数 $f$ 是双射函数。Function $f$ is **可逆的(invertible)** if and only if $f$ is bijective. No inverse function exists unless $f$ is a bijection.\n\n### 2.4. 函数的复合 Compositions of Functions\n\nLet $g$ be a function from the set $A$ to the set $B$ and let $f$ be a function form the set $B$ to the set $C$. The composition of the functions $f$ and $g$ denoted by $f \\circ g$ is defined by:\n\n$$\nf \\circ g (a) = f(g(a))\n$$\n\n- $f\\circ g$ can’t be defined unless the range of $g$ is a subset of the domain of $f$.\n\n### 2.5. 高斯函数 Floor and Ceiling Functions\n\n> [!important] 关于高斯函数的实用性质 Useful Properties of the Floor and Ceiling Functions\n> ![|400](https://img.memset0.cn/2024/03/19/bw4HXnEf.png)\n\n## 3. 数列 Sequence\n\n### 3.1. 引言 Introduction\n\nA **数列(sequence)** is a function from a subset of the set of integers (usually either the set $\\{0, 1, 2, \\ldots\\}$ or the set $\\{1, 2, 3,\\ldots\\}$) to a set $S$. We use the notation $a_n$ to denote the image of the integer $n$. We call an a term of the sequence.\n\nA **等比数列(geometric progression)** is a sequence of the form\n\n$$\na,\\ ar,\\ ar^2,\\ \\ldots,\\ ar^n\n$$\n\nwhere the initial term $a$ and the **公比(common ratio)** $r$ are real numbers.\n\nAn **等差数列(arithmetic progression)** is a sequence of the form\n\n$$\na,\\ a+d,\\ a+2d\\, \\ldots,\\ a+nd\n$$\n\nwhere the initial term $a$ and the **公差(common difference)** $d$ are real\nnumbers.\n\n### 3.2. 和式 Summations\n\n$$\n\\sum_{s\\in S} f(s)\n$$\n\n$S$: the subset of the domain of the function $f$\n\n> [!important] Some Useful Summation Formulae\n>\n> ![|400](https://img.memset0.cn/2024/03/19/nO5YyxEI.png)\n\n## 4. 集合的基数 Cardinality of Sets\n\n### 4.1. 引言 Introduction\n\n- The cardinality of a set $A$ is equal to the cardinality of a set $B$, denoted $| A | = | B |$, iff there exists a bijection from $A$ to $B$.\n- If there is an _injection_ from $A$ to $B$, the cardinality of $A$ is less than or the same as the cardinality of $B$ and we write $|A| \\le |B|$. When $|A| \\le |B|$ and $A$ and $B$ have different cardinality, we say that the cardinality of $A$ is less than the cardinality of $B$ and write $|A|<|B|$.\n\n所以说，比较**集合的基数(cardinality of set)** 的大小最关键的步骤就在于找到一个集合 $S$ 到另一个集合 $T$ 的**单射**，如果这样的单射能够找到，就有 $|S|\\le |T|$。\n\n### 4.2. 可数的 Countable\n\n- A set that is either **有限的(finite)** or has the same cardinality as the set of positive integers called **可数的(countable)**.\n- A set that is not countable is called **不可数的(uncountable)**.\n- When an infinite set $S$ is countable, we denote the cardinality of $S$ by $\\aleph_0$ (**阿列夫零(aleph null)**).\n- If $|A| = | \\mathbb{Z}_+ |$, the set $A$ is **可数无穷(countable infinite)**.\n\n> [!example]- 证明：正有理数集 $\\mathbb{Q}_+$ 是可数的。\n>\n> (1) $|\\mathbb{Q}_+| \\le |S|$：$x=p/ q \\rightarrow (p,q)$\n>\n> (2) $|S| = |\\mathbb{Z}_+|$：沿着对角线取——TBD\n>\n> (3) $|\\mathbb{Z}_+| \\le |\\mathbb{Q}_+|$：$x\\rightarrow x/1$\n\n> [!example]- 证明：$0$ 到 $1$ 之间的实数集是不可数的。\n>\n> ![|500](https://img.memset0.cn/2024/06/22/LFoyqlhc.png)\n>\n> ![|480](https://img.memset0.cn/2024/06/22/c3Aj5m03.png)\n>\n> ![|550](https://img.memset0.cn/2024/06/22/HKmYecs0.png)\n\n> [!example]- 证明：$[0,1]$ 和 $(0,1)$ 是等势的。\n>\n> ![|500](https://img.memset0.cn/2024/06/22/GwJYbVUH.png)\n\n> [!example]- 证明：$\\mathbb N$ 的所有有限子集是可数的。\n>\n> 先直接给出一种数数方法：数集合的二进制表示。\n>\n> 再给出一个证明：\n>\n> ![|600](https://img.memset0.cn/2024/06/22/aFp3dpVl.png)\n\n### 4.3. 康托定理 Cantor's Theorem\n\n> [!important] Theorem: **康托定理(Cantor's Theorem)**\n>\n> The cardinality of the powerset of an arbitrary set has a greater cardinality than the original arbitrary set.\n>\n> 实际上有：$|\\mathcal P(\\aleph_k)| = |\\aleph_{k+1}|$。\n","publishedTitle":"「离散数学及其应用」Chapter 2. Basic Structures"}},{"id":"8cdd50f9-1f98-5642-85b8-e67dd9a51d84","fields":{"slug":"/course/dm/note/3/","plainText":"\n> 本篇笔记主要介绍了算法的基本概念，包括算法的定义、性质、函数的增长以及算法的复杂度等内容。通过对这些内容的深入探讨，读者将能够理解算法在计算机科学中的重要性，并掌握评估和分析算法性能的基本方法。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 算法 Algorithms\n\n### 1.1. 导论 Introduction\n\nAn **算法(algorithm)** is a finite set of precise instructions for performing a computation or for solving a problem.\n\n### 1.2. 算法的性质 Properties of Algorithms\n\n算法一般都有一些共同性质，在描述与评价算法时这种性质是常用的。\n\n- **输入(input)**：An algorithm has input values from a specified set.\n- **输出(output)**：From each set of input values, an algorithm produces output values from a specified set.\n- **确定性(definiteness)**：算法的每一步都应该被精确定义。The steps of an algorithm must be defined precisely.\n- **正确性(correctness)**：算法应该给出正确的输出结果。An algorithm should produce the correct output values for each set of input values.\n- **有限性(finiteness)**：算法应当在有限步内结束。An algorithm should produce the desired output after a finite number of steps for any input in the set.\n- **有效性(effectiveness)**：算法的每一步都可以被有效执行。Each step of an algorithm must be executed exactly and in a finite amount of time.\n- **通用性(generality)**：我们的算法应该对于任意符合条件的输入都应用，而不是只适用某些特定的输入。The procedure should be applicable for all problems of the desired form, not just for a particular set of input values.\n\n> [!warning]- correctness 和 effectiveness 辨析 ★\n>\n> correctness 主要将算法应该给出 correct output values，而 effectiveness 则主要指出算法应当是可以被 exactly execute。作业题中有一题是一算法会出现 $1/0$ 的情况，应该判定为缺少 effectiveness.\n\n## 2. 函数的增长 The Growth of Functions\n\n### 2.1. 渐进运行时间 Asymptotic Running Time\n\n**渐进运行时间(asymptotic running time)** is the number of operations used by the algorithm as the input size approaches infinity.\n\n### 2.2. 记号 Notations\n\n**大 O 记号(Big-O notation)**：Let $f$ and $g$ be functions from $Z$ (or $R$) to $R$. We say that “$f(x)$ is $O(g(x))$” if there are constants $C$ and $k$ such that $|f(x)| \\le C|g(x)|$ whenever $x>k$.\n\n**大$\\Omega$记号(Big-Omega notation)**：Let $f$ and $g$ be functions from $Z$ (or $R$) to $R$. We say that “$f(x)$ is $\\Omega(g(x))$” if there are constants $C$ and $k$ such that $|f(x)|\\ge C|g(x)|$ whenever $x>k$.\n\n**大$\\Theta$记号(Big-Theta notation)**：Let $f$ and $g$ be functions from $Z$ (or $R$) to $R$. We say that “$f(x)$ is $\\Theta(g(x))$” if “$f(x)$ is $O(g(x))$” and “$f(x)$ is $\\Omega(g(x))$”, i.e., there are constants $C_1$, $C_2$, and $k$ such that $0\\le C_1 g(x) \\le f(x) \\le C_2 g(x)$ whenever $x>k$.\n\n## 3. 算法的复杂度 Complexity of Algorithms\n\n![|400](https://img.memset0.cn/2024/03/29/dIvQCt1z.png)\n\n> [!note] Commonly used Terminology for the Complexity of Algorithms\n>\n> |     Complexity     |                 Terminology                  |\n> | :----------------: | :------------------------------------------: |\n> |    $\\Theta(1)$     |     **常数复杂度(constant complexity)**      |\n> |  $\\Theta(\\log n)$  |    **对数复杂度(logarithmic complexity)**    |\n> |    $\\Theta(n)$     |      **线性复杂度(linear complexity)**       |\n> | $\\Theta(n \\log n)$ |                                              |\n> |   $\\Theta(n^b)$    |   **多项式复杂度(polynomial complexity)**    |\n> |   $\\Theta(b^n)$    | **指数复杂度(exponential complexity)** (b>1) |\n> |    $\\Theta(n!)$    |     **阶乘复杂度(factorial complexity)**     |\n","publishedTitle":"「离散数学及其应用」Chapter 3. Algorithm"}},{"id":"df2ae727-879e-5ec1-8276-fa606d979981","fields":{"slug":"/course/dm/note/5/","plainText":"\n> 本篇笔记涵盖了计数原理的基本概念，包括加法原理、乘法原理、容斥原理和树形图等。接着介绍了鸽笼原理及其广义形式，排列组合的定义和计算方法，以及如何处理重复元素的排列和组合。还探讨了将对象分配到盒子中的不同情况，组合恒等式的应用，以及递推关系的定义和解法。最后，生成函数的概念及其在计数问题和递推关系中的应用也得到了阐述。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 计数原理 Counting Principles\n\n### 1.1. 加法原理 The Sum Rule\n\n**加法原理(the sum rule)**：If $S$ and $T$ are **不相交的(disjoint)** finite sets, then\n\n$$\n|S\\cup T| = |S| +|T|\n$$\n\n### 1.2. 乘法原理 The Product Rule\n\n**乘法原理(the product rule)**：If $S$ and $T$ are finite sets, then\n\n$$\n|S \\times T| = |S| \\times |T|\n$$\n\nHere $S \\times T$ denotes the Cartesian product of sets $S$ and $T$.\n\n### 1.3. 容斥原理 The Inclusion-Exclusion principle\n\n**容斥原理(the inclusion-exclusion principle = subtraction rule)**：If $S$ and $T$ are finite sets, then\n\n$$\n|S\\cup T| = |S| + |T| - |S\\cap T|\n$$\n\n### 1.4. 树形图 Tree Diagrams\n\n一种用**树形图(tree diagram)** 来计数的思想：To use trees in counting, we use a branch to represent each possible choice. We represent the possible outcomes by the leaves.\n\n> [!example] Chapter 6.1 - Example 9\n>\n> How many bit strings of length four do not have two consecutive 1s?\n>\n> > [!quote]- Solution\n> > ![|320](https://img.memset0.cn/2024/04/07/8n9QNU4U.png)\n> > There are $8$ bit strings of length four without two consecutive 1s.\n\n## 2. 鸽笼原理 The Pigeonhole Principle\n\n> [!important] **鸽笼原理(the pigeonhole principle)**\n>\n> If $k$ is a positive integer and $k+1$ or more objects are placed into $k$ boxes, then there is at least one box containing two or more of the objects.\n\n> [!important] **广义鸽笼原理(the generalized pigeonhole principle)**\n>\n> If $n$ objects are placed into $k$ boxes, then there is at least one box containing at least $\\lceil n/k \\rceil$ objects.\n\n> [!example] Chapter 6.2 - Example 6\n>\n> Every sequence of $n^2+1$ distinct integers contains a subsequence of length $n + 1$ that is either strictly increasing or strictly decreasing.\n>\n> > [!quote]- Solution by myself\n> > Dilworth 定理指出，对于任意有限偏序集，其最长反链长度必等于最小链划分中链的数目。故命题“最长上升子序列的长度为 $n$” 的对偶命题为“非升子序列的最小划分数为 $n$”。\n> >\n> > 对于原数列，若其最长上升子序列的大于等于 $n+1$，则问题解决；否则存在一组 $n$ 个下降子序列的划分。根据鸽笼原理，其中至少有一个的长度大于 $n$，即可找到一个长度大于等于 $n+1$ 的下降子序列。\n>\n> > [!quote]- Solution by teacher\n> >\n> > 反证法：用 $(x_i,y_i)$ 表示第 $i$ 个位置开始的最长上升子序列长度和最长下降子序列长度，根据鸽笼原理，必存在 $i,j$ 满足 $(x_i,y_i) = (x_j,y_j)$，而 $a_i \\neq  a_j$，故矛盾。\n> >\n> > ![480](https://img.memset0.cn/2024/04/07/lARFh590.png)\n> >\n> > ![|480](https://img.memset0.cn/2024/04/07/hxBsNyp7.png)\n\n## 3. 排列组合 Permutations and Combinations\n\n### 3.1. Introduction\n\n> [!summary] Definition: Permutation\n>\n> A **排列(permutation)** of a set of _distinct_ objects is an _ordered_ arrangement of these objects.\n>\n> An r-permutation is an _ordered_ arrangement of $r$ elements of a set, denoted by $P(n,r)$.\n>\n> $$\n> P(n,r) = {n\\times (n-1)\\times \\cdots \\times (n-r+1)}\n> $$\n\n> [!summary] Definition: Combination\n> A r-**组合(combination)** of elements of a set is an _unordered_ selection of $r$ elements from the set, denoted by $C(n,r) = \\displaystyle\\binom n r$.\n>\n> $$\n> C(n,r) = \\frac{P(n,r)}{P(r,r)} = \\frac{n\\times (n-1)\\times \\cdots \\times (n-r+1)}{r\\times (r-1)\\times \\cdots \\times 1}\n> $$\n\n### 3.2. Permutation and Combination with Repetition\n\n**$r$-permutation with repetition**：The number of $r$-permutations of a set of $n$ objects with repetition allowed is\n\n$$\nn^r\n$$\n\n**$n$-permutation with limited repetition**：The number of different permutations of $n$ objects, where there are $n_1$ indistinguishable objects of type1, …, and $n_k$ indistinguishable objects of type $k$, is\n\n$$\n\\frac{n!}{n_1!n_2!\\cdots n_k!}\n$$\n\n**$r$-circle permutation**：The number of $r$-circle permutations of a set of $n$ objects is\n\n$$\n\\frac{P(n,r)}{r}\n$$\n\n![|280](https://img.memset0.cn/2024/04/09/sZRkbD1Z.png)\n\n**$r$-combination with repetition**：The number of $r$-combination from a set with $n$ elements when repetition of elements is allowed is\n\n$$\n\\binom{n+r-1}{r}\n$$\n\n这个就是隔板法大家懂的都懂。\n\n### 3.3. Distributing Objects into Boxes\n\n**Distinguishable objects and distinguishable boxes**：The number of ways to distribute $n$ distinguishable objects into $k$ distinguishable boxes so that $n_i$ objects are place into box $i$, $i=1,2,\\cdots,k$, equals\n\n$$\n\\frac{n!}{n_1! n_2! \\cdots n_k!}\n$$\n\n**Distinguishable objects and indistinguishable boxes**：The number of ways to distribute $n$ distinguishable objects into $k$ indistinguishable boxes is\n\n$$\n\\sum_{j=1}^k S(n,j) = \\sum_{j=1}^k \\left( \\sum_{i=0}^{j-1} \\binom{i}{j} \\frac{(-1)^i (j-i)^n}{j!}  \\right)\n$$\n\n需要引入第二类斯特林数。但一般来说，不搞斯特林数那一套，手动枚举一下可能的隔板情况，并利用组合数进行统计的做法更为高效。\n\n**Indistinguishable objects and distinguishable boxes**：The number of ways to distribute $n$ indistinguishable objects into $k$ distinguishable boxes is\n\n$$\n\\binom{n-1}{k-1}\n$$\n\n还是使用隔板法。\n\n**Indistinguishable objects and indistinguishable boxes**：The number of ways to distribute $n$ indistinguishable objects into $k$ indistinguishable boxes is\n\n### 3.4. 组合恒等式 Combinatorial Indentities\n\n> [!important] Theorem 1: **二项式定理(the binomial theorem)**\n>\n> Let $x$ and $y$ be variables, and let $n$ be a nonegative integer. Then\n>\n> $$\n> (x+y)^n = \\sum_{j=0}^n \\binom{n}{j} x^{n-j} y^j\n> $$\n\n可以得到以下推论：\n\n$$\n\\sum_{k=0}^n \\binom{n}{k} = 2^n\n$$\n\n$$\n\\sum_{k=0}^n (-1)^k \\binom {n}{k} = 0\n$$\n\n> [!important] Theorem 2: **帕斯卡恒等式(PASCAL's identity)**\n>\n> Let $n$ and $k$ be positive integers with $k\\le n$. Then\n>\n> $$\n> \\binom{n+1}{k}=\\binom{n}{k-1}+\\binom{n}{k}\n> $$\n\n> [!important] Theorem 3: **范德蒙德恒等式(Vandermonde's indentity)** ★\n>\n> Let $m,n$ and $r$ be nonnegative integer with $r$ not exceeding either $m$ or $n$. Then\n>\n> $$\n> \\binom{m+n}{r} = \\sum_{k=0}^r \\binom{m}{r-k}\\binom{n}{k}\n> $$\n\n可以得到以下推论：\n\n$$\n\\binom{2n}{n} = \\sum_{k=0}^n \\binom{n}{k}^2\n$$\n\n> [!important] Theorem 4\n> Let $n$ and $r$ be nonnegative integer with $r \\le n$. Then\n>\n> $$\n> \\binom{n+1}{r+1} = \\sum_{j=r}^n\\binom{j}{r}\n> $$\n\n## 4. 组合证明 Combinatorial Proofs\n\nA **数两次的证明方法(double counting proof)** uses counting arguments to prove that both sides of an identity count the same objects, but in different ways.\n\nA **基于双射的证明方法(bijective proof)** shows that there is a bijection between the sets of objects counted by the two sides of the identity.\n\n> [!example]- 利用组合方法证明：$C(n,r)=C(n,n-r)$\n>\n> ![|540](https://img.memset0.cn/2024/04/09/KoYDr1Fd.png)\n\n## 5. 递推关系 Recurrence Relations\n\n### 5.1. 递推关系 Recurrence Relations\n\n> [!summary] Definition: Recurrence Relations\n> A **递推关系(recurrence relation)** for the sequence $\\{a_n\\}$ is an equation that expresses $a_n$ in terms of one or more orf the previous terms of the sequence, namely, $a_0,a_1,\\ldots,a_{n-1}$ or all integers $n$ with $n\\ge n_0$, where $n_0$ is a nonnegative integer.\n>\n> $$\n> a_n= f(a_0,a_1,a_2,\\ldots,a_{n-1}),\\quad  n\\ge n_0\n> $$\n\n满足同一组递推关系的数列可能有很多，我们用**初始条件(initial conditon)** 区分他们。\n\n### 5.2. 线性递推 Linear Recurrence Relations\n\n> [!summary] Definition: Linear Homogeneous Recurrence Relation of Degree $k$ with Constant Coefficients\n>\n> It refers to a recurrence relation in the form\n>\n> $$\n> a_n=c_1 a_{n-1} + c_2 a_{n-2} + \\cdots + c_k a_{n-k}\n> $$\n>\n> where $c_1,c_2,\\ldots,c_k$ are real numbers, and $c_k\\neq 0$.\n\n- **线性(linear)**：linear combination of previous terms\n- **常系数(constant coefficient)**：the coefficients of $a_i$s are constants\n- **阶(degree)** $k$：$a_n$ 可以看做一个之和*前* $k$ 项有关的函数。 $a_n$ is a function of the previous $k$ terms of the sequence\n- **齐次(homogeneous)**：等式右边没有非零的常数项。If we put all the $a_i$s on the left side of the equation and everything else on the right side, then the right side is $0$. Otherwise **非齐次(nonhomogeneous)**\n\n> [!example]- Some Examples\n>\n> ![|500](https://img.memset0.cn/2024/04/16/AaDunHCW.png)\n\n我们可以从常系数 $k$ 阶线性齐次递推的递推式中得到他的**特征方程(characteristic equation)**：\n\n$$\nr^k - c_1 r^{k-1} - c_2 r^{k-2} - \\cdots - c_k = 0\n$$\n\n和**特征根(characteristic root)**：\n\n$$\nr_1,r_2,\\ldots,r_k\n$$\n\n#### 5.2.1. 解常系数线性齐次递推 Solve Linear Homogeneous Recurrence Relation With Constant Coefficients\n\n> [!important] Theorem\n>\n> 设 $c_1,c_2,\\cdots,c_k$ 为实系数。假设递推关系的特征方程 $r^k-c_1 r^{k-1} - \\cdots - c_k=0$ 有 $t$ 个不同的特征根 $r_1,r_2,\\cdots,r_t$ 且重复次数分别为 $m_1,m_2,\\cdots,m_t$。那么常系数线性齐次递推数列 $\\{a_n\\}$ 的一个**通解(general solution)** 是\n>\n> $$\n> \\begin{aligned}\n> a_n = & \\,(\\alpha_{1,0} +\\alpha_{1,1} n+\\cdots+\\alpha_{1,m_1-1} n^{m_1-1}) r_1^n\\\\\n> + & \\,(\\alpha_{2,0} + \\alpha_{2,1} n + \\cdots + \\alpha_{2,m_2-1} n^{m_2-1}) r_2^n  \\\\\n> + &\\, \\cdots\\\\\n> + & \\,(\\alpha_{t,0} + \\alpha_{t,1} n + \\cdots +\\alpha_{t,m_t-1} n^{m_t-1}) r_t^n\n> \\end{aligned}\n> $$\n\n这里通解的系数 $\\alpha_{i, j} \\,(1\\le i\\le t,\\,1\\le j\\le m_i)$ 一般采用插值（或者说解线性方程组）的方式求得。\n\n#### 5.2.2. 解常系数线性非齐次递推 Solve Linear Nonhomogeneous Recurrence Relation With Constant Coefficients\n\n这一节中我们解决的是形如这样的递推关系（这里 $c_i\\,(1\\le i\\le k)$ 是常实数，$F(n)$ 是一个非恒为零且只与 $n$ 有关的函数）：\n\n$$\na_n = c_1 a_{n-1} +c_2 a_{n-2} +\\cdots + c_k a_{n-k} +F(n)\n$$\n\n> [!important] Theorem 1\n>\n> 设 $\\{a_n^{(p)}\\}$ 是常系数线性非齐次递推 $a_n=c_1 a_{n-1} +c_2 a_{n-2}+\\cdots c_k a_{n-k}+ F(n)$ 的一个**特解(particular solution)**，那么他的通解可以被表示为 $\\{a_n^{(p)}+a_n^{(h)}\\}$，这里 $\\{a_n^{(h)}\\}$ 是常系数线性齐次递推 $a_n=c_1 a_{n-1} +c_2 a_{n-2} +\\cdots + c_k a_{n-k}$ 的一个通解。\n>\n> > [!quote]- Proof\n> >\n> > ![|600](https://img.memset0.cn/2024/05/07/3vNPY5HQ.png)\n\n> [!important] Theorem 2 ★\n>\n> 假设常系数线性非齐次递推的非齐次部分可以表示为\n>\n> $$\n> F(n)=(b_t n^t + b_{t-1} n^{t-1} + \\cdots + b_1 n + b_0) s^n\n> $$\n>\n> 那么该非齐次递推的特解遵循以下形式\n>\n> $$\n> n^m (p_t n^t + p_{t-1} n^{t-1} + \\cdots + p_1 n + p_0) s^n\n> $$\n>\n> 这里 $m$ 表示 $s$ 作为特征方程的解的重数，如果 $s$ 不是特征根则 $m=0$。\n\n一般来说要解的 $F(n)$ 都符合 Theorem 2 的形式，这种情况下先把特解的形式代入递推式，即可求特一组特解 $\\{a_n^{(p)}\\}$。随后若给了原数列的初始条件，则将其减去 $\\{a_n^{(p)}\\}$ 中的对应项，从而解得 $\\{a_n^{(h)}\\}$。\n\n## 6. 生成函数 Generating Functions\n\n> [!quote] Some Mathematical Terms\n>\n> - **$x$ 的 $k$ 次方($x$ to the power of $k$)**：$x^k$\n> - **分式分解(partial fraction decomposition)**\n> - **一阶导数(the first derivative)**、**二阶导数(the second derivvative)**：“$f(x)$ 的一阶导”用英语说是“the first derivative of $f(x)$”。\n> - **卷积(convolution)**\n\n> [!summary] Definition: (Original) Generating Function\n>\n> The **生成函数(generating function)** for the sequence $a_0,a_1,a_2,\\ldots a_k,\\ldots$ of read numbers is the infinite series\n>\n> $$\n> G(x) = a_0 + a_1 x + a_2 x^2 + \\cdots + a_k x^k + \\cdots = \\sum_{k=0}^{\\infty} a_k x^k\n> $$\n\n- 在使用生成函数时，我们不关心其定义域，也不关心其的敛散性。\n- 本课程中，我们不学习指数生成函数，狄利克雷生成函数等其他类型的生成函数，故直接用“生成函数”一词默认指代 OGF。\n\n> [!important] Theorem 1\n>\n> Let $f(x) = \\sum\\limits_{k=0}^{\\infty} a_k x^k$，$g(x) = \\sum\\limits_{k=0}^{\\infty} b_k x^k$. Then\n>\n> - $f(x) + g(x) = \\sum\\limits_{k=0}^\\infty (a_k + b_k) x^k$；\n> - $\\alpha \\cdot f(x) = \\sum\\limits_{k=0}^\\infty \\alpha \\cdot a_k x^k$；\n> - $x \\cdot f'(x) = \\sum\\limits_{k=0}^\\infty k \\cdot a_k x^k$；\n> - $f(\\alpha x) = \\sum\\limits_{k=0}^\\infty a_k \\alpha^k x^k$；\n> - $f(x)g(x) = \\sum\\limits_{k=0}^\\infty \\sum\\limits_{i=0}^\\infty a_k b_i x^{k+i}$。\n\n### 6.1. 广义二项式定理 The Extended Binomial Theorem\n\n> [!summary] Definition: **广义二项式(extended binomial coefficient)**\n>\n> Let $u$ be a real number and $k$ a nonnegative integer. Then the extended binomial coefficient is defined by\n>\n> $$\n> \\binom{u}{k} = \\begin{cases}\n> u(u-1)\\cdots (u-k+1)/k! \\quad &\\text{if } k>0\\\\\n> 1\\quad&\\text{if }k=0\n> \\end{cases}\n> $$\n\n> [!important] Theorem: **广义二项式定理(the extended binomial theorem)** ★\n> Let $x$ be a real number with $|x|<1$ and let $u$ be a real number. Then\n>\n> $$\n> (1+x)^u  = \\sum_{k=0}^\\infty \\binom{u}{k} x^k\n> $$\n\n### 6.2. Some Common Used Generating Functions\n\n|        Sequence         |             Generating Function             |\n| :---------------------: | :-----------------------------------------: |\n|        $C(n,k)$         |                  $(1+x)^n$                  |\n|      $C(n,k) a^k$       |                 $(1+ax)^n$                  |\n|         $[k<n]$         | $1+x+x^2+\\cdots+x^{n-1}=\\dfrac{1-x^n}{1-x}$ |\n|           $1$           |              $\\dfrac{1}{1-x}$               |\n|          $a^k$          |              $\\dfrac{1}{1-ax}$              |\n|          $k+1$          |            $\\dfrac{1}{(1-x)^2}$             |\n|      $C(n+k-1,k)$       |                $(1-x)^{-n}$                 |\n|   $(-1)^k C(n+k-1,k)$   |                $(1+x)^{-n}$                 |\n|    $C(n+k-1,k) a^k$     |                $(1-ax)^{-n}$                |\n|     $\\dfrac{1}{k!}$     |                    $e^x$                    |\n| $\\dfrac{(-1)^{k+1}}{k}$ |                 $\\ln (1+x)$                 |\n\n### 6.3. 生成函数的应用 Applications of Generating Function\n\n> [!example] Example: Solve Counting Problems with Generating Function\n>\n> Suppose that there are $2r$ red balls, $2r$ blue balls, and $2r$ white balls. How many ways to select $3r$ balls from these balls?\n>\n> > [!quote]- Combinational Solution\n> >\n> > 容斥原理+隔板法。先不加限制任取，然后减掉某种颜色选超过 $2r$ 个的情况，按理来说还要加上有两个选超但是这已经超过 $3r$ 了故不需要考虑。所以答案是：\n> >\n> > $$\n> > \\binom{3r+3-1}{3-1} - 3 \\binom{3r-(r-1)+3-1}{3-1}\n> > $$\n>\n> > [!quote]- Solution by Generating Function\n> >\n> > $$\n> > [x^{3r}] \\left( \\frac{1-x^{2r+1}}{1-x} \\right)^3 = \\binom{3r+2}{2}- 3\\binom{r+1}{2}\n> > $$\n\n> [!example] Example: Solve Recurrence Relations with Generating Function\n>\n> Use generating functions to solve the recurrence relation $a_n=2a_{n-1} + 3 a_{n-2} + 4^n + 6$ with initial conditions $a_0=20,\\,a_1=60$.\n>\n> > [!quote]- Solution\n> >\n> > ![ydMpu3C0.png|590](https://img.memset0.cn/2024/04/26/ydMpu3C0.png)\n> >\n> > ![sgMGeqvD.png|365](https://img.memset0.cn/2024/04/26/sgMGeqvD.png)\n\n## 7. 容斥原理 The Principle of Inclusion-Exclusion\n\n> [!important] Theorem: The Principle of Inclusion-Exclusion\n>\n> $$\\mid A_{1}\\cup A_{2}\\cup\\cdots\\cup A_{n}\\mid=\\sum_{i=1}^{n}|A_{i}|-\\sum_{1\\leq i<j\\leq n}| A_{i}\\cap A_{j}|+\\sum_{1\\leq i<j<k\\leq n}| A_{i}\\cap A_{j}\\cap A_{k}|+\\cdots+(-1)^{n+1} | A_{1}\\cap A_{2}\\cap\\cdots\\cap A_{n}|$$\n>\n> and an alternative form:\n>\n> $$N(P_1^{\\prime}P_2^{\\prime}\\cdots P_n^{\\prime})=N-\\left|A_1\\cup A_2\\cdots\\cup A_n\\right|=N-\\sum_{1\\leq i\\leq n}N(P_i)+\\sum_{1\\leq i<j\\leq n}N(P_iP_j)+\\cdots+(-1)^nN(P_1P_2\\cdots P_n)$$\n\n### 7.1. Examples\n\n#### 7.1.1. 埃氏筛 The Sieve of Eratoshenes\n\n> [!example] Example: The sieve of Eratoshenes\n>\n> ![|300](https://img.memset0.cn/2024/04/23/RZk5WHVt.png)\n\n> [!example] Example: Derangement\n>\n> Count the permutations for n objects that leave no objects in their original positions.\n>\n> > [!important] Theorem\n> >\n> > The number of derangements of a set with $n$ elements is\n> >\n> > $$\n> > D_n=n! \\left(1-\\frac{1}{1!}+\\frac{1}{2!}-\\frac{1}{3!}+\\cdots+(-1)^n \\frac{1}{n!} \\right)\n> > $$\n","publishedTitle":"「离散数学及其应用」Chapter 6 & 8. Counting"}},{"id":"ba73b2c7-bef8-5044-bc18-455982a13965","fields":{"slug":"/course/dm/note/6/","plainText":"\n> 本篇笔记主要介绍了二元关系的定义、表示方法及其特殊性质，包括自反性、对称性、传递性等。还介绍了关系的组合、复合、逆关系及其闭包，最后探讨了等价关系和偏序关系的概念及其相关定理。通过这些内容，读者可以深入理解关系在集合论中的重要性及其应用。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 二元关系 Binary Relations\n\nA **二元关系(binary relation)** $R$ from a set $A$ to a set $B$ is a subset of $A\\times B$.\n\n- 关系是集合：“A binary relation $R$” is a set.\n- $R\\subseteq A\\times B$\n- $R=\\{(a,b)\\mid a\\in A, b\\in B, a\\;R\\;b\\}$.\n- “A relation on set $A$” means a relation from set $A$ to itself.\n\n> [!example]- Question: How many binary relations are there on a set $A$ with $n$ elements?\n>\n> $$\n> 2^{n^2}\n> $$\n\n> [!success] 关系的证明题的解题思路\n>\n> - 利用定义。\n> - 利用数学归纳法。\n\n### 1.1. 表示方法 Represent Methods\n\n#### 1.1.1. 连接矩阵 Connection Matrices\n\n举个例子，$R$ 是一个二元关系，表示两个集合中按位或不为零的对：\n\n$$\n\\begin{aligned}\nA  =\\{2,&3,4\\},B=\\{2,3,4,5,6\\} \\quad\nR = \\{(x,y) \\mid x \\in A,\\ y \\in B,\\ x \\mid y\\} \\\\\n&\\implies R =\\{(2,2),(2,4),(2,6),(3,3),(3,6),(4,4)\\}\n\\end{aligned}\n$$\n\n可以通过**连接矩阵(connection matrix)** 表示二元关系：\n\n![jHqiS9Pb.png|277](https://img.memset0.cn/2024/04/23/jHqiS9Pb.png)\n\n#### 1.1.2. 有向图 Directed Graph\n\n关系 $(V,E)$ 对应的**有向图(directed graph = digraph)** 是将 $V$ 作为点集，$E$ 作为边集的图。\n\n对于一条边 $(a,b)$，$a$ 被叫作其**起始节点(initial vertice)**，$b$ 被叫作其**终止节点(terminal vertice)**。\n\n### 1.2. 二元关系的特殊性质 Special Properties of Binary Relations\n\n| 性质                        | 条件                                                                                 | 备注                                                                                    | 举例                   |\n| --------------------------- | ------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------- | ---------------------- |\n| **自反性(reflexive)**       | $\\forall x (x\\in A\\rightarrow (x,x)\\in R)$                                           |                                                                                         | $(\\mathbb Z, =)$       |\n| **非自反性(irreflexive)**   | $\\forall x (x\\in A\\rightarrow (x,x)\\not\\in R)$                                       |                                                                                         | $(\\mathbb Z, \\neq)$    |\n| **对称性(symmetric)**       | $\\forall x\\forall y((x,y)\\in R\\rightarrow (y,x)\\in R)$                               |                                                                                         | $(\\mathbb Z_+, \\perp)$ |\n| **反对称性(antisymmetric)** | $\\forall x \\forall y((x,y)\\in R \\land (y,x)\\in R\\rightarrow x=y)$                    | 与非对称性的差别在于允许有自环。                                                        | $(\\mathbb Z, \\leq)$    |\n| **非对称性(asymmetric)**    | $\\forall x \\forall y ((x,y) \\in R \\rightarrow \\lnot ((y,x)\\in R))$                   | 与反对称性的差别在于不允许有自环，是更强的条件。                                        | $(\\mathbb Z, <)$       |\n| **传递性(transitive)**      | $\\forall x \\forall y \\forall z ((x,y)\\in R \\land (y,z)\\in R \\rightarrow (x,z)\\in R)$ | 若同时存在 $x\\rightarrow y$ 和 $y \\rightarrow z$ 的边，则必存在 $x\\rightarrow z$ 的边。 | $(\\mathbb Z, \\leq)$    |\n\n> [!example]- 讨论题\n>\n> Is a relation $R$ is reflexive if it is symmetric and transitive?\n>\n> > [!quote] Yet a wrong proof\n> >\n> > $(a,b) \\in R$ and $R$ is symmetric implys $(b,a) \\in R$.\n> >\n> > $(a,b) \\in R$, $(b,a)\\in R$ and $R$ is transitive $(a,a) \\in R$.\n> >\n> > Which means that $R$ is reflexive.\n>\n> Incorrect. Because it cannot be guaranteed that for all $a \\in S$, there exists a $b$ such that $(a,b)\\in R$. Therefore, there might exist such an $a\\in R$ for which there is no relation concerning $a$.\"\n\n## 2. 组合关系 Combining Relations\n\n因为定义在集合 $A, B$ 上的任意关系 $R$ 是 $A\\times B$ 的子集，我们可以对关系定义任意组合运算。\n\n### 2.1. 集合运算 Set Operations\n\n定义在关系上的集合运算可以直接类比集合上的集合运算。\n\nLet $A=\\{a_1,a_2,\\cdots,a_n\\}$, $B=\\{b_1,b_2,\\cdots,b_n\\}$, $M_{R_1} = [c_{ij}]$, $M_{R_2}=[d_{i,j}]$, the set operations of two relations are defined by\n\n$$\n\\begin{aligned}\nM_{R_1 \\cup R_2} &= [c_{ij} \\lor d_{ij}] = M_{R_1} \\lor M_{R_2} \\\\\nM_{R_1 \\cap R_2} &= [c_{ij} \\land d_{ij}] = M_{R_1} \\land M_{R_2}\\\\\nM_{\\overline{R_1}}&=[\\overline{c_{ij}}]\\\\\nM_{R_1-R_2} &= M_{R_1\\cap \\overline{R_2}} = [c_{ij} \\land \\overline{d_{ij}}]\\\\\n\\end{aligned}\n$$\n\n### 2.2. 关系的复合 Composition of Relations\n\n对于关系 $R=\\{(a,b)\\mid a\\in A,b\\in B,aRb\\}$ 和关系 $S=\\{(b,c)\\mid b\\in B, c\\in C, bSc\\}$，定义 **$S$ 与 $R$ 的复合(the composite of $R$ and $S$)** 为：\n\n$$\nS \\circ R =\\{(a,c)\\mid a\\in A \\land c\\in C \\land \\exists b(b\\in B\\land aRb \\land bSc)\\}\n$$\n\n- 关系合成运算满足结合律：$(R\\circ Q)\\circ S = R \\circ (Q \\circ S)$。\n\n于此我们还可以递归定义**关系的幂(the power of relation)**：\n\n$$\nR^1=R,\\text{ and }R^{n+1}=R^n\\circ R\n$$\n\n> [!important] Theorem\n>\n> The relation $R$ on a set $A$ is transitive if and only if $R^n \\subseteq R,\\, n=1,2,3,\\ldots$.\n>\n> > [!quote]- Proof\n> >\n> > (1) $\\forall n (R^n\\subseteq R) \\Rightarrow R \\text{ is transitive}$\n> >\n> > $(a,b)\\in R$，$(b,c)\\in R$，故 $(a,b)\\in R^2$；由于 $R^2\\subseteq R$，可以得到 $(a,c)\\in R$，故 $R\\text{ is transitive}$。\n> >\n> > (2) $R\\text{ is transitive} \\Rightarrow \\forall n (R^n \\subseteq R)$\n> >\n> > 使用数学归纳法，对于所有 $(a,b)\\in R^{n+1}=R^n\\circ R$，那么 $(a,x)\\in R^n\\subseteq R,\\ (x,b)\\in R$ 且 $R$ 有传递性可以推出 $(a,b)\\in R$。\n\n### 2.3. 逆关系 Inverse Relations\n\n对于定义在集合 $A$ 到 $B$ 上的关系 $R=\\{(a,b)\\mid a\\in A,b\\in B,aRb\\}$，我们可以定义 $B$ 到 $A$ 的**逆关系(inverse relation)**：\n\n$$\nR^{-1} = \\{(b,a) \\mid (a,b)\\in R ,a\\in A,b\\in B\\}\n$$\n\n> [!note]- 一些关于逆关系的恒等式\n>\n> 设 $R,S$ 是从集合 $A$ 到集合 $B$ 上的关系，$T$ 是从集合 $B$ 到集合 $C$ 的关系，$P$ 是从集合 $C$ 到集合 $D$ 的关系。\n>\n> - $(R \\cup S)^{-1} = R^{-1} \\cup S^{-1}$\n> - $(R\\cap S)^{-1} = R^{-1} \\cap S^{-1}$\n> - $(\\overline R)^{-1} = \\overline{R^{-1}}$\n> - $(R-S)^{-1} = R^{-1} - S^{-1}$\n> - $(A\\times B)^{-1} = B \\times A$：\n> - $\\overline R= A \\times B - R$\n> - $(S \\circ T)^{-1} = T^{-1} \\circ S^{-1}$\n> - $(R \\circ T) \\circ P = R \\circ (T \\circ P)$\n> - $(R \\cup S) \\circ T = R \\circ T \\cup S \\circ T$\n\n## 3. 关系的闭包 Closures of Relations\n\n> [!summary] Definition: 关系的闭包\n>\n> The **闭包(closure)** of a relation $R$ with respect to property $P$ is the relation $S$ with property if and only if\n>\n> (1) $S$ contains $R$;\n>\n> (2) $S$ is a subset of every relation with property $P$.\n>\n> (3) $S$ is the smallest relation satisfying (1) and (2).\n\n### 3.1. 自反闭包 Reflexive Closure\n\n给定关系 $R$，其**自反闭包(reflexive closure)** 是在 $R$ 上添加元素，使得对于每一个元素 $a$，都有 $(a, a)$ 在 R 中。\n\n> [!important] Theorem\n>\n> 关系 $R$ 的自反闭包用 $r(R)$ 表示，且满足 $r(R) = R \\cup I_A$。\n>\n> - 这里 $I_A$ 表示集合 $A$ 上的对角线关系，即 $I_A = \\{(x,x) \\mid x \\in A\\}$。\n>\n> > [!quote]- Proof\n> >\n> > ![|500](https://img.memset0.cn/2024/05/13/eF4AKxZo.png)\n\n> [!important] Corollary\n>\n> $R = R \\cup I_A$ 当且仅当 $R$ 是自反关系。\n>\n> > [!quote]- Proof\n> >\n> > ![|420](https://img.memset0.cn/2024/05/27/VmP32Mw0.png)\n\n### 3.2. 对称闭包 Symmetric Closure\n\n给定关系 $R$，其**对称闭包(symmetric closure)** 是在 $R$ 上添加元素，使得对于每一对元素 $(a, b)$，如果 $(a, b)$ 在 R 中，那么 $(b, a)$ 也在 $R$ 中。\n\n> [!important] Theorem\n>\n> 关系 $R$ 的对称闭包用 $s(R)$ 表示，且满足 $s(R) = R \\cup R^{-1}$。\n>\n> > [!quote]- Proof\n> >\n> > ![|490](https://img.memset0.cn/2024/05/13/MbiFU6BO.png)\n> >\n> > ![|520](https://img.memset0.cn/2024/05/13/knvAP0JH.png)\n\n> [!important] Corollary\n>\n> $R = R \\cup R^{-1}$ 当且仅当 $R$ 是对称关系。\n\n### 3.3. 传递闭包 Transitive Closure\n\n给定关系 $R$，其**传递闭包(transitive closure)** 是在 $R$ 上添加元素，使得对于每一对元素 $(a, b)$ 和 $(b, c)$，如果 $(a, b)$ 和 $(b, c)$ 在 $R$ 中，那么 $(a, c)$ 也在 $R$ 中。\n\n> [!important] Theorem 1\n>\n> 设 $R$ 是定义在 $A$ 上的关系，则有一条从 $a$ 到 $b$ 的长度为 $n$ 的路径当且仅当 $(a,b) \\in R^n$。\n>\n> 一些来自下一章的概念：\n>\n> - A **路径(path)** of length $n$ in a digraph $G$: A sequence of edges $(x_0,x_1),(x_1,x_2),\\ldots,(x_{n-1},x_n)$.\n> - **环(cycle)**: A path of length $n$ with $x_0=x_n (n\\ge 1)$.\n>\n> > [!quote]- Proof (by induction)\n> >\n> > ![|500](https://img.memset0.cn/2024/05/13/lIkfBsZF.png)\n\n> [!important] Theorem 2\n>\n> The **传递闭包(transitive closure)** of a relation $R$ is $t(R) = R^\\ast$.\n>\n> > [!summary] Definition: 连通关系\n> >\n> > **连通关系(connectivity relation)** 是所有可通过 $R$ 上的边连通的有序对的集合，即：\n> >\n> > $$\n> > R^\\ast = \\displaystyle{\\bigcup_{i=1}^\\infty R^i}\n> > $$\n>\n> > [!quote]- Proof\n> >\n> > 证明 $R^\\ast$ 是 $R$ 的传递闭包：\n> >\n> > (1) $R \\subseteq R^\\ast$。\n> >\n> > (2) $R^\\ast$ is transitive：对于任意 $(a,b) \\in R^\\ast \\land (b,c) \\in R^\\ast$，有一条从 $a$ 到 $b$ 的路径和一条从 $b$ 到 $c$ 的路径，那自然也有一条从 $a$ 到 $c$ 的路径，故 $(a,c) \\in R^\\ast$。\n> >\n> > (3) $R^\\ast$ is the smallest：对于任意 $S$ 满足 $S$ 具有传递性且 $R\\subseteq S$。我们有 $R^\\ast \\subseteq S^\\ast = S$，故 $R^\\ast \\subseteq S$，得证。\n\n实际上，通过 $R^\\ast = \\displaystyle{\\bigcup_{i=1}^n R^i}$ 即可计算，因为根据鸽笼原理可以证明，长度 $>n$ 的环至少有一个环。\n\n> [!important] Floyd-Warshall Algorithm\n>\n> 可以通过 Floyd-Warshall 算法求解关系的传递闭包。（这就是最经典的 $O(n^3)$ 的 Floyd 算法。）\n>\n> ![|313](https://img.memset0.cn/2024/05/25/avpGisKx.png)\n\n## 4. 等价关系 Equivalence Relations\n\n> [!summary] Definition: Equivalence relation\n>\n> A relation $R$ on a set $A$ is an **等价关系(equivalence relation)** if $R$ is (1) reflexive; (2) symmetric; (3) transitive.\n>\n> We call $a$ and $b$ is **等价的(equivalent)** if $(a,b) \\in R$, denoted as $a\\sim b$.\n\n如果我们想要证明一个关系是等价关系，通常可以通过证明这一关系满足以上三个性质。\n\n### 4.1. 等价类 Equivalence Classes\n\n> [!summary] Definition: Equivalence class\n>\n> The **等价类(equivalence class)** of $x$: the set of all elements that is equivalent to $x$, denoted as $[x]_R$ or $[x]$.\n\n> [!important] Theorem\n>\n> 如果 $R$ 是集合 $A$ 上的等价关系，则以下三个命题等价：\n>\n> (1) $aRb$\n>\n> (2) $[a]=[b]$\n>\n> (3) $[a]\\cap[b] \\neq \\emptyset$\n>\n> > [!note] Note\n> >\n> > (2) 和 (3) 的区别在于我们需要说明 $[a]$ 和 $[b]$ 不是空集。\n>\n> > [!quote]- Proof\n> >\n> > ![|500](https://img.memset0.cn/2024/06/22/X42rGPW3.png)\n> >\n> > ![|500](https://img.memset0.cn/2024/06/22/ABjw8WKz.png)\n\n> [!important] Theorem 1\n>\n> 设 $R_1,R_2$ 是集合 $A$ 上的等价关系，则 $R_1 \\cap R_2$ 也是集合 $A$ 上的等价关系。\n\n> [!important] Theorem 2\n>\n> 设 $R_1,R_2$ 是集合 $A$ 上的等价关系，则 $R_1 \\cup R_2$ 具有自反性和对称性。进一步的，$(R_1\\cup R_2)^\\ast$ 是集合 $A$ 上的等价关系。\n\n### 4.2. 划分 Partitions\n\n> [!summary] Definition: Partition\n>\n> A **划分(partition)** of set $A$ is a collection of disjoint nonempty subsets of $A$ that have $A$ as their union, denoted as $pr(A) = \\{A_1,A_2,\\cdots A_n\\}$.（两两不交，并为全集）\n\n> [!important] Theorem\n>\n> Let $R$ be an equivalence relation on a set $A$. Then the equivalence classes of $R$ form a partition of $A$.\n>\n> Conversely, given a partition $\\{A_i\\mid i \\in I\\}$ of the set $A$, there is an equivalence relation $R$ that has the sets $A_i,i\\in I$, as its equivalence classes.\n\n集合 $A$ 的所有等价类是原集合的一个划分；任给一个划分存在一个关系 $R$ 使得划分出的每个子集都是等价类。\n\n## 5. 偏序关系 Partial Orderings\n\n### 5.1. 偏序集 Poset\n\n> [!summary] Definition: Partial ordering\n> A relation $R$ on a set $A$ is an **偏序关系(partial ordering)** if $R$ is (1) reflexive; (2) antisymmetric; (3) transitive.\n>\n> Notation:\n>\n> - $(S,R)$: partially ordered set or **偏序集(poset)**.\n> - $a\\preccurlyeq b$: $(S,R)$ is a poset and $(a,b) \\in R$.\n\n如 $(\\mathbb Z, \\leq)$ 对应的关系为 $R=\\{(a,b)\\mid a,b\\in \\mathbb Z\\land a\\le b\\}$。\n\n### 5.2. 字典序 Lexicographic Order\n\n> [!summary] Definition: **字典序(lexicographic order)**\n>\n> Given two posets $(A_1,\\preccurlyeq_1)$ and $(A_2,\\preccurlyeq_2)$, the lexicographic ordering on $A_1\\times A_2$ is defined by specifying that $(a_1,a_2)$ is less than $(b_1,b_2)$, that is, $(a_1, a_2)\\prec (b_1,b_2)$, either if $a_1 \\prec_1 b_1$ or if $a_1 =_1 b_1$ and $a_2 \\prec_2 b_2$.\n\n相当于就是从低位到高位依次比较大小。这是定义在两个偏序集的笛卡尔积上，可以通过此定义递推得到多个偏序集的笛卡尔积的字典序的定义。\n\n> [!important] Theorem\n>\n> 由多个偏序集的笛卡尔积得到的字典序是一个偏序关系。\n\n### 5.3. 哈斯图 Hasse Diagrams\n\n**哈斯图(hasse diagram)** 是一种表示偏序集或者格的图形工具。构架哈斯图的步骤如下：\n\n1. 根据偏序集 $(A,R)$ 构造有向图，并使所有边都指向上方。（一般来说哈斯图是上大下小的）\n2. 消除所有的自环。\n3. 消除所有可由偏序集的传递性导出的边。\n4. 消除所有边的箭头，因为所有的边都应该是指向上方的。\n\n> [!summary] Definition: maximal/minimal elements\n>\n> 设 $(A,\\preccurlyeq)$ 是一个偏序集，称 $a$ 是一个**最大元素(maximal element)** 当且仅当 $A$ 中不存在元素 $b$ 满足 $a \\prec b$。称 $a$ 是一个**最小元素(minimal element)** 当且仅当 $A$ 中不存在元素 $b$ 满足 $b\\prec a$。\n\n显然，最小元素和最大元素可能不止一个。进一步地，在任意有限偏序集中，其最大元素和最小元素一定存在。体现在哈斯图中，则最大元素是位于其顶端的点，最小元素是位于其底端的点。正确性显然。\n\n> [!summary] Definition: greatest/least element\n>\n> 设 $(A,\\preccurlyeq)$ 是一个偏序集，称 $a$ 是其**最大值(greatest element)** 当且仅当对于每个 $A$ 中的元素 $b$ 都有 $b \\preccurlyeq a$；称 $a$ 是其**最小值(least element)** 当且仅当对于每个 $A$ 中的元素 $b$ 都有 $a \\preccurlyeq b$。\n\n偏序集的最大值和最小值不一定存在，且如果存在则一定是唯一的。\n\n> [!summary] Definition: upper/lower bounds\n>\n> 设 $(S,\\preccurlyeq)$ 是一个偏序集，$A \\subset S$。若存在一个 $S$ 中的元素 $a$ 满足对于 $A$ 中的所有元素 $b$ 都有 $b\\preccurlyeq a$，则称 $a$ 是 $A$ 的一个**上界(upper bound)**。若存在一个 $S$ 中的元素 $a$ 满足对于所有 $A$ 中的元素 $b$ 都有 $a\\preccurlyeq b$，则称 $a$ 是 $A$ 的一个**下界(lower bound)**。\n\n类似的，上下界可能不止一个，也可能不存在。\n\n可以通过哈森图帮助我们找到子集的上下界。\n\n![gTZSJKzn.png|572](https://img.memset0.cn/2024/05/20/gTZSJKzn.png)\n\n> [!summary] Definition: least upper bound / greatest lower bound\n>\n> 如果 $a$ 是子集 $A$ 的上界中最小的，则称其是 $A$ 的**最小上界(least upper bound)**，记为 $\\text{lub}(A)$。如果 $a$ 是子集 $A$ 的下界中最大的，则称其是 $A$ 的**最大下界(greatest lower bound)**。\n\n### 5.4. 链 Chain\n\n> [!summary] Definition: comparable / incomparable\n> The elements $a$ and $b$ of a poset $(S,\\preccurlyeq)$ are **可比较的(comparable)** if either $a\\preccurlyeq b$ or $b\\preccurlyeq a$. When $a$ and $b$ are elements of $S$ so that neither $a\\preccurlyeq b$ nor $b\\preccurlyeq a$, then $a$ and $b$ are called **不可比较的(incomparable)**.\n\n对于偏序集 $(S,R)$ 如果集合 $S$ 中的元素两两都是可比较的，那么认为 $S$ 是**全序的(total ordered)** 或者说**线性关系(linear order)**。\n\n> [!summary] Definition: Chain\n>\n> $(A,\\preccurlyeq)$ 是一个偏序集，$B\\subseteq A$。如果 $(B,\\preccurlyeq)$ 是全序的，则称 $B$ 是 $A$ 的一条**链(chain)**。\n\n> [!summary] Definition: Antichain\n>\n> $(A,\\preccurlyeq)$ 是一个偏序集，$B\\subseteq A$。如果 $\\forall a, b ,\\in B(a \\neq b),\\space (a, b)\\not\\in R, (b, a)\\not\\in R$，则称 $B$ 是 $A$ 的一条**反链(antichain)**。\n\n### 5.5. 良序集 Well-ordered Sets\n\n> [!summary] Definition: Well-ordered set\n>\n> 一个偏序集 $(A,R)$ 是**良序集(well-ordered set)** 当且仅当其每一个非空子集都有一个最小值。\n\n一个偏序集一定是一个**全序集(totally ordered set)**。\n\n### 5.6. 格 Lattices\n\n> [!summary] Definition: Lattices ★\n>\n> 一个偏序集被称为**格(lattice)** 当且仅当其每一对元素都有一个最小上界和最大下界。\n\n如 $(\\mathbb Z^+, \\mid)$ 是一个格，对于其任意一对元素 $(x,y)$，他们的 lub 为他们的**最小公倍数(least common multiple)**，记为 $\\text{lcm}(x,y)$；他们的 glb 为他们的**最大公因数(great common divisor)**，记为 $\\gcd(x,y)$。\n","publishedTitle":"「离散数学及其应用」Chapter 9. Relations"}},{"id":"0890813c-8526-5c39-b4c9-4d328defb9ae","fields":{"slug":"/course/dm/note/7/","plainText":"\n> 本篇笔记主要介绍了图论的基本概念，包括图的定义、类型（如无向图、有向图、二分图等）、图的表示方法（邻接矩阵和关联矩阵）、图同构、连通性、经典图论问题（如欧拉路径、哈密顿路径、最短路径问题和平面图）以及图的染色与对偶图等内容。通过这些内容，读者可以深入理解图的结构及其在不同领域中的应用。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 图论术语 Graph Terminologies\n\n### 1.1. 基本术语 Basic Terminology\n\n> [!summary] Definition: Graph\n> A **图(graph)** $G=(V,E)$ consists of $V$, a nonempty set of **顶点(vertex, node)** and $E$, a set of **边(edge)**. Each edge has either one or two vertices associated with it, called its **端点(endpoint)**. An edge is said to **连接(connect)** its endpoints.\n\n在无向图中，定义点的**度(degree)** 与这一顶点**关联(incident)** 的边的数量。记号：$\\text{deg}(v)$。\n\n- 如果 $\\text{deg}(v) = 0$，则称 $v$ 是**孤立的(isolated)**；\n- 如果 $\\text{deg}(v) = 1$，则称 $v$ 是**悬挂的(pendant)**。\n\n### 1.2. 无向图和有向图 Undirected and Directed Graphs\n\n![](https://img.memset0.cn/2024/05/20/1f3nONYr.png)\n\n**无向图(undirected graph)**：\n\n- **简单图(simple graph)**：没有重边和自环的无向图。\n- **多重图(multigraph)**：允许重边但不允许自环的无向图。\n- **伪图(pseudograph)**：允许自环和重边的无向图。\n\n![Uy7IUPyq.png|406](https://img.memset0.cn/2024/06/22/Uy7IUPyq.png)\n\n**有向图(directed graph = digraph)**：$E$ 是**有向边(directed edge, arc)** 的集合。\n\n- **简单有向图(simple directed graph)**：没有重边和自环的有向图。\n- **有向多重图(directed multigraph)**：有重边或自环的有向图。如果恰有一条 $(u,v)$ 的边和一条 $(v,u)$ 的边，这种情况不属于重边。\n\n### 1.3. 一些特殊的简单图 Some Special Simple Graphs\n\n**完全图(complete graph)** - $K_n$：$n$ 个顶点有一条边的简单无向图。\n\n![|449](https://img.memset0.cn/2024/11/13/5jJF5AHG.png)\n\n**环(cycle)** - $C_n\\ (n>2)$：\n\n![gMi8SdeB.png|448](https://img.memset0.cn/2024/05/14/gMi8SdeB.png)\n\n**轮(wheel)** - $W_n\\ (n>2)$：在 $C_n$ 的基础上添加一个点，并于前 $n$ 个点相连。（注意 $W_n$ 有 $n+1$ 个点）\n\n![lKNyixLm.png|441](https://img.memset0.cn/2024/05/14/lKNyixLm.png)\n\nn-Cubes - $Q_n (n>0)$：\n\n![ONwVeFU2.png|475](https://img.memset0.cn/2024/05/14/ONwVeFU2.png)\n\n### 1.4. 二分图 Bipartite Graph\n\n> [!summary] Definition: **二分图(bipartite graph)**\n>\n> 一个简单图是**二分的(bipartite)** 当且仅当其点集 $V$ 可以被划分成两个子集 $V_1$ 和 $V_2$ 满足所有边都是连接 $V_1$ 和 $V_2$ 的（即 $V_1$ 和 $V_2$ 内部不连边）。\n\n**完全二分图(complete bipartite graph)**：对于 $V_1$ 和 $V_2$ 的每个点之间都有连边的二分图。\n\n> [!important] Theorem\n>\n> 一个图是二分的当且仅当其可以被黑白染色。\n\n### 1.5. 正则图 Regular Graph\n\n> [!summary] Definition: Regular Graph\n>\n> 一个简单图是**正则的(regular)** 当且仅当其每个顶点都有相同的度。\n>\n> 一个**正则图(regular graph)** 被称为 $n$-regular 的当且仅当每个顶点的度数均为 $n$。\n\n## 2. 图表示 Graph Representings\n\n> [!summary] **邻接矩阵(adjacency matrix)**\n>\n> 一张 $n$ 个点 $(v_1,v_2,\\cdots,v_n)$ 的简单图 $G=(V,E)$ 可以用邻接矩阵 $A$ 表示，其中：\n>\n> $$\n> a_{i,j} = \\begin{cases}  1 \\quad\\text{if }\\{v_i,v_j\\}\\text{ is an edge of }G\\\\0\\quad\\text{otherwise.}\\end{cases}\n> $$\n\n> [!summary] **关联矩阵(incidence matrix)**\n>\n> 一张 $n$ 个点 $m$ 条边的简单图 $G=(V,E)$ 可以用邻接矩阵 $A_{n\\times m}$ 表示，其中：\n>\n> $$\n> a_{i,j} = \\begin{cases}\n> 1\\quad&\\text{iff edge }e_j\\text{ is incident with }v_i\\\\\n> 0\\quad&\\text{otherwise.}\n> \\end{cases}\n> $$\n\n## 3. 图同构 Graph Isomorphism\n\n> [!summary] 同构\n>\n> 我们称两个图 $G_1=(V_1,E_1)$ 和 $G_2=(V_2,E_2)$ 是**同构(isomorphic)** 的当且仅当存在一个从 $V_1$ 到 $V_2$ 的双射函数满足 $(u,v) \\in E_1$ 当且仅当 $(f(u),f(v)) \\in E_2$。\n\n判定两个图是否同构，重点可以考察一些**不变量(invariant)**，比如：\n\n- 点数\n- 边数\n- 对应点的度数\n- 如果一个是二分图，另一个也必须是二分图\n- 如果一个是完全图，另一个也必须是完全图\n\n等等。所以，如果我们要断言图是同构的，就给出一组映射关系；如果我们要断言图不是同构的，就找出一个改变的不变量。\n\n## 4. 连通性 Connectivity\n\n### 4.1. 无向图的连通性 Connectedness in Undirected Graphs\n\n一张无向图被称作**联通的(connected)** 当且仅当对于每一对图中的点对，都存在一条他们之间的路径。\n\n无向图的极大连通子图被称为一个**联通块(connected component = component)**\n\n- 在无向图中，如果删除一个点会产生更多的联通块，则将这个点称为**割点(cut vertex)**。\n- 在无向图中，如果删除一条边会产生更多的联通块，则将这条边称为**割边(cut edge)** 或**桥(bridge)**。\n\n### 4.2. 有向图的连通性 Connectedness in Directed Graphs\n\n在一张有向图中，如果对于任意两个点 $a,b$ 都存在一条从 $a$ 到 $b$ 的有向路径，也存在一条 $b$ 到 $a$ 的有向路径，则称这个有向图是**强连通的(strongly connected)**。\n\n对于一张有向图，所有有向边当做无向边，所得到的图是联通的，我们就称这个有向图是**弱联通的(weakly connected)**。\n\n有向图的一个极大强连通子图被称为一个**强连通分量(strongly connected component = strong component)**。\n\n## 5. 图上的经典问题 Classic Problems on Graphs\n\n### 5.1. 欧拉路径 Euler Paths\n\n- **欧拉路径(euler path)**：经过图 $G$ 每条边恰好一次的简单路径。\n- **欧拉回路(euler circuit)**：过图 $G$ 的每条边恰好一次的简单回路。\n- **欧拉图(euler graph)**：包含欧拉回路的图。\n\n> [!important] Theorem 1\n>\n> 一张联通多重图存在欧拉回路当且仅当每个节点的度数都是偶数。\n>\n> > [!quote]- Proof\n> >\n> > ![|500](https://img.memset0.cn/2024/06/02/VbhtQPa0.png)\n> >\n> > ![|500](https://img.memset0.cn/2024/06/02/ElJHKzSL.png)\n\n> [!important] Theorem 2\n>\n> 一张联通多重图存在不是欧拉回路的欧拉路径当且仅当有恰好两个节点的度数为奇数。\n\n> [!important] Theorem 3\n>\n> 一张连通有向多重图存在欧拉回路当且仅当：1. 图是弱联通的 2. 每个点的入度和出度相等。\n\n> [!important] Theorem 4\n>\n> 一张连通有向多重图存在不是欧拉回路的欧拉路径当且仅当：1. 图是弱联通的 2. 每个点的入度和出度相等，但除了两个点，其中一个入度比出度多 $1$，另一个出度比入度多 $1$。\n\n### 5.2. 哈密顿路径 Hamilton Paths\n\n- **哈密顿路径(hamilton path)**：经过图 $G$ 每个点恰好一次的简单路径。\n- **哈密顿回路(hamilton circuit)**：经过图 $G$ 每个点恰好一次，但除了第一个点的简单回路。\n- **哈密顿图(hamilton graph)**：包含哈密顿回路的图。\n\n> [!important] Dirac's Theorem\n>\n> 简单图 $G$ 存在哈密顿回路的一个充分条件是图的顶点数 $\\ge 3$ 且每个点的度数 $\\ge n/2$。\n\n> [!important] Ore's Theorem\n>\n> 简单图 $G$ 存在哈密顿回路的一个充分条件是图的顶点数 $\\ge 3$，且对于对于所有不相邻的顶点 $u$ 和 $v$，他们的度数之和总是 $\\ge n$。\n\n> [!important] Theorem\n>\n> 简单图 $G$ 存在哈密顿路径的必要条件有：\n>\n> (1) $G$ 是连通的。  \n> (2) 有至多两个点的度数小于 $2$。\n>\n> 简单图 $G$ 存在哈密顿回路的必要条件有：\n>\n> (1) $G$ 是连通的。  \n> (2) 每个点的度数都大于 $1$。\n\n所以我们在构建哈密顿回路的过程中，有一些性质可以被利用：\n\n- 如果有一个点的度数恰好为 $2$，那么其两条边都一定在哈密顿回路上。\n- 如果在构建哈密顿回路的过程中，某个点的两条边已经被确认在哈密顿回路上，他们它剩下的边可以被删去。\n\n> [!important] Erdős–Stone Theorem\n>\n> 对于一个图 $G=(V,E)$，其存在哈密顿回路的必要条件是：对于 $V$ 的子集 $S$，图 $G - S$ 中的连通分量数量 $\\leq |S|$。其中 $G-S$ 是指从图 $G$ 中删除点集 $S$ 和其相连的边后得到的子图。\n>\n> - **证明思路**：考虑一个 $n$ 个点的环，拿掉其中 $m$ 个点后至多有 $m$ 个联通快。\n\n**旅行商问题(traveling salesman problem)**：求解在给定的图中，找出一条路径，使得旅行商从一个城市出发，经过其他所有城市一次且仅一次后，返回出发城市且总费用最小。\n\n### 5.3. 最短路问题 Shortest Path Problems\n\n**带权图(weighted graph)**：$G = (V,E,W)$，每条边有一个边权。\n\n**最短路问题(shortest path problem)**：在带权图 $G=(V,E,W)$ 中，对于给定的两点 $a,z \\in V$，找到一条 $a$ 到 $z$ 的路径使其长度（即所经过边的边权和）最短。\n\n关于 Dijkstra 算法的讲解略去。\n\n### 5.4. 平面图 Planar Graphs\n\n> [!summary] Definition: **平面图(planar graph)**\n>\n> 如果一张图可以被画到一个平面上且没有任何边在非定点处交叉，则称这张图是 planar 的。\n>\n> 这样的画法被称为一个图的**平面表示(planar representation)**。\n\n**区域(region)**：在平面表示中，与平面的其他部分通过平面图的边分割开来的一部分，称为区域。区域分为**有界区域(bounded region)** 和**无界区域(unbounded region)** 两种。（注意对于一个封闭图形，则封闭图形外面的区域也称一块区域）\n\n**区域的度(degree of the region)**：在区域 $R$ 的边界上的边的数量，记为 $\\operatorname{Deg}(R)$，这一定义对于有界区域和无界区域都相同。\n\n> [!important] **欧拉公式(Euler's formula)** ★\n>\n> 设 $G$ 是有 $v$ 个点和 $e$ 条边的简单连通平面图，设 $r$ 为其平面表示中的区域数量，则满足\n>\n> $$\n> r=e-v+2\n> $$\n\n注意到需要将一个区域划分出来，至少需要三条边；而每条边恰会属于两个区域的边界，即 $r\\le \\dfrac{2}{3} e$。将这一结论代入欧拉公式，可以得到如下推论：\n\n> [!important] Corollary 1 ★\n>\n> 如果 $G$ 是有 $v$ 个点和 $e$ 条边的简单连通平面图且 $v\\ge 3$，则必定满足 $e\\le 3v-6$。\n>\n> - 当每个区域的度都恰好为 $3$ 时取等号。\n> - 如果进一步要求每个区域的度数至少为 $k$ 时，可以得到通式 $e \\le \\dfrac{(v-2)k}{k-2}$。\n\n> [!important] Corollary 2 ★\n>\n> 如果 $G$ 是简单连通平面图，则 $G$ 存在一个度数不超过 $5$ 的节点。\n\n**基本细分(elementary subdivision)**：在原来的一条边中插入一个节点，将一条边分为两条边。\n\n**同胚(homeomorphic)**：如果图 $G_1$ 和 $G_2$ 可以分别作一系列基本细分操作，得到一张相同的图，则称 $G_1$ 和 $G_2$ 是同胚的。\n\n![fHHobbG5.png|530](https://img.memset0.cn/2024/06/03/fHHobbG5.png)\n\n> [!important] Kuratowski's Theorem ★\n>\n> 一个无向图 $G$ 是平面的当且仅当其没有一个子图与 $K_5$ 或 $K_{3,3}$ 同胚。\n\n### 5.5. 图染色与对偶图 Graph Coloring and Dual Graphs\n\n**对偶图(dual graph)**：任何一张平面图可以转化为其对偶图，通过如下步骤：\n\n- 将原图的每一个区域用一个顶点表示。\n- 对于所有仅相隔一条边（只有定点相邻的不算）的两个相邻的区域，在他们对应的顶点直接添加一条边。\n\n![ubH4EMQH.png|402](https://img.memset0.cn/2024/06/03/ubH4EMQH.png)\n\n对于平面图染色的问题的研究，可以转化到其对应的对偶图上。\n\n> [!important] **四色定理(the four color theorem)**\n>\n> - **染色(coloring)**：对每个顶点分配一个颜色，满足相邻两节点的颜色不同。\n> - **染色数(the chromatic number)**：至少需要多少种不同的颜色，才能将给定图 $G$ 染色。记为 $x(G)$。\n>\n> 四色定理指出，任意平面图的染色数不超过 $4$。\n\n> [!important] Theorem\n>\n> - 染色数为 $2$ 的简单图一定是二分图。\n>\n> - 连通二分图的染色数一定为 $2$。\n","publishedTitle":"「离散数学及其应用」Chapter 10. Graph"}},{"id":"6afc80c2-0efe-548e-9366-5e51daa5e2cf","fields":{"slug":"/course/dm/note/8/","plainText":"\n> 本篇笔记主要介绍了树的基本概念和术语，包括树的定义、性质、不同类型的树（如二叉树和 $m$ 叉树）、树的应用（如二叉搜索树和前缀编码）、树的遍历方法以及生成树的相关内容。通过这些内容的学习，读者将能够理解树在离散数学中的重要性，并掌握如何分析和应用这些树的知识。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 树论术语 Tree Terminologies\n\n**树(tree)** 是没有简单环的连通无向图。\n\n**森林(forest)** 是没有简单环的无向图。\n\n> [!important] Theorem\n>\n> 一个无向图 $G=(V,E)$ 是树当且仅当对于 $V$ 中的任意两点，都有唯一的一条简单路径。\n\n**有根树(rooted tree)**：在树的若干节点中，选择一个特定的节点作为**根(root)**，这样的树称为有根树，在有根树中我们有如下概念：\n\n- **父亲节点(parent)**：对于非根节点 $v$，其父亲节点是唯一的有指向 $v$ 的有向边的节点（以根节点为起点给边定向）。\n- **孩子节点(child/children)**：若 $u$ 是 $v$ 的父亲，则称 $v$ 是 $u$ 的一个孩子节点。\n- **兄弟节点(sibling)**：有相同父亲节点的两个节点互称兄弟节点。\n- **祖先节点(ancestor)**：节点 $v$ 的祖先是从根到 $v$ 的路径上的所有节点。\n- **后代节点(descendant)**：若 $u$ 是 $v$ 的祖先，则称 $v$ 是 $u$ 的一个后代节点。\n- **叶子节点(leaf)**：没有孩子节点的节点称为叶子节点。\n- **内部节点(internal vertex)**：有孩子节点的节点称为内部节点。\n- **子树(subtree)**：点 $v$ 的子树是指 $v$ 和 $v$ 的所有后代节点组成的子图。\n\n## 2. 树的性质 Tree Properties\n\n一棵 m-叉树被认为是平衡的当且仅当每个叶子节点的深度不是 $h$ 就是 $h-1$。\n\n## 3. 二叉树 Binary Tree\n\n**m 叉树(m-ary tree)**：每个节点的孩子个数都不超过 $m$ 的有根树。\n\n**二叉树(binary tree)**：每个节点的孩子个数都不超过 $2$ 的有根树。\n\n**满二叉树(full binary tree)**：每个非叶节点的孩子个数都恰好为 $2$ 的有根树。（即每个节点要么有两个儿子要么没有儿子，叶子结点可以不全在同一深度）\n\n**有序二叉树(ordered binary tree)**：每个节点都有一个可能的左孩子和右孩子，据此可以定义**左子树(left subtree)** 和**右子树(right subtree)**。\n\n节点 $v$ 的**深度(level, depth)**：根节点到 $v$ 的路径长度。（根节点的深度定义为 $0$。）\n\n> [!warning] Caution ★\n>\n> 本书中，根节点深度定义为 $0$。\n\n树 $T$ 的**高度(height)**：所有节点的深度最大值。\n\n## 4. 树的应用 Applications of Trees\n\n### 4.1. 二叉搜索树 Binary Search Tress\n\n**二叉搜索树(binary search tree, BST)**：略。\n\n### 4.2. 前缀编码 Prefix Codes\n\n**前缀编码(prefix codes)**：是一种编码方式，这样对于每个编码后的 01 串，他们都没有共同的前缀。相当于画出字典树的话所有编码最后都走到了叶子结点上。\n\n用**哈夫曼编码(huffman coding)** 的方法可以最小化每一字符编码后的平均位长。\n\n### 4.3. 树的遍历 Tree Travelsal\n\n- **先序遍历(preorder travelsal)**\n- **中序遍历(inorder travelsal)**\n- **后序遍历(postorder travelsal)**\n\n### 4.4. 表达式表示法 Expression Notations\n\n- **前缀形式(prefix form)**，**波兰表达式(Polish notation)**\n- **中缀形式(infix form)**\n- **后缀形式(postfix form)**，**逆波兰表达式(reverse Polish notation)**\n\n## 5. 生成树 Spanning Tree\n\n图 $G$ 的**生成树(spanning tree)** 是包含 $G$ 中每一个节点的子图。\n\n> [!important] Theorem 1\n>\n> A simple graph is connected if and only if it has a spanning tree.\n\n### 5.1. 深度优先搜索 & 宽度优先搜索 DFS & BFS\n\n**深度优先搜索(depth-first search, DFS)** 又叫做**回溯(backtracking)**。\n\n**宽度优先搜索(breadth-first search, BFS)**。\n\n可以用 DFS 或 BFS 来解决一些数据规模小的离散问题。\n\n![tNmm4Czr.png|535](https://img.memset0.cn/2024/06/22/tNmm4Czr.png)\n\n> [!example] Ex. 11.4 29\n>\n> Explain how backtracking can be used to find a Hamilton path or circuit in a graph.\n>\n> > [!quote]- Answer\n> >\n> > ![|600](https://img.memset0.cn/2024/06/22/APw1zFtg.png)\n> >\n> > ![|600](https://img.memset0.cn/2024/06/22/re1sEyKF.png)\n\n### 5.2. 最小生成树 Minimum Spanning Trees\n\n- Prim’s algorithm：随便选定一个点作为开始的最小生成树，每次把与最小生成树外的点相连的最小边及其新增点加入最小生成树，直到得到整张图的最小生成树。\n\n![G3SYw7dY.png|450](https://img.memset0.cn/2024/06/22/G3SYw7dY.png)\n\n- Kruskal’s algorithm：把所有边按照大小从小到大的顺序枚举，如果两端点不在同一个联通块中则将这条边加入最小生成树。\n\n![CobUzofr.png|498](https://img.memset0.cn/2024/06/22/CobUzofr.png)\n","publishedTitle":"「离散数学及其应用」Chapter 11. Tree"}},{"id":"67e8eab1-3bf4-5b68-b925-1155d7520abd","fields":{"slug":"/course/se/note/03/","plainText":"\n> 本篇笔记总结了软件工程中团队项目管理与敏捷开发的核心概念。首先，介绍了软件项目管理的四个关键要素（人员、产品、过程、项目）以及主要干系人角色，并探讨了团队领导者的 MOI 模型和不同的软件团队结构。随后，分析了团队协调与沟通的重要性，并强调了避免团队“毒性”的必要性。接着，笔记详细介绍了敏捷开发的核心理念，包括敏捷宣言、敏捷原则、敏捷团队的特点以及敏捷开发过程的关键实践，如极限编程（XP）、Scrum 和动态系统开发方法（DSDM）。最后，讨论了敏捷建模和敏捷统一过程（AUP），强调了敏捷方法在软件开发中的灵活性和高效性。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o 生成摘要）</small>\n\n<!-- more -->\n\n# Ch.31 Project Management Concepts\n\n## 1. The Four P's\n\n在软件项目管理中，有四个关键要素（被称为 **四个 P(The Four P's)**），它们共同决定着项目的成败。\n\n- **人员(People)**：这是项目成功的**最重要**的因素。\n- **产品(Product)**：指的是要构建的软件本身。\n- **过程(Process)**：指为了完成软件工程工作而采用的一系列框架活动和软件工程任务。\n- **项目(Project)**：指的是使产品成为现实所需完成的所有工作。\n\n## 2. Stakeholders\n\n**干系人(Stakeholder)** 是指所有受到项目影响或者对项目有影响的个人或组织。主要的软件项目干系人包括：\n\n- **高级管理者(Senior manager)**：他们定义业务问题，这些问题通常对项目有重大影响。高级管理者的支持和决策对项目的资源分配和方向具有重要意义。\n- **项目经理(Project manager)** / **技术经理(technical manager)**：负责计划、激励、组织和控制进行软件工作的实践者。\n- **实践者(Practitioner)**：提供工程化产品或应用所需的技术技能，包括程序员、设计师、测试人员等。\n- **顾客(Customer)**：包括提出软件需求的人员和对结果有间接兴趣的其他相关方。\n- **最终用户(End-user)**：软件发布投入生产使用后与之交互的人员。\n\n## 3. The MOI Model\n\n**MOI 模型(The MOI Model)** 概括了优秀的 **团队领导者(Team Leader)** 需要具备的三个关键能力：\n\n- **激励(Motivation)**：鼓励技术人员尽最大能力进行生产（通过“push or pull”）。\n- **组织(Organization)**：塑造现有流程（或创建新流程），使最初的概念转化为最终产品。\n- **想法或创新(Ideas or innovation)**：鼓励人们即使在为特定的软件产品或应用程序建立的界限内工作时，也能创造并感到有创造力。团队领导者需要营造鼓励创新的氛围，激发团队成员的创造潜力，从而产生更具竞争力的软件产品。\n\n## 4. Software Team Structure\n\n选择软件项目团队结构时，必须考虑以下因素：\n\n- 要解决的问题的难度。\n- 最终程序的大小（以代码行或功能点计）。\n- 团队将保持在一起的时间（团队 _寿命(lifetime)_）。\n- 问题可以 _模块化(modularized)_ 的程度。\n- 要构建的系统的所需质量和 _可靠性(reliability)_。\n- 交付日期的 _严格性(regidity)_。\n- 项目所需的社交性（沟通程度）。\n\n![|421](https://img.memset0.cn/2025/03/03/AivoJ0Bc.png)\n\n### 4.1. Organizational Paradigms\n\n**组织范式(Organizational Paradigm)** 描述了不同的团队组织结构和管理风格。Constantine 提出了四种组织范式：\n\n- **封闭范式(closed paradigm)**：按照传统的等级权威结构组织团队，强调集中控制和层级管理。\n- **随机范式(random paradigm)**：结构松散地组织团队，并依赖于团队成员的 ==个人自驱力==。这种范式鼓励创新和自由。\n- **开放范式(open paradigm)**：试图以一种方式组织团队，使其实现与封闭范式相关的一些控制，但也实现了使用随机范式时发生的许多创新。——试图在控制和创新之间找到平衡，是综合了前两个。\n- **同步范式(synchronous paradigm)**：依赖于问题的自然划分，并组织团队成员在问题的各个部分上工作，团队成员之间几乎没有积极的沟通。同步范式适用于问题可以被清晰地分解为独立模块的项目，各模块可以并行开发。\n\n### 4.2. Avoid Team \"Toxicity\"\n\n团队“**毒性(Toxicity)**”指的是阻碍团队有效工作并导致项目失败的负面因素。应该努力避免以下团队“毒性”：\n\n- 疯狂的工作氛围，使得团队成员浪费精力，失去对工作目标的关注。\n- 个人冲突、业务目标不明确、技术难题等导致团队成员之间产生 _矛盾(friction)_ 和 _挫折(frustration)_。\n- “_分散的(fragmented)_ 或 _协调不良的(poorly coordinated)_ 程序” 或定义不明确或选择不当的流程模型，成为完成任务的障碍。流程混乱、缺乏规范、流程模型不适合项目特点都可能导致团队工作效率低下。\n- 角色定义不清导致项目成员缺乏 _责任感(accountability)_，并随之而来引发 _互相指责(finger-pointing)_。\n- 持续和反复的失败，这将导致团队成员的信心丧失，_士气(morale)_ 低落。\n\n## 5. Agile Teams\n\n**敏捷团队(agile team)** 是一种适应性强、高效协作的团队模式，特别适用于需求变化频繁的项目。敏捷团队具有以下特点：\n\n- 团队成员之间必须相互信任。\n- 技能的分布必须适合问题，团队成员之间能够形成互补的技能组合。\n- 为了保持团队凝聚力，可能必须将特立独行者排除在团队之外。\n- 团队是“自组织”的：\n  - _自适应(adaptive)_ 的团队结构：敏捷团队的结构可以根据项目需要灵活调整。\n  - 使用随机 / 开放 / 同步范式的元素，敏捷团队综合了这些范式的优点。\n  - 成员拥有高度的 _自主权(autonomy)_。\n\n## 6. Team Coordination & Communication\n\n有效的 **团队协调与沟通(Team Coordination & Communication)** 是项目成功的关键保障。团队可以使用多种沟通方式：\n\n- **正式的、非个人方法(formal & impersonal approaches)**：包括软件工程文档、工作产品、技术备忘录、项目里程碑、进度表和项目控制工具（第 23 章）、变更请求和相关文档、错误跟踪报告、和存储库数据（第 26 章）。这些方法主要用于记录和传递项目信息，例如需求文档、设计文档、代码、测试报告等。\n- **正式的、人际程序(formal & interpersonal procedures)**：侧重于应用于软件工程工作产品的质量保证活动（第 25 章）。这些包括状态审查会议以及设计和代码检查。例如：评审会议、代码审查、走查等，这些方法主要用于确保软件质量。\n- **非正式的、人际程序(informal & interpersonal procedures)**：包括用于信息传播和问题解决的小组会议以及“需求和开发人员的搭配”，如头脑风暴等。\n- **电子通讯(electronic communication)**：包括电子邮件、电子公告板，以及扩展的、基于视频的会议系统，这些方法可以打破时间和空间的限制，方便团队成员远程沟通。\n- **人际网络(interpersonal networking)**：包括与团队成员和项目外部人员的非正式讨论，他们可能拥有有帮助的经验或见解。\n\n## 7. The Product Scope\n\n**产品范围(The Product Scope)** 定义了软件系统需要实现的功能和特性，它必须在管理和技术层面都是明确和可理解的。产品范围需要从以下几个方面进行描述：\n\n- **背景(Context)**：要构建的软件如何适应更大的系统、产品或业务背景？由此产生什么约束？ 理解软件的背景有助于确定其边界和约束条件。\n- **信息目标(Information objectives)**：软件作为输出产生哪些客户可见的数据对象？需要哪些数据对象作为输入？ 明确输入和输出数据对象有助于定义软件的功能和数据处理流程。\n- **功能和性能(Function and performance)**：软件执行什么功能将输入数据转换为输出？是否需要解决任何特殊的性能特征？ 定义软件的功能和性能指标，有助于指导软件设计和开发。\n\n### 7.1. Problem Decomposition\n\n**问题分解(Problem Decomposition)** 有时也称为 **分区(partitioning)** 或 **问题细化(problem elaboration)**。\n\n- 一旦定义了范围，其可以被分解为 **组成功能(constituent functions)**、用户可见的 **数据对象(data objects)**、一组 **问题类(problem classes)**……\n- 分解过程将持续进行，直到定义了所有功能或问题类为止。\n- 目的：将复杂的问题分解为更小、更易于管理和解决的子问题。\n\n## 8. The Process\n\n项目的 **过程(process)** 框架的搭建需要考虑以下要素：\n\n- 项目 _特点(characteristic)_\n- 确定所需的 _严谨程度(degree of rigor)_\n- 为每个软件工程活动定义 **任务集(task set)**——任务集包含以下内容：\n  - **软件工程任务(software engineering task)**：为了完成特定的软件工程活动而需要执行的具体任务，如需求分析、设计、编码、测试等等。\n  - ==**工作产品(work product)**：可交付物，包括需求文档、源代码、测试用例等等==。\n  - **质量保证点(quality assurance point)**：如测试或。\n  - **里程碑(milestone)**：项目进展过程中的重要事件或时间节点。\n\n![Melding the Problem and the Process|522](https://img.memset0.cn/2025/03/03/JJddAB70.png)\n\n## 9. The Project\n\n项目在以下情况下会陷入困境...\n\n- 软件人员不了解客户的需求。\n- 产品范围定义不明确。\n- 变更管理不善。\n- 选择的技术发生变化。\n- 业务需求发生变化或定义不明确。\n- 截止日期 _不切实际(unrealistic)_。\n- 用户抵制。\n- _赞助(sponsorship)_ 丢失或未正确获得。\n- 项目团队缺乏具有适当技能的人员。\n- 管理人员（和实践者）没有从最佳实践中吸取教训。\n\n### 9.1. Common-Sense Approach to Projects\n\n对项目采取 **常识性方法(Common-Sense Approach to Projects)**，可以有效地提高项目成功率。这包含以下几个关键原则：\n\n- **良好的开端(Start on the right foot)**：努力（非常努力）理解要解决的问题，然后设定切合实际的目标和期望。项目启动阶段至关重要，需要充分理解客户需求，明确项目目标和范围。\n- **保持动力(Maintain momentum)**：项目经理必须提供激励措施，以最大限度地减少人员流动，团队应强调其执行的每项任务的质量，高级管理层应尽一切可能不干涉团队的工作。保持团队稳定、重视质量、减少外部干扰，都有助于项目保持良好势头。\n- **跟踪进展(Track progress)**：对于软件项目，当工作产品（例如，模型、源代码、成套测试用例）被生产出来并作为质量保证活动的一部分获得批准（使用正式技术评审）时，就会跟踪进展。通过定期跟踪项目进展，及时发现和解决问题，确保项目按计划进行。\n- **做出明智的决定(Make smart decisions)**：本质上，项目经理和软件团队的决定应该是“保持简单”。在项目决策过程中，应优先考虑简单有效的方案，避免过度设计和复杂化。\n- **进行事后分析(Conduct a postmortem analysis)**：为每个项目建立一致的机制，以吸取经验教训。项目结束后，应进行回顾和总结，提炼经验教训，为后续项目提供借鉴。\n\n### 9.2. To Get to the Essence of a Project\n\nBarry Boehm 提出了以下五个 W 和两个 H，以帮助抓住项目的核心要点：\n\n| CN                                                                | EN                                                                                  |\n| ----------------------------------------------------------------- | ----------------------------------------------------------------------------------- |\n| 为什么要开发系统？                                                | Why is the system being developed?                                                  |\n| 将要完成什么？                                                    | What will be done?                                                                  |\n| 何时完成？                                                        | When will it be accomplished?                                                       |\n| 谁负责？                                                          | Who is responsible?                                                                 |\n| 他们在组织结构中的位置在哪里？                                    | Where are they organizationally located?                                            |\n| 如何在技术和管理上完成这项工作？                                  | How will the job be done technically and managerially?                              |\n| 每种 _资源(resource)_（例如，人员、软件、工具、数据库）需要多少？ | How much of each resource (e.g., people, software, tools, database) will be needed? |\n\n### 9.3. Critical Practices\n\n以下是一些**关键实践(Critical Practices)**，可以显著提高软件项目成功率：\n\n| CN                                         | EN                                      |\n| ------------------------------------------ | --------------------------------------- |\n| 系统的风险管理                             | Formal risk management                  |\n| 经验成本和进度估算                         | Empirical cost and schedule estimation  |\n| _基于度量的(metrics-based)_ 项目管理       | Metrics-based project management        |\n| _挣值(earned value)_ 跟踪                  | Earned value tracking                   |\n| 针对质量目标的 _缺陷跟踪(defect tracking)_ | Defect tracking against quality targets |\n| 以人为本的项目管理                         | People aware project management         |\n\n# Ch.5 Agile Development\n\n## 1. Agile Development\n\n### 1.1. The Manifesto for Agile Software Development\n\n由 Kent Beck 提出的敏捷软件开发 _宣言(manifesto)_ 的核心价值观是：\n\n- **个体与互动(Individuals and interactions)** 胜过 **流程与工具(processes and tools)**\n- **可工作的软件(Working software)** 胜过 **完善的文档(comprehensive documentation)**\n- **客户合作(Customer collaboration)** 胜过 **合同谈判(contract negotiation)**\n- **响应变化(Responding to change)** 胜过 **遵循计划(following a plan)**\n\n### 1.2. What is \"Agility\"?\n\n**敏捷(Agility)** 意味着：\n\n| CN                                                                             | EN                                                               |\n| ------------------------------------------------------------------------------ | ---------------------------------------------------------------- |\n| 所有 _干系人(stakeholder)_ 之间有效的沟通                                      | Effective communication among all stakeholders                   |\n| 将客户融入团队                                                                 | Drawing the customer onto the team                               |\n| 组织团队使其能够掌控工作                                                       | Organizing a team so that it is in control of the work performed |\n| 进而实现：==快速、增量式的软件交付==（逐步交付软件，而不是一次性交付所有功能） | Yielding... Rapid, incremental delivery of software              |\n\n![Agility and the Cost of Change|444](https://img.memset0.cn/2025/03/03/XdvU65wJ.png)\n\n## 2. Agile Process\n\n典型的 **敏捷开发过程(Agile Process)** 具有以下特点：\n\n| CN                                                                                                         | EN                                                                             |\n| ---------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |\n| 根据客户的需求描述驱动敏捷开发                                                                             | Is driven by customer descriptions of what is required (scenarios)             |\n| 必须认识到计划是短期的，承认计划需要不断调整和迭代，不能奢求直接得到长期计划                               | Recognizes that plans are short-lived                                          |\n| 通过高度强调构建活动来迭代地开发软件——每个迭代周期都需要包含设计、编码和测试环节，确保都能产生可工作的版本 | Develops software iteratively with a heavy emphasis on construction activities |\n| 将软件分解成多个“软件增量”并交互给客户                                                                     | Delivers multiple software increments                                          |\n| 随着变化而适应——能够根据项目进展和客户需求灵活调整方向                                                     | Adapts as changes occur                                                        |\n\n## 3. Agility Principles\n\n敏捷开发遵循以下 12 条 **敏捷开发原则(Agility principles)**。\n\n| CN                                                                                                                    | EN                                                                                                                                            |\n| --------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |\n| 最重要的目标是通过尽早和==持续交付==有价值的软件来满足客户。                                                          | Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.                                   |\n| ==欢迎需求变化，即使在项目后期==。敏捷过程 _利用(harness)_ 变化来为客户创造竞争优势。                                 | Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage.             |\n| 经常交付可工作的软件，交付周期从几周到几个月不等，倾向于较短的周期。                                                  | Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.                |\n| 业务人员和开发人员必须在整个项目中每天一起工作。                                                                      | Business people and developers must work together daily throughout the project.                                                               |\n| 围绕积极主动的个人构建项目。为他们提供所需的环境和支持，并信任他们能够完成工作。                                      | Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.             |\n| 与开发团队进行信息传递的==最有效方法是 _面对面(face-to-face)_ 的交谈==。                                              | The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.               |\n| 可工作的软件是衡量进度的 _主要指标(primary measure)_。                                                                | Working software is the primary measure of progress.                                                                                          |\n| 敏捷过程提倡 ==_可持续的(sustainable)_ 开发==。发起人、开发者和用户应该能够 _无限期地(indefinitely)_ 保持稳定的节奏。 | Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely. |\n| 持续关注技术卓越和良好设计有助于提高敏捷性。                                                                          | Continuous attention to technical excellence and good design enhances agility.                                                                |\n| ==_简洁(simplicity)_ 至关重要==，应最大限度地减少工作量。                                                             | Simplicity - the art of maximizing the amount of work not done - is essential.                                                                |\n| 最好的架构、需求和设计来自 ==_自组织的(self-organizing)_== 团队。                                                     | The best architectures, requirements, and designs emerge from self-organizing teams.                                                          |\n| 团队 ==_定期(at regular intervals)_ 反思==如何变得更有效率，并据此调整自身的行为。                                    | At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.                     |\n\n## 4. Human Factors\n\n在敏捷开发中，**人为因素(Human Factors)** 至关重要。开发过程应该去 ==_适应(mold)_ 人和团队的 _需求(need)_==。以下是敏捷团队成员和团队必须具备的关键特质：\n\n- **能力(Competence)**：团队成员需要具备完成工作所需的专业技能和知识。\n- **共同目标(Common focus)**：团队成员需要对项目目标有统一的认识和认同。\n- **协作(Collaboration)**：团队成员之间需要密切合作，共同解决问题。\n- **决策能力(Decision-making ability)**：团队需要拥有自主决策的能力，快速响应变化。\n- **模糊问题解决能力(Fuzzy problem-solving ability)**：面对不确定性和模糊性，团队需要能够灵活应变，找到解决方案。\n- **相互信任和尊重(Mutual trust and respect)**：团队成员之间需要相互信任和尊重，营造积极和谐的工作氛围。\n- **自组织(Self-organization)**：团队需要具备自组织能力，自主管理和分配任务。\n\n## 5. Agile Progress Examples\n\n### 5.1. Extreme Programming\n\n**极限编程(Extreme Programming, XP)** 是最广泛使用的一种敏捷开发过程，最初由 Kent Beck 提出。\n\n- **XP Planning**\n  - 从创建 **用户故事(user stories)** 开始——用户故事是描述用户需求的一种简洁方式。\n  - 敏捷团队评估每个用户故事并分配成本。\n  - 用户故事被分组形成 _可交付的(deliverable)_ 增量。\n  - 做出 _交付日期(delivery date)_ 的 _许诺(commitment)_。\n  - 使用 **项目速度(project velocity)** 帮助定义后续增量的交付日期——项目速度指每个迭代周期内需要完成的工作量。\n- **XP Design**\n  - 遵循 **KIS 原则(Keep It Simple, KIS)**，保持设计简单。\n  - 鼓励使用 ==**类-职责-协作卡(Class-Responsibility-Collaboration card, CRC card)**==（第 8 章）。\n  - 对于困难的设计问题，使用小型的设计 _原型(prototype)_ 来探索和验证设计方案的可行性，称作“spike solutions”。\n  - 鼓励 _重构(refactoring)_，通过迭代改进内部程序设计。\n- **XP Coding**\n  - 建议在开始编码之前，为用户故事构建 **单元测试(unit test)**。\n  - 鼓励 **结对编程(pair programming)**。\n- **XP Testing**\n  - 每天执行所有单元测试——可以使用 **持续集成(Continuous Integration, CI)** 工具。\n  - _验收测试(Acceptance test)_：由客户定义，用于评估软件是否满足客户的需求。\n\n![Adaptive Software Development|555](https://img.memset0.cn/2025/03/03/GEQYhWc2.png)\n\n### 5.2. Industrial XP\n\n**工业极限编程(Industrial Extreme Programming, IXP)** 是 XP 的扩展和增强版本，更加注重管理、客户角色和技术实践。其包含六个新的实践：\n\n- **准备度评估(Readiness assessment)**：在项目开始前评估团队和组织的敏捷开发准备程度。\n- **项目社区(Project community)**：强调建立积极协作的项目社区，包括所有利益相关者。\n- **项目章程(Project chartering)**：制定清晰的项目目标、范围和愿景。\n- **测试驱动管理(Test driven management)**：使用测试结果来驱动项目管理和决策。\n- **回顾(Retrospectives)**：定期回顾和总结项目经验，持续改进。\n- **持续学习(Continuous learning)**：鼓励团队成员持续学习和提升技能。\n\n### 5.3. Scrum\n\n**Scrum** 最初由 Schwaber 和 Beedle 提出，其显著特点包括：\n\n- 将大的开发工作划分为一个一个小的 **包(packets)**。\n- 测试和文档在产品构建过程中持续进行，贯穿始终。\n- 通过 **待办事项列表(backlog)** 划出若干段的开发周期，称为 “**冲刺(sprints)**”。\n- 使用非常简短的会议形式，有时甚至可以站着进行。\n- 每一个冲刺周期结束后的都向客户交付 **演示(demo)**。\n\n### 5.4. Dynamic Systems Development Method\n\n**动态系统开发方法(Dynamic Systems Development Method, DSDM)** 由 DSDM 联盟推广，其大多数方面与 XP 相似，并有以下九条指导原则：\n\n| CN                                                               | EN                                                                                               |\n| ---------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |\n| 用户的积极参与 _至关重要(imperative)_                            | Active user involvement is imperative.                                                           |\n| DSDM 团队必须 _被授权(empowered)_ 进行自主决策                   | DSDM teams must be empowered to make decisions.                                                  |\n| 重点是产品的频繁交付                                             | The focus is on frequent delivery of products.                                                   |\n| 验收的基本标注是对业务的 _符合程度(fitness)_                     | Fitness for business purpose is the essential criterion for acceptance of deliverables.          |\n| 迭代和增量开发是实现精确业务解决方案的必要条件                   | Iterative and incremental development is necessary to converge on an accurate business solution. |\n| 开发期间的所有变更都是 _可逆的(reversible)_                      | All changes during development are reversible.                                                   |\n| 需求在较高层次上基线化——即不必太过详细，可以在迭代过程中进行细化 | Requirements are baselined at a high level                                                       |\n| 测试贯穿整个 _生命周期(life-cycle)_——必须在每个阶段都进行        | Testing is integrated throughout the life-cycle.                                                 |\n\n![|592](https://img.memset0.cn/2025/03/03/C6FRCcQx.png)\n\n> **80% 原则(80 percent rule)**：通常，一个应用程序的 80% 经常在 20% 的时间内交付，而另外 20% 的部分则需要剩余的 80% 的时间。\n\n## 6. Agile Modeling\n\n**敏捷建模(Agile Modeling)** 最初由 Scott Ambler 提出，包括以下原则：\n\n- **以目标为导向进行建模(Model with a purpose)**：建模应该服务于特定的目标，例如沟通、理解或设计。\n- **使用多种模型(Use multiple models)**：根据需要选择合适的模型，例如用例图、类图、流程图等。\n- **轻量级建模(Travel light)**：避免过度建模，只创建必要的模型，保持模型的简洁和实用性。\n- **内容比表示形式更重要(Content is more important than representation)**：模型的目的是传达信息，内容比模型的具体表示形式更重要。\n- **了解模型和用于创建模型的工具(Know the models and the tools you use to create them)**：熟练掌握建模技术和工具。\n- **局部适应(Adapt locally)**：根据具体项目和团队情况，灵活调整建模方法。\n\n## 7. Agile Unified Process\n\n**敏捷统一过程(Agile Unified Process, AUP)** 是一种简化的 Rational Unified Process (RUP) 的敏捷版本，包含以下活动：\n\n- **建模(Modeling)**：理解需求，设计系统架构和组件。\n- **实现(Implementation)**：编写代码，构建软件组件。\n- **测试(Testing)**：单元测试、集成测试、系统测试等，确保软件质量。\n- **部署(Deployment)**：将软件部署到目标环境。\n- **配置(configuration)** 和 **项目管理(project management)**：版本控制、配置管理、项目计划、进度跟踪等。\n- **环境管理(Environment management)**：搭建和维护开发、测试和部署环境。\n","publishedTitle":"「软件工程」III. 团队项目管理与敏捷开发"}},{"id":"1e5b3373-f109-5c97-8c4d-d20c6831740d","fields":{"slug":"/course/java/note/1/","plainText":"\n> 本篇笔记介绍了 Java 编程的基础知识，包括标识符规则、变量声明与初始化、final 关键字的使用、字面量与类型转换、选择语句（if-else、switch）、运算符结合性、字符与字符串处理、输入输出、循环语句、方法定义与重载、数组的创建与使用等内容。特别强调了 Java 与 C/C++ 的一些重要区别，如变量初始化要求、布尔类型使用规则等。同时详细讲解了 String 类的常用方法、Scanner 类的输入处理、格式化输出、方法重载的规则以及数组的内存分配特点。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. Ch02 Elementary Programming\n\n### 1.1. Identifiers\n\n- **标识符(indentifier)** 是由字母、数字、下划线 `_` 和美元符号 `$` 组成的字符序列。\n- **规则**：\n  1. 必须以字母、下划线 `_` 或美元符号 `$` 开头，不能以数字开头。\n  2. 不能是 Java 的保留字。\n  3. 不能是 `true`、`false` 或 `null`。\n  4. 区分大小写。\n  5. 长度没有限制。\n\n### 1.2. Variables\n\n- **变量(variable)** 是存储数据的容器。\n- 可以在一步中完成变量的声明和初始化。\n- **Java 变量与 C/C++ 变量的区别**\n  - 在 Java 中，变量的声明和定义没有区分。\n  - ==Java 不会为方法中的局部变量赋默认值，必须显式初始化，否则会报 CE==。\n\n### 1.3. The `final` Keyword\n\n- 使用 `final` 修饰变量得到 **命名常量(named constant)**。\n  - final 变量是不可改变的，只能在初始化的时候被改变一次，但是这个初始化可以在运行时刻初始化，也可以在编译时刻初始化，甚至可以放在构造函数中初始化，而不必在声明的时候初始化。\n    - 举例：==定义类时写 `final int x;` 然后在构造函数中在初始化 `x = 1;` 是合法的==。\n  - 修饰对象引用时，不能改变引用指向的对象，但不意味着不能改变对象实例的内容。\n- 使用 `final` 修饰方法表示该方法不能被 **重写(override)**。\n- 使用 `final` 修饰类表示该类不能被继承，里面的所有方法也自动会是 `final` 的。\n\n### 1.4. Literals\n\n- 使用 `f` 结尾表示单精度浮点数字面量，使用 `d` 结尾表示双精度浮点数字面量。\n- 特殊的浮点数值：\n  - `Double.POSITIVE_INFINITY`：正无穷大。\n  - `Double.NEGATIVE_INFINITY`：负无穷大。\n  - `Double.NaN`：非数值。\n\n### 1.5. Type Casting\n\n- **隐式转换**（从小范围到大范围）：如 `double d = 3;`\n- **显式转换**（从大范围到小范围）：如 `int i = (int)3.9;`\n  - ==像这样的转换必须显示地写出，否则会 CE==。\n\n## 2. Ch03 Selections\n\n### 2.1. The `boolean` Data Type\n\n- `boolean` 类型只有两个值：`true` 和 `false`。\n- 与 C/C++ 不同，==整型与布尔型不能直接转换==，如当 `even` 是 `boolean` 类型时写 `if (even != 0)` 会编译错误，`if (even)` 可以通过编译。\n\n### 2.2. if-else statment\n\n- ==`else` 语句采用就近原则，做题时不要被代码缩进欺骗==。\n\n### 2.3. switch statement\n\n- 每一个 `case` 下的 `break` 语句可以省略，这种情况下会继续执行下一个 `case` 的语句。\n- **参数的类型限制**：\n  - 在 java 中 switch 后的表达式的类型只能为以下几种：byte、short、char、int、枚举类（在 Java1.6 中是这样），在 java1.7 后支持了对 string 的判断；\n  - 注意：==boolean==、long 类型不能作为 switch 参数。\n\n### 2.4. Operator Associativity\n\n- ==所有二元运算符都是左结合的==：`a – b + c – d` 等价于 `((a – b) + c) – d`。\n- ==但是所有赋值运算符都是右结合的==：`a = b += c = 5` 等价于 `a = (b += (c = 5))`。\n\n## 3. Ch04 Mathematical Functions, Characters, and Strings\n\n### 3.1. Characters\n\n- ==Java 中的字符默认采用 UTF-16 编码，每个字符占用 2 字节。==\n  - Comment：对于超出基本字符集（BMP）的字符，会使用代理对（Surrogate Pair）来表示，每个代理对占用 4 字节。\n- **`char` Data Type**\n  - 表示单个字符，支持 ASCII 和 Unicode。\n  - 示例：\n    - `char letter = 'A';` （ASCII）\n    - `char letter = '\\u0041';`（Unicode）\n  - ==可以使用递增或递减操作符获取下一个或前一个字符。==\n    - 示例：`char ch = 'a'; System.out.println(++ch);` 输出 b。\n- `Character` 类中的方法：\n  - `isDigit(ch)`：判断是否为数字。\n  - `isLetter(ch)`：判断是否为字母。\n  - `isUpperCase(ch)`：判断是否为大写字母。\n  - `isLowerCase(ch)`：判断是否为小写字母。\n  - `toUpperCase(ch)`：将字符转换为大写。\n  - `toLowerCase(ch)`：将字符转换为小写。\n\n### 3.2. The `String` Class\n\n- ==Java 的 `String` 类是不可变类。==\n  - ==坑点：后面的各种方法都不是在原串上做修改。==\n- **定义与基本操作**\n  - 使用 `String` 对象表示字符串。\n  - 示例：`String message = \"Welcome to Java\";`\n- **常用方法**\n  - `length()`：获取字符串长度。\n    - 示例：`\"Hello\".length()` 返回 5。\n  - `charAt(index)`：获取指定索引的字符。\n    - 示例：`\"Hello\".charAt(0)` 返回 `H`。\n  - `concat(s1)` 或 `+`：拼接字符串。\n    - 示例：`\"Hello\".concat(\" World\")` 返回 `\"Hello World\"`。\n  - `toUpperCase()` 和 `toLowerCase()`：大小写转换。\n    - 示例：`\"Hello\".toUpperCase()` 返回 `\"HELLO\"`。\n  - `trim()`：去除字符串两端的空格。\n    - 示例：`\" Hello \".trim()` 返回 `\"Hello\"`。\n  - ![|557](https://img.memset0.cn/2024/12/17/YO4ut5FQ.png)\n- **字符串比较**\n  - `equals(s1)`：比较字符串内容是否相等。\n    - 示例：`\"Hello\".equals(\"hello\")` 返回 `false`。\n  - `equalsIgnoreCase(s1)`：忽略大小写比较字符串内容是否相等。\n    - 示例：`\"Hello\".equalsIgnoreCase(\"hello\")` 返回 `true`。\n  - `compareTo(s1)`：比较字符串的字典顺序。\n    - 返回值：\n      - 大于 0：当前字符串大于 `s1`。\n      - 等于 0：两字符串相等。\n      - 小于 0：当前字符串小于 `s1`。\n  - `compareToIgnoreCase(s1)`：忽略大小写比较字符串的字典顺序。\n  - `startsWith(s1)`：判断字符串是否以 `s1` 开头。\n  - `endsWith(s1)`：判断字符串是否以 `s1` 结尾。\n- **子字符串操作**\n  - `substring(beginIndex)`：从指定索引开始截取到末尾。\n  - `substring(beginIndex, endIndex)`：截取指定范围（==左闭右开==）的子字符串。\n    - 示例：`\"Hello\".substring(1, 4)` 返回 `\"ell\"`。\n- **查找字符或子字符串**\n  - `indexOf(ch)`：返回字符首次出现的索引。\n  - `indexOf(ch, fromIndex)`：从指定索引开始返回字符首次出现的索引。\n  - `indexOf(s1)`：返回子字符串首次出现的索引。\n  - `indexOf(s1, fromIndex)`：从指定索引开始返回子字符串首次出现的索引。\n  - `lastIndexOf(ch)`：返回字符最后一次出现的索引。\n  - （类似地还有三个这里略。）\n- **字符串转数字**\n  - `Integer.parseInt()`：将字符串转换为整数。\n    - 示例：`Integer.parseInt(\"123\")` 返回 123。\n  - `Double.parseDouble()`：将字符串转换为浮点数。\n    - 示例：`Double.parseDouble(\"3.14\")` 返回 3.14。\n- **数字转字符串**\n  - `String.valueOf()`：会调用对应基础数据类型的包装类的 `toString()` 静态方法。\n  - 可以使用 `+ \"\"`\n    - 示例：`123 + \"\"` 返回 `\"123\"`。\n\n#### 3.2.1. String Matching & Replacing & Splitting (Ch10)\n\n- `replace(oldChar, newChar)`：字符替换\n- `replaceFirst(oldString, newString)`：子字符串替换，但只替换第一次\n- `replaceAll(oldString, newString)`：子字符串替换\n- `split(delimiter): String[]`：将字符串按指定串分割成数组\n- ==这里的 `match`、`replace` 系列、`split` 方法都支持正则表达式==。\n\n#### 3.2.2. String Formatting (Ch10)\n\n- 支持 `String.format()` 的静态方法，其中第一个参数是格式化字符串，支持的语法参见下面的 String-Formatting 部分。\n\n### 3.3. Input: The `Scanner` Class\n\n- `Scanner sc = new Scanner(System.in);`\n- 使用 `Scanner` 类：\n  - `nextInt()`、`nextDouble()`、`nextFloat()`、`nextLong()` 方法：读取整数、浮点数、长整数等等基本数据类型。\n  - `next()` 方法：读取单词。==从遇到第一个有效字符（非空格、换行符）开始扫描，遇到第一个分隔符或结束符（空格 ` ` 或者换行符 `\\n`）时结束==。\n  - `nextLine()` 方法：读取整行。==扫描剩下的所有字符串直到遇到回车为止。（可以从空格开始）==。\n- 注意：`nextInt()` 和 `nextLine()` 的组合可能导致读取问题（即剩一个空的行末）。解决方法：在 `nextInt()` 后添加一个 `nextLine()`。\n\n### 3.4. Formatting Output\n\n> TODO：具体还是得看一下课件。\n\n- **使用 `printf` 格式化输出**\n  - ==格式：`%[index$][标识][最小宽度][.精度]转换符`。==\n    - ![](https://img.memset0.cn/2024/12/17/VtSnq2pS.png)\n  - **常用转换符**\n    - `%b`：布尔值。\n    - `%c`：字符。\n    - `%s`：字符串。\n    - `%d`：整数。\n    - `%f`：浮点数。\n    - `%e`：科学计数法（`4.556000e+01`）。\n    - 日期和时间：\n      - `%tF`：完整日期（如 2024-12-17）。\n      - `%tT`：完整时间（如 15:45:14）。\n      - 还有各种，以 `%t` 开头。\n  - **标识**\n    - `-`：左对齐。\n    - `0`：用零填充。\n    - `,`：千位分隔符。\n    - `+`：显示正负号。\n  - **示例**\n    - 将整数补零：`String.format(\"%04d\", 5)` 返回 `\"0005\"`。\n    - 千位分隔符：`String.format(\"%,d\", 1000000)` 返回 `\"1,000,000\"`。\n\n## 4. Ch05 Loops\n\n### 4.1. `do`-`while` Loop\n\n- 基本结构：\n  ```java\n  do {\n      // Loop body;\n      Statement(s);\n  } while (loop-continuation-condition);\n  ```\n- **特点**：至少执行一次循环体，然后再检查条件。\n\n### 4.2. Break with Tag\n\n- ==使用带标签的 `break` 语句可以跳出多层嵌套循环==。\n  - 示例：\n    ```java\n    outer: for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (j == 2) break outer; // 跳出 outer 循环\n            System.out.println(\"i = \" + i + \", j = \" + j);\n        }\n    }\n    ```\n- 可以将标签用到任意语句块中（即大括号括起来的一段语句），使用带标签的 `break` 语句可以跳出该语句块，即使这个语句块不是循环体。\n\n### 4.3. For-in\n\n- Java 5 引入了用于数组和容器的 for-in 语法，这类似于 C++ 14 的 range-based for 语法。\n  - 示例：\n    ```java\n    int[] numbers = {1, 2, 3, 4, 5};\n    for (int number : numbers) {\n        System.out.println(number);\n    }\n    ```\n\n## 5. Ch06 Methods\n\n### 5.1. Methods\n\n- **方法(method)** 是一组语句的集合，用于完成某个特定的操作。通过方法可以实现代码的复用、模块化和易维护性。\n- **方法签名(method signature)** 定义为方法名和参数列表的组合，它是方法的唯一标识。\n\n### 5.2. Formal & Actual Parameters\n\n- **形式参数(formal parameter)** 是方法头中定义的变量，用于接收调用方法时传递的值。\n- **实际参数(actual parameter)** 是在调用方法时传递给形式参数的值。\n- ==Java 中的参数传递是 **按值传递(pass by value)** 的，即将实际参数的值复制一份传递给方法==。\n  - 即方法内对参数的修改不会影响方法外的变量。\n\n### 5.3. Overloading\n\n- 方法的 **重载(overload)** 是指在同一个类中定义多个同名方法，==但参数列表不同==。\n  - 注意区分 overload 和 override。  \n     ![|662](https://img.memset0.cn/2024/12/18/bkmjRMM6.png)\n  - 可以重载静态方法，但不能重写静态方法。\n- **模糊调用(ambiguous invocation)**：在方法调用时，编译器可能发现有多个方法匹配，无法确定哪一个是最具体的，==这种时候会直接 CE==。\n  - 原因：\n    - 方法重载时，多个方法的参数列表可能存在一定的重叠，导致编译器无法确定调用哪个方法。\n    - 方法调用中涉及自动类型转换或可变参数时，可能会有多个方法同时符合调用条件。\n  - 举例：如果有 `print(int); print(double);` 两个方法，则在 `print(1);` 时会认为前者更具体而不会报错，但如果同时有 `print(int, double);` 和 `print(double, int);` 两个方法，则 `print(1, 1);` 时就无法确定调用哪个方法更具体，从而会报错。\n\n## 6. Ch07 Single-Dimensional Arrays\n\n### 6.1. Single-Dimensional Arrays\n\n- **声明数组**\n  - 语法：\n    - `datatype[] arrayRefVar;`\n    - `datatype arrayRefVar[];` （不推荐）\n- **创建数组**\n  - 语法：\n    - `arrayRefVar = new datatype[arraySize];`\n    - 示例：`myList = new double[10];`\n  - 创建时会自动设定为默认值：\n    - 数值基本类型自动设定为 `0`，字符类型默认为 `\\u0000`，布尔类型默认为 `false`。\n    - 对象引用类型默认为 `null`。\n- ==使用 `arrayRefVar.length` 获取数组大小==。\n  - ==数组一旦创建，大小就固定不能改变==。\n- **数组初始化器(array initializer)**：==使用时必须要在一个语句中完成数组的声明、创建和初始化，否则会导致 CE==。\n  - 举例：`double[] myList = {1.9, 2.9, 3.4, 3.5};`\n  - 可以用 `new int[]{3, 1, 5, 2, 4}` 的语法用数组初始化器创建 **匿名数组(anonymous array)**。\n- ==Java 数组的内存分配在堆上==。而在 C 中，使用 `int a[100]` 创建的数组分配在栈上，使用 `int *a = new int[100];` 创建的数组分配在堆上。\n- **边界检查**：==Java 的 `[]` 操作符会检查数组边界==。\n- **拷贝数组**：==不会重新创建数组，而是直接将引用复制==。\n  ![|514](https://img.memset0.cn/2024/12/18/rOzNOMdV.png)\n  - 正确的拷贝数组方式：\n    - 重新创建一个并依次赋值\n    - **使用 `System.arraycopy`**：`System.arraycopy(sourceArray, 0, targetArray, 0, sourceArray.length);`。\n    - **使用 `Arrays.copyOf`**：`int[] copiedArray = Arrays.copyOf(sourceArray, sourceArray.length);`\n\n## 7. Ch08 Multidimensional Arrays\n\n### 7.1. Two-dimensional Arrays\n\n- 声明与创建：\n  ```java\n  // 声明数组引用变量\n  dataType[][] refVar;\n  refVar = new dataType[10][10];\n  // 声明和创建结合\n  dataType[][] refVar = new dataType[10][10];\n  // 另一种语法\n  dataType refVar[][] = new dataType[10][10];\n  ```\n  - 多维数组的创建时应从左到右指定维数，未指定的维数不会自动创建内容，需要再手动创建。\n    - 即 `int a[][] = new int[3][0]` 和 `new int[3][3]` 都是合法的，但是前者要再使用 `a[0] = new int[3]` 才能创建第二维的内容。\n- Java 的数组每一维可以有不同的大小，大小不同的数组称为 **不规则数组(ragged array)**。\n\n## 8. 杂项\n\n- `System.currentTimeMillis()`  返回自 1970 年 1 月 1 日以来的毫秒数。\n- Java 语言的 `public static void main(String args[])` 命令行参数中，==从第一个位置开始存储命令行参数==（即 `args[0]`），程序名没有存储在 `args` 中。\n- ==Java 中不能在 **嵌套** 代码块中重复声明同名变量==，这点与 C/C++ 不同。\n- **静态导入 `import static`**：可以引入类的静态成员，如 `import static java.lang.Math.PI` 后可以直接用 `PI` 而不用 `Math.PI`。\n\n### 8.1. `java.lang.Math` (Ch04)\n\n- **常用常量**\n  - `Math.PI`：圆周率。\n  - `Math.E`：自然对数的底。\n- **常用方法**\n  - **三角函数**：`Math.sin`、`Math.cos`、`Math.tan`、`Math.toRadians` 等。\n  - **指数函数**：`Math.exp`、`Math.log`、`Math.log10`、`Math.pow`、`Math.sqrt`。\n  - **四舍五入方法**：`Math.ceil`、`Math.floor`、`Math.rint`、`Math.round`。\n    - ==`Math.rint()` 方法是向最接近的整数取整，如果出现 x.5 的情况则向 x 和 x+1 中的偶数取整。==\n  - **最值和绝对值**：`Math.max`、`Math.min`、`Math.abs`。\n  - **随机数生成**：\n    - `Math.random()` 生成 $[0., 1.)$ 的随机数。\n\n### 8.2. `java.utils.Arrays` (Ch07)\n\n- `copyOf(array, newLength)` 静态方法：拷贝数组。\n- `binarySearch(array, key)` 静态方法：二分搜索（要求数组有序）。\n- `sort(array)` 静态方法：将数组排序。\n\n### 8.3. `java.util.Date` (Ch09)\n\n- **构造函数**：\n  - `Date()`：构造一个表示当前时间的 Date 对象。\n  - `Date(elapseTime: long)`：构造一个 Date 对象，表示==自 1970 年 1 月 1 日 GMT 以来指定毫秒数的时间==。\n- **方法**：\n  - `toString() : String`：返回表示日期和时间的字符串。（例：`Sun Mar 09 13:50:19EST 2003`）\n  - `getTime() : long`：返回自 1970 年 1 月 1 日 GMT 以来的毫秒数。\n  - `setTime(elapseTime: long) : void`：设置对象的新时间。\n\n### 8.4. `java.util.Random` (Ch09)\n\n- **构造函数**：\n  - `Random()`：使用当前时间作为种子构造一个 Random 对象。\n  - `Random(seed: long)`：使用指定的种子构造一个 Random 对象。\n- **方法**：\n  - `nextInt() : int`：返回一个随机的 int 值。\n  - `nextInt(n: int) : int`：返回一个 0（含）到 n（不含）之间的随机 int 值。\n  - `nextLong() : long`：返回一个随机的 long 值。\n  - `nextDouble() : double`：返回一个 0.0（含）到 1.0（不含）之间的随机 double 值。\n  - `nextFloat() : float`：返回一个 0.0F（含）到 1.0F（不含）之间的随机 float 值。\n  - `nextBoolean() : boolean`：返回一个随机的 boolean 值。\n","publishedTitle":"「Java 应用技术」I. Java 语言基础"}},{"id":"52cd8b44-293a-58f8-a097-dcccf44ea187","fields":{"slug":"/course/java/note/2/","plainText":"\n> 本篇笔记主要介绍了 Java 面向对象编程的核心概念和实践。涵盖了类与对象的基本概念、封装与访问控制、继承与多态、接口与抽象类等重要主题。通过理论讲解和代码示例，系统地阐述了 Java 面向对象编程的设计理念和实现方法，帮助读者深入理解面向对象程序设计的思想。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. Ch09 and Classes\n\n### 1.1. Object-Oriented Programming (OOP)\n\n- **对象(object)**：\n  - 对象一般用来表示现实世界中可以被识别的实体，具有唯一标识、状态和行为。\n  - **状态(state)**：由数据字段（属性）及其当前值组成。\n  - **行为(behavior)**：由方法定义。\n  - 对象与基本数据类型的区别\n    - **基本类型变量**：存储实际值。\n    - **对象引用变量**：存储对象的内存地址。\n    - ==Java 中的参数传递始终是值传递。因为 Java 中的对象实际上是一种引用，我们在传递参数时是将对应的地址作为值传递进去的；而在传递基本类型时那更是直接传递这个值了。==\n  - ==所有对象的实例都存储在堆中，只有局部的基本类型变量和对象引用存储在栈中，这是 Java 语言的一大特性。==\n- **类(class)**：\n  - 类是定义相同类型对象的构造。\n  - Java 中的类用 **变量(variable)** 来表示状态，用 **方法(method)** 来表示行为。\n  - **UML 类图(UML class diagram)**：通过图形化方式展示类的属性和方法。\n\n### 1.2. Constructors\n\n- **构造函数(constructor)** 是一类特殊的方法，用于创建对象并初始化其属性。\n- 使用 `new` 运算符创建对象并触发构造函数。\n- **要求**：\n  - 构造函数的名称必须与类名相同。\n  - 无返回类型（不是 `void`，直接不用写）。\n- **默认构造函数(default constructor)**\n  - 如果类没有定义构造函数，Java 会自动提供一个默认的空的无参构造函数。\n  - 当且仅当类没有显式声明的构造函数时才会创建。\n- **默认初始化**：\n  - ==对于没有进行初始化的对象中的变量会分配**默认值(default value)**==：\n    - 引用类型：`null`\n    - 数值类型：`0`\n    - 字符类型：`\\u0000`\n  - ==注意：在方法内的局部变量并不会有默认值，这种时候会 CE 报错（variable not initialized）==！\n  - 这其实是关系到使用 `new` 运算符创建对象时，是在堆中申请了一块新的空间，Java 会将其中的 data fields 自动初始化为全 0，这也就是不同类型所对应的默认值。\n- **指定初始化**：\n  - 示例\n    ```java\n    public class Test {\n    \t\tstatic int STATIC_ONE = 1;\n    \t\tstatic int STATIC_TWO;\n    \t\t{\n    \t\t\t\tSTATIC_TWO = 2;\n    \t\t}\n    }\n    ```\n  - 指定初始化的其实是在默认初始化的动作之后执行的。（如在这里执行 `STATIC_TWO = 2;` 语句之前 `STATIC_TWO` 的值应为 0。）\n- 三种初始化方法的顺序是：==① 默认初始化 ② 指定初始化（直接给变量赋值，或者一个直接写在 class 里的块） ③ 构造函数==。\n\n### 1.3. Garbage Collection (GC)\n\n- **垃圾回收(garbage collection)**：Java 虚拟机（JVM）会自动回收不再被引用的对象。\n- **内存泄漏(memory leak)**：如果程序不正确地管理对象的引用，让其无法自动释放，就会存在内存泄漏的问题。\n  - ==这里 `return elements[--size]` 时没有释放 `elements` 数组中对对应对象的引用（因为这不是一个基本类型的栈，而是一个 Object 的栈），这种时候就会有内存泄漏的问题产生==。\n    ![|403](https://img.memset0.cn/2024/12/17/wh5AT5RR.png)\n- ==**手动释放引用**：可以通过显式地将对象引用赋值为 `null`，来提示 JVM 进行回收==。\n  - 示例：\n    ```java\n    Circle c1 = new Circle(5.0);\n    c1 = null; // c1指向的对象会被回收\n    ```\n\n### 1.4. Static Variables & Methods\n\n- 使用 `static` 关键字修饰全局变量、常量和方法。\n  - 对于全局常量，使用 `final static` 修饰。\n- **静态成员**：属于类，而不是某个实例。\n- **实例成员**：属于特定对象的实例。\n- **访问限制**：\n  - 静态方法只能访问静态的变量和方法。\n  - 实例方法可以访问静态和实例的变量和方法。\n- **生命周期**：==第一次通过类名访问静态变量或静态方法时，Java 会将类加载进内存，为这个类分配一块空间，包含了定义、变量和方法信息，还有类的静态变量，并对静态变量复制。类在加载进内存之后一般不会释放，直到程序结束。一般情况下，类只会这样加载一次==。（具体参见“类加载过程”的部分）\n\n### 1.5. Encapsulation and Access Control\n\n- **封装(encapsulation)**：保护数据，便于维护。\n- **访问修饰符(visibility modifiers)**：\n  - `private`：仅类内部可访问。\n  - `public`：所有类均可访问。\n  - ==默认（无修饰符）：同一包内可访问。==\n  - ![|555](https://img.memset0.cn/2024/12/17/Cm4bIw3D.png)\n- 通过让类提供 `get` 和 `set` 方法来从外部访问私有数据字段。\n- ==`private Constructor`：通过 `private` 修饰构造函数，防止从外部创建类的示例==。\n  - 示例 1（只能静态访问）：Java 提供的 `Math` 类的构造函数就是 `private Math() {}`。\n  - ==示例 2（只能被类的静态方法调用）：单例模式==  \n     ![|640](https://img.memset0.cn/2024/12/17/LVn4d5uF.png)\n  - ==示例 3（只能被类的其他构造函数调用，用于减少重复代码）==\n\n### 1.6. Immutable Objects and Classes\n\n- **不可变对象**：不可变类的对象，一旦创建，其内容不能更改。（典例：`String`）\n- **不可变类的设计规则**：\n  1.  不提供修改对象状态的方法。\n  2.  ==将类声明为 `final`，防止继承=。\n      - 还可以采用一种更为灵活的方式让类的所有构造器都变为私有的或包级私有的，并添加公共的静态工厂来代替公有的构造器。（如常量池技术，下一章会详细介绍。）\n  3.  ==所有字段声明为 `private` 和 `final`==。\n  4.  确保没有返回可变对象引用的方法。\n- **不可变类的优点**：\n  - 不可变对象是线程安全的。\n  - ==不需要进行保护性拷贝，因为对象的引用不会被修改。（TODO：？）==\n  - 可以提供静态工厂，把频繁被请求的实例缓存起来。\n    ![|450](https://img.memset0.cn/2024/12/17/59fbk4bi.png)\n  - 对于特殊不可变对象的部分常用方法，可以直接提供结果。\n    ![|450](https://img.memset0.cn/2024/12/17/KP1Be31g.png)\n- ==必要时进行保护性拷贝：必须要返回对象的场合，重新创建一个临时对象返回，确保当前对象不被修改==。\n  - ![|528](https://img.memset0.cn/2024/12/17/rs5sEnMw.png)\n  - 另一个例子：类具有公有的静态 final 数组域，或者返回这种域的访问方法，这是安全漏洞的一个常见根源。  \n     ![|420](https://img.memset0.cn/2024/12/17/ijwg7L04.png)\n\n### 1.7. this\n\n- **用途**：\n  1.  引用当前对象。\n  2.  调用类的其他构造函数。\n- 示例：\n  ```java\n  class Circle {\n  \t\tprivate double radius;\n  \t\tpublic Circle(double radius) {\n  \t\t\t\tthis.radius = radius; // 只能通过 this 引用当前对象的 radius 字段\n  \t\t}\n  \t\tpublic Circle() {\n  \t\t\t\tthis(1.0); // 调用另一个构造函数\n  \t\t}\n  \t\tpublic double getArea() {\n  \t\t\t\treturn this.radius * this.radius * Math.PI; // 这里一般省略 this\n  \t\t}\n  }\n  ```\n\n### 1.8. Package\n\n- **包(package)**：用于组织类，避免命名冲突。\n  - ==如果缺省 package 语句，则类属于**默认包(default package)**==。\n  - 约定俗称的包命名方式为将公司域名倒过来写。\n  - ==编译器在编译源文件时不会检查目录结构，但是会在运行时报错。==\n- **导入(import)**：\n  - 使用 `import` 语句导入包中的某个类或整个包。\n  - 默认行为：`import java.lang.*`。\n  - 当导入的多个包中存在同名类时，可以用通过指定包名来区分。\n    - 举例：\n      ```java\n      import java.util.*;\n      import java.sql.*;\n      Date d = new Date(); // 错误\n      java.util.Date d = new java.util.Date(); // 正确\n      ```\n  - **静态导入(static import)**：\n    - ==使用 `import static` 语句导入包中的静态方法和静态域==。\n      - 示例：\n        ```java\n        import static java.lang.System.*;\n        out.println(\"Hello, World!\"); // System.out\n        exit(0); // System.exit\n        ```\n\n### 1.9. JAR\n\n- **创建 JAR 文件**：\n  - 命令行：`jar -cvf filename.jar files`\n- **运行 JAR 文件**：\n  - 命令行：`java -jar filename.jar`\n- 在 JAR 中打包资源。\n\n## 2. Ch10 Thinking in Objects\n\n### 2.1. Association & Aggregation & Composition\n\n1. **关联(association)**：表示对象之间的多重性关系。\n   - 示例：学生和教师之间的关联。\n2. **聚合(aggregation)**：一种方向性关联关系，表示 \"has-a\" 关系。\n   - 示例：一个部门包含多个员工。\n3. **组合(composition)**：聚合的一种特殊形式（即也是一种 \"has-a\" 关系），表示更强的依赖关系。\n   - 示例：一个人包含一个心脏，心脏不能脱离人存在。\n   - 聚合和组合的区别：组合更为严格，聚合的多个对象可以均独立存在，而组合的多个对象不能独立存在。\n\n### 2.2. Wrapper Classes\n\n- **包装类(wrapper class)**：指将基本数据类型封装为对象的类。\n  - 如 `Boolean`, `Integer`, `Double` 等等。\n- 特点：\n  1.  ==没有无参构造器（总得来个参数才能被包装吧）==。\n  2.  包装类对象是不可变的。\n- **数值包装类(numeric wrapper class)**：\n  - 所有数值包装类都继承自 `Number` 类，有 `doubleValue`、`intValue`、`longValue`、`floatValue`、`shortValue` 等方法，用于把包装类对象转换为对应的基本数据类型。\n  - 所有数值包装类都有 `MAX_VALUE` 和 `MIN_VALUE` 两个静态常量：\n    - 对于整数（`Integer`, `Short`, `Byte`, `Long`）：用来表示该类型的最大值和最小值。\n    - 对于浮点数（`Float`, `Double`）：==`MIN_VALUE` 用来表示该类型能表示的最小正数==，`MAX_VALUE` 用来表示该类型能表示的最大值。\n  - 数值包装类的 `valueOf()` 静态方法不光可以将基本类型转化为对应包装类对象，也可以把字符串转化为对应包装类对象。\n  - ==整型包装类的 `parseInt(str, radix)` 静态方法还可以把指定进制的字符串转化为对应整型包装类==。\n  - 浮点数包装类的 `parseDouble(str)` 静态方法还可以把字符串转化为对应浮点数包装类。\n  - ![|620](https://img.memset0.cn/2024/12/18/qMgyh6eq.png)\n\n### 2.3. Automatic Boxing & Unboxing\n\n- **自动装箱(automatic boxing)**：基本类型自动转换为包装类对象。\n  - 示例：`Integer[] intArray = {2, 4, 3};`\n  - ==自动装箱会带来额外的性能开销==，在需要频繁装箱和拆箱的场合，建议使用基本类型。\n    - 举例：这段代码答案是正确的，但是速度会慢特别多：\n      ```java\n      Long sum = 0L;\n      for (long i = 0; i < Integer.MAX_VALUE; i++) {\n      \t\tsum += i;\n      }\n      System.out.println(sum);\n      ```\n- **自动拆箱(automatic unboxing)**：包装类对象自动转换为基本类型。\n  - 示例：`System.out.println(intArray[0] + intArray[1] + intArray[2]);`\n\n### 2.4. `BigInteger` & `BigDecimal`\n\n- ==`BigInteger` 和 `BigDecimal` 都是不可变类==。\n- **`BigInteger`**：支持任意大小的整数运算。\n  - 示例：\n    ```java\n    BigInteger a = new BigInteger(\"9223372036854775807\");\n    BigInteger b = new BigInteger(\"2\");\n    BigInteger c = a.multiply(b); // 结果：18446744073709551614\n    ```\n- **`BigDecimal`**：支持高精度的浮点数运算。\n  - 示例：\n    ```java\n    BigDecimal a = new BigDecimal(1.0);\n    BigDecimal b = new BigDecimal(3);\n    BigDecimal c = a.divide(b, 20, BigDecimal.ROUND_UP);\n    System.out.println(c);\n    ```\n\n### 2.5. Interned Strings\n\n- 因为字符串是不可变的且被频繁使用，为了提升性能并节省内存，Java 引入了 **字符串池(string pool)** 的技术，只为每一种相同的字符串只创建一份实例，这样的实例被称为 **被池化的(interned)** 字符串。\n- 使用 `new` 关键词创建的字符串一定会创建一个新的对象（不会被池化），使用 string initializer 创建的对象会被池化，即只有在字符串池中没有相同字符串时才会创建新的对象。\n  - 示例：（第一个判断是 false，第二个判断是 true）  \n     ![|618](https://img.memset0.cn/2024/12/18/rgcyKLVI.png)\n  - 可以使用字符串对象的 `intern()` 方法显式地将 `new` 关键词创建的字符串加入字符串池。\n- 像这种字符串拼接的情况，如果不能在编译器常量化得到结果的化，则会编译到 `StringBuilder` 来拼接，并在最后返回时创建一个新的字符串对象，这种时候是不会被自动池化的，需要显式调用 `intern()` 方法。\n  - ![|397](https://img.memset0.cn/2024/12/18/RKxu0vRv.png)\n\n### 2.6. Constant Pool\n\n- Java 的常量池技术，是提升创建某些对象的性能而出现的，当需要一个对象时，直接从池中取一个出来，能节省不少创建对象的时间。\n- 常量池其实就是一块内存空间，存在于方法区中。\n- 对于字符串类，JVM 编译器会在编译器将字符串字面量常量化，即直接加入到常量池中。\n- 对于整数包装类，只会对 -128 到 127 之间的整数进行常量化，且不创建或管理超出这一范围的整数包装类对象。\n  - 为了性能提升，应尽量使用 `Integer.valueOf(int)` 方法来创建对象，而不是使用 `new Integer(int)` 方法。\n  - 示例：这里划红框的两个部分的区别是前者可以在编译器优化，后者则在运行自动拆箱并计算。\n    ![|422](https://img.memset0.cn/2024/12/18/scbQfK7B.png)\n- 对于浮点数包装类，没有实现常量池。\n\n### 2.7. `StringBuilder` & `StringBuffer`\n\n- **`StringBuilder`**：\n  - ==非线程安全==，但性能更高。适用于单线程场景。\n  - 方法：\n    - `+StringBuilder()`：构造空 StringBuilder，默认容量为 16。\n    - `+StringBuilder(capacity: int)`：构造空 StringBuilder，容量为 `capacity`。\n    - `+StringBuilder(s: String)`：构造一个 StringBuilder，内容为字符串 `s`。\n    - `+append(data: char[]) : StringBuilder`：将字符数组追加到此字符串生成器中。\n    - `+append(data: char[], offset: int, len: int) : StringBuilder`：将字符数组从 `offset` 开始，长度为 `len` 的字符追加到此字符串生成器中。\n    - `+append(v: aPrimitiveType) : StringBuilder`：将原始类型的值作为字符串追加。\n    - `+append(s: String) : StringBuilder`：将字符串追加到此字符串生成器中。\n    - `+delete(startIndex: int, endIndex: int) : StringBuilder`：删除指定范围内的字符。\n    - `+deleteCharAt(index: int) : StringBuilder`：删除指定索引处的字符。\n    - `+insert(index: int, data: char[], offset: int, len: int) : StringBuilder`：将字符数组从 `offset` 开始，长度为 `len` 的字符插入到指定索引处。\n    - `+insert(offset: int, data: char[], len: int) : StringBuilder`：在指定位置插入字符数组。\n    - `+insert(offset: int, s: String) : StringBuilder`：在指定位置插入字符串。\n    - `+replace(startIndex: int, endIndex: int, s: String) : StringBuilder`：用指定字符串替换指定范围内的字符。\n    - `+reverse() : StringBuilder`：反转此字符串生成器中的字符。\n    - `+setCharAt(index: int, ch: char) : void`：在指定索引处设置新字符。\n    - `+toString() : String`：返回一个字符串对象。\n    - `+capacity() : int`：返回此字符串生成器的容量。\n    - `+charAt(index: int) : char`：返回指定索引处的字符。\n    - `+length() : int`：返回字符串生成器中的字符数。\n    - `+setLength(newLength: int) : void`：设置字符串生成器的新长度。\n    - `+substring(startIndex: int) : String`：返回从 startIndex 开始到末尾的子字符串。\n    - `+substring(startIndex: int, endIndex: int) : String`：返回从 startIndex 到 endIndex-1 的子字符串。\n    - `+trimToSize() : void`：减少用于字符串生成器的存储空间大小。\n- **`StringBuffer`**：\n  - 线程安全，适用于多线程场景。\n  - 接口与 `StringBuilder` 相同。\n\n### 2.8. Enum\n\n- 使用 `enum` 关键字定义。\n- ==每个枚举值都是该枚举类的实例==，所有枚举类都是 `java.lang.Enum` 的子类。\n  - 没有可访问的构造器，不能通过 `new` 关键词创建枚举类，是真正的 final 类。\n- ==提供编译时的类型安全检查==，若声明参数的类型为枚举类，则只能传入该参数的非 null 对象引用一定属于该枚举类的某个值。\n- ==在 enum 类外使用枚举值时，需要使用 `enumName.enumValue` 的完全限定名形式==。\n- 可以在 `switch` 语句中使用，此时可以不使用完全限定名。\n- 方法：\n  - `ordinal()` 方法：返回该枚举值的顺序，这个顺序就是根据枚举值声明的顺序确定的，从 0 开始。\n  - `name()` 方法：返回该枚举值的名称。\n  - `toString()` 方法：返回该枚举值的名称。\n  - `values()` 静态方法：返回枚举类的所有值。\n  - `valueOf(name: String)` 静态方法：可以通过枚举值的名字返回对应的枚举值实例。\n- 高级用法（**关联数据**）：构造函数参数通过括号给出，方法通过大括号给出；两者都可缺省。\n  - 在一些需要用到枚举类编号的地方，不建议直接用 `ordinal()` 方法得到编号，因为这种时候返回的值就和代码中编码的顺序有关了，可以考虑通过这种方式：\n    ```java\n    public enum Fruit {\n        APPLE(1), PEAR(2), ORANGE(3); // 每个枚举值的构造函数参数\n        private final int number; // 定义一个字段，用于存储水果编号\n        Fruit(int num) { // 构造函数，用于初始化每个枚举值的字段\n            number = num;\n        }\n        public int numberOfFruit() {\n            return number;\n        }\n    }\n    ```\n  - 特定于常量的方法实现：\n    ```java\n    public enum Operation {\n    \t\tPLUS { double apply(double x, double y) { return x + y; } },\n    \t\tMINUS { double apply(double x, double y) { return x - y; } },\n        TIMES { double apply(double x, double y) { return x * y; } },\n        DIVIDE { double apply(double x, double y) { return x / y; } };\n        abstract double apply(double x, double y);\n    }\n    ```\n  - **策略枚举**：  \n     ![|561](https://img.memset0.cn/2024/12/18/WOszsFdr.png)\n\n## 3. Ch11 Inheritance and Polymorphism\n\n### 3.1. Superclasses and Subclasses\n\n- ==超类的构造函数是否会被继承不会被 **继承(inherite)**，但可以显式或隐式调用==。\n  - 显式调用：必须使用 `super` 关键字。\n    - 使用 `super` 调用必须放在构造函数的第一行。\n    - ==不能使用超类构造函数的名称来调用超类的构造函数==。\n  - 如果未显式调用，==会默认调用超类的无参构造函数（没有就会 CE），且顺序在子类构造函数之前==。\n- 使用 `super.methodName()` 调用超类的方法。\n- 调用顺序类初始化时构造函数的调用顺序：\n  - 初始化对象的存储空间为默认值（`0`、`null` 或 `false`）。\n  - 调用父类的构造函数。\n  - 按顺序分别调用类成员变量和实例成员变量的初始化表达式。\n  - 调用子类的构造函数剩余部分。\n- 当子类的 **实例变量(instance variable)** 和超类的变量重名时，==子类变量会隐藏超类变量==。\n  - 注意，这并不以为着超类变量会被覆盖，重名的实例变量和类变量是两个不同的变量，都会被保留。\n  - 可以使用 `super.variableName` 访问被隐藏的超类变量。\n  - 如果我们把子类实例赋值给超类对象的引用，也会访问到被隐藏的类变量。\n- ==继承时与超类重名的静态方法和静态变量的处理，都遵循类似的方式==。\n\n### 3.2. Overriding\n\n- 子类可以重写从超类继承的方法，这种特性称为 **重写(overriding)**。\n- **要求**：\n  - 方法签名（方法名和参数列表）必须完全相同。\n  - 只有可访问的方法才能被重写（即 private 的方法不能被重写）。\n    - 否则其实是实现了两个无关的方法。\n  - ==静态方法不能被重写，只能被隐藏==。\n  - ==重写后的方法不能比被重写的方法拥有更严格的访问权限==。\n- `@Override` 注解：==编译器会负责检查是否真的重写了方法，否则会报 CE==。推荐始终使用 `@Override` 注解，尽管它不是必须的。\n- ==重载的方法选择是静态绑定的（compile-time）， 而重写的方法选择是动态绑定的（runtime）==。\n- ==在父类构造函数中调用被重写的方法，调用的实际上是子类的重写后的方法==。（这也是动态绑定机制的一个体现。）\n  - 注意：如果父类中的方法是 `private` 的话，那这里实际上没有发生重写，调用的还是父类的方法。\n\n### 3.3. Polymorphism\n\n- **多态(polymorphism)**：一个超类类型的变量可以引用子类的对象。\n  - 示例：\n    ```java\n    GeometricObject obj = new Circle();\n    ```\n- 选用的方法调用（如果存在重写的情况，则）在运行时解析，就是上文提到的动态绑定机制。\n\n### 3.4. Generic Programming & Object Casting\n\n- **泛型编程(generic programming)**：允许我们编写可以处理多种类型的代码，而不需要为每种类型单独编写代码；多态是实现泛型编程的基础。我\n- **向上转换(upcasting)**：子类对象可以隐式转换为超类类型。\n  - 示例：\n    ```java\n    Object o = new Student();\n    ```\n- **向下转换(downcasting)**：超类转化为子类类型时必须显式转换。\n  - 向下转换并不总是成功，==在类型转换失败时会抛出一个异常==。而不是像 C++ 的 `dynamic_cast` 一样返回一个空指针。\n  - 可以使用 `instanceof` 检查能否进行类型转换。\n  - 示例：\n    ```java\n    Student s = (Student) o;\n    ```\n- **`instanceof` 运算符**：用于测试对象是否是某个类的实例。\n  - 示例：\n    ```java\n    if (o instanceof Circle) {\n        Circle c = (Circle) o;\n    }\n    ```\n\n### 3.5. `equals` method & `==` operator\n\n- `==` 运算符用于比较两个对象的引用是否相等，即比较两个对象是否指向同一个内存地址。\n  - `==` 只能用于比较基本类型的内容是否相同，在比较对象引用类型时，只会比较引用是否相同而不会比较内容。\n- `equals` 方法用于比较两个对象的内容是否相等，即比较两个对象的属性值是否相同。\n  - 对于自己定义的类，这需要重写 `equals` 方法。\n  - **重写 `equals` 方法**。\n    - ==`Object.equals` 方法的参数是 `Object` 类型，为了成功重写我们需要保持这一方法签名相同，并用 `instanceof` 检查参数是否是当前类的实例==。\n    - ```java\n                      public class Bigram {\n                          private final char first;\n                          private final char second;\n                          public Bigram(char first, char second) {\n                              this.first = first;\n                              this.second = second;\n                          }\n                          public boolean equals(Bigram b) { // 错误\n                              return b.first == first && b.second == second;\n                          }\n                          @Override public boolean equals(Object o) { // 正确 (需要与 Object 类的 equals 方法签名相同)\n                              if (!(o instanceof Bigram)) return false;\n                              Bigram b = (Bigram) o;\n                              return b.first == first && b.second == second;\n                          }\n                      }\n      ```\n\n### 3.6. The `final` Modifier\n\n- **`final` 类**：不能被继承。\n- **`final` 方法**：不能被子类重写。\n- **`final` 变量**：不能被修改。\n  - 如果是基本类型变量，可以理解为类似常量的概念（只能被赋值一次，之后不能被修改）。\n  - 如果是对象引用变量，则只是引用的地址是常量，而对象内部的内容是可以更改的。\n\n### 3.7. Review: Handling Objects\n\n- **类加载过程**：第一次使用类时，才会加载类\n  - 分配内存保存类的信息\n  - 给类变量（静态变量）赋默认值\n  - 加载父类\n  - 设置父子关系\n  - 执行类初始化代码\n    - 定义静态变量时的赋值语句\n    - 静态初始化代码块\n- **对象创建过程**：\n  - 分配内存\n  - 对所有实例变量赋默认值（`0`、`null` 或 `false`）\n  - 执行实例初始化代码\n- **方法调用过程**：\n  - 由于是动态绑定，所以这一实例是什么类就从什么类开始找方法。\n  - 如果在当前类中找不到，就依次向父类寻找，直到找到为止。\n  - 如果找不到方法，则报 `NoSuchMethodError` 错误。\n  - 如果存在重载的情况，则会根据参数链表选择最匹配的方法，如果同时存在多个最优匹配，则会报错（不过需要注意，可能父类的方法被子类重写了，这种时候只会找到子类的方法）。\n- 如何应对继承的双面性?\n  - 避免使用继承：\n    - 使用 `final` 限制继承。\n    - 优先使用组合而非继承。\n  - 正确使用继承：\n    - 确保超类设计稳定。\n    - 使用接口代替继承。\n\n### 3.8. Decorator Pattern\n\n- **装饰器模式(decorator pattern)**：允许我们通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。\n\n### 3.9. Nested Classes\n\n- **嵌套类(nested class)**：在一个类中嵌套另一个类。外面的类叫 **外部类(outer class)**，里面的类叫 **内部类(inner class)**。\n  - 内部类和外部类可以互相访问对方的私有成员变量和方法，多个内部类可以相互访问对方的私有成员变量和方法。\n  - 内部类可以声明为 private 从而实现对外完全隐藏，拥有更好的封装性。\n- 内部类需要调用方法时：\n  - 首先检查内部类是否有该方法，如果有就调用。\n  - 如果内部类没有该方法，则检查并调用外部类的方法。\n  - ==如果内部类和外部类的方法重名且想要调用外部类的方法，需要使用 `OuterClass.this.methodName()`==。\n  - ==如果内部类和外部类的方法重名但参数列表不同，则 Java 会根据参数列表选择最匹配的方法，注意这一过程只在内部类中进行，而不会跨越到外部类的方法==。\n- 四种内部类：\n  - **静态内部类(static inner class)**：\n    - 使用 `static` 修饰。\n    - 可以访问外部类的静态成员变量和静态方法，但是不能访问外部类的实例成员变量和实例方法。\n    - 可以在外部类外被使用，例：`new OuterClass.StaticInnerClass()`。\n  - **成员内部类(member inner class)**：\n    - 没有 `static` 修饰。\n    - 成员内部类需要与一个外部类实例绑定，可以访问外部类的所有成员变量和方法。\n    - 在外部类外使用时需要外部类实例才能创建。`outer.new InnerClass()`。\n  - **方法内部类(local class)**：\n    - 定义在方法中且只能在方法中使用。\n    - 方法内部类也区分是否是 `static` 修饰的，如果是 `static` 则只能访问外部类的静态成员，否则可以访问所有成员。\n    - ==方法内部类访问方法中的参数和局部变量时，这些变量需要声明为 `final` 的==。这些变量实际上会在方法内部类创建时被复制一份作为方法内部类自己的成员变量所使用。\n  - **匿名内部类(anonymous class)**：\n    - 匿名内部类没有单独的类定义，而是在创建对象的同时定义类。\n    - 匿名内部类没有构造函数，但可以通过参数列表调用对应的父类构造函数。\n    - 和方法内部类相同，可以访问外部类的所有变量和方法，也可以访问方法中的 `final` 参数和局部变量。\n\n## 4. Ch12 Abstract Classes and Interfaces\n\n### 4.1. Abstract Classes\n\n- **抽象类(abstract class)** 是相对于 **具体类(concrete class)** 而言的：\n  - 抽象类是一种不能直接实例化的类（即不能通过 new 操作创建对象）。\n  - 抽象类可以包含抽象方法（没有实现的方法）和具体方法（有实现的方法）。非抽象类不能包含抽象方法。\n  - ==抽象方法必须在子类中被完全实现，否则子类也必须是抽象类==。\n- 即使父类是具体类，子类也可以是抽象类。\n- 即使父类中实现了某一方法，子类也可以重写该方法为抽象方法。\n- ==抽象类不能实例化，但可以作为一种数据类型使用==。例如可以定义一个抽象类数组，用于存放其作为具体类的子类对象。\n\n### 4.2. Interfaces\n\n- **接口(interface)** 是一种特殊的类的结构，用于定义类的行为规范。\n  - 一个类只能继承一个抽象类，但是==一个类可以实现多个接口==。\n    - ==如果多个接口中存在相同的方法签名，则会被编译器检测并报 CE==。\n  - 接口中只能包含常量和抽象方法。\n    - 所有方法默认是 `public abstract` 的。\n    - 所有成员变量默认是 `public static final` 的。\n  - 接口中不能有构造器。\n  - （Java 8 新增）静态方法：\n    - 属于接口本身，而不是实现类。\n    - ==只能通过接口名调用，而不能通过实现类或对象调用==。\n  - （Java 8 新增）默认方法：\n    - 通过 `default` 关键字修饰。\n    - 提供了接口方法的默认实现，实现类可以选择重写该默认方法。\n  - （Java 9 新增）私有方法：\n    - 只能在接口中被其他默认方法和或静态方法调用，不能被实现类访问。\n  - （Java 9 新增）私有静态方法：\n    - 只能在接口中被其他静态方法调用，不能被实现类或默认方法访问。\n  - 接口可以通过 `extends` 关键词继承另一个接口。\n- 相比于抽象类被设计用于描述“是什么”，接口被设计用于描述“能做什么”。\n  - 常用的接口如：`Comparable`、`Cloneable`。\n- 类似于抽象类，接口不能被实例化，但可以作为数据类型使用。\n- 示例：自定义类实现 `Cloneable` 接口，用于标记类的对象可被克隆。\n  ```java\n  @Override\n  public Object clone() {\n      try {\n          return super.clone();\n      } catch (CloneNotSupportedException ex) {\n          return null;\n      }\n  }\n  ```\n","publishedTitle":"「Java 应用技术」II. Java 面向对象设计"}},{"id":"9baa1919-5953-5e15-ae74-4b35b71654ae","fields":{"slug":"/course/java/note/3/","plainText":"\n> 本篇笔记主要介绍了 Java 的六个高级特性：异常处理、IO、泛型、集合框架、多线程以及 Lambda 表达式与流式处理。在异常处理部分，详细讲解了异常的分类、捕获与处理机制；IO 部分介绍了文本和二进制的输入输出操作；泛型部分阐述了泛型的使用规则与限制；集合框架部分系统地介绍了 Java 常用的集合类；多线程部分包含了线程的创建、控制与同步机制；最后的 Lambda 与流式处理部分则介绍了 Java 的函数式编程特性。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. Ch13 Exception Handling and Text IO\n\n### 1.1. Exceptions\n\n- **异常(exception)**  是程序运行时发生的错误事件，可能导致程序无法正常运行。\n- 常见的异常：\n  - `ArithmeticException`：除零错误。\n  - `InputMismatchException`：输入数据类型不匹配。\n  - `NullPointerException`：访问未初始化的对象。\n- **异常分类**：\n  - ![|576](https://img.memset0.cn/2024/12/22/3gCP2gwM.png)\n  - 上半部分的 `Exception` 是程序级错误，可以捕获并处理。\n    - 运行时异常（`RuntimeException`）通常由逻辑错误引发，属于 **非检查型异常(unchecked exception)**。\n      - 不需要强制捕获，通常由逻辑错误引发。\n    - 非运行时异常（如  `IOException` 等）需要显式处理，属于 **检查型异常(checked exception)**。\n      - ==编译器强制程序员检查并处理==，即程序员应该使用使用 `try-catch` 块进行捕获这些异常并进行操作。\n  - 下半部分的 `Error` 是系统级错误，由 JVM 检测，通常不可恢复，比如内存不足。\n- **抛出异常**：用 `throw` 关键词抛出异常示例，异常示例通常使用 `new` 运算进行创建。\n  - 语法：`throw new TheException();`\n- **声明异常**：定义方法时用 `throws` 关键词声明可能抛出的异常，多个异常之间用逗号隔开。\n  - ==使用这种方法声明的异常是检查型异常，必须在调用该方法的代码中进行显示捕获，否则会报 CE==。\n  - 语法：`public void myMethod() throws IOException`\n  - 调用时，必须用：`try { } catch(IOException ex) { }` 来处理可能抛出的异常。\n\n### 1.2. Exception Handling\n\n- 用 `try-catch` 块捕获异常。\n  - 语法：`try { } catch(ExceptionType ex) { }`\n- `finally` 块：\n  - `finally` 块中的代码无论是否发生异常都会执行。\n  - 使用 `finally` 块与在 `try-catch` 块之后跟语句的区别时：==如果在 `catch` 块中抛出异常（或者 return 等情况），则 `try-catch` 块之后的代码不会执行，但是 `finally` 中的代码始终会执行==。  \n     ![|494](https://img.memset0.cn/2024/12/22/aEfAfKjt.png)\n  - `finally` 关键字保证无论程序使用何种方式退出 `try-catch` 块，`finally` 块中的代码都会被执行。更具体的，`finally` 块会在以下情况发生之后执行：\n    - try 块中的代码正常执行完毕。\n    - 在 try 块中抛出异常。\n    - 在 try 块中执行 return、break、continue。\n    - catch 块中代码执行完毕。\n    - 在 catch 块中抛出异常。\n    - 在 catch 块中执行 return、break、continue\n  - 通常使用 `finally` 块来释放资源。\n- **多个 `catch` 块的情况**：\n  - 拥有多个 `catch` 块时，JVM 会由上而下来检测每个异常是否被捕获。\n  - **不可达代码检测机制**：如果先 `catch` 了一个异常，又 `catch` 了另一个异常的子类，则后者是不可达的。因为无论抛出什么异常，都会被先前的 `catch` 块捕获。==编译器会检测这种不可达的 `catch` 块，并报 CE==。\n    - ==所以捕获子类异常的 `catch` 块要放在捕获父类异常的 `catch` 块之前==。\n- 捕获到异常 `e` 后：\n  - 使用 `e.getMessage()` 获取异常信息。\n  - 使用 `e.printStackTrace()` 打印异常调用堆栈。\n  - 如果需要进一步抛出异常，建议带上 `e` 的异常信息：可以使用 `Throwable(Throwable cause)` 或者 `Throwable(String message, Throwable cause)` 的构造方法。\n\n### 1.3. Assertions\n\n- **断言(assertions)**：用于验证程序中的某些假设是否成立。\n- 语法：\n  - `assert condition;`，其中 `condition` 是一个布尔表达式。\n  - `assert condition : message;`，其中 `message` 可以是基本数据类型或对象。\n- 当断言失败时，JVM 会抛出 `AssertionError` 异常。\n- 设计原则：\n  - 断言仅用于开发阶段的内部检查。\n  - 不应在公共方法中使用断言检查参数。\n- 断言默认在运行时禁用，需要在命令行手动使用 `-enableassertions` 或 `-ea` 选项启用。\n\n### 1.4. Text IO\n\n- `File` 类：提供文件和路径的抽象。\n  - **常用方法**：\n    - `exists()`：检查文件是否存在。\n    - `createNewFile()`：创建新文件。\n    - `delete()`：删除文件。\n- 使用 `Scanner` 类读取数据。\n  - ==使用 `new Scanner(Paths.get(path))` 从文件中创建 `Scanner` 对象，注意不能直接写字符串==。\n  - ==使用 `new Scanner((new URL(url)).openStream())` 从网络资源中创建 `Scanner` 对象==。\n  - ==第二个参数（可选）用于指定编码，否则使用该系统的默认编码==。\n- 使用 `PrintWriter` 类向文件写入数据。\n  - 支持 `print(...)`、`println(...)`、`printf(...)` 等方法。\n  - 第二个参数（可选）用于指定编码，否则使用该系统的默认编码。\n\n## 2. Ch14 Binary IO\n\n### 2.1. Binary IO Basic\n\n- 几乎所有方法都需要显示捕捉 `java.io.Exception` 异常，故应显式声明或捕捉。\n- `inputStream.read()` 的返回值和 `outputStream.write(int b)` 都是 `int`，但实际上都是以 `byte` 为单位读写的。\n  - 其中 `inputStream.read()` 在 EOF 时会返回 -1，这就是为什么需要用 `int` 而不是 `byte` 表示。\n- `DataInputStream` 在到达文件末尾后继续读取数据会抛出 `EOFException` 异常。\n- `Reader` 是读取字符流的抽象类，`Writer` 是写入字符流的抽象类。\n  - `InputStreamReader`：字节流转字符流\n  - `OutputStreamWrite`：字符流转字节流\n  - `BufferedReader`、`BufferedWriter`：字符缓冲流\n  - `FileReader`：`InputStreamReader` 类的直接子类，用来读取==字符==文件\n  - `FileWriter`：`OutputStreamWriter` 类的直接子类，用来写入==字符==文件\n\n### 2.2. Object IO Stream\n\n- `transient` 关键字：在序列化时忽略（静态成员也会被忽略）。\n- 如果一个对象不止一次写入对象流，不会存储对象的多份副本。JVM 会将对象的内容和序号一起写入对象流。\n- 反序列化后的对象，不需要调用构造函数重新构造。\n- 序列前的对象与序列化后的对象是深复制。\n- 类需要显示地实现 `Serializable` 接口才能被序列化。（即使成员都可以序列化也需要这么做）\n- 如果数组中的所有元素都是可序列化的，这个数组就是可序列化的。\n- _24-25 秋冬期末考试还考察了子类/父类中只有一个实现了序列化接口在序列化/反序列化时的行为，读者可以自行查阅相关资料_。\n\n### 2.3. Piped IO Stream\n\n- PipedOutputStream 和 PipedInputStream 的作用是让多线程可以通过管道进行线程间的通讯。PipedReader 和 PipedWriter 和这两个的区别也类似：操作字符而不是字节。\n- 我们在线程 A 中向 PipedOutputStream 中写入数据，这些数据会自动的发送到与 PipedOutputStream 对应的 PipedInputStream 中，进而存储在 PipedInputStream 的缓冲中；此时，线程 B 通过读取 PipedInputStream 中的数据。就可以实现，线程 A 和线程 B 的通信。\n\n## 3. Ch16 Generics\n\n- 构造方法中不需要写泛型（如是 `Stack()` 而不是 `Stack<E>()`）\n- 泛型方法若编译器可以推断则可省略，否则用类似 `GenericMethodDemo.<Integer>print(integers)` 的语法。\n- **有界泛型类型(bounded generic type)**：`<E extends GeometricObject>` 表示 `E` 必须是 `GeometricObject` 或其子类。\n- 泛型类型之间没有继承关系\n  - 如 `Integer` 和 `Number` 有继承关系但是 `GenericStack<Integer>` 和 `GenericStack<Number>` 没有\n  - `List<Integer> list = new List<Object>();` 报错且==反之亦然==\n- 三种通配\n  - **unbound wildcard**：`<?>` 适用于任何类型\n  - **bound wildcard**：`<? extends T>` 类型参数必须是 T 或其子类。\n    - `List<? extends Number> list = new ArrayList<Integer>();`\n    - 不能添加 `Number` 或 `Integer` 或 `Double` 到 list 中\n  - **lower-bound wildcard**：`<? super T>` 表示类型参数必须是 T 或其父类。\n    - `List<? super Integer> list = new ArrayList<Number>();`\n    - 只能添加 `Integer` 或 `Integer` 的子类到 list 中\n- 泛型的限制\n  - 不能创建泛型类型的实例\n    - `new E()` 会 CE\n  - 不能创建泛型数组\n    - `new E[10]` 会 CE，应改为 `(E[]) new Object[10]`\n  - 泛型类的静态上下文中不能使用类型参数\n    - 泛型类的所有实例都==有相同的运行时类==，所以泛型类的静态变量和方法是被它的所有实例共享的。\n    - 在静态方法、数据域或初始化语句中，为了类而引用泛型参数是非法的。\n  - 泛型类不能继承 `Throwable`\n    - `class MyException<T> extends Exception {}` 会 CE\n    - 主要是为了 catch 的问题\n- `ArrayList<String>` 不是一个类，所以 `ArrayList<String> list1 = new ArrayList<String>();` 后调用 `list1 instanceof ArrayList<String>` 是错误的。\n\n## 4. Ch17 Java Collections Framework\n\n- Collection 接口关系图（==P22==）\n  - `Map` 是独立的接口，不继承自 `Collection`\n  - `ArrayList` 和 `LinkedList` 实现了 `List` 接口。\n  - `HashSet` 和 `TreeSet` 实现了 `Set` 接口。\n  - `HashMap` 和 `TreeMap` 实现了 `Map` 接口。\n- `addAll`、`removeAll`、`retainAll` 类似于集合的并、差、交。\n- Set\n  - `HashSet`\n    - 通过 `hashCode` 和 `equals` 方法保证元素唯一性。\n    - 集合元素可以是 null，但只能放入一个 null\n  - `LinkedHashSet`\n    - 额外使用双向链表维护元素的插入顺序（似乎访问也还会被提到最前，即遵循 LRU）。\n  - `TreeSet`\n    - `TreeSet` 是 `SortedSet` 接口的唯一实现类\n    - `SortedSet` 是 Set 的一个子接口。first()和 last()返回集合中的第一个和最后一个元素；headSet(toElement)和 tailSet(fromElement)返回集合中元素小于 toElement 和大于 fromElement 的那部分。\n    - NavigableSet 扩展了 SortedSet，提供导航方法 lower(e),floor(e), ceiling(e)和 higher(e)，分别返回小于、小于或等于、大于或等于、大于一个元素的元素，若没这样的元素，则返回 null。\n    - pollFirst()和 pollLast()则分别删除和返回 TreeSet 中的第一个和最后一个元素。\n- List\n  - ArrayList：基于动态数组。\n    - 支持随机访问，访问速度快。插入和删除操作效率低（特别是中间位置）。\n  - LinkedList：基于双向链表。\n    - 插入和删除速度快。查询效率较低。\n- Map：`HashMap`、`TreeMap`、`LinkedHashMap`。\n  - 对于 `HashMap` 和 `LinkedHashMap`，自定义对象作为 key 时需要重写 `hashcode()` 和 `equals()` 方法\n- ArrayList 中迭代器的陷阱\n  - 在迭代过程中，调用容器的删除方法，则会抛出异常\n  - 迭代器内部会维护索引位置相关的数据（包含最近返回的元素的索引和下一个返回的元素的索引），在迭代过程中，容器不能发生结构性变化\n- `List<String> a = new ArrayList<String>();` 和 `List<String> a = new ArrayList<>();` 都是合法的写法。\n- `Map`  不能直接使用  `Iterator`  遍历，但可以通过  `entrySet()`、`keySet()`  或  `values()`  方法间接获取可迭代的集合。\n  `for (Map.Entry<String, Integer> entry : map.entrySet()) { System.out.println(entry.getKey() + \": \" + entry.getValue()); }`\n\n## 5. Ch25 Multithreading\n\n- 创建线程\n  - 实现 `Runnable` 接口并将实例传递给 `Thread` 构造函数\n  - 继承 `Thread` 类：重写 `run()` 方法\n- 线程控制\n  - 使用 `run()` 启动在当前线程创建，使用 `start()` 启动在新线程创建\n  - `Thread.yield()`：让出当前线程的 CPU 时间片。\n  - `Thread.sleep(long millis)` 静态方法：当前线程休眠指定时间。\n  - `anotherThread.join()`：等待另一个线程结束。\n  - 中断\n    - InterruptedException：是 sleep 和 join 的必检异常，注意放在循环体中要手动 break。\n    - 线程的生命周期\n      - New（新建）：线程对象被创建，但未调用 `start()` 方法。\n      - Runnable（就绪）：调用 `start()` 方法后，线程处于可运行状态，但可能未获得 CPU 时间。\n      - Running（运行）：线程获得 CPU 时间，正在执行任务。\n      - Blocked（阻塞）：线程等待某些资源（如锁或 IO）。\n      - Terminated（终止）：线程执行完毕或被中断。\n    - `isAlive()`：用于检查线程是否处于活动状态（Ready、Blocked 或 Running）\n    - `interrupt()`：设置中断标志。对于受阻塞（`Object.wait()`、`Thread.join()`、`Thread.sleep()`）的线程，将其唤醒并抛出 InterruptedException；否则将暂时不起作用。\n    - `isInterrupted()`：检查线程的中断标志是否被设置。不会清除中断标志。\n  - 优先级控制\n    - `setPriority(int newPriority)`：设置线程的优先级。\n    - `Thread.MAX_PRIORITY` / `Thread.MIN_PRIORITY` / `Thread.NORM_PRIORITY`\n- **线程同步(thread synchronization)**\n  - 内存可见性问题：一个线程对共享变量的修改，可能不被另一个线程及时看到。因为每个线程都有自己的工作内存，而共享变量存储在主内存中。如果线程对共享变量的修改没有及时刷新到主内存就可能出现问题。\n  - `volatile` 关键词：保证变量的可见性。\n  - `synchronized` 关键词或 `synchronized` 块\n    - 成员方法加 `synchronized` 相当于对 `this` 上锁，静态方法加 `synchronized` 相当于对 `XXClass.class` 上锁。\n    - 功能\n      - 保证可见性：释放锁时，所有的写入都会写回内存，获得锁后，会从内存中读最新数据。\n      - 保证互斥性：同一时刻只有一个线程可以执行 synchronized 块中的代码。\n    - 可重入性：对同一个线程，它在获得锁之后，在调用其他需要同样锁的代码时，可以直接调用。\n- `wait()` & `notify()`\n  - 必须在 `synchronized` 方法或代码块中使用。\n  - ![|804](https://img.memset0.cn/2025/01/12/hixSD3p6.png)\n  - 用法\n    - `wait()`：当前线程等待，释放锁。\n    - `notify()`：唤醒一个等待线程。\n    - `notifyAll()`：唤醒所有等待线程。\n  - 机制\n    - 把当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为 WAITING 或 TIMED_WAITING。\n    - 等待时间到或被其他线程调用 notify/notifyAll 从条件队列中移除，这是，要重新竞争对象锁\n    - 如果能获得锁，线程变为 RUNNABLE，并从 wait 调用中返回\n    - 否则，线程加入对象锁等待队列，线程变为 BLOCKED，只有在获得锁后才会从 wait 调用中返回。\n\n## 6. Ch28 Lambda & Stream & RTTI\n\n- Lambda 表达式是一种特殊的匿名内部类。\n- 任何可以接受一个函数式接口（Functional Interface, FI）实例的地方，都可以使用 Lambda 表达式。\n- 函数式接口：只能有一个抽象方法。可以有多个静态方法和默认方法。接口中的方法默认是 `public abstract`。\n  - `java.util.function` 包中包含了多种函数式接口，例如：`Function`：接收参数并返回结果。`Predicate`：接收参数并返回布尔值。`Consumer`：接收参数但无返回值。`Supplier`：无参数但返回结果。\n- Stream 对象：实现了  `java.util.stream.Stream`  接口。\n  - 生成流：`stream()` 或 `parallelStream()` 或 `Stream.of(\"a1\", \"a2\", \"a3\")`\n  - 常用方法：\n    - filter：过滤满足条件的元素。\n    - map：映射为新值\n    - flatMap：映射成流并 flat 成一个\n    - distinct：去重（基于 `hashCode` 和 `equals`）\n    - sorted：排序\n    - limit(int n)：只保留前至多 $n$ 个\n    - skip(int n)：跳过前 $n$ 个\n  - 终端操作：\n    - `boolean allMatch(Predicate<? super T> predicate);` 检查是否匹配所有元素。\n    - `boolean anyMatch(Predicate<? super T> predicate);` 检查是否至少匹配一个元素。\n    - `boolean noneMatch(Predicate<? super T> predicate);` 检查是否没有匹配所有元素。\n    - `Optional<T> findFirst();` 返回当前流中的第一个元素。\n    - `Optional<T> findAny();` 返回当前流中的任意元素。\n    - `long count();` 返回流中元素总数。\n    - `Optional<T> max(Comparator<? super T> comparator);` 返回流中最大值。\n    - `Optional<T> min(Comparator<? super T> comparator);` 返回流中最小值。\n    - `T reduce(T identity, BinaryOperator<T> accumulator);` 可以将流中元素反复结合起来，得到一个值。返回 T。这是一个归约操作。\n    - `collect`：转化为其他形式，如 `.collect(Collectors.toSet())`、`toList()`\n- `IntStream` 与 `getAsInt()`\n- RTTI\n  - `object.getClass()` 或 `TheClass.class` 来获取类对象。\n  - `clazz.isInstance(obj)` 判断 `obj` 是不是当前类或当前类子类的实例\n  - `getSuperclass()`、`getInterfaces()`、`getModifiers()`\n  - Method 类\n    - invoke()\n    - instanceof 运算符\n","publishedTitle":"「Java 应用技术」III. Java 高级特性"}},{"id":"a205e15f-98e2-571b-b777-c4f3cf2eff3b","fields":{"slug":"/course/ads/note/1/","plainText":"\n> 本篇笔记概述了二叉搜索树的基本概念及其变种，包括 AVL 树、Splay 树、红黑树和 B+ 树。首先介绍了 AVL 树的定义、插入和删除操作，以及如何维护树的平衡。接着讨论了 Splay 树的旋转操作和均摊分析，随后介绍了红黑树的插入和删除策略，最后讲解了 B+ 树的结构特性及其分裂和插入过程。整体上，笔记提供了对这些数据结构的深入理解和操作方法。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n## 1. AVL Tree\n\n> [!info]- Fun Fact：AVL 树名字的由来\n>\n> Adelson-Velskii-Landis Trees 分别是论文的三位作者的名字。\n\n1. 空二叉树是一个 **AVL 树(AVL tree)**。\n2. 如果 T 是一棵 AVL 树，那么其左右子树也是 AVL 树，并且 $|h(ls) - h(rs)| \\le 1$，其中 $h(x)$ 是子树 $x$ 的高度。\n3. 树高为 $O(\\log n)$。\n\n**平衡因子(balance factor)**：右子树高度 $-$ 左子树高度。（按照定义，对于任意节点都有 $BF(\\text{node})=-1,0\\text{ or } 1$）\n\n> [!example]- 证明：树高为 $O(\\log n)$\n> 用 $f_n$ 表示树高为 $n$ 的 AVL 树最少有多少个节点。\n>\n> $$\n> f_n = \\left\\{\\begin{aligned}\n> &1\\quad&(n=1)\\\\\n> &2\\quad&(n=2)\\\\\n> &f_{n-1} + f_{n-2} + 1 \\quad&(n>2)\\\\\n> \\end{aligned}\\right.\n> $$\n>\n> 注意到 $f_n$ 的通项是类似于斐波那契数列的。同理树高为 $n$ 的 AVL 树最多的节点数 $g_n$ 也是指数级的，故 AVL 树的树高为 $\\Theta(\\log n)$。\n\n### 1.1. Insertion\n\n先与一般的二叉平衡树类似，先进行一次失败的查找，可以定位要插入的位置。插入的位置一定是一个叶子节点。之后自底向上检查有没有节点的平衡被破坏，如果有，其 $BF$ 值要么为 $-2$ 要么为 $2$。我们分类讨论进行调整。\n\n称平衡被破坏的节点为**失衡节点(trouble finder)**，导致平衡被破坏的节点（即刚插入的节点）为**肇事者(trouble maker)**，只需要对于 trouble finder & maker 之间的子树进行调整。\n\n在调整平衡时，我们只需要关注 trouble finder：\n\n- 是左子树偏重（$BF = -2$）还是右子树偏重（$BF = 2$）？\n- 是偏重的子树的左子树偏重还是偏重的子树的右子树偏重？\n\n这里以左子树偏重（$BF = -2$）为例，右子树偏重的情况是对称的。当左子树的左子树偏重（$\\text{height}[A]\\ge \\text{height}[C]$）时，需要执行**单旋(single rotation)**：\n\n![单旋（红色标注的是树高）|600](https://img.memset0.cn/2024/02/26/bT4d0Ls7.png)\n\n> [!hint] Hint：AVL 树的左旋和右旋\n> 重点关注蓝框框出的节点在旋转前后的变化（右旋的情况与左旋对称）。\n\n当左子树的右子树偏重时（$\\text{height}[A]< \\text{height}[C]$），需要执行**双旋(double rotation)**：\n\n![双旋|600](https://img.memset0.cn/2024/02/26/Yad7iBp1.png)\n\n> [!example]- Q：为什么双旋？\n> 观察需要被旋转的点（$D,B,C$），只通过一次旋转不能维护其中序遍历不变的性质。\n\n容易发现，只需要在离 trouble maker 最近的 trouble finder 处进行一次单旋或双旋即可，因为旋转后 trouble finder 处的树高与插入节点前相同，在它上面的节点的 BF 值应与插入节点前相同。\n\n维护平衡操作的伪代码如下：\n\n```plain\nMaintain-Balanced(p)\n    if h[ls[p]] - h[rs[p]] == 2\n        if h[ls[ls[p]]] >= h[rs[ls[p]]]\n            Right-Rotate(p)\n        else\n            Left-Rotate(ls[p])\n            Right-Rotate(p)\n    else if h[ls[p]] - h[rs[p]] == -2\n        if h[ls[rs[p]]] <= h[rs[rs[p]]]\n            Left-Rotate(p)\n        else\n            Right-Rotate(rs[p])\n            Left-Rotate(p)\n```\n\n### 1.2. Deletion\n\n先定位要删除的节点，如果是叶子则直接删除，否则找到其前驱（左子树中最右的节点）或后继（右子树中最左的节点）将其替换。这样可以保证每次删除操作实际删掉的点一定是叶子。\n\n删除节点后也要应用调整操作，维护平衡的方法类似插入操作。\n\n> [!quote] Useful Links\n>\n> - [Lecture 1 | AVL Trees & Splay Trees - Isshiki 修's Notebook (isshikih.top)](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/Lec01/)\n> - [AVL 树 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/ds/avl/)\n\n## 2. Splay Tree\n\n**生长树(Splay Tree)** 单次操作的**均摊成本(averaged cost)** 为 $O(\\log n)$，但最坏情况下单次是 $O(n)$ 的。\n\n### 2.1. Rotate\n\nSplay 树的核心思想是每次将被访问的节点旋转到根，称为 Splay 操作。如果还是用前面的旋转方式，复杂度是可能被卡到 $O(n^2)$ 的：\n\n![qXVDgA80.png|487](https://img.memset0.cn/2024/02/26/qXVDgA80.png)\n\n这里需要引入 Splay 的旋转方式：设当前节点 $X$ 的父节点为 $P$，父节点的父节点为 $G$ 都存在。定义对 $X$ 的旋转操作 $Rotate(X)$ 为将 $X$ 旋转到 $P$ 的位置，即 $X$ 的父亲将变为 $G$，且维持平衡树的中序遍历不变。当 $X$ 是 $P$ 的左孩子时定义这样的旋转为右旋，当 $X$ 是 $P$ 的右孩子时定义这样的旋转为左旋。\n\n（注意这里的 $Rotate$ 函数的参数和上文 AVL 树中的说法并不一样，即 $Rotate(X)$ 对应着 $LeftRotate(P)$ 或 $RightRotate(P)$，至于到底是哪个取决于 $X$ 和 $P$ 的位置关系。相当于一个说的时转上来，另一个说的是转下去，所以还需要讨论是从左边还是右边下去）\n\n![（这里红色节点代表 X，黄色节点代表 P）|575](https://img.memset0.cn/2024/02/26/gn7NSlBu.png)\n\n可以通过精巧的实现让代码自行决定左旋还是右旋，下文我们也直接用 $Rotate$ 操作来表示（自动决定的）左旋或右旋。\n\n接下来：讨论 $X,P,G$ 是否在同一直线上。若在，则应用 Zig-Zig 操作，旋转 $Rotate(P),\\,Rotate(X)$（虽然旋转的不是同一个点，但是两次旋转的方向相同）：\n\n![Zig-Zig|390](https://img.memset0.cn/2024/02/26/5hObMV2e.png)\n\n若不在，则应用 Zig-Zag 操作，旋转 $Rotate(X),\\,Rotate(X)$（虽然都是旋转同一个点，但是两次旋转的方向不同）：\n\n![Zig-Zag|400](https://img.memset0.cn/2024/02/26/E1wvUUKl.png)\n\n这样子 Splay 树的复杂度将会得到保证，具体证明参见下面的**均摊分析(amortized analysis)** 环节。\n\n### 2.2. Amortized Analysis\n\n**均摊分析(amortized analysis)** 分为三种：\n\n- **聚合分析(aggregate analysis)**：总时间复杂度为 $T(n)$，则单次操作的均摊复杂度为 $T(n)/n$。\n- **核算法(accounting method)**：每消耗 $1$ 的时间进行操作，就为之后的操作累计 $1$ 的信用。操作要么消耗时间要么消耗信用。\n- **势能法(potential method)**：利用势能函数进行分析。\n\n> [!important] 均摊分析之势能法\n>\n> 定义 $c_i$ 表示第 $i$ 次操作的实际成本，$\\hat{c_i}$ 表示第 $i$ 次操作后的均摊成本。$D_i$ 表示第 $i$ 次操作后的数据结构，$\\Phi(D_i)$ 表示第 $i$ 次操作后的势能函数。我们有：\n>\n> $$\n> \\hat{c_i} - c_i = Credit_i = \\Phi(D_i) - \\Phi(D_{i-1})\n> $$\n>\n> $$\n> \\begin{aligned}\n> \\sum_{i=1}^n \\hat{c_i} &= \\sum_{i=1}^n \\left(c_i + \\Phi(D_i) - \\Phi(D_{i-1})\\right)\\\\\n> &= \\left(\\sum_{i=1}^n c_i\\right) + \\Phi(D_n) - \\Phi(D_0)\n> \\end{aligned}\n> $$\n>\n> 只需要对于所有 $n$ 都满足 $\\Phi(D_n)-\\Phi(D_0)\\ge 0$，就可以用均摊成本来确定实际成本的上限。一个好的势能函数的实现应该有 $\\Phi(D_0)=0$，这样只需 $\\Phi(D_n)\\ge 0 = \\Phi(D_0)$。\n\n现在问题的关键在于确定势能函数。如果简单的将节点高度和定义为势能函数，虽然量级正确了，但是在 Splay 的过程中有许多节点的高度会发生变化，且数量不确定，这样定义的势能函数很难分析。\n\n一个可用的势能函数是树中所有节点的 $\\text{rank}$ 之和，我们用 $R(i)$ 表示节点 $i$ 的 $\\text{rank}$，有\n\n$$\nR(i) = \\log S(i)\n$$\n\nTBD\n\n## 3. Red Black Tree\n\n![npUGjy8F.png|557](https://img.memset0.cn/2024/03/04/npUGjy8F.png)\n\n- 每条从叶子到根的路径中黑节点数 $\\geq$ 红节点数。\n- 每个叶子结点的左右指针都指向 NIL，定义 NIL 都是黑节点。——补上 NIL 后，整棵树中的黑节点数 $\\geq$ 红节点数。\n\n作出以下定义：\n\n- The **black-height** of any node $x$, denoted by $bh(x)$：从节点 $x$ 到任意叶子的最短路径上的黑点数量。\n\n### 3.1. Insertion\n\n> 这里介绍 bottom-up 的插入方法。红黑树是存在 top-down 的插入方式的，但这里不展开。\n\n- **Step 1**：先通过一次失败的查找确定要插入的位置（NIL 节点），将其替换为新节点并染成红色。由于新节点自带两个黑色的 NIL 结点，所以树的 black-height 不变，但可能出现连续的红节点。\n\n- **Step 2**：自底向上处理连续的红节点的问题，分以下三种情况讨论：\n  ![yKhJJP8i.png|280](https://img.memset0.cn/2024/03/04/yKhJJP8i.png)\n\n### 3.2. Deletion\n\n- 兄红转兄黑。父兄换色兄旋升。（case 1）\n- 兄黑远黑近侄红，侄兄换色侄旋升。（case 3）\n- 兄黑远红化其黑，父兄换色兄旋升。（case 4）\n- 兄侄全黑则兄红，黑父不当则上传。（case 2）\n\n![0ut1PH2M.png|549](https://img.memset0.cn/2024/06/24/0ut1PH2M.png)\n\n![IjiC44te.png|544](https://img.memset0.cn/2024/06/24/IjiC44te.png)\n\n## 4. B+ Tree\n\n**定义**：A B+ tree of order $M$ is a tree with the following structural properties:\n\n- (1) The root is either a leaf or has between $2$ and $M$ children.\n- (2) All non-leaf nodes (except the root) have between $\\lceil M/2 \\rceil$ and $M$ children.\n- (3) All leaves are at the same depth.\n\n可以注意到：\n\n1. B+ 树的所有数据都存储在叶子节点，非叶节点只存储索引信息。\n2. 每一个非叶节点上最多存储 $M-1$ 个索引，每一个叶子节点上最多存储 $M$ 个数据。\n3. 对于非叶节点的第 $i$ 个索引，其值等于其第 $i+1$ 个子树的叶子节点最小值。（根据这一性质可以进行查找）\n\n![B+ 树示意图|467](https://img.memset0.cn/2024/03/06/tbIAaCu7.png)\n\n### 4.1. Split\n\nB+ 树的核心在于其分裂操作。可以把 $M$ 的限制看做对连出去的边数的限制，叶子节点相当于是连出去至多 $M$ 条节点—数据的边，这样可以把非叶节点和叶子节点的情况统一看待。\n\n当某个节点已经连出去 $M$ 条边，需要塞第 $M+1$ 条边的时候，需要分裂。分裂会产生一个和原节点同级的节点，就在原节点的右侧。原节点的前 $\\lceil(M+1)/2\\rceil$ 个孩子还属于自己，剩下的 $\\lfloor(M+1)/2\\rfloor$ 个孩子需要交给新创建的节点。\n\n如果分裂的过程中，导致父节点也超出了 $M$ 的限制，就需要对父节点也进行分裂，以此类推。如果父节点已经是根节点，就创建一个新根再进行分裂，此时树高会增加 $1$，其他情况下树高不会改变。\n\n### 4.2. Insertion\n\n先进行一次查找确定需要插入的节点并执行挂在那个叶子节点上，接下来进行 bottom-up 的维护即可。\n\n![课件中给出的伪代码|464](https://img.memset0.cn/2024/03/06/TDgpEcGD.png)\n\n### 4.3. Complexity Analysis\n\n一般来说我们取 $M=3$（2-3 树）或 $M=4$（2-3-4 树）。当 $M$ 不是常数级别时，需要用二分查找对插入过程进行优化。\n\nTBD：复杂度分析\n","publishedTitle":"「高级数据结构与算法分析」第一部分：二叉搜索树"}},{"id":"e2ba34d8-1e0a-5f3a-b4d8-f9b2e5cc6d11","fields":{"slug":"/course/ads/note/2/","plainText":"\n> 本篇笔记主要介绍了可并堆的概念及其相关操作，包括左倾堆、斜堆和二项堆的定义、操作及复杂度分析。左倾堆通过空路径长度来定义节点的结构，斜堆则通过自适应的方式进行合并，而二项堆则是由多个堆有序树组成的森林。每种堆的合并、插入和删除操作都有其独特的实现方式和复杂度分析。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n## 1. Leftist Heap\n\n**空路径长度(null path length)**：$Npl(X)$ 定义为从节点 $X$ 任意没有两个孩子的子节点的最短距离。特别地，定义 $Npl(\\text{NULL})=-1$，对于叶子节点或只有一个孩子的子节点，其 $Npl$ 显然为 $0$。显然有：\n\n$$\nNpl(X)= 1+\\min\\{Npl(C) \\mid C \\text{ is a child of } X\\}\n$$\n\n**左倾堆(leftist heap)**：对于左倾堆的每个节点，其左节点的 $Npl$ 值大于等于右节点的 $Npl$ 值。\n\n### 1.1. Operations\n\n#### 1.1.1. Merge\n\n递归合并，每次插入到右侧。插入后如果右子树的 $Npl$ 更大则交换左右子树。\n\n也有一种不“交换”左右孩子的方法，定义一个 $rc$ 函数每次根据左右孩子的 $Npl$ 返回 $Npl$ 较小的店作为右节点即可。\n\n#### 1.1.2. Insert\n\n看做与一个单节点的子树合并。\n\n#### 1.1.3. DeleteMin\n\n删去根，合并根节点的两个子树。\n\n### 1.2. Complexity Analysis\n\nTBD\n\n## 2. Skew Heap\n\n**斜堆(Skew Heap)**，也叫做**自适应堆(self-adjusting heap)** 是另一种可并堆，它不需要记录任意一个节点的距离，只是在合并操作上有所改变。\n\n### 2.1. Operations\n\n#### 2.1.1. Merge (Recursive)\n\n- 比较两个堆；设 $p$ 是具有更小的 $root$ 的键值的堆，$q$ 是另一个堆，$r$ 是合并后的结果堆。\n- 根据堆性质，选 $p$ 的根节点作为 $r$ 的根节点。\n- 令 $r$ 的右子树为 $p$ 的左子树。\n- 令 $r$ 的左子树为 $p$ 的右子树与 $q$ 合并的结果。\n\n![5AvjjzEn.png|439](https://img.memset0.cn/2024/03/18/5AvjjzEn.png)\n\n#### 2.1.2. Merge (Non-recursive)\n\n- 把每个堆的每棵（递归意义下）最右子树切下来。这使得得到的每棵树的右子树均为空。\n- 按 $root$ 的键值的升序排列这些树。\n- 迭代合并具有最大 $root$ 键值的两棵树：\n  - 具有次大 $root$ 键值的树的右子树必定为空。把其左子树与右子树交换。现在该树的左子树为空。\n  - 具有最大 $root$ 键值的树作为具有次大 $root$ 键值树的左子树。\n\n![llycHoJp.png|327](https://img.memset0.cn/2024/03/18/llycHoJp.png)\n\n### 2.2. Complexity Analysis\n\n**重节点(heavy node)**：称一个节点 $p$ 是 heavy 的，当且仅当它右子树的节点数大于等于左子树的节点数。\n\n进行均摊分析，定义势能函数\n\n$$\n\\Phi(D_i) = \\text{the number of heavy nodes}\n$$\n\n考虑第 $i$ 次合并过程，它们**右路径上的**轻重节点个数分别为 $l_p,\\ h_p$ 和 $l_q,\\ h_q$。则一次合并的实际代价为\n\n$$\nc_i = l_p+ l_q+h_p+h_q\n$$\n\n另外注意到，一次操作后，重节点一定变成轻节点，但是轻节点不一定变成重节点。这是因为\n\n- 对于一个重节点，原先较大的右子树交换到右侧且会与另一棵树合并，从而变得更大，故重节点合并后一定变成轻节点。\n- 对于一个轻节点，虽然较重的子树被换到右侧，但是由于左子树和另一个树合并可能变得更大，故合并后有可能是轻节点也有可能是重节点。\n\n故势能增加量\n\n$$\n\\Phi(D_{i+1}) - \\Phi(D_i) \\leq l_p+l_q-h_p-h_q = O(\\log N)\n$$\n\n而右路径上的轻节点的数是 $O(\\log n)$ 级别的，所以总复杂度为 $O(n\\log n)$。\n\n## 3. Binomial Queue\n\n**二项堆(binomial queue)**：A binomial queue is not a heap-ordered tree, but rather a collection of heap-ordered trees, known as a forest. Each heap-ordered tree is a binomial tree.\n\n**二项树(binomial tree)**：A binomial tree of height $0$ is a one-node tree. A binomial tree, $B_k$, of height $k$ is formed by attaching a binomial tree, $B_{k-1}$, to the root of another binomial tree, $B_{k-1}$.\n\n![|500](https://img.memset0.cn/2024/03/25/kWPGWSjF.png)\n\n> [!important] Observation\n>\n> $B_k$ consists of a root with $k$ children, which are $B_0,B_1,\\ldots B_{k-1}$. $B_k$ has exactly nodes. The number of nodes at depth $d$ is $\\displaystyle\\binom{k}{d}$.\n\n注意到二项树有以下重要性质：\n\n- 二项树 $B_k$ 的总结点数是 $2^k$，这意味着我们想要构建一颗大小为 $n$ 的二项堆时，可以对 $n$ 进行二进制拆分。\n- 二项树的合并是简单的，可以通过两个 $B_{k-1}$ 通过 $O(1)$ 的复杂度直接得到 $B_k$，并且维持堆性质不变。\n\n### 3.1. Operations\n\n#### 3.1.1. FindMin\n\n枚举 binomal queue 中的每个堆，取他们的根节点的最小值。由于 binomal queue 中的堆的数量是 $O(\\log n)$ 的，故这一操作的复杂度为 $O(\\log n)$。\n\n#### 3.1.2. Merge / Insert\n\n可以类比二进制数的竖式加法，来确定需要按照什么样的顺序将哪些 binomal trees 合并，这里别忘了要考虑**进位**。\n\n![|600](https://img.memset0.cn/2024/03/25/Me4cgHFD.png)\n\n#### 3.1.3. DeleteMin\n\n找到根节点值最小的 binomal tree，设为 $B_{k-1}$ 将其根节点删除，其孩子应分别为 $B_0,B_1,\\cdots,B_{k-1}$，将这些孩子视为另一个 binomal queue，和原 binonal queue 删除 $B_k$ 后的结果合并，应用上面的 Merge 算法即可。\n\n### 3.2. Implementation\n\n实现时为了方便快速实现孩子的**顺序遍历**，在存储孩子时可以考虑使用**链表**的方式，或者说，使用**左儿子右兄弟(left-child , right-sibling)** 的连接方式。\n\n另一方面，我们的链表最好按照 $B_{k-1},B_{k-2},\\cdots,B_0$ 的方法存储这些数，这样在合并的时候不用遍历孩子链表也能维持左儿子有兄弟的结构，具体自己画个图就知道了。\n\n![|550](https://img.memset0.cn/2024/03/25/UHW79OoD.png)\n\n### 3.3. Complexity Analysis\n\n> [!note] Claim\n>\n> A binomial queue of $n$ can be built by $n$ **successive(连续)** insertions in $O(n)$ time.\n\n可以用均摊分析证明，具体证明过程略。\n\n$$\n\\begin{aligned}\nc_i &::= \\text{cost of the }i\\text{th insertion.}\\\\\n\\Phi_i &::= \\text{number of trees after the }i\\text{th insertion } (\\Phi_0=0)\n\\end{aligned}\n$$\n","publishedTitle":"「高级数据结构与算法分析」第二部分：可并堆"}},{"id":"37a52659-ec66-5012-b0ee-cf31b51ccf76","fields":{"slug":"/course/ads/note/3/","plainText":"\n> 本篇笔记概述了经典算法的多种类型，包括倒排索引、回溯算法、分治法、动态规划、贪心算法、近似算法、局部搜索、随机化算法、并行算法以及外部排序。每种算法都配有具体的例子和复杂度分析，帮助读者理解其应用场景和实现方式。通过这些内容，读者可以掌握算法设计的基本思想和技巧，为解决实际问题提供理论基础和实践指导。<small style=\"font-style: italic; opacity: 0.5\">（由 gpt-4o-mini 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 倒排索引 Inverted File Index\n\n### 1.1. Optimize a Search Engine\n\n读取时的处理：\n\n- word stemming\n- stop words\n\n**阈值(thresholding)**：\n\n- document: 只检索前面 $x$ 个按权重排序的文档\n- query：把带查询的 terms 按照出现的频率升序排序\n\n搜索引擎的**相关性度量(relevance measurement)**：\n\n- **准确率(precision)**：指检索出相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率 $P_R=R_R/(R_R+I_R)$。\n- **召回率(recall)**：指检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率 $R_R=R_R/(R_R+R_N)$。\n\n![6dDuxn44.png|302](https://img.memset0.cn/2024/06/22/6dDuxn44.png)\n\n## 2. 回溯 Backtracing\n\n- 解空间约束\n\n求解问题的一个可靠方法是找出所有可能得情况，逐一检查，找到正确答案。**回溯(backtracing)** 算法利用了**剪枝(pruning)** ，可以减少对大量已知不可能的情况的显示检查。\n\n- 尽量选择从少到多的搜索方式，这样在剪枝的时候可以一次性剪掉更多的情况数。\n\n### 2.1. Minimax Search & α-β Pruning\n\n定义 goodness 函数为 $f(P) = W_\\text{Computer} - W_\\text{Human}$，则 Human 想要最小化 $f(P)$ 而 Computer 想要最大化 $f(P)$。\n\n$\\alpha-\\beta$ 剪枝的核心思想：根据当前局面可以推定不会影响上层节点结果的就可以进行剪枝。\n\n> [!example] 习题\n>\n> Given the following game tree, which node in the right subtree is the first node to be pruned with α-β pruning algorithm?\n>\n> ![|400](https://img.memset0.cn/2024/04/22/qHOiJ06o.png)\n>\n> > [!quote]- 答案\n> > D。可以分析而知：无论节点 $d$ 的值是多少，都不会影响到根节点 $68$ 的值，故可以进行剪枝。\n> >\n> > 另外左子树中可以减掉的节点是 $38$。\n\n### 2.2. Examples\n\n> [!summary] Eight Queens\n>\n> （八皇后问题）在棋盘中找到八个位置放置皇后，使得它们都不同行且不同列，也不能同时位于对角线上。\n\n在游戏树上进行 DFS 搜索。\n\n> [!summary] Turnpike Reconstruction Problem\n>\n> 在一条直线上找到 $n$ 个地方建立加油站，已知它们两两之间的距离（共 $\\dfrac{n(n-1)}{2}$ 对），求出所有加油站的位置，假定第一个加油站的坐标是 $0$。\n\n就是暴搜。在 DFS 过程中维护未分配的距离集合，还有当前的处理区间，每次从距离集合中找到最大的距离 $D$，看新的加油站应当放在 $x_1+D$ 的位置还是 $x_n-D$ 的位置即可。\n\n> [!summary] Stick Problem\n>\n> 给一个从若干根长度为 $L$ 的大棍子里切出来的小棍子长度集合，求最小的可能的 $L$。\n\n从小到大枚举 $L$ 然后将原来通过回溯法进行搜索。\n\n> [!summary] Tic-tac-toe Game (play with computer)\n>\n> 经典井字棋小游戏。\n\n这里定义 $W_\\text{Player}$ 为 Player 能够赢得胜利的可能数（如果把剩下所有各自都填上你的棋子，可以有多少个三连），可以一定程度上表征局面对于自己的优劣情况。定义 goodness 函数 $f(P)=W_\\text{AI}-W_\\text{Player}$，使用 Minimax 搜索交替进行选手——计算机的对弈，需要使用 $\\alpha-\\beta$ 剪枝。\n\n## 3. 分治 Divide & Conquer\n\n- **分治(divide conquer)**\n\n### 3.1. Complexity Analysis\n\n分析分治算法的复杂度有三种常用的方法：\n\n- **代换法(substitution method)**：先猜对答案，然后使用数归证明。\n- **递归树法(recursion-tree method)**：写成多叉线段树的形式，每一层分别计算，最后加起来。\n- **主方法(master method)**：用主定理解决。\n\n### 3.2. Master Theorems\n\n> [!important] **主定理(master theorems)**\n>\n> ![](https://img.memset0.cn/2024/04/22/ggv99pe2.png)\n>\n> ![](https://img.memset0.cn/2024/04/22/YLitclF0.png)\n\n> [!example] 习题\n>\n> For each of the following recurrences, choose the one that we cannot apply the Master Theorems to solve.\n>\n> A. $T(n) = 3 T(n/3) +n / \\lg n$\n>\n> B. $T(n) = 4 T(n/2) +n / \\lg n$\n>\n> C. $T(n) = 4 T(n/2) +n^2 / \\lg n$\n>\n> D. $T(n) = 3 T(n/4) +n \\lg n$\n>\n> > [!quote]- 答案\n> > AC？然而 pta 上的答案是 A。\n\n### 3.3. Examples\n\n> [!summary] Closest Point Problem\n>\n> 给平面上 $n$ 个点，求解最近点对。\n\n## 4. 动态规划 Dynamic Programming\n\n- **背包问题(the knapsack problem)**\n\n### 4.1. Examples\n\n> [!summary] Fibonacci Numbers\n>\n> $a_n=a_{n-1}+a_{n-2}$，求解 $a_n$。\n\n两种实现：启发式搜索或者直接序列 DP，都是用一张表来存 $a_n$。\n\n> [!summary] Ordering Matrix Multiplications\n>\n> 安排 $n$ 个矩阵的乘法的计算顺序，最小化计算量。（第 $i$ 个矩阵 $M_i$ 的大小是 $r_{i-1}\\times r_i$）\n\n区间 DP，$f[i][j]=f[i][k]+f[k+1][j]+r[i-1]\\times r[k]\\times r[j]$。\n\n> [!summary] Optimal Binary Search Tree\n>\n> 给 $n$ 个词的搜索频率，应如何构建 BST 以最小化 access 期望代价？相比于 Haffman 编码问题，我们确定了中序遍历，且内部节点上也能有键值。\n>\n> ![sHVVVUcH.png|600](https://img.memset0.cn/2024/04/15/sHVVVUcH.png)\n\n从**最优子结构**转移：最优方案的两棵子树一定是最优方案。定义 $w_{i,j}  =\\sum_{k=i}^j p_k$，$c_{i,j}$ 表示给区间 $[i,j]$ 节点建树的最小花费，则有转移：\n\n$$\nc_{i,j}\n= \\min\\limits_{i\\le k\\le j} \\{p_k + w_{i,k-1} + c_{i,k-1} + w_{k+1,j} + c_{k+1,j} \\}\n= w_{i,j} + \\min \\{c_{i,k-1}+c_{k+1,j}\\}\n$$\n\n> [!summary] All-Pairs Shortest Path\n>\n> 求任意两点间最短路径。\n\n我看了看怎么感觉就是 Floyd 啊？\n\n> [!summary] Product Assembly\n>\n> 有 $n$ 步的工序，可以在两条生产线之间切换，消耗的时间和本次及上千次在哪条生产线完成有关，求最优生产流程。\n>\n> ![|400](https://img.memset0.cn/2024/06/22/sQMmQMdC.png)\n\n我看了看怎么感觉就是直接 DP 啊？\n\n## 5. 贪心 Greedy\n\n### 5.1. Examples\n\n> [!summary] Activity Selection Problem\n>\n> ![ZfAxMf1F.png|620](https://img.memset0.cn/2024/06/14/ZfAxMf1F.png)\n\nDP 做法：设 $dp_{i}$ 表示前 $i$ 个单位时间里最多选几个，找到所有 $f_t-1=i$ 的活动，从 $dp_{s_t - 1} + 1$ 转移。时间复杂度 $O(n^2)$，不够优秀。\n\n贪心做法：把所有区间按照右端点排序，每次取右端点最小的，即选择尽早结束的活动（反过来也可，即选择最迟开始的活动），然后把有重合的都删掉，如此循环直到结束。时间复杂度 $O(n\\log n)$。\n\n> [!summary] Huffman Codes\n>\n> 哈夫曼编码问题。\n\n建 Huffman 树的过程正体现了贪心思想。\n\n## 6. 近似 Approximation\n\n### 6.1. Approximation Ratio\n\n设 $C$ 为我们算法的 cost，$C^\\ast$ 为最优解的 cost，定义**近似率(approximation ratio)** 为：\n\n$$\n\\max\\left(\\dfrac{C}{C^\\ast},\\dfrac{C^\\ast}{C}\\right) \\le \\rho(n)\n$$\n\n- 称这样的算法为 $\\rho(n)$-approximation algorithm\n- approximation scheme: 近似率 $\\rho(n)=1+\\epsilon$ 的算法，即 $(1+\\epsilon)$-approximation algorithm\n- `PTAS`：polynomial-time approximation scheme 关于 $n$ 成多项式复杂度的算法 (设 $\\epsilon$ 为常数)\n- `FPTAS`：fully polynomial-time approximation scheme 关于 $n$ 和 $\\epsilon$ 都成多项式复杂度的\n  算法\n\n### 6.2. On-line & Off-line Algorithms\n\n在读入数据的时候进行决策，一旦决策之后不能修改。\n\n### 6.3. Examples\n\n> [!summary] Approximate Bin Packing\n>\n> Given $N$ items of sizes $S_{1},S_{2},\\cdots,S_{N}$, such that $0<S_i\\leq1$ for all $1\\leq i\\leq N$. Pack these items in the fewest number of bins, each of which has unit capacity.\n>\n> ——这一问题是 NP-Hard 的。\n\nNext Fit 做法：依次读入每个物品，看看是否能和前一个物品放在同一个 bin，如果不行的话就开一个新 bin。\n\n> [!quote]- 证明：设最优解为 $M$，则用 Next Fit 做法得到的解不超过 $2M-1$。\n>\n> 设用 Next Fit 做法生成的解为 $2M$（或 $2M+1$），那么有 $S_{2i-1}+S_{2i} > 1 \\space (1\\le i\\le M)$，故 $\\sum_{i=1}^{2M} S_i > M$，故至少需要 $M+1$ 个 bin。\n\nFirst Fit 做法：依次读入每个物品，扫描所有已有的箱子，找到第一个能放下的放，如果不存在则新开一个箱子放。设最优解为 $M$，则得到的解不超过 $1.7M$。\n\nBest Fit 做法：依次读入每个物品，在可以放下这一物品的箱子中选剩余空间最小的，如果不存在则新开一个箱子放。设最优解为 $M$，则得到的解不超过 $1.7M$。\n\n这里的 Next Fit、First Fit 和 Best Fit 做法都是在线做法，如果允许离线，则可将所有物品按照体积从大到小排序，然后应用 First Fit（或 Best Fit）做法。设最优解为 $M$，则得到的解不超过 $\\dfrac{11 M+6}{9}$。\n\n> [!summary] The Knapsack Problem (0-1 Version)\n>\n> 就是 0-1 背包问题。\n\n- 用 DP 解决的复杂度是指数级的，因为物品大小和 $n$ 不同阶，实际上 Knapsack 问题是 **NP-Hard 问题**，Knapsack 的判定是 NPC 问题。\n- 如果将物品的大小缩放到 $poly(n)$ 的范围，则有多项式复杂度的 DP，但算法也变成了近似算法。\n\n如果使用贪心做法，每次选（可选的）里价值最高或性价比最高的（两种做法分别做一次），可以证明近似比为 $2$。\n\n> [!quote]- 证明：贪心做法的近似比为 $2$。\n>\n> 这里 $P_\\text{Greedy}$ 是两种贪心做法得到结果的 max。\n>\n> ![|550](https://img.memset0.cn/2024/06/14/zGqxpFu0.png)\n>\n> ![|700](https://img.memset0.cn/2024/06/23/f7vNK3he.png)\n\n> [!summary] The K-center Problem\n>\n> 平面上给定 $n$ 个点，确定 $K$ 个圆心的位置覆盖所有点并使最大圆的半径最小。\n>\n> ![|400](https://img.memset0.cn/2024/06/14/w3TDaglB.png)\n\n> [!quote] 定理：除非 $\\text{P}=\\text{NP}$，否则不存在 $\\text{ratio}<2$ 的解法。\n>\n> 若 K-center 存在 $(2-\\epsilon)$-approximation，则可用于精确求解 Dominating Set 问题，而后者是一个 NPC 问题。\n\n## 7. 局部搜索 Local Search\n\n- $S \\sim S'$：$S'$ 是 $S$ 的一个**相邻解(neighboring solution)**，只需要对 $S$ 进行一个微小的修改就可以得到。\n- $N(S)$：$S$ 的**邻域(nerghborhood)**，即 $\\{S'\\mid S\\sim S'\\}$。\n- 称 $S^\\ast$ 是 $S$ 的 local optimum，即 $S^\\ast\\in N(S)$ 且是其中最优的。\n\n### 7.1. Gradient Descent\n\n爬山——梯度下降法：每次在邻域中选一个**最优的**转移，如果找不到则退出。\n\n容易陷入==局部最优解==中。\n\n### 7.2. The Metropolis Algorithm\n\n模拟退火——Metropolis 算法：每次在邻域中随机选一个转移，如果比当前情况更有则以一定概率 $-e^{\\dfrac{\\Delta cost}{k T}}$ 接收，否则概率接收且这一概率随迭代次数指数下降。\n\n### 7.3. Examples\n\n> [!summary] Vertex Cover Problem\n>\n> 最小点覆盖问题。\n\n直接使用爬山问题容易陷在 e 局部最优解，建议使用模拟退火算法。\n\n> [!summary] Hopfield Neural Network\n>\n> 给定 $G=(V,E)$ 其中边权有正负，给每个节点分配一个 $s_u\\in\\{-1,1\\}$，称一个点是 state assignment 当且仅当\n>\n> ![|600](https://img.memset0.cn/2024/06/15/fReDCwxW.png)\n>\n> ![|474](https://img.memset0.cn/2024/06/15/hWEqLUNB.png)\n\nstate-flipping 算法：每次反转一个不稳定的节点作为转移。\n\n> [!quote]- 证明：State-flipping 算法一定能达到一个稳定状态，且最多反转 $W = \\sum_e |w_e|$ 次。\n>\n> ![|500](https://img.memset0.cn/2024/06/15/zRE5pyxX.png)\n\n> [!summary] Maximal Cut Problem\n>\n> 最大割问题。把点集划分为两部分 $A,B$，最大化 $w(A,B) = \\sum_{u\\in A, v\\in B} w_{u,v}$。\n\n采用类似于上一问的转移，即翻转一个点的状态。若进行爬山算法，可以得到一局部最优解 $A,B$。设最优解为 $A^\\ast,B^\\ast$。\n\n> [!quote]- 证明：$w(A,B) \\ge \\dfrac{1}{2} w(A^\\ast, B^\\ast)$。\n>\n> ![|500](https://img.memset0.cn/2024/06/15/V5n2aolc.png)\n\nbig-improvement-flip 算法：当新的局部最优解的增长的幅度小于 $\\dfrac{2\\varepsilon}{|v|} w(A,B)$ 的时候就停止，这样算法可以在一定近似比的代价下保证在多项式复杂度内结束。\n\n> [!important] 定理\n>\n> 这样就有 $(2+\\varepsilon) w(A,B) \\ge w(A^\\ast, B^\\ast)$，可以在最多 $O\\left(\\dfrac{n}{\\varepsilon} \\log W\\right)$ 次翻转后结束。\n\n## 8. 随机化 Randomize\n\n有两种随机算法：\n\n- 有非常高的概率给出正确答案。efficient randomized algorithms that only need to yield the correct answer with high probability\n- 总是正确的，并在期望中运行的很有效率。 randomized algorithms that are always correct, and run efficiently in expectation\n\n### 8.1. Random Shuffle\n\n给每个元素分配一个随机的 key：`a[i].key = rng() % (n * n * n)`，然后根据 key 进行排序。根据生日碰撞，这里取 $N^3$ 作为模数就能有一个不错的效果。\n\n### 8.2. Examples\n\n> [!summary] The Hiring Problem\n>\n> - Hire an office assistant from headhunter.\n> - Interview a different applicant per day for $N$ days.\n> - Interviewing Cost = $C_{i} \\ll$ Hiring Cost $=C_{h}$\n> - Analyze interview & hiring cost instead of running time\n> - Assume $M$ people are hired. Total Cost: $O(N C_{i} + M C_{h})$.\n>\n> 总花费 = 面试次数 $\\times$ 每次面试的花费 $+$ 雇佣人数 $\\times$ 雇佣费用。\n\n一种简单的做法：看到比先前更好的人就雇佣，但是在面试者按照优秀程度递增顺序进来的时候就会爆炸。不妨进行随机排序，则期望花费为 $O(C_h \\ln N + N C_i)$。\n\n> [!summary] Online Hiring Problem - Hire at Once\n>\n> 将前面的问题改为在线，但只能雇佣一次。\n\n一种较高概率成功的解：先面试前 $k$ 个人但一定不从中雇佣，然后依次面试第 $k+1\\cdots N$ 个人，其中第一个满足比前 $k$ 个人优秀即 $A_j = \\max_{i=1}^k A_i$ 的人进行雇佣。可以证明取 $k = \\dfrac{N}{e}$ 时最优。\n\n> [!quote]- 证明：最优解 $k = \\dfrac{N}{e}$。\n>\n> 根据微积分的知识我们有：\n>\n> $$\n> \\ln N-\\ln k = \\int_k^N \\dfrac{1}{x}\\text dx \\le \\sum_{i=k}^{N-1} \\dfrac{1}{i} \\le \\int_{k-1}^{N-1} \\dfrac{1}{i}  \\text dx = \\ln (N-1) - \\ln(k-1)\n> $$\n>\n> 那么取到最优解的概率为：\n>\n> $$\n> Pr[S] = \\sum_{i=k+1}^N Pr[S_i] = \\dfrac{k}{N} \\sum_{i=k}^{N-1} \\dfrac{1}{i} \\sim \\dfrac kN \\ln \\left(\\dfrac Nk\\right)\n> $$\n>\n> 根据高中数学的知识可以知道取 $\\dfrac N k=e$ 时最大即 $k=\\dfrac{N}{e}$，且概率为 $\\dfrac{1}{e}$。\n\n> [!summary] Quicksort\n>\n> 众所周知，直接选中间位置作为 pivot 的快速排序是可以被卡到 $O(n^2)$ 的，那应该怎么选呢。\n\n随机一个数作为 pivot，但如果这一 pivot 是最小的 1/4 或最大的 1/4 则重选，期望意义下只重选一次。\n\n这样至少会将规模划分为 $\\dfrac{n}{4}$ 和 $\\dfrac{3n}{4}$，可以证明复杂度是 $O(n\\log n)$。\n\n## 9. 并行算法 Parallel Algorithm\n\n两个模型：Parallel Random Access Machine (PRAM)；Work-Depth (WD)。\n\n### 9.1. PRAM Model\n\n![yfN9mtsC.png|524](https://img.memset0.cn/2024/06/23/yfN9mtsC.png)\n\n![fN50Vo13.png|776](https://img.memset0.cn/2024/06/23/fN50Vo13.png)\n\n### 9.2. WD Model\n\n![HrnJ84fN.png|782](https://img.memset0.cn/2024/06/23/HrnJ84fN.png)\n\n【WD-presentation Sufficiently Theorem】An algorithm in the WD mode can be implememnt by any $P(n)$ processors within $O(W(n)/P(n) + T(n))$ time, using the same concurrent-write convention as in the WD presentation.\n\n> [!summary] Maximal Finding\n>\n> 找 $n$ 个数的最大值，并行算法。\n\n- Replace \"+\" by \"max\" in the summation algorithm. $T(n)=O(\\log n),\\ W(n)=O(n)$\n- Compare al pairs (find $B(i)=0$). $T(n)=O(1),\\ W(n)=O(n^{2})$\n- Doubly-logarithmic Paradigm: Parition by $n^{1/2}$. $T(n)=O(\\log \\log n),\\ W(n)=O(n \\log \\log n)$\n- Paritition by $h=\\log \\log n$. $T(n) = O(\\log \\log n),\\ W(n) =O(n)$\n- Random Sampling. $n^{7/8}=n^{3/4} \\times n^{1/8},\\ n^{3/4}=n^{1/2} \\times n^{1/4}$. $M(n^{7/8}) \\sim T = O(1),\\ W=O(n)$.\n\n## 10. 外部排序 External Sorting\n\n我们只有有限的内存（只能存放 $M$ 个数）和若干 tape（一种特殊的存储结构，只能顺序读写），需要解决排序问题。\n\n这个具体的过程特别抽象我懒得记录了，可以看一下别人的笔记。不过别因为这个是最后一讲就不看了，似乎是每年必考的内容。\n","publishedTitle":"「高级数据结构与算法分析」第三部分：算法"}},{"id":"f66de247-c16f-57bb-b9b5-d83aaa370203","fields":{"slug":"/course/physics/note/6/","plainText":"\n> 本篇笔记介绍了静电学的基本概念和定律。首先讨论了电荷的基本性质和库仑定律，引入了电场强度的概念，并阐述了电通量和高斯定理。随后详细探讨了电势和电势能的关系，以及它们与电场的联系。最后分析了导体在静电平衡时的特性，包括导体表面的电荷分布和静电屏蔽现象，并讨论了各种典型带电体（如带电球壳、球体、直线和平面）的电场与电势分布。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. Ch13 静电场\n\n### 1.1. 电荷·电场·电场强度\n\n- **电荷量子化**：带电粒子的电量只能是基本电荷 $e=1.60217733 \\times 10^{-19} \\text{ C}$ 的整倍数。\n- **库仑定律**：$\\displaystyle{\\color{blue}\\boldsymbol{F}_{12} =\\dfrac{1}{4\\pi \\varepsilon_{0} }\\frac{q_1q_2}{r^2}\\hat{\\boldsymbol{r}}_{12} }$。\n- **电场强度**：单位试验电荷（电量小，可看成点电荷）在该点所受电场力，$\\displaystyle{\\color{blue}\\boldsymbol{E} = \\dfrac{\\boldsymbol{F}}{q_{0}}} \\displaystyle{ = \\frac1{4\\pi\\varepsilon_0}\\int\\frac{\\mathrm{d}q}{r^2}\\hat{r}}$（第二个等号为 **场强叠加原理**）。\n  - 线分布：$\\text{d}q = \\lambda \\text{d}l$；面分布：$\\text{d} q = \\sigma \\text{d} s$；体分布：$\\text{d}q = \\rho \\text{d}V$。\n- **电通量**：$\\Phi_E=\\displaystyle{\\int_{S}\\boldsymbol{E}\\cdot\\text{d}\\boldsymbol{S}}$。\n- **电通量的高斯定理**：$\\color{blue}\\Phi_{E} = \\displaystyle{\\oint_{S} \\boldsymbol{E} \\cdot \\text{d}\\boldsymbol{S}=\\frac{1}{\\varepsilon_0}\\sum_iq_{i(\\text{内})}}$（这里 $S$ 是闭合曲面）；即闭合曲面的电通量等于内部电荷量除以 $\\varepsilon_{0}$，一般取 $\\boldsymbol{E}$ 与 $\\text{d}\\boldsymbol{S}$ 同向的情况方便计算。\n  - 对于均匀带电球面：对于球面外任一点，有 $\\boldsymbol{E}=\\dfrac q{4\\pi\\varepsilon_0r^2}\\hat{\\boldsymbol{r}}$。\n  - 对于轴对称分布（包括无限长均匀带电的直线，圆柱面，圆柱体等）：$E=\\dfrac\\lambda{2\\pi\\varepsilon_0r}$。\n  - 对于无限大平面电荷（包括无限大的均匀带电平面，平板等）：$E=\\dfrac{\\sigma}{2\\varepsilon_0}$。\n\n### 1.2. 电势\n\n- **静电场环路定理**：对于任意闭合曲线 $L$，有 $\\displaystyle{\\oint_{L} \\boldsymbol{E} \\cdot \\text{d} \\boldsymbol{l}  = 0}$。\n- **电势能**：当试验电荷 $q_{0}$ 从 $a$ 移到 $b$，其间电场力（保守力）所做的功应等于电荷静电势能增量的负值，$\\displaystyle{\\color{blue}W_{ab}=q_0\\int_a^b\\boldsymbol{E}\\cdot\\mathrm{d}\\boldsymbol{l}=-(W_{b}-W_{a})=-\\Delta W}$。\n  - 电荷从高电势能点移向低电势能点，电势能减小，电场力做正功；<br>电荷从低电势能点移向高电势能点，电势能增加，电场力做负功。\n  - 电势能是相对的，需要规定一个电势能为 $0$ 的参考点。一般选无限远点或接地为 $0$。规定无限远点为 $0$ 时有 $\\displaystyle{W_{P} = q_{0} \\int_{P}^{\\infty} q_{0} \\boldsymbol{E} \\cdot \\text{d}\\boldsymbol{l}}$。\n  - 对于点电荷电场的情况可以推出 $W_{ab}=\\displaystyle{\\int_{r_{a}}^{r_{b}} \\dfrac{1}{4\\pi \\epsilon_{0}} \\dfrac{q_{0}q}{r^{2}} \\text{d}r = \\dfrac{q_{0}q}{4\\pi \\epsilon_{0}} \\left( \\dfrac{1}{r_{1}}-\\dfrac{1}{r_{2}} \\right)}$。\n- **电势**：某点电势能与其电荷量的比值，是只与位置有关的函数，$\\color{blue}\\displaystyle{U_P=\\frac{W_P}{q_0}=\\int_P^{P_{0}}\\boldsymbol{E}\\cdot\\mathrm{d}\\boldsymbol{l}}$（这里 $P_{0}$ 是势能零点）。\n  - **电场和电势的关系**：$\\boldsymbol{E} = -\\nabla \\boldsymbol{V}$。\n  - 静电力与电势能的关系：$\\boldsymbol{F} = -\\nabla \\boldsymbol{U}$。\n  - 点电荷在电场中的电势：$U_{p} = \\dfrac{q}{4\\pi \\varepsilon_{0} r}$。\n- **电势差** / **电压**：$U_{ab} =\\displaystyle{U_a-U_b = \\int_{a}^{\\infty} \\boldsymbol{E} \\cdot \\text{d}\\boldsymbol{l}- \\int_{b}^{\\infty} \\boldsymbol{E} \\cdot \\text{d}\\boldsymbol{l} =\\int_a^b\\boldsymbol{E}\\cdot\\mathrm{d}\\boldsymbol{l}}$。\n  - 沿着电场线方向，电势降低。\n- 常见带电体的电场与电势分布：\n  - 均匀带电球壳\n    - 电场：$E=\\begin{cases}0\\quad& r <R\\\\ \\dfrac{q}{4 \\pi \\varepsilon_{0} r^{2}}\\quad&r > R\\end{cases}$\n    - 电势：$U=\\begin{cases} \\dfrac{q}{4 \\pi \\varepsilon_{0}R}\\quad& r<R\\\\ \\dfrac{q}{4\\pi \\varepsilon_{0}r}\\quad&r>R\\end{cases}$\n  - 均匀带电球体\n    - 电场：$E=\\begin{cases} \\dfrac{rq}{4 \\pi \\varepsilon_{0} R^{3}}\\quad& r<R\\\\ \\dfrac{q}{4 \\pi \\varepsilon_{0} r^{2}}\\quad& r>R\\end{cases}$\n  - <img src=\"https://img.memset0.cn/2024/10/30/xujrh4hf.png\" width=\"100\" align=\"right\"/>均匀无限长带电直线\n    - 电场：$E= \\dfrac{\\lambda}{2\\pi \\varepsilon_{0} r} = \\dfrac{1}{\\varepsilon_{0}}\\dfrac{\\lambda \\text{d}l}{2\\pi r \\cdot \\text{d}l}$\n  - <img src=\"https://img.memset0.cn/2024/10/30/upKcfkIJ.png\" width=\"145\" align=\"right\">均匀无限大带电平面\n    - 电场：$E=\\dfrac{\\sigma}{2\\varepsilon_{0}}=\\dfrac{1}{\\varepsilon_{0}} \\dfrac{\\sigma S}{2S}$\n      - 推论：无限大平行板电容器内部电场：$E=\\dfrac{\\sigma}{\\varepsilon_{0}}$（在外部来自两块极板的电场相互抵消）\n\n## 2. Ch14 静电场中的导体和电介质\n\n### 2.1. 导体\n\n- **静电平衡**：外电场引起导体上自由电子的移动，使导体带上等量异号的 **感应电荷**；感应电荷激发附加电场，改变导体内外的电场。当导体内的外电场与附加电场正好相互抵消时，导体上的自由电子停止宏观运动，导体达到 **静电平衡**。\n  - 导体内部场强处处为零 。\n  - 导体是一个等势体，导体表面是一个等势面。\n  - 电荷只分布在导体的表面上，所有电荷的代数和等于初始电荷量。\n  - 导体表面场强：$E=\\dfrac{\\sigma}{\\varepsilon_{0}}$。\n- **静电屏蔽**：利用接地空腔导体将腔内带电体与外界隔绝的现象。腔外电场不能穿入腔内，腔内电场恒为零；导体接地可以屏蔽内电场。\n  - 应用：高压带电作业，电气设备金属罩接地等。\n\nTBD：补充一下空腔相关的各种分析。\n\n> [!example]- 静电场中的导体分析（$+q_1\\ll+q_{2}$）\n>\n> | **图示**                                                               | **分析**                                                                                                                                    |\n> | ---------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\n> | <img src=\"https://img.memset0.cn/2024/10/31/DBIgvIXp.png\" width=\"380\"> | 现感应电荷 $+q_2$，$B$ 球所带电量 $+q_2$ 与球壳内表面所带电量 $-q_2$ 对外产生电场完全抵消，故 $A$ 球受到球壳外表面电荷 $+q_2$ 的斥力。      |\n> | <img src=\"https://img.memset0.cn/2024/10/31/A2970WHV.png\" width=\"380\"> | 在球壳外表面将出现带电量分别为 $+q’$ 和 $-q’$ 的感应电荷。总电荷虽为零，但负电荷靠近 $A$ 球，而正电荷远离 $A$ 球，故 $A$ 球总体上受吸引力。 |\n> | <img src=\"https://img.memset0.cn/2024/10/31/GbSd92xQ.png\" width=\"380\"> | $B$ 球与球壳内表面接触，则构成一体，$B$ 球所带的电荷 $+q_2$ 全部转移到了球壳外表面。                                                        |\n> | <img src=\"https://img.memset0.cn/2024/10/31/X0XWaMm0.png\" width=\"380\"> | 接地球壳电势为零，球壳表面的正感应电荷与大地所带的负电荷中和，只剩负感生电荷 $-q’$。                                                        |\n> | <img src=\"https://img.memset0.cn/2024/10/31/1rzKR7Ee.png\" width=\"380\"> | 内表面出现感应电荷 $-q_2$，由于接地，外表面感应电荷仍为 $-q’$。                                                                             |\n> | <img src=\"https://img.memset0.cn/2024/10/31/bcfxmxnH.png\" width=\"380\"> | 拆地线后，球壳所带总电量为 $-(q_2+q’)$，当 $B$ 球移去后，这些电荷全部跑到外表面，故 $A$ 球受吸引力。                                        |\n\n### 2.2. 电容\n\n- **孤立球导体电容**：$\\displaystyle{C=\\dfrac{q}{U}=4\\pi \\varepsilon_{0}R}$。\n- **电容器的电容**：$\\color{blue}C=\\dfrac{Q}{U_{A}-U_{B}}$（单位为 $\\text{F}$）；注意，这里的带电量 $Q$ 是==一侧==极板带电量的==绝对值==。\n  - 平行板电容器：$C=\\dfrac{Q}{U_{A}-U_{B}}=\\displaystyle{\\dfrac{\\varepsilon_{0}S}{d}}$\n  - 圆柱形电容器：$\\displaystyle{C=\\frac{2\\pi\\varepsilon_0l}{\\ln\\frac{R_B}{R_A}}}$\n  - 球形电容器：$\\displaystyle{C=4\\pi\\varepsilon_0\\frac{R_AR_B}{R_B-R_A}}$\n- **电容器的串联**：总电势差为每个电容器电势差的和，极板电量都相同；$\\displaystyle{\\frac1C=\\frac1{C_1}+\\frac1{C_2}+\\cdots+\\frac1{C_N}}$。\n- **电容器的并联**：总电量为每个电容器所带电量的和，两板间电势差都相同；$C=C_1+C_2+\\cdots+C_N$。\n- 电介质充满电容器可增大电容 $\\varepsilon_{r}$ 倍，即 $C=\\varepsilon_{r} C_0$。\n\n### 2.3. 电介质的极化\n\n- **电介质**：是电的非导体（绝缘介质）。在外电场中时，对电场有影响。处于静电平衡时，内部场强不为零。\n- **电介质的极化**：电介质在外场中时，在与外电场 $\\boldsymbol{E}_{0}$ 垂直的表面层里会出现不能自由移动的正负电荷层，这一现象称为 **电介质的极化**，这些电荷称为 **束缚电荷** 或 **极化电荷**。\n- **电介质中的场强**：极化电荷会激发电场 $\\boldsymbol{E'}$，与自由电荷激发的电场 $\\boldsymbol{E}_{0}$ 作矢量和可以得到电介质中的合场强 $\\boldsymbol{E}=\\boldsymbol{E}_{0}+\\boldsymbol{E}'$。\n- **极化强度**：某点对应的体积微元中所有分子电矩的矢量和 $\\boldsymbol{P}$；外加电场不太大时，有线性关系 $\\boldsymbol{P}=\\varepsilon_{0} \\chi_{e} \\boldsymbol{E}=\\varepsilon_{0} (\\varepsilon_{r} - 1) \\boldsymbol{E}$。\n  - **极化电荷面密度**：均匀电介质极化时，电介质表面上某点处的极化电荷面密度 $\\sigma'$ 等于极化强度在该点表面的法向分量 $\\color{blue}\\sigma'=\\boldsymbol{P}\\cdot \\boldsymbol{e}_{n}$。\n- **电位移**：为了不考虑极化电荷和附加电场，引入电位移 $\\color{blue}\\boldsymbol{D}=\\varepsilon_{0} \\boldsymbol{E}+\\boldsymbol{P}=\\varepsilon_{0} \\varepsilon_{r} \\boldsymbol{E}=\\varepsilon \\boldsymbol{E}$。电位移并没有实际物理意义。\n- **电介质中的高斯定理**：通过电场中任意闭合曲面的位移电通量，等于该闭合面所包围的==自由电荷==的代数和。$\\displaystyle{\\oint_{S} \\boldsymbol{D} \\cdot \\text{d} \\boldsymbol{S} = \\sum q_{0}}$（这里 $S$ 是闭合曲面）。\n\n### 2.4. 静电场中的能量\n\n- **点电荷系统的能量**：$\\color{blue}\\displaystyle{W=\\dfrac{1}{2} \\sum q_{i} U_{i}}$，这里 $U_{i}$ 在点电荷 $q_{i}$ 处除了 $q_{i}$ 以外所有电荷产生的电势。\n  - 可以通过考虑将每个电荷依次（所以这里会有一个 $1 / 2$ 的系数）移到无穷远处得到。\n- **电场能量**：定义单位体积上的电场能量为 **电能密度** $\\color{blue}\\omega_{e}=\\dfrac{1}{2} \\varepsilon E^{2} = \\dfrac{1}{2} DE$，则 $\\displaystyle{W=\\int_{V} \\omega_{e} \\text{d} V}$。\n  - **电容器的能量**：$W=\\dfrac{1}{2} \\dfrac{Q^{2}}{C}$。\n","publishedTitle":"「大学物理(乙)」VI. 静电学"}},{"id":"5527af52-776a-5650-aab5-2b983262131f","fields":{"slug":"/course/physics/note/7/","plainText":"\n> 本篇笔记介绍了静磁学的基本概念和定律。首先讨论了电流的基本性质，包括电流强度、电流密度和稳恒电流的概念，以及电动势和欧姆定律。随后详细阐述了磁场的产生和特性，重点介绍了毕奥-萨伐尔定律，并分析了多种载流导体（直导线、圆线圈、螺线管等）产生的磁场分布。同时还讨论了运动电荷产生的磁场，以及磁场的安培环路定理及其应用。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. Ch15 电流·磁场\n\n### 1.1. 电流·电动势\n\n> 电荷的定向移动形成电流。而电荷的移动需要有能移动的带电粒子，被成为**载流子**，主要是电子或离子。这个定向移动的速度和无规则运动的速度不同，被称为**漂移速度**，其数量级为  $10^{-3} \\text{ m}\\cdot \\text{s}^{-1}$。\n\n- **电流强度**：单位时间内通过某一截面的电量，$\\color{blue} I=\\dfrac{\\text{d}q}{\\text{d}t}$，是标量。\n  - 设电流元 $I \\text{d}l$ 的横截面积为 $S$，单位时间内有 $n$ 个定向运动的正电荷，带电量 $q$，速度 $v$，则 $I=qnvS$。\n- **电流密度**：单位时间内通过单位界面的电量：$j=\\dfrac{\\text{d}I}{\\text{d}S_{\\perp}}$，$\\boldsymbol{j}$ 的方向为正电荷载流子的方向。\n  - $\\boldsymbol{j}$ 构成了一个矢量场，可以通过 $\\color{blue} \\boldsymbol{I}=\\displaystyle{\\int_{S} \\boldsymbol{j}\\cdot \\text{d}\\boldsymbol{S}}$ 求得通过导体任意截面的电流强度。\n- 稳恒电流：导体中各点电流密度矢量 $\\boldsymbol{j}$ 或通过导体任一截面的电流强度 $I$ 不随时间变化的电流。\n\n> 在导体中的静电平衡一章中我们看到，如果不维持使得载流子运动的电场，电流很快就会消失。这里也有电阻生热的原因。此时，为了维持电流，需要将导体上电势能较低点的载流子搬到较高的地方。对于稳定电流，其电场不变，是静电场，有环路积分为 $0$。故需要非静电力做功。这一非静电力通常用电动势衡量。\n\n- **电动势**：电荷 $q$ 受非静电力做功 $W$ 和 $q$ 的比值，即 $\\displaystyle{\\mathcal{E}=\\dfrac{W_{AB}}{q}=\\oint_{A}^{B} \\boldsymbol{E}_{k} \\cdot \\text{d}\\boldsymbol{l}}$。\n  - 电动势与电势的量纲一致，但是物理意义不同，不能等同看待。\n- **欧姆定律**：$I=\\dfrac{U}{R}$。\n- 电阻：$R=\\rho \\dfrac{l}{S}$，电阻率 $\\rho$，电导率 $\\gamma=\\dfrac{1}{\\rho}$。\n  - 电流密度等于电导率乘以电场强度。\n\n### 1.2. 磁力·磁场\n\n- **磁感应强度**：定义式 $B=\\dfrac{F_{\\text{max}}}{qv}$，方向沿 $\\boldsymbol{F}_{\\text{m}} \\times \\boldsymbol{v}$ 的方向，可通过右手螺旋法则确定。单位 $\\text{T}$（特斯拉），$1\\text{ T} = 1 \\text{ N} \\cdot (\\text{A} \\cdot \\text{m})^{-1}$。\n- **电流产生的磁场**（毕奥-萨伐尔定律）：电流源 $I\\text{d}\\boldsymbol{l}$ 在点 $P$ 产生的磁场为：$\\color{blue}\\text{d}\\boldsymbol{B}=\\displaystyle{\\dfrac{\\mu_{0}}{4\\pi} \\frac{I\\text{d}\\boldsymbol{l} \\times \\hat{r}}{r^{2}}}$，这里 $\\boldsymbol{r}$ 为电流元指向 $P$ 的矢量。\n  - $\\mu_{0}=4 \\pi \\times 10^{-7} \\text{ N/A}^2$ 为真空磁导率。\n  - **右手螺旋定则**：<img src=\"https://img.memset0.cn/2024/10/25/t4tEFQnR.png\" width=\"101\" align=\"right\">\n    - 若是直线电流产生的磁场，大拇指指向电流方向，则其它四指的绕行方向就是 $B$ 的方向。\n    - 若是环形电流产生的磁场，其它四指的绕行方向为电流方向，则大拇指指向 $B$ 的方向。\n  - <img src=\"https://img.memset0.cn/2024/11/02/ZW9zfbCp.png\" width=\"100\" align=\"right\">载流直导线的磁场：其中任意电流元 $I\\text{d}\\boldsymbol{l}$ 在同一点 $P$ 处产生的元磁场 $\\text{d}\\boldsymbol{B}$ 的方向都相同，故总磁感应强度大小为每一微元的代数和：$\\color{blue}B=\\displaystyle{\\dfrac{\\mu_{0}}{4\\pi} \\int_{A_{1}}^{A_{2}} \\dfrac{I \\text{d} l \\sin \\theta}{r^{2}} = \\dfrac{\\mu_{0}}{4\\pi}  \\dfrac{I}{r_{0}} \\left( \\cos \\theta_{1} - \\cos \\theta_{2} \\right)}$。\n    - 对于无限长导线，可认为 $\\theta_{1}=0$，$\\theta_{2} =\\pi$，则 $B=\\dfrac{\\mu_{0}I}{2 \\pi r_{0}}$。\n    - 对于无限长直导线端点所在垂直平面内，可认为 $\\theta_{1}=\\dfrac{\\pi}{2}$，$\\theta_{2}=\\pi$，则 $B=\\dfrac{\\mu_{0}I}{4\\pi r_{0}}$。\n    - 对于载流直导线延长线上的一点，$B=0$。\n  - <img src=\"https://img.memset0.cn/2024/11/02/8oIY3lel.png\" align=\"right\" width=\"195\">载流圆线圈轴线上的磁场：任意电流元在轴线上同一点 $P$ 上产生的元磁场大小相等，但是方向各不相同，其中垂直于轴线的分量相互抵消，只剩下沿轴线的分量：$\\displaystyle{B=\\oint \\text{d}B \\sin \\alpha =\\dfrac{\\mu_{0}}{4\\pi} \\dfrac{I\\sin \\alpha}{R^{2}+x^{2}}\\oint \\text{d}l =  \\dfrac{\\mu_{0}IR^{2}}{2(R^{2}+x^{2})^{3/2}}}$。\n    - 在圆线圈中心处，$x=0$，则 $B=\\dfrac{\\mu_{0}I}{2R}$。\n      - 在角度为 $\\theta$ 的圆弧电流中心处，$B=\\dfrac{\\mu_{0} I}{2 R} \\dfrac{\\theta}{2\\pi}$。\n    - 在轴线上远离圆线圈处，$r_{0} \\gg R$，则 $B=\\dfrac{\\mu_{0}}{2\\pi} \\dfrac{IS}{x^{3}}$。\n      - 引入磁矩 $\\boldsymbol{p}_{m}=IS \\boldsymbol{e}_{n}$，则有 $B=\\dfrac{\\mu_{0}}{2\\pi} \\dfrac{\\boldsymbol{p}_{m}}{x^{3}}$。\n  - <img src=\"https://img.memset0.cn/2024/10/30/54pTZkEr.png\" width=\"180\" align=\"right\">载流直螺线管内部的磁场（推荐用安培环路定理分析）：在螺线管上取 $\\text{d}l$，相当于电流强度为 $In\\text{d}l$ 的圆电流，故 $\\displaystyle{\\boldsymbol{B}=\\int \\dfrac{\\mu_{0} IR^{2} n \\text{ d}l}{2 (R^{2}+l^{2})^{3/2}} = \\int_{\\beta_{1}}^{\\beta_{2}} -\\dfrac{\\mu_{0}}{2} nI \\sin \\beta \\text{d} \\beta} = \\dfrac{\\mu_{0}}{2} n I \\left( \\cos \\beta_{2} - \\cos \\beta_{1} \\right)$。\n    - 当 $L\\gg R$ 时，$\\beta_{1}\\to\\pi$，$\\beta_{2}\\to0$，则 $B=\\mu_{0} nI$。\n    - 在长直螺线管两端点处，$\\beta_{1}\\to \\dfrac{\\pi}{2}$，$\\beta_{2}\\to\\pi$，则 $B=\\dfrac{1}{2} \\mu_{0} n I$。\n- **电荷产生的磁场**：以速度 $\\boldsymbol{v}$ 运动电荷 $q$ 产生的磁场为：$\\color{blue}\\boldsymbol{B}=\\dfrac{\\mu_{0}}{4\\pi} \\dfrac{q(\\boldsymbol{v}\\times \\hat{r})}{r^{2}}$。\n  - **电荷运动的等效电流**：在有多电荷（尤其是连续分布电荷）进行匀速运动时，可考察某截面单位时间内通过的电荷量而求等效电流 $I$。\n    - 在 $v\\ll c$ 的情况下，恒速运动的点电荷产生的电场可认为和该点的静止电荷的静电场没有区别，即 $\\boldsymbol{E}=\\dfrac{1}{4\\pi \\epsilon_{0}} \\dfrac{q}{r^{2}} \\hat{r}$。\n- **磁场的安培环路定理**：在磁场中，沿任意闭合曲线的磁感应强度的线积分等于真空磁导率 $\\mu_{0}$ 乘以穿过该环路所有电流的代数和：$\\color{blue}\\displaystyle{\\oint_{L} \\boldsymbol{B} \\cdot \\text{ d} \\boldsymbol{l} = \\mu_{0} \\sum_{S_{L}} I_{内}}$。\n  - <img src=\"https://img.memset0.cn/2024/10/25/a5RY173l.png\" width=\"95\" align=\"right\">无限长载流圆柱体内外的磁场：设圆柱截面半径为 $R$，取距离轴为 $r$ 的一点考察磁场 $B$，沿半径为 $r$ 的圆一周的磁感应强度环积分（即绕磁感应线一周）为 $\\displaystyle{\\oint_{L} B \\text{d} l = B \\cdot 2 \\pi r}$。\n    - 当 $r>R$ 时：$B=\\dfrac{\\mu_{0}}{2\\pi} \\dfrac{I}{r}$。\n    - 当 $r<R$ 时：\n      - 若为电流面（电流仅分布在导体表面）分布，则 $B\\cdot 2 \\pi r=0$ 即 $B=0$；\n      - 若为电流体分布（电流均匀分布在整个导体中），则 $B \\cdot 2 \\pi r=\\mu_{0} I \\dfrac{\\pi r^{2}}{\\pi R^{2}}$，故 $B=\\dfrac{\\mu_{0}}{2\\pi} \\dfrac{Ir}{R^{2}}$。\n  - <img src=\"https://img.memset0.cn/2024/11/02/JTUiUlqg.png\" align=\"right\" width=\"120\">载流螺绕环内的磁场：设螺绕环内外径 $r_{1},r_{2}$，总匝数 $N$，电流 $I$。取管内一点 $P$，距离轴线距离 $r\\in(r_{1},r_{2})$，则 $\\displaystyle{\\oint_{L}B \\cdot \\text{d}l=B\\cdot 2\\pi r=\\mu_{0} NI}$，故 $B=\\mu_{0} \\dfrac{N}{2R} I$。\n  - <img src=\"https://img.memset0.cn/2024/10/25/sr3rYKQJ.png\" align=\"right\" width=\"180\">载流长直螺线管内的磁场：设螺线管长 $l$，总匝数 $N$，通电流 $I$。取管内一点 $P$，如图作一矩形闭合回路 $ABCDA$，其中 $AD,DC,BC$ 段均有 $B\\cdot \\text{d}l=0$，故 $\\displaystyle{\\oint_{L} B\\cdot \\text{d}l=\\int_{AB}B\\cdot \\text{d}l=B\\cdot |AB|}$。考虑被包围的总电流为 $I'=\\dfrac{N}{l} I \\cdot |AB|$，故 $B=\\mu_{0} \\dfrac{N}{l} I$。\n    - 如果用 $n$ 表示单位长度环绕的线圈匝数，则螺绕环和螺线管的公式都可以统一为 $\\color{blue}B=\\mu_{0} nI$。\n  - <img src=\"https://img.memset0.cn/2024/11/02/uBGmxDdc.png\" align=\"right\" width=\"150\">无限大载流平面的磁场：$\\color{blue}B=\\dfrac{\\mu_{0}}{2} j$，这里 $j$ 为电流线密度，磁场方向与平面平行，可以通过右手螺旋定则确定。\n- **磁通量**：类似于引入电通量的方法，定义磁通量为：$\\Phi_{B}=\\displaystyle{\\int_{S}\\boldsymbol{B}\\cdot \\text{d}\\boldsymbol{S}}$。\n  - 单位为 $\\text{Wb}$（韦伯）。\n- **磁场的高斯定理**：由于自然界不存在磁荷，故任意封闭曲线面的磁通量为 $0$，即 $\\displaystyle{\\oint_{S}\\boldsymbol{B}\\cdot \\text{d}\\boldsymbol{S}=0}$。\n\n> [!example]- 分析无限长载流直导线的产生的磁场\n>\n> - $B=\\displaystyle{\\dfrac{\\mu_{0}}{4\\pi} \\int_{A_{1}}^{A_{2}} \\dfrac{I \\text{d} l \\sin \\theta}{r^{2}}}$，需要转化成关于角度的积分，重点在于 $\\text dl$ 和 $r$ 的部分。\n>   - $\\text dl$：考虑 $l=\\dfrac{r_0}{\\tan\\theta}$，故 $\\text dl=-\\dfrac{r_0 \\text d\\theta}{\\sin^2\\theta}$。\n>   - $r=\\dfrac{r_0}{\\sin\\theta}$。\n> - 综上得到 $\\displaystyle{B=\\dfrac{\\mu_0}{4\\pi}\\int_{\\theta_1}^{\\theta_2} \\frac{I \\left(-\\frac{r_0\\text d\\theta}{\\sin^2 \\theta}\\right) \\sin\\theta}{\\left(\\frac{r_0}{\\sin\\theta}\\right)^2} = -\\frac{\\mu_0}{4\\pi} \\int_{\\theta_1}^{\\theta_2} \\frac{I \\sin\\theta \\text d\\theta}{r_0} = \\frac{\\mu_0 I}{4\\pi r_0} (\\cos\\theta_1-\\cos\\theta_2)}$。\n\n### 1.3. 磁场中的作用力\n\n- **安培力**：安培力是洛伦兹力的宏观表现。载流导线（可以等效为从起点到终点的直导线 $\\boldsymbol{L}$）在磁场 $\\boldsymbol{B}$ 中所受安培力为 $\\displaystyle{\\color{blue} \\boldsymbol{F}=\\int_{L} I\\text{d} \\boldsymbol{l} \\times \\boldsymbol{B}=I \\boldsymbol{L}\\times \\boldsymbol{B}}$。\n  - 两根平行载流直导线的作用力：$F_{m}=\\dfrac{\\mu_{0}}{2\\pi} \\dfrac{I_{1}I_{2}}{d}$（$\\mu_{0}=2\\pi k=4\\pi \\times 10^{-7} \\text{ N} \\cdot \\text{A}^{-2}$）。\n- **磁矩**：磁矩是与闭合回路有关的物理量 $\\color{blue}\\boldsymbol{p}_{m}=NI S\\boldsymbol{e}_{n}$，这里 $N$ 是线圈匝数，对于其中任一匝的围成的平面，$S$ 是其面积，$\\boldsymbol{e}_{n}$ 是其法向量。\n- **载流平面线圈的磁力矩**：\n  - 均匀磁场对载流线圈的合作用力为 $0$，但存在力矩 $\\color{blue}\\boldsymbol{M}=\\boldsymbol{p}_{m} \\times \\boldsymbol{B}$。\n  - 一般磁场对载流线圈的磁力矩为 $\\color{blue}\\text{d}\\boldsymbol{M}=\\boldsymbol{r}\\times (I\\text{d}\\boldsymbol{l} \\times \\boldsymbol{B})$。\n\n## 2. Ch16 物质中的磁场\n\n### 2.1. 磁介质\n\n> 分子本身具有磁矩（**固有磁矩** $\\boldsymbol{p}_{m}$），可认为由等效的圆电流（**分子电流**）产生。由于磁矩取向无规则，它们相互抵消，导致磁介质不显磁性。磁介质处于外磁场时，每个分子均产生与外磁场方向相反的 **附加磁矩** $\\Delta \\boldsymbol{p}_{m}$。顺磁质的 $\\boldsymbol{p}_{m}$ 远大于 $\\Delta \\boldsymbol{p}_{m}$，且分子受到的磁力矩尽可能使固有磁场转向外磁场方向；抗磁质的 $\\boldsymbol{p}_{m}$ 为 $0$，附加磁矩是产生磁化的唯一原因。\n\n- **磁介质**：在磁场的作用下能够获得磁矩的物质。磁介质内的磁感应强度 $\\boldsymbol{B}$ 为真空中原来的磁感应强度 $\\boldsymbol{B}_{0}$ 和附加磁感应强度 $\\boldsymbol{B}'$ 的和，即 $\\boldsymbol{B}=\\boldsymbol{B}_{0}+\\boldsymbol{B}'$。\n- **分子电流**：分子或原子中所有电子对外界所产生磁效应总和可以等效于一个圆电流 $I$。\n- **分子磁矩**：每一个分子电流都具有磁矩，具有关系 $\\boldsymbol{p}_{m} = I S \\boldsymbol{e}_{n}$。\n- **磁化强度**：表征磁介质磁化程度。定义为某体积微元内分子的总磁矩之和 $\\color{blue}\\displaystyle{\\boldsymbol{M}=\\sum \\dfrac{\\boldsymbol{p}_{m}}{\\text{d}V}}$。\n  - 顺磁质 $\\boldsymbol{M}$ 与 $\\boldsymbol{B}_{0}$ 同向，抗磁质 $\\boldsymbol{M}$ 与 $\\boldsymbol{B}_{0}$ 反向。\n  - 如果介质内各点的 $\\boldsymbol{M}$ 都相同，称为均匀磁化，否则称为不均匀磁化。\n- **磁化电流** / **束缚电流**：由磁介质中各分子的分子电流叠加而成，仅在磁介质表面产生的等效环形电流（或者说是宏观上未被抵消而沿圆柱面流动的电流），常用 $I_{\\text{m}}$ 表示。\n  - 磁介质表面上某处 **磁化电流线密度** $j_{\\text{m}}$ 等于该点磁化强度 $\\boldsymbol{M}$ 沿表面的==切向分量==：$\\displaystyle{M=\\sum \\dfrac{p_{m}}{\\Delta V}=\\dfrac{j_{m}lS}{Sl}=j_{m}}$，其正负可以通过考察是顺磁质还是抗磁质得到。\n\n### 2.2. 磁场强度\n\n- **磁场强度**：定义式：$\\color{blue}\\boldsymbol{H}=\\dfrac{\\boldsymbol{B}}{\\mu_{0}} - \\boldsymbol{M}$，单位 $\\text{A/m}$。\n  - **束缚电流与磁化强度的关系**：介质内 $M=j_{\\text{m}}$，磁化强度 $\\boldsymbol{M}$ 对闭合回路的线积分等于通过回路所包围的束缚电流，即 $\\displaystyle{\\oint_{L} \\boldsymbol{M}\\cdot\\text{d}\\boldsymbol{l}=j_{\\text{m}} |AB|=\\sum_{L\\text{内}}I_{\\text{m}}}$。这虽然是通过均匀磁介质与矩形闭合回路推导出的，但对于任何情况都普遍适用。\n- **磁化率**：对于各向同性的电介质，$\\boldsymbol{M}$ 与 $\\boldsymbol{H}$ 成正比：$\\color{blue}\\boldsymbol{M}=\\chi_{m}\\boldsymbol{H}$，其中 $\\chi_{m}$ 称为磁化率。\n  - 对于抗磁质：$\\chi_{m}<0$，$\\mu_r<1$，$B<B_{0}$。\n  - 对于顺磁质：$\\chi_{m}>0$，$\\mu_{r}>1$，$B>B_{0}$。\n  - 对于铁磁质：$\\chi_{m}$ 很大且不是常数，$B\\gg B_{0}$。\n- **相对磁导率**：相对磁导率 $\\color{blue}\\mu_{r}=1+\\chi_{m}$，有 $\\boldsymbol{B}=\\mu_{0}\\mu_{r}\\boldsymbol{H}=\\mu_{0}(1+\\chi_{m}) \\boldsymbol{H}=\\mu_{0}\\boldsymbol{H}+\\mu_{0}\\boldsymbol{M}$。\n- **有磁介质时的安培环路定理**：$\\color{blue}\\displaystyle{\\oint_{L} \\boldsymbol{H}\\cdot\\text{d}\\boldsymbol{l}=\\sum I_{0}}$。\n  - 有介质时的磁场高斯定理依然成立，即闭合曲线面积分为 $0$。\n\n## 3. Ch19 带电粒子在电场和磁场中的运动\n\n- **洛伦兹力**：速度为 $\\boldsymbol{v}$ 的运动电荷在磁感应强度为 $\\boldsymbol{B}$ 的某点受到的磁场作用力（**洛伦兹力**）为 $\\boldsymbol{F}=q \\boldsymbol{v} \\times \\boldsymbol{B}$。\n  - 若空间中同时存在电场 $E$ 和磁场 $B$，则电荷所受作用力为 $\\boldsymbol{F}=q\\boldsymbol{E}+q \\boldsymbol{v} \\times \\boldsymbol{B}$。\n    - 考虑相对论效应后：$q\\boldsymbol{E}+q\\boldsymbol{v}\\times \\boldsymbol{B}=\\dfrac{\\text{d}}{\\text{d} t} \\left( \\dfrac{m\\boldsymbol{v}}{\\sqrt{1-(v/c)^{2}}} \\right)$。\n- **带电粒子在磁场中的运动**：\n  - $\\boldsymbol{v}\\parallel \\boldsymbol{B}$：带电粒子作匀速直线运动。\n  - $\\boldsymbol{v}\\perp \\boldsymbol{B}$：带电粒子作匀速圆周运动，圆周半径 $R=\\dfrac{mv}{qB}$，周期 $T=\\dfrac{2\\pi m}{qB}$。\n  - $\\boldsymbol{v}$ 与 $\\boldsymbol{B}$ 呈任意夹角 $\\theta$，则带电粒子作等间距螺旋线运动，运动半径 $R=\\dfrac{mv_{\\perp}}{qB}=\\dfrac{mv \\sin \\theta}{qB}$，螺距：$h=\\dfrac{2\\pi m v_{\\parallel}}{qB}=\\dfrac{2\\pi mv \\cos \\theta}{qB}$。\n- **霍尔效应**：在磁场中载流导体上出现横向电势差的现象，其霍尔电压为 $V_H=R_{H} \\dfrac{IB}{d}$，$d$ 为导体板的厚度。\n  - **霍尔系数**：$R_{H}=\\dfrac{1}{nq}$，若测得 $R_{H}$，就可以求出导体中载流子的浓度。\n\n## 4. Ch17 电磁感应\n\n- **法拉第电磁感应定律** / **楞次定律**：$\\mathcal{E}_{i}=- \\dfrac{\\text{d}\\Phi_{B}}{\\text{d}t}$。\n- **电动势**：是指在电源内部，将单位正电荷从负极经电源内部移到正极时非静电力所作的功，$\\displaystyle{\\mathcal{E}=\\dfrac{\\text{d} A}{\\text{d} q} =\\oint_{-}^{+} \\boldsymbol{E}_{k} \\cdot \\text{d} \\boldsymbol{l}}$。\n- **感生电动势**：由于磁场变化而产生的电场称为 **涡旋电场**，涡旋电场产生的电动势称为感生电动势，$\\displaystyle{\\color{blue}\\mathcal{E}=\\oint_{L}\\boldsymbol{E}_{\\text{旋}} \\cdot \\text{d}\\boldsymbol{l}=-\\dfrac{\\text{d}\\Phi_{B}}{\\text{d}t}}$。\n  - 半径为 $r$ 的无限长圆柱内沿轴线方向通随时间均匀变化的磁场 $B$，则涡旋电场分布：$E_{旋}=-\\dfrac{r}{2} \\dfrac{\\text{d}B}{\\text{d}t},\\space r\\leq R;\\quad E_{旋}=-\\dfrac{R^{2}}{2r} \\dfrac{\\text{d}B}{\\text{d}t},\\space r\\geq R$。其中 $- \\dfrac{\\text{d}\\boldsymbol{B}}{\\text{d}t}$ 与 $\\boldsymbol{E}_{\\text{旋}}$ 在方向上满足右手螺旋定则。\n- **楞次定律**：感应电流总是使感应电流所激发的磁场去阻止原磁通量的变化。可用于判断感应电流的方向。\n- **动生电动势**：导体在恒定磁场中运动时产生的感应电动势，$\\displaystyle{\\mathcal{E}_{ab}= -\\dfrac{\\text{d}  \\Phi_{B}}{\\text{d}  t} = \\int_{a}^{b} (\\boldsymbol{v} \\times \\boldsymbol{B})\\cdot \\text{d}\\boldsymbol{l}}$。\n  - 若 $\\mathcal{E}_{ab}<0$，则 $V_{a}<V_{b}$；若 $\\mathcal{E}_{ab}>0$，则 $V_a>V_{b}$。\n","publishedTitle":"「大学物理(乙)」VII. 电磁学"}},{"id":"d6a749a4-211b-5027-85ad-afe7c283f16f","fields":{"slug":"/course/physics/note/8/","plainText":"\n> 本篇笔记主要介绍了光学的三个重要章节：光的干涉、光的衍射和光的偏振。在光的干涉部分，详细讨论了光源的基本概念、折射率、光程等基础知识，以及杨氏双缝实验、洛埃镜实验和薄膜干涉等典型实验。在光的衍射部分，介绍了惠更斯原理，并对单缝衍射和光栅衍射进行了深入分析。最后在光的偏振部分，讨论了不同类型的光束、偏振片的原理，以及马吕斯定律和布儒斯特定律等重要规律。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. Ch20 光的干涉\n\n### 1.1. 光的基本概念\n\n- **光源**：能够发射光波的物体称为光源。\n  - 热辐射光源：将热能转化为辐射。\n  - 冷光源：与周围温度相同，不需要加热。\n  - 普通光源：激发态原子的自发辐射，频率、相位、振动方向或传播方向不相同；谱线宽度 $\\Delta \\lambda: 10^{-3} \\sim 10^{-1} \\text{ nm}$。\n  - 激光光源：原子的受激辐射，频率、相位、振动方向和传播方向都相同；谱线宽度 $\\Delta \\lambda: 10^{-9}\\text{ nm}$。\n- 单色光与复色光\n  - **单色光**：具有单一频率的光波。\n  - 复色光：不同频率单色光的混合光。\n- 光强：\n  - 谱线宽度 $\\Delta \\lambda$：谱线在光强 $I_{0}/2$ 处的波长范围。\n- **折射率**：同频率的光波在不同介质中，其波速和波长不一样。\n  - 设光在真空中的波速为 $c_{0}$，则在 **折射率** 为 $n$ 的介质中的波速 $c$ 满足 $n=\\dfrac{c_{0}}{c}$。\n  - 设光在真空中的波长为 $\\lambda$，则在 **折射率** 为 $n$ 的介质中的波长 $\\lambda_{n} = \\dfrac{c}{\\nu} =\\dfrac{\\lambda}{n}$。\n- **光程**：光在折射率为 $n$ 的介质中经过的路程为 $r$ 时，称 $L=nr$ 为光程。\n  - 这是为了方便计算光的相位变化所定义的概念，因为经过光程为 $L$ 所引起的相位差变化为：$\\Delta \\varphi = 2\\pi \\dfrac{r}{\\lambda_{n}} = \\dfrac{2\\pi}{\\lambda} nr=\\dfrac{2\\pi}{\\lambda} L$（$\\lambda$：真空中的波长）。\n  - **等光程性**：光线通过透镜会改变它的传播方向，但不产生附加的光程差。即，物点与象点之间各光线的光程都相等，观测仪器不会带来附加的光程差。\n- **半波损失**：如果光是从光束介质传向光密介质，则在其分界面上==反射==时将发生 **半波损失**，即相位有 $\\pi$ 的突变。折射波没有半波损失。\n\n### 1.2. 光的干涉\n\n> <img src=\"https://img.memset0.cn/2024/11/27/k6yl4GCX.png\" align=\"right\" width=\"160\">设符合相干条件的两光矢量 $E_{1},E_{2}$ 在其原点有：\n>\n> $$\n> \\begin{aligned}E_1&=E_{10}\\cos(\\omega t+\\varphi_{10})\\\\ E_2&=E_{20}\\cos(\\omega t+\\varphi_{20})\\end{aligned}\n> $$\n>\n> 则在 $P$ 点：\n>\n> $$\n> \\begin{aligned}&E_1=E_{10}\\cos(\\omega t-{\\color{green}2\\pi n_{1}r_1/\\lambda}+\\varphi_{10})\\\\ &E_2=E_{20}\\cos(\\omega t-{\\color{green}2\\pi n_{2}r_2/\\lambda}+\\varphi_{20})\\\\ &({\\color{green}2\\pi n_{i}r_{{i}}/\\lambda\\ (i=1,2)}\\text{: 从光源 }S\\text{ 到 }P\\text{ 的相位变化量})\\end{aligned}\n> $$\n>\n> 矢量合成的结果为：\n>\n> $$\n> \\begin{aligned}E_0^2=E_{10}^2+E_{20}^2+2E_{10}E_{20}\\cos\\Delta\\varphi\\\\ \\Delta\\varphi=(\\varphi_{20}-\\varphi_{10})-\\frac{2\\pi}\\lambda(n_{2}r_2-n_{1}r_1)\\end{aligned}\n> $$\n>\n> 则光发生干涉的判据为：\n>\n> $$\n> \\Delta \\varphi = \\begin{cases}\\pm 2k \\pi,\\quad &k = 0, 1, 2, \\ldots\\ (\\text{干涉加强})\\\\ \\pm (2k+1) \\pi, \\quad &k=0, 1, 2,\\ldots\\ (\\text{干涉减弱})\\end{cases}\n> $$\n>\n> 当 $\\varphi_{10} = \\varphi_{20}$ 时，用 $\\delta=n_{2}r_{2}-n_{1}r_{1}=L_2-L_{1}$ 来表示光程差，则有\n>\n> $$\n> \\delta = \\begin{cases}\\pm (2k) \\frac{\\lambda}{2},&\\quad k=0,1,2,...\\ (\\text{干涉加强})\\\\\\pm(2k+1)\\frac\\lambda2,&\\quad k=0,1,2,...\\ (\\text{干涉减弱})\\end{cases}\n> $$\n\n- 光的干涉条件：频率相同、振动方向相同、==相位差恒定==。\n  - 相干光的获得方法\n    - 分波阵面法：同一波阵面的不同部分分离出两束相干光。\n    - 分振幅法：反射光和折射光作为两束相干光。\n- <img src=\"https://img.memset0.cn/2024/11/27/FeDtxCoY.png\" align=\"right\" width=\"360\">**杨氏双缝实验**（利用分波阵面法获得相干光）\n  - 一般认为实验在真空（或空气）中进行，则光程差为：$\\delta = r_{2} - r_{1} \\approx d \\sin \\theta \\approx d \\tan \\theta = d \\cdot \\dfrac{x}{D}$。\n  - 相邻两明纹（或暗纹）的间距，实际上就是光程差改变 $\\lambda$ 的位置，有 $\\Delta x = \\dfrac{D}{d} \\lambda$。\n  - 屏中心处由于 $\\delta = r_{2}-r_{1} = 0$，是相长干涉，称为 **中央亮纹**，故有：明条纹 $x_{\\pm k}= \\pm k \\dfrac{D}{d} \\lambda$，暗条纹 $x_{\\pm k} = \\pm (2k+1) \\dfrac{D}{2d} \\lambda$。\n  - 推论：$\\Delta x\\propto\\lambda$，故复色光做实验时，红光在外，紫光在内。\n- <img src=\"https://img.memset0.cn/2024/11/27/vUQTODOM.png\" align=\"right\" width=\"190\">**洛埃镜实验**（也是利用分波阵面法获得相干光）\n  - 将屏幕移至 $NM$ 的位置，两光束到 $N$ 点的几何路径相同位相差为零，但在 $N$ 处出现的是暗点，这说明反射光有 **半波损失**。\n- **薄膜干涉**\n  - <img src=\"https://img.memset0.cn/2024/11/27/v79drNJ7.png\" align=\"right\" width=\"200\">**等倾干涉**（厚度均匀的薄膜产生的干涉）\n    - 单色光照射到平行的平面薄膜上，在 $A$ 点产生反射和折射，形成 $a,b$ 两光束，其光程差为：$\\delta = n_{2} (AC + CB) - n_{1} AD + \\delta'$。\n      - 其中 $\\delta'$ 是半波损失产生的附加光程差：\n        - 当 $n_{1}>n_{2}>n_{3}$ 或 $n_{1}<n_{2}<n_{3}$ 时，$\\delta'=0$；\n        - 当 $n_{1} < n_{2} > n_{3}$ 或 $n_{1} > n_{2} < n_{3}$ 时，$\\delta'=\\dfrac{\\lambda}{2}$。\n      - 推论：当光==垂直入射==时，光程差为：$\\color{blue}\\delta = 2n_{2} e + \\delta'$。\n  - **等厚干涉**（厚度不均匀的薄膜产生的干涉）\n    - <img src=\"https://img.memset0.cn/2024/11/28/7gzEGie5.png\" align=\"right\" width=\"220\">**劈尖膜干涉**：\n      - 设 $n$ 为中间介质折射率，$e$ 为该位置薄膜厚度，则光程差为：$\\color{blue} \\delta = 2ne + \\dfrac{\\lambda}{2}$（两束反射光应刚好一个有半波损失另一个没有）。\n      - 相邻两明纹（或暗纹）之间的距离为 $l=\\dfrac{\\lambda}{2 n \\sin \\theta}$，与膜的厚度 $e$ 无关。\n    - <img src=\"https://img.memset0.cn/2024/11/28/hQxCQUeM.png\" align=\"right\" width=\"145\">**牛顿环**：\n      - 同理，设对应位置的厚度为 $e$，则光程差也是：$\\delta = 2ne + \\dfrac{\\lambda}{2}$。\n      - 设半径为 $r$，曲率半径为 $R$，则对应厚度可以用 $\\color{blue}e \\approx \\dfrac{r^{2}}{2R}$ 近似计算。\n      - 代入解得 $k$ 级明环半径为 $r_{k}=\\sqrt{\\left( k-\\dfrac{1}{2}\\right) R \\lambda}$，$k$ 级暗环半径为 $r_{k}=\\sqrt{kR\\lambda}$，注意牛顿环中间是一个暗斑。\n- 光的干涉的应用（注意判断半波损失）\n  - 增透膜：利用薄膜干涉使反射光减小。\n  - 高反射膜：利用薄膜干涉折射光减小。\n\n## 2. Ch21 光的衍射\n\n- **光的衍射现象**：光在传播过程中，绕过障碍物而偏离了直线传播的现象。\n- <img src=\"https://img.memset0.cn/2024/11/21/sqlgveyx.png\" width=\"110\" align=\"right\">**惠更斯原理**：媒质中波源 $S$ 所到达的任一点都可以看作一个新的子波源；这些子波源向空间发射球面子波，在以后的任一时刻，这些子波的包络面就是波在该时刻的新的波阵面。——解决了波的==传播方向==问题\n- 光的衍射的分类\n  - <img src=\"https://img.memset0.cn/2024/11/28/yWNVRwwm.png\" align=\"right\" width=\"125\">**菲涅尔(近场)衍射**：是指当光源和接收屏离障碍物（衍射屏）的距离为==有限远==时，或两者之一离衍射屏的距离为==有限远==时，所发生的衍射现象。\n  - **夫琅禾费(远场)衍射**：是指衍射屏离光源和接收屏==无限远==的衍射，相当于入射光和衍射光都为平行光。实验上可利用两个透镜来实现。\n- <img src=\"https://img.memset0.cn/2024/11/29/zM3rQnWf.png\" align=\"right\" width=\"55\"><img src=\"https://img.memset0.cn/2024/11/28/6iAkSe4I.png\" align=\"right\" width=\"250\">**单缝衍射**：设平行光垂直入射单缝（如果不是垂直入射，而是存在入射角 $i$，则将下面的 $\\sin \\theta$ 替换为 $\\sin \\theta +\\sin i$）。\n  - 当 $\\theta$ 不大时，$\\sin \\theta \\approx \\tan \\theta = \\dfrac{x}{f}$。\n  - 单个半波带宽度为 $\\dfrac{\\lambda}{2}$。\n    - 明暗条纹\n      - 中央明纹中心：$\\theta=0$，注意宽度是其他明纹的两倍。\n      - 暗纹中心：$a \\sin \\theta = \\pm k \\lambda,\\quad k=1,2,\\cdots$\n      - 明纹中心：$a \\sin \\theta = \\pm (2k+1) \\dfrac{\\lambda}{2}, \\quad k=1,2,\\cdots$\n- <img src=\"https://img.memset0.cn/2024/11/29/WIw0aSlz.png\" width=\"220\" align=\"right\">**光栅衍射**：\n  - **光栅常数** $d=a+b$，其中 $a$ 为透光缝的宽度，$b$ 为不透光裂痕的宽度。\n  - **主极大明纹**：$d \\sin \\theta = \\pm k \\lambda,\\ k=0,1,2,\\cdots$ 满足该方程的 $\\theta$ 初可以看到明纹。由于 $-\\dfrac{\\pi}{2} < \\theta < \\dfrac{\\pi}{2}$，主极大明纹的个数是==有限的==。\n  - 缺级：某些衍射角 $\\theta$ 同时满足光栅方程和单缝衍射的暗纹条件吗，此时原定的主极大明纹就会变成暗纹：$\\begin{cases}a \\sin \\theta = k_{1} \\lambda \\quad \\text{(单缝衍射暗纹)}\\\\ d \\sin \\theta = k_{2} \\lambda \\quad \\text{(光栅主极大)}\\end{cases} \\Longrightarrow {\\color{blue}k_{2} = \\dfrac{d}{a} k_{1}}$。\n  - **光栅分辨本领** $\\color{blue}R=\\dfrac{\\overline{\\lambda}}{\\Delta \\lambda} = k N$。TBD。\n\n## 3. Ch22 光的偏振\n\n- 光束的分类\n  - **线偏振光**：空间各点的光矢量都沿同一个固定的方向振动。\n  - **自然光**：两个振动方向互相垂直、相位差随机、等振幅的线偏振光组合。\n  - **部分偏振光**：介于自然光和线偏振光之间，振动在各个方向上的振幅不同。\n- 偏振片：（理想偏振片）平行于指定方向的振动分量完全通过，垂直于指定方向的振动分量完全吸收。\n- <img src=\"https://img.memset0.cn/2024/11/29/IIBZ1JrS.png\" align=\"right\" width=\"120\">**马吕斯定律**：设起偏器和检偏器的偏振化方向成 $\\alpha$ 角，入射到检偏器的光强为 $I_{1}$，透射光强为 $I_{2}$，则 $\\color{blue} I = I_{0} \\cos^{2} \\alpha$。\n  - 当 $\\alpha=0$ 时 $I=I_{\\max} = I_{0}$；当 $\\alpha=\\dfrac{\\pi}{2}$ 时，$I=0$。\n- <img src=\"https://img.memset0.cn/2024/11/29/SAC1oLiB.png\" align=\"right\" width=\"195\">**布儒斯特定律**：当光线以 $i_{B}$ （称为 **布儒斯特角**）入射并且满足 $\\color{blue}i_{B} +r =90\\degree$ 时，反射光线是完全偏振光，而折射光线仍是部分偏振光，且 $\\color{blue}\\tan i_{B}=\\dfrac{n_{2}}{n_{1}}=n_{21}$。\n","publishedTitle":"「大学物理(乙)」VIII. 光学"}},{"id":"e9568e1a-3a4f-5d38-8f22-58824a89b96e","fields":{"slug":"/course/ptms/note/1/","plainText":"\n> 本篇笔记主要介绍了概率论的基本概念。首先定义了随机试验、样本空间和随机事件等基础术语。然后详细讨论了事件之间的关系和运算，包括包含、相等、和事件、积事件等。接着引入了频率的概念及其性质，作为概率的基础。最后给出了概率的严格定义及其基本性质。这些内容为后续学习概率论奠定了重要基础。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 概率论的基本概念\n\n- <span class=\"m-definition\">(样本空间)</span> 将随机试验 $E$ 的所有可能结果组成的集合称为 **样本空间**，记为 $S$，样本空间的元素，即 $E$ 的每个结果，称为 **样本点**。\n- <span class=\"m-definition\">(随机事件)</span> 称试验 $E$ 的样本空间 $S$ 的子集为 **随机事件**，简称 **事件**。在每次试验中，当且仅当这个集合中的一个样本点出现时，称这一事件 **发生**。\n    - 由一个样本点组成的事件称为 **基本事件**。\n    - 样本空间 $S$ 包含所有的样本点，则每次试验中 $S$ 总是发生，称 $S$ 为 **必然事件**。\n    - 空集 $\\varnothing$ 不包含任何样本点，每次试验 $\\varnothing$ 都不发生，称 $\\varnothing$ 为 **不可能事件**。\n- <span class=\"m-definition\">(事件的关系与运算)</span> 设试验 $E$ 的样本空间为 $S$，而 $A,B,A_k \\subset S$。\n    - 若 $A \\subset B$，则称事件 $B$ **包含** 事件 $A$，事件 $A$ 的发生必导致事件 $B$ 发生。\n        - 若 $A \\subset B \\land B \\subset A$ 即 $A = B$，则称事件 $A$ 与事件 $B$ **相等**。\n    - 事件 $A \\cup B = \\{x \\mid x \\in A \\text{ or } x \\in B\\}$ 称为事件 $A$ 与事件 $B$ 的 **和事件**，当且仅当 $A,B$ 中至少有一个发生时，事件 $A \\cup B$ 发生。\n    - 事件 $A \\cap B = \\{x \\mid x \\in A \\text{ and } x \\in B\\}$ 称为事件 $A$ 与事件 $B$ 的 **积事件**，也记作 $AB$。称 $\\bigcap_{k=1}^n A_k$ 为可列个事件 $A_1, A_2, \\cdots$ 的积事件。\n    - 事件 $A - B = \\{x \\mid x \\in A \\text{ and } x \\notin B\\}$ 称为事件 $A$ 与事件 $B$ 的 **差事件**。\n    - 若 $A \\cap B = \\varnothing$，则称事件 $A$ 与事件 $B$ **互不相容** 或 **互斥** 的。\n    - 若 $A \\cup B = S\\land A \\cap B = \\varnothing$，则称事件 $A$ 与事件 $B$ 互为 **逆事件**，又称事件 $A$ 与事件 $B$ 互为 **对立事件**。\n- <span class=\"m-definition\">(频率)</span> 在相同的条件下，进行了 $n$ 次试验。在这 $n$ 次试验中，事件 $A$ 发生的次数 $n_A$ 称为事件 $A$ 发生的 **频数**。比值 $n_A/n$ 称为事件 $A$ 发生的 **频率**，并记做 $f_n(A)$。\n    - <span class=\"m-proposition\">(频率的基本性质)</span>\n        - $0 \\leq f_n(A) \\leq 1$\n        - $f_n(S) = 1$\n        - 若 $A_1, \\cdots, A_k$ 是两两互不相容的事件，则 $f_n(A_1 \\cup \\cdots \\cup A_k) = f_n(A_1) + \\cdots + f_n(A_k)$\n    - 频率 $f_n(A)$ 反映了事件 $A$ 发生的 **频繁程度**。\n- <span class=\"m-definition\">(概率)</span> 设 $E$ 是随机试验，$S$ 是它的样本空间。对于 $E$ 的每一事件 $A$ 赋予一个实数，记为 $P(A)$，称为事件 $A$ 的 **概率**，如果集合函数 $P(\\cdot)$ 满足：① **非负性**：对于每一事件 $A$，有 $P(A) \\geq 0$；② **规范性**：对于必然事件，有 $P(S) = 1$；③ **可列可加性**：设 $A_1, A_2, \\cdots$ 是两两互不相容事件，有 $\\displaystyle{P(A_1 \\cup A_2 \\cup \\cdots) = P(A_1) + P(A_2) +  \\cdots}$。\n    - <span class=\"m-proposition\">(概率的加法公式)</span> $P(A\\cup B)=P(A)+P(B)-P(AB)$，可以推广到更一般情形。\n- <span class=\"m-definition\">(古典概型)</span> 若试验的样本空间==只包含有限个元素==且其中每个基本事件发生的可能性相同。则称这种试验为 **古典概型** 或 **等可能概型**。\n    - <span class=\"m-theorem\">(实际推断定理)</span> 人们在长期的实践中总结得到“概率很小的事件在一次试验中实际上几乎是不发生的”。如果我们计算出一个事件发生的概率极低，则可以认为这一事件不会发生。\n- <span class=\"m-definition\">(独立试验)</span> 指任一次子试验出现的结果都不影响其他各子试验出现的结果。\n- <span class=\"m-definition\">(重复试验)</span> 如果各子试验是在相同条件下进行的。\n\n## 2. 条件概率与独立性\n\n- <span class=\"m-definition\">(条件概率)</span> 设 $A,B$ 是两个事件，且 $P(A) > 0$。称 $\\displaystyle{P(B|A) = \\frac{P(AB)}{P(A)}}$ 为在事件 $A$ 发生的条件下事件 $B$ 发生的 **条件概率**。\n    - <span class=\"m-proposition\">(条件概率的性质)</span> 条件概率 $P(\\cdot\\vert A)$ 符合概率的所有性质：\n        - **非负性**：对于每一事件 $B$，有 $P(B|A) \\geq 0$\n        - **规范性**：对于必然事件 $S$，有 $P(S|A) = 1$\n        - **可列可加性**：设 $B_1, B_2, \\cdots$ 是两两互不相容事件，则有 $\\displaystyle{P\\left(\\bigcup_{i=1}^\\infty B_i|A\\right) = \\sum_{i=1}^\\infty P(B_i|A)}$\n    - <span class=\"m-theorem\">(乘法公式)</span> 设 $P(A) > 0$，则有 $P(AB) = P(B|A)P(A)$。\n        - 更一般地，设 $A_1, \\cdots, A_n$ 为 $n$ 个事件，$n \\geq 2$，且 $P(A_1 \\cdots A_{n-1}) > 0$，则有 $\\displaystyle{P(A_1 \\cdots A_n) = P(A_n|A_1 \\cdots A_{n-1})P(A_{n-1}|A_1 \\cdots A_{n-2}) \\cdots P(A_2|A_1)P(A_1)}$。\n- <span class=\"m-definition\">(划分)</span> 设 $S$ 为试验 $E$ 的样本空间，$B_{1},\\cdots,B_{n}$ 为 $E$ 的一组事件，若满足：① 对于任意 $i\\neq j$，$B_i\\cap B_{j}=\\varnothing$；② $B_{1}\\cup B_{2}\\cup \\cdots B_{n}=S$。则称 $B_{1},\\cdots,B_{n}$ 为样本空间 $S$ 的一个 **划分**。\n- <span class=\"m-theorem\">(全概率公式)</span> 设试验 $E$ 的样本空间为 $S$，$A$ 为 $E$ 的事件，$B_1,\\ldots,B_n$ 为 $S$ 的一个划分，且 $P(B_i) > 0$，则 $P(A) = P(A|B_1)P(B_1) + \\cdots + P(A|B_n)P(B_n)$。\n- <span class=\"m-theorem\">(贝叶斯公式)</span> 设试验 $E$ 的样本空间 $S$，$A$ 为 $E$ 的事件，$B_1, \\cdots, B_n$ 为 $S$ 的一个划分，$P(B_i) > 0$，且更进一步地有 $P(A) > 0$ 则 $\\displaystyle{P(B_i|A) = \\frac{P(A|B_i)P(B_i)}{\\sum_{j=1}^n P(A|B_j)P(B_j)}}$。\n    - 特别地，取 $n = 2$，则：\n        - $P(A) = P(A|B)P(B) + P(A|\\overline{B})P(\\overline{B})$\n        - $\\displaystyle{P(B|A) = \\frac{AB}{A} = \\frac{P(A|B)P(B)}{P(A|B)P(B) + P(A|\\overline{B})P(\\overline{B})}}$\n    - 所以说贝叶斯公式，解决的是==由果溯因==的推理。\n- <span class=\"m-definition\">(相互独立)</span> 设 $A, B$ 是两事件，如果满足 $P(AB) = P(A)P(B)$ 则称事件 $A, B$ **相互独立**，简称 $A, B$ **独立**。\n    - <span class=\"m-definition\"></span> 更一般地，设 $A_1, \\cdots, A_n$ 为 $n$ 个随机事件，如果对于其中任意 $2, 3,\\cdots , n$ 个事件的积事件的概率，都等于各事件概率之积，则称事件 $A_1, \\cdots, A_n$ **相互独立**。\n        - 对于 $n$ 个随机事件，相互独立可以推出两两独立，但是两两独立==不能推出==相互独立。\n    - <span class=\"m-proposition\"></span> 设 $A, B$ 是两事件，且 $P(A) > 0$，若 $A, B$ 相互独立，则 $P(B|A) = P(B)$。\n    - <span class=\"m-proposition\"></span> 若事件 $A, B$ 相互独立，则 $A$ 与 $\\overline{B}$、$\\overline{A}$ 与 $B$、$\\overline{A}$ 与 $\\overline{B}$ 也相互独立。\n","publishedTitle":"「概率论与数理统计」I. 概率论的基本概念"}},{"id":"fd819593-c34e-5c2d-8dbc-ed085347e611","fields":{"slug":"/course/ptms/note/2/","plainText":"\n> 本篇笔记主要介绍了随机变量及其分布的基本概念，包括离散型随机变量和连续型随机变量的定义、性质及其分布律。内容涵盖了两点分布、二项分布、泊松分布、均匀分布、指数分布和正态分布等重要分布类型，并详细阐述了每种分布的概率密度函数和分布函数的性质。通过这些内容，读者可以更好地理解随机变量的行为及其在概率论中的应用。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 离散型随机变量及其分布\n\n- <span class=\"m-definition\">(随机变量)</span> 设随机试验的样本空间为 $S = \\{e\\}$, $X = X(e)$ 是定义在样本空间 $S$ 上的实值单值函数，则称 $X = X(e)$ 为 **随机变量**。\n- <span class=\"m-definition\">(概率分布函数)</span> 设 $X$ 是一个随机变量，$x$ 是任意实数，称 $\\displaystyle{F(x) = P\\{X \\leq x\\}, -\\infty < x < \\infty}$ 为 $X$ 的 **分布函数**。\n  - 对于任意实数 $x_1, x_2(x_1 < x_2)$，有 $P\\{x_1 < X \\leq x_2\\} = P\\{X \\leq x_2\\} - P\\{X \\leq x_1\\} = F(x_2) - F(x_1)$。\n- <span class=\"m-definition\">(离散型随机变量)</span> 称取值至多可数的随机变量为 **离散型随机变量**。\n- <span class=\"m-definition\">(分布律)</span> 设离散型随机变量 $X$ 所有可能取的值为 $x_k (k = 1,2,...)$，$X$ 取各个可能值的概率，即事件 $\\{X = x_k\\}$ 的概率，为离散型随机变量 $X$ 的 **分布律**：$P\\{X=x_{k}\\}=p_{k},\\space k=1,2,\\ldots$。\n  - <span class=\"m-proposition\">(分布律的基本性质)</span>\n    - $p_{k} \\geq 0,\\space k=1,2,\\ldots$\n    - $\\sum_{k=1}^{\\infty} p_{k} = 1$\n  - 分布律也可以以表格的形式表示。\n- <span class=\"m-definition\">(两点分布)</span> 设随机变量 $X$ 服从以 $p\\ (0<p<1)$ 为参数的 **(0-1) 分布** 或 **两点分布**，记为 $X\\sim B(1,p)$，则 $X$ 只能取 $0$ 或 $1$ 两个值。\n  - 分布律：$P\\{X=k\\}=p^{k} (1-p)^{1-k}\\ (k\\in \\{ 0,1 \\})$（即 $k=1$ 的概率为 $p$，$k=0$ 的概率为 $1-p$）\n  - <span class=\"m-definition\">(伯努利实验)</span> 设试验 $E$ 只有两个可能结果：$A$ 及 $\\bar{A}$，则称 $E$ 为 **伯努利试验**。设 $P(A) = p\\space (0 < p < 1)$，则 $P(\\bar{A} )= 1 - p$。\n- <span class=\"m-definition\">(二项分布)</span> 设随机变量 $X$ 服从以 $p,n\\ (0<p<1,\\ n\\in \\mathbb{N}_{+})$ 为参数的 **二项分布**，记为 $X \\sim B(n,p)$。\n  - 分布律：$\\displaystyle{P\\{ X=k \\}=\\binom nk p^{k} (1-p)^{n-k}}$\n  - <span class=\"m-definition\">($n$ 重伯努利试验)</span> 将伯努利实验独立重复地进行 $n$ 次，称这一串重复的独立试验为 **$\\boldsymbol{n}$ 重伯努利试验**。\n- <span class=\"m-definition\">(泊松分布)</span> 设随机变量 $X$ 服从参数为 $\\lambda\\ (\\lambda>0)$ 的 **泊松分布**，记为 $X\\sim \\Pi(\\lambda)$ 或 $X\\sim P(\\lambda)$。\n  - 分布律：$\\displaystyle{P\\{X = k\\} = \\frac{\\lambda^k e^{-\\lambda}}{k!},\\quad k=0,1,2,\\cdots}$\n    - $\\displaystyle{\\sum_{k=0}^{\\infty} P\\{X = k\\} = \\sum_{k=0}^{\\infty} \\frac{\\lambda^k}{k!} = e^{-\\lambda} \\sum_{k=0}^{\\infty} \\frac{\\lambda^k}{k!} = e^{-\\lambda} e^{\\lambda} = 1}$\n  - <span class=\"m-theorem\">(泊松定理)</span> 设 $\\lambda>0$ 是一个常数，$n$ 是任意正整数，设 $np_{n} = \\lambda$，则对于任意固定的非负整数 $k$，有 $\\displaystyle{\\lim_{n \\to \\infty} \\binom{n}{k} p_n^k (1-p_n)^{n-k} = \\frac{\\lambda^k e^{-\\lambda}}{k!}}$。也就是说以 $n,p$ 为参数的二项分布的概率值可以由参数为 $\\lambda=np$ 的泊松分布的概率值近似。\n\n## 2. 连续型随机变量及其分布\n\n- <span class=\"m-definition\">(概率密度函数)</span> 如果对于随机变量 $X$ 的分布函数 $F(x)$，存在非负函数 $f(x)$ 使对于任意实数 $x$ 有 $\\displaystyle{F(x) = \\int_{-\\infty}^x f(t)\\text dt}$。则称 $X$ 为 **连续型随机变量**，其中函数 $f(x)$ 称为 $X$ 的 **概率密度函数**，简称 **概率密度**。\n  - <span class=\"m-proposition\">(概率密度函数的基本性质)</span>\n    - $f(x)\\geq0$\n    - $\\displaystyle{\\int_{-\\infty}^{\\infty} f(x) \\text{d}x} = 1$\n    - 对于任意实数 $x_{1},x_{2}\\ (x_{1}\\leq x_{2})$，有 $\\displaystyle{ P\\{x_1 < X \\leq x_2\\} = F(x_2) - F(x_1) = \\int_{x_1}^{x_2} f(x)\\text dx}$\n    - 若 $f(x)$ 在点 $x$ 处连续，则 $F'(x) = f(x)$。\n- <span class=\"m-definition\">(均匀分布)</span> 设连续型随机变量 $X$ 在区间 $(a,b)$ 上服从 **均匀分布**，记为 $X \\sim U(a,b)$。\n  - 概率密度函数：$\\displaystyle{f(x) = \\begin{cases}\\dfrac{1}{b-a} & a < x < b, \\\\ 0 & \\text{other.}\\end{cases}}$\n  - 概率分布函数：$\\displaystyle{F(x) = \\begin{cases}0 & x < a, \\\\\\dfrac{x-a}{b-a} & a \\leq x < b, \\\\1 & x \\geq b.\\end{cases}}$\n- <span class=\"m-definition\">(指数分布)</span> 设连续型随机变量 $X$ 服从参数为 $\\lambda\\ (\\lambda>0)$ 的 **指数分布**，记为 $X \\sim \\operatorname*{Exp}(\\lambda)$ 或 $X \\sim E(\\lambda)$。\n  - 概率密度函数：$\\displaystyle{f(x) = \\begin{cases}\\lambda e^{- x \\lambda} & x > 0,\\\\0 & x \\leq 0.\\end{cases}}$\n  - 概率分布函数：$\\displaystyle{F(x) = \\begin{cases}1 - e^{-x \\lambda} & x > 0 ,\\\\0 & x \\leq 0.\\end{cases}}$\n  - <span class=\"m-proposition\"></span> 期望：$E(X)=\\dfrac{1}{\\lambda}$；方差 $D(X)=\\dfrac{1}{\\lambda^{2}}$。\n  - <span class=\"m-proposition\"></span> $k$ 阶（原点）矩：$E(X^{k})=\\dfrac{k!}{\\lambda^{k}}$。\n  - <span class=\"m-proposition\">(指数分布的无记忆性)</span> 设 $X$ 服从指数分布，则 $\\forall s, t > 0$，有 $P\\{X > s + t|X > s\\} = P\\{X > t\\}$，这种性质称为 **无记忆性**。\n    - <span class=\"m-example\"></span> 如果 $X$ 表示元件寿命，无记忆性说明只要元件还没坏掉，那么元件剩余寿命仍服从参数为 $\\lambda$ 的指数分布。\n- <span class=\"m-definition\" data-content=\"正态分布\"></span> 设连续型随机变量 $X$ 服从参数为 $\\mu,\\sigma^{2}\\ (\\sigma>0)$ 的 **正态分布** 或 **高斯分布**，记为 $X \\sim N(\\mu, \\sigma^{2})$。\n  - 概率密度函数：$\\displaystyle{f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}},\\ -\\infty < x < \\infty}$\n  - <span class=\"m-proposition\" data-content=\"正态分布的基本性质\"></span>\n    - $f(x)$ 关于直线 $x=\\mu$ 对称。\n    - $f_{\\max} = f(\\mu) = \\dfrac{1}{\\sqrt{2\\pi}\\sigma}$\n    - $\\displaystyle{\\lim_{ |x-\\mu| \\to \\infty } f(x) = 0}$\n    - 推论：$E(X^2)=\\mu^{2} + \\sigma^{2}$。\n  - 当固定 $\\sigma$，调整 $\\mu$ 时，函数图像可以看作沿着 $x$ 轴的平移变换；当固定 $\\mu$ 调整 $\\sigma$ 时，函数图像可以看做 $y$ 轴方向上的拉伸变换，且 $\\sigma$ 越小，图形越高越瘦，$\\sigma$ 越大，图形越矮越胖。\n  - 设 $\\displaystyle{\\Phi(x) = \\frac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^x e^{-t^2/2}dt}$，则 $P(X\\leq b) = \\Phi \\left( \\dfrac{b-\\mu}{\\sigma} \\right)$。当 $X \\sim N(\\mu,\\sigma)$ 时 $\\dfrac{X-\\mu}{\\sigma} \\sim N(0,1)$，故 $\\Phi(x)$ 是常值函数。\n    - 需背诵：$\\Phi(0) = 0.5$，$\\Phi(1) = 0.8413$，$\\Phi(2) = 0.9772$，$\\Phi(3) = 0.9987$。\n    - <span class=\"m-proposition\"></span> $\\Phi(-x) = 1-\\Phi(x)$。\n  - <span class=\"m-proposition\"></span> 若 $X \\sim N(\\mu,\\sigma^{2})$，$Y=aX + b$，则 $Y \\sim N(a \\mu +b, a^{2} \\sigma^{2})$。\n- <span class=\"m-theorem\"></span> 设随机变量 $X$ 具有概率密度 $f_X(x)$, $-\\infty < x < \\infty$, 又设函数 $g(x)$ 处处可导且恒有 $g'(x) > 0$ (或恒有 $g'(x) < 0$), 则 $Y = g(x)$ 是连续型随机变量，且其概率密度为 $$\\displaystyle{f_Y(y) = \\begin{cases}f_X[h(y)]|h'(y)|, & \\alpha < y < \\beta ,\\\\0, & \\text{other.}\\end{cases}}$$ 其中 $h(y)$ 是 $g(x)$ 的反函数，$\\alpha = \\min\\{g(-\\infty), g(+\\infty)\\}$, $\\beta = \\max\\{g(-\\infty), g(+\\infty)\\}$。\n  - 解决类似问题，关键在于找==等价事件==。在这一过程中，常常需要通过==转化成概率分布函数==作为媒介。\n\n> [!example]- 证明：正态分布的概率密度函数积分为 1\n>\n> 令 $(x-\\mu)/\\sigma = t$, 记 $I = \\int_{-\\infty}^{\\infty} e^{-t^2/2} \\text{d} t$，则有\n>\n> $$\n> I^2 = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} e^{-(t^2+u^2)/2} \\text{d} t\\text{d} u\n> $$\n>\n> 利用极坐标得\n>\n> $$\n> I^2 = \\int_0^{2\\pi} \\int_0^{\\infty} re^{-r^2/2} \\text{d}  r\\text{d}  \\theta = 2\\pi\n> $$\n","publishedTitle":"「概率论与数理统计」II. 随机变量及其分布"}},{"id":"0b61b0df-30d8-58a8-a1da-c038d9cfd7f9","fields":{"slug":"/course/ptms/note/3/","plainText":"\n> 本篇笔记主要介绍了多元随机变量及其分布的相关概念。首先讨论了二元随机变量的基本定义，包括离散型和连续型随机变量的联合分布、边际分布和条件分布。其次介绍了二元正态分布这一重要的特例。随后探讨了多元随机变量的独立性概念及其判定方法。最后讨论了多元随机变量函数的分布问题，包括和、商、积以及最大最小值等情形的分布推导方法。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 二元随机变量及其分布\n\n- <span class=\"m-definition\">(二元随机变量)</span> 设 $E$ 是一个随机试验，样本空间是 $S = \\{e\\}$，设 $X = X(e)$，$Y = Y(e)$ 是定义在 $S$ 上的随机变量，由它们构成向量的 $(X,Y)$ 叫 **二元随机变量**。\n- <span class=\"m-definition\">(二元离散型随机变量)</span> 若二元随机变量 $(X,Y)$ 全部可能取到的不同值是有限对或可列无限对，则称 $(X,Y)$ 是 **二元离散型随机变量**。\n- <span class=\"m-definition\">(联合分布律)</span> 设二元离散型随机变量 $(X,Y)$ 的所有可能取值为 $(x_{i},y_{j})\\,\\quad i,j=1,2,\\cdots$，设 $p_{ij} = P(X=x_{i},Y=y_{j})$ 为 $(X,Y)$ 的 **联合(概率)分布律**。\n  - <span class=\"m-proposition\">(联合分布律的性质)</span>\n    - $p_{ij} \\geq 0\\quad i,j=1,2,\\cdots$\n    - $\\displaystyle{\\sum_{i=1}^{\\infty} \\sum_{j=1}^{\\infty} p_{ij} = 1}$\n    - <span class=\"m-definition\">(边际分布律)</span> 在上述条件下，设 $(X,Y)$ 的 **边际(概率)分布律** 为 $P(Y=y_{j})=P(X<\\infty,Y=y_{j})=p_{\\cdot j}$ 和 $P(X=x_{i})=P(X=x_{i},Y<\\infty) = p_{i\\cdot}$。\n    - <span class=\"m-definition\">(条件分布律)</span> 在上述条件下，设 $(X,Y)$ 的 **条件(概率)分布律** 为 $P(X=x_{i}\\mid Y=y_{j})=\\dfrac{p_{ij}}{p_{\\cdot j}}$ 和 $P(Y=y_{j}\\mid X=x_{i})=\\dfrac{p_{ij}}{p_{i\\cdot}}$。\n- <span class=\"m-definition\">(联合分布函数)</span> 设 $(X,Y)$ 为二元随机变量，对于任意实数 $x,y$，二元函数 $F(x,y)=P\\{ (X\\leq x) \\cap (Y\\leq y) \\}=P(X\\leq x,Y\\leq y)$ 称为二元随机变量 $(X,Y)$ 的 **联合(概率)分布函数**。\n  - <span class=\"m-proposition\">(联合分布函数的性质)</span>\n    - $F(x,y)$ 关于 $x,y$ 分别单调不减\n    - $0\\leq F(x,y)\\leq 1,\\ F(+\\infty,+\\infty)=1$ 且对任意 $x,y$，$F(-\\infty,y)=F(x,-\\infty)=F(-\\infty,-\\infty)=0$\n    - $F(x,y)$ 关于 $x,y$ 右连续，即 $\\displaystyle{\\lim_{ \\varepsilon \\to 0^{+} } F(x+\\varepsilon,y) = \\lim_{ \\varepsilon \\to 0^{+} } F(x,y+\\varepsilon)=F(x,y)}$\n    - 若 $x_{1}<x_{2},y_{1}<y_{2}$，则 $F(x_{2},y_{2})-F(x_{2},y_{1})-F(x_{1},y_{2})+F(x_{1},y_{1})= P(x_{1}<X\\leq x_{2},y_{1}<Y\\leq y_{2}) \\geq 0$\n  - <span class=\"m-definition\">(边际分布函数)</span> 在上述条件下，设 $X,Y$ 的 **边际(概率)分布函数** 分别为 $F_{X}(x) = F(x,+\\infty)$ 和 $F_{Y}(y) = F(+\\infty,y)$。\n  - <span class=\"m-definition\">(条件分布函数)</span> 在上述条件下，设 $X,Y$ 的 **条件(概率)分布函数** 分别为 $F_{X\\mid Y}(x\\mid y)=P(X\\leq x\\mid Y=y)=\\dfrac{P(X\\leq x,Y=y)}{P(Y=y)}$。特别地，若 $P(Y=y)=0$，则记 $\\displaystyle{P(X\\leq x\\mid Y=y)=\\lim_{ \\varepsilon \\to 0^{+}} \\dfrac{P(X\\leq x,y<Y<y+ \\varepsilon)}{P(y<Y<y+\\varepsilon)}}$。\n- <span class=\"m-definition\">(联合密度函数)</span> 对于二元随机变量 $(X,Y)$，如果存在非负函数 $f(x,y)$ 使对于任意 $(x,y)$ 满足 $\\displaystyle{F(x,y)=\\int_{-\\infty}^{y}\\int_{-\\infty}^{x} f(u,v) \\text{d}u\\text{d}v}$，则称 $(X,Y)$ 为 **二元连续型随机变量**，称 $f(x,y)$ 为二元随机变量的 **联合(概率)密度函数**。\n  - <span class=\"m-proposition\">(联合密度函数的性质)</span>\n    - $f(x,y) \\geq 0$\n    - $\\displaystyle{\\int_{-\\infty}^{+\\infty} \\int_{-\\infty}^{+\\infty} f(x,y) \\text{d} x \\text{d}y = 1}$\n    - 设 $G$ 是平面上区域，则 $(X,Y)$ 落在 $G$ 内的概率 $\\displaystyle{P\\{ (X,Y) \\in G \\} = \\iint_{G} f(x,y) \\text{d}x\\text{d}y}$\n    - 在 $f(x,y)$ 的连续点 $(x,y)$，有 $\\dfrac{\\partial^{2} F(x,y)}{\\partial x \\partial y} = f(x,y)$\n  - <span class=\"m-definition\">(边际密度函数)</span> 在上述条件下，设 $X,Y$ 的 **边际(概率)密度函数** 分别为 $\\displaystyle{f_{X} (x) = \\int_{-\\infty}^{\\infty} f(x,y) \\text{d}y=\\int_{-\\infty}^{x} f_{X} (u) \\text{d}u}$ 和 $f_{Y} (y) = \\displaystyle{\\int_{-\\infty}^{+\\infty} f(x,y) \\text{d} x=\\int_{-\\infty}^{y} f_{Y} (v)\\text{d}v}$。\n  - <span class=\"m-definition\">(条件密度函数)</span> 在上述条件下，设 $X,Y$ 的 **条件(概率)密度函数** 分别为 $f_{X\\mid Y}(x\\mid y)=\\dfrac{f(x,y)}{f_{Y}(y)},\\ f_{Y}(y)>0$ 和 $f_{Y\\mid X}(y\\mid x)=\\dfrac{f(x,y)}{f_{X}(x)},\\ f_{X}(x)>0$。\n    - <span class=\"m-proposition\">(条件密度函数的性质)</span>\n      - $f_{X\\mid Y} (x\\mid y)\\geq0$\n      - $\\displaystyle{\\int_{-\\infty}^{+\\infty} f_{X\\mid Y} (x \\mid y) \\text{ d}x = 1}$\n      - $P\\{a<X<b \\mid Y=y\\} = \\displaystyle{ \\int_{a}^{b} f_{X\\mid Y} (x\\mid y)\\text{d}x }$\n      - 在 $f_{X \\mid Y} (x\\mid y)$ 的连续点 $x$，有 $\\dfrac{\\text{d} F_{X\\mid Y}(x \\mid y)}{\\text{d}x} =f_{X \\mid Y} (x\\mid y)$\n      - $f(x,y) = f_{X\\mid Y}(x \\mid y) f_{Y} (y) = f_{X}(x) f_{Y\\mid X} (y \\mid x)$\n- <span class=\"m-definition\">(二元正态分布)</span> 设二元随机变量 $(X,Y)$ 的概率密度函数为 $\\displaystyle{f(x,y) = \\dfrac{1}{2\\pi \\sigma_{1} \\sigma_{2} \\sqrt{1-\\rho^{2}}} \\cdot \\exp \\left( -\\dfrac{1}{2(1-\\rho^{2})}  \\left( \\frac{\\left(x-\\mu_1\\right)^2}{\\sigma_1^2}-2\\rho\\frac{\\left(x-\\mu_1\\right)\\left(y-\\mu_2\\right)}{\\sigma_1\\sigma_2}+\\frac{\\left(y-\\mu_2\\right)^2}{\\sigma_2^2} \\right)\\right)}$ $\\quad (-\\infty<x<+\\infty,\\ -\\infty<y<+\\infty)$ 其中 $\\mu_{1},\\mu_{2},\\sigma_{1},\\sigma_{2},\\rho$ 都是常数，且 $\\sigma_{1}>0,\\sigma_{2}>0,-1<\\rho<1$；称 $(X,Y)$ 为服从参数为 $\\mu_{1},\\mu_{2},\\sigma_{1},\\sigma_{2},\\rho$ 的 **二元正态分布**，记为 $(X,Y) \\sim N(\\mu_{1},\\mu_{2},\\sigma_{1}^{2},\\sigma_{2}^{2},\\rho )$。\n  - 图例：  \n     ![|420](https://img.memset0.cn/2024/12/04/92IynnLw.png)\n\n## 2. 多元随机变量的独立性\n\n- <span class=\"m-definition\">(二元随机变量的独立性)</span> 设 $F(x,y)$ 及 $F_{X}(x),F_{Y}(y)$ 分别是随机变量 $(X,Y)$ 的联合分布函数及边际分布函数，若对所有实数 $x,y$ 都有 $P(X\\leq x,Y\\leq y)=P(X\\leq x)P(Y\\leq y)$，即 $F(x,y)=F_{X}(x)F_{Y}(y)$，则称随机变量 $X,Y$ **相互独立**。\n  - 若 $(X,Y)$ 是离散型随机变量，则 $X,Y$ 相互独立的条件等价于 $p_{ij}=p_{i\\cdot}p_{\\cdot j}$ 对一切 $i,j$ 都成立。\n  - 若 $(X,Y)$ 是连续型随机变量，则 $X,Y$ 相互独立的条件等价于 $f(x,y)=f_{X}(x)f_{Y}(y)$ 在平面上除去“零面积”集以外处处成立。\n  - <span class=\"m-theorem\"></span> 连续型随机变量 $X,Y$ 相互独立的充分必要条件是存在连续函数 $m(\\cdot),n(\\cdot)$ 使得 $f(x,y)=m(x)\\cdot n(y),\\ |x|<+\\infty,|y|<+\\infty$。\n\n> [!example]- 证明：对于二维正态随机变量 $(X,Y)$，$X$ 与 $Y$ 相互独立的充要条件是参数 $\\rho=0$。\n> TBD\n\n## 3. 多元随机变量的函数的分布\n\n- $Z=X+Y$ 的情形\n  - <span class=\"m-definition\">(卷积公式)</span> 设连续型随机变量 $(X,Y)$ 的密度函数为 $f(x,y)$ 且 $X$ 与 $Y$ ==相互独立==，则 $Z=X+Y$ 的密度函数为 $\\displaystyle{f_{Z}(z)=\\int_{-\\infty}^{+\\infty} f_{X}(z-y)f_{Y}(y) \\text{d}y=\\int_{-\\infty}^{\\infty} f_{X}(x)f_{Y}(z-x)\\text{d}x}$，称为 **卷积公式**。\n    - <span class=\"m-corollary\"></span> 设 $X$ 与 $Y$ 相互独立且 $X \\sim N(\\mu_{1},\\sigma_{1}^{2}),\\ Y\\sim N(\\mu_{2},\\sigma_{2}^{2})$，则 $aX+bY+c\\sim N(a\\mu_{1}+b\\mu_{2}+c,a^{2}\\sigma_{1}^{2}+b^{2}\\sigma_{2}^{2})$。\n- $Z=\\dfrac{Y}{X}$ 或 $Z=XY$ 的情形：\n  - $Z=\\dfrac{Y}{X}$ 的概率密度函数为：$\\displaystyle{f_{Z}(z)=\\int_{-\\infty}^{+\\infty} |x| f(x,xz)\\text{d}x}$\n  - $Z=XY$ 的概率密度函数为：$\\displaystyle{f_{Z} (z) = \\int_{-\\infty}^{+\\infty} \\dfrac{1}{|x|} f \\left( x, \\dfrac{z}{x} \\right) \\text{d}x}$\n- $M=\\max \\{ X,Y \\}$ 或 $N=\\min \\{ X,Y \\}$ 的情形\n  - 设 $X,Y$ 是两个==相互独立==的随机变量，则 $M=\\max \\{ X,Y\\}$ 的分布函数为 $F_{M}(z) = F_{X}(z)F_{Y}(z)$；$N=\\min \\{ X,Y \\}$ 的分布函数为 $F_{N}(z)=1-(1-F_{X}(z))(1-F_{Y}(z))$。\n","publishedTitle":"「概率论与数理统计」III. 多元随机变量及其分布"}},{"id":"87c03518-cfc4-5365-b91d-a764ab939834","fields":{"slug":"/course/ptms/note/4/","plainText":"\n> 本篇笔记介绍了随机变量的三个重要数字特征：数学期望、方差和协方差。首先讨论了离散型和连续型随机变量的数学期望定义及其性质，包括线性性和独立变量的期望。其次介绍了方差和标准差的概念、计算方法以及切比雪夫不等式，并总结了常见分布的均值与方差。最后探讨了协方差与相关系数，阐述了它们的计算公式、基本性质，以及在描述随机变量之间线性关系中的重要作用。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 数学期望\n\n- <span class=\"m-definition\">(数学期望)</span> 对于离散型随机变量 $X$，设其分布律为 $P(X=x_{k}) = p_{k}$，若级数 $\\displaystyle{\\sum_{k=1}^{+\\infty} x_{k} p_{k}}$ ==绝对收敛==，则称 $\\displaystyle{\\sum_{k=1}^{+\\infty} x_{k} p_{k}}$ 的值为 $X$ 的 **数学期望**，记为 $E(X)$；对于离散型随机变量 $X$，设其密度函数为 $f(x)$，若积分 $\\displaystyle{\\int_{-\\infty}^{\\infty} x f(x) \\text{d}x}$ ==绝对收敛==，则称 $\\displaystyle{\\int_{-\\infty}^{\\infty} x f(x) \\text{d}x}$ 的值为 $X$ 的 **数学期望**。\n- <span class=\"m-theorem\"></span> 随机变量函数的数学期望：\n  - 设 $X$ 是离散型随机变量且 $E(Y)$ 存在，则有 $\\displaystyle{E(Y)=E(g(X))=\\sum_{k=0}^{+\\infty} g(x_k) p_{k}}$。\n  - 设 $X$ 是连续型随机变量且 $E(Y)$ 存在，则有 $\\displaystyle{E(Y)=E(g(X))=\\int_{-\\infty}^{+\\infty} g(x) f(x) \\text{d}x}$。\n  - 设 $(X,Y)$ 是二元离散型随机变量且 $E(Z)$ 存在，则有 $\\displaystyle{E(Z)=E(h(X,Y))=\\sum_{i=1}^{\\infty} \\sum_{j=1}^{\\infty} h(x_{i},y_{j}) p_{ij}}$。\n  - 设 $(X,Y)$ 是二元连续型随机变量且 $E(Z)$ 存在，则有 $E(Z)=E(h(X,Y))=\\displaystyle{\\int_{-\\infty}^{+\\infty} \\int_{-\\infty}^{+\\infty} h(x,y) f(x,y) \\text{d}x\\text{d}y}$。\n- <span class=\"m-theorem\">(期望的线性性)</span> 设 $X_1,X_2,\\cdots,X_n$ 是随机变量，则 $\\displaystyle{E \\left( c_{0} + \\sum_{i=1}^{n} c_{i} X_{i} \\right) = c_{0} +\\sum_{i=1}^{n} c_{i} E(X_{i})}$。\n- <span class=\"m-theorem\">(独立变量的期望)</span> 设 $X_1,X_2,\\cdots,X_n$ 是相互独立的随机变量，则 $\\displaystyle{E \\left( \\prod_{i=1}^{n} X_{i} \\right) = \\prod_{i=1}^{n} E(X_{i})}$。\n\n## 2. 方差\n\n- <span class=\"m-definition\">(方差与标准差)</span> 设 $X$ 是随机变量，若 $E \\left( \\left( X-E(X) \\right)^{2} \\right)$ 存在，则称其为 $X$ 的 **方差**，记为 $D(X)$ 或 $\\operatorname*{Var}(X)$。又称 $\\sqrt{D(X)}$ 为 **标准差** 或 **均方差**，记为 $\\sigma(X)$。\n  - 对于离散型随机变量 $X$ 且 $D(X)$ 存在，则 $\\displaystyle{D(X) = \\sum_{i=1}^{\\infty} (x_{i} - E(X))^{2} p_{i}}$。\n  - 对于连续型随机变量 $X$ 且 $D(X)$ 存在，则 $\\displaystyle{D(X) = \\int_{-\\infty}^{+\\infty} (x-E(X))^{2} f(x) \\text{d} x}$。\n- <span class=\"m-theorem\"></span> $D(X)=E(X^{2}) - [E(X)]^{2}$；“平方的期望减期望的平方”。\n  - 可以通过这一公式和期望的定义式，通过积分/求和计算随机变量的方差与标准差。\n- <span class=\"m-theorem\">(切比雪夫不等式)</span> 设随机变量 $X$ 具有数学期望 $E(X)=\\mu$，方差 $D(X)=\\sigma^{2}$，则对于任意正数 $\\varepsilon$，不等式 $\\displaystyle{P\\{|X-\\mu|\\geq\\varepsilon\\}\\leq\\frac{\\sigma^2}{\\varepsilon^2}}$ 成立。\n- ![几种常见分布的均值与方差|600](https://img.memset0.cn/2024/11/26/JXJgjXkI.png)\n- <span class=\"m-definition\">(标准化变量)</span> 设随机变量 $X$ 具有数学期望 $E(X)=\\mu$，方差 $D(X)=\\sigma^{2} \\neq 0$，则记 $X^{\\ast} = \\dfrac{X-\\mu}{\\sigma}$ 为 $X$ 的 **标准化变量**。\n\n## 3. 协方差与相关系数\n\n- <span class=\"m-definition\">(协方差)</span> 设 $\\operatorname*{Cov}(X,Y)=E\\{ [E-E(X)] [E-E(Y)] \\}$ 为随机变量 $X$ 与 $Y$ 的 **协方差**。\n  - <span class=\"m-theorem\">(协方差的计算公式)</span> $\\operatorname*{Cov}(X,Y)=E(XY)-E(X)E(Y)$。\n  - <span class=\"m-theorem\">(方差的加法性质)</span> $D(X+Y)=D(X)+D(Y)+2\\operatorname*{Cov}(X,Y)$。\n  - <span class=\"m-proposition\">(协方差的基本性质)</span>\n    - $\\operatorname*{Cov}(X,Y)=\\operatorname*{Cov}(Y,X)$；\n    - $\\operatorname*{Cov}(X,X)=D(X)$；\n    - $\\operatorname*{Cov}(aX,bY)=ab\\cdot\\operatorname*{Cov}(X,Y)$，其中 $a,b\\in \\mathbb{R}$；\n    - $\\operatorname*{Cov}(X_{1}+X_{2},Y)=\\operatorname*{Cov}(X_{1},Y)+\\operatorname*{Cov}(X_{2},Y)$；\n    - 当 $D(X)D(Y) \\neq 0$ 时有 $\\left( \\operatorname*{Cov}(X,Y) \\right)^{2} \\leq D(X)D(Y)$，当 $X$ 与 $Y$ 有严格的线性关系时取等号。\n- <span class=\"m-definition\">(相关系数)</span> 设 $\\displaystyle{\\rho_{XY}=\\dfrac{\\operatorname*{Cov}(X,Y)}{\\sqrt{D(X) \\cdot D(Y)}}}$ 为随机变量 $X$ 与 $Y$ 的 **相关系数**，这是一个无量纲的量，用于表征 $X,Y$ 之间==线性关系的紧密程度==。\n  - <span class=\"m-definition\"></span> 当且仅当 $\\rho_{XY}=0$ 时称随机变量 $X,Y$ **不相关**。（注意：不相关不意味着相互独立！但相互独立的随机变量一定不相关）\n  - <span class=\"m-proposition\">(相关系数的基本性质)</span>\n    - $|\\rho_{XY}| \\leq 1$；\n    - 当且仅当 $P\\{ Y=a+bX \\}=1$ 时上式取等号，且 $b>0$ 时 $\\rho_{XY}=1$；当 $b<0$ 时 $\\rho_{XY}=-1$。\n  - <span class=\"m-theorem\"></span> 用关于 $X$ 的线性函数 $a+bX$ 来近似表示 $Y$，以均方误差 $e(a,b)=E\\left( (Y-(a+bX))^{2} \\right)$ 衡量近似表示的好坏程度，$e(a,b)$ 越小，$X.Y$ 之间的相关系数越大。\n\n> [!example]- 证明：线性近似时均方误差最小时相关系数最大\n>\n> 根据已知，\n>\n> $$\n> e(a,b)=E(Y^2)+b^2E(X^2)+a^2-2bE(XY)+2abE(X)-2aE(Y)\n> $$\n>\n> 分别关于 $a,b$ 求偏导可以得到\n>\n> $$\n> \\begin{cases}\\dfrac{\\partial e}{\\partial a}=2a+2bE(X)-2E(Y)=0\\\\\\dfrac{\\partial e}{\\partial b}=2bE(X^2)-2E(XY)+2aE(X)=0\\end{cases}\n> $$\n>\n> 解得：\n>\n> $$\n> b_0=\\frac{Cov(X,Y)}{D(X)},\\quad a_0=E(Y)-b_0E(X)\n> $$\n>\n> 代入得此时：\n>\n> $$\n> e_{\\min}(a,b)=(1-\\rho_{XY}^2)D(Y)\n> $$\n\n## 4. 其他数字特征\n\n- <span class=\"m-definition\">($k$ 阶(原点)矩)</span> 设 $X$ 是随机变量，若 $E(X^{k})\\, (k=1,2,\\cdots)$ 存在则称它为 $X$ 的 **$k$ 阶(原点)距**。\n- <span class=\"m-definition\">($k$ 阶中心矩)</span> 设 $X$ 是随机变量，若 $E((X-E(X))^{k})\\, (k=1,2,\\cdots)$ 存在则称它为 $X$ 的 **$k$ 阶中心矩**。\n- <span class=\"m-definition\">($k+l$ 阶混合(原点)矩)</span> 设 $X,Y$ 是随机变量，若 $E(X^{k}Y^{l})\\, (k,l=1,2,\\cdots)$ 存在则称它为 $X,Y$ 的 **$k+l$ 阶混合(原点)矩**。\n- <span class=\"m-definition\">($k+l$ 阶混合中心矩)</span> 设 $X,Y$ 是随机变量，若 $E((X-E(X))^{k}(Y-E(Y))^{l})\\, (k,l=1,2,\\cdots)$ 存在则称它为 $X,Y$ 的 **$k+l$ 阶混合中心矩**。\n","publishedTitle":"「概率论与数理统计」IV. 随机变量的数字特征"}},{"id":"d5478423-fa8f-5a4c-a2b0-3a7dfbb08804","fields":{"slug":"/course/ptms/note/5/","plainText":"\n> 本篇笔记介绍了概率论中两个重要的极限定理。首先讨论了大数定律，包括依概率收敛的定义、弱大数定律、辛钦大数定律和伯努利大数定律，以及证明这些定理所需的马尔科夫不等式和切比雪夫不等式。随后介绍了中心极限定理，重点阐述了独立同分布的中心极限定理及其特例棣莫弗-拉普拉斯定理，这些定理揭示了大量独立随机变量之和的概率分布趋近于正态分布的性质。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 大数定律\n\n- <span class=\"m-definition\">(依概率收敛)</span> 对于随机变量序列 $Y_{1},Y_{2},\\cdots$，若存在某常数 $c$ 使得 $\\forall \\varepsilon>0$，均有：$\\displaystyle{\\lim_{ n \\to +\\infty } P\\left\\{ \\left| Y_{n}-c \\right| \\geq \\varepsilon \\right\\}} = 0$，则称 $\\{ Y_{n},n\\geq1 \\}$ **依概率收敛** 于常数 $c$，记为：当 $n\\to+\\infty$ 时，$Y_{n} \\stackrel{P}\\longrightarrow c$。\n  - <span class=\"m-proposition\"></span> 若 $X_n \\stackrel{P}\\longrightarrow a$，$f(x)$ 在点 $a$ 连续，则当 $n\\to+\\infty$ 时，$f(X_{n}) \\stackrel{P}\\longrightarrow f(a)$。\n  - <span class=\"m-proposition\"></span> 若 $X_{n} \\stackrel{P}\\longrightarrow a$，$Y_{n} \\stackrel{P}\\longrightarrow b$，$g$ 在 $(a,b)$ 连续，则 $g(X_{n},Y_{n}) \\stackrel{P}\\longrightarrow g(a,b)$。\n- <span class=\"m-theorem\">(弱)大数定律</span> 设 $\\{ X_{n},n\\geq1 \\}$ 为随机变量序列，若存在常数序列 $\\{ c_{n},n\\geq1 \\}$，使得当 $n\\to+\\infty$ 时，$\\displaystyle{\\dfrac{1}{n} \\sum_{i=1}^{n} X_{i}-c_{n} \\stackrel{P}{\\longrightarrow} 0}$。即 $\\forall \\varepsilon>0$，有 $\\displaystyle{\\lim_{ n \\to \\infty } P\\left\\{ \\left| \\dfrac{1}{n} \\sum_{i=1}^{n} X_{i} - c_{n} \\right| \\right\\} \\geq \\varepsilon = 0}$，则称 $\\{ X_{n},n\\geq1 \\}$ 服从弱大数定律。\n- <span class=\"m-theorem\">(辛钦大数定律)</span> 设随机变量序列 $\\{ X_{n},n\\geq1 \\}$ 独立同分布且具有相同的数学期望 $E(X_{k})=\\mu$，则序列的平均值 $\\displaystyle{\\overline{X} = \\dfrac{1}{n} \\sum_{k=1}^{n} X_{k}}$ 依概率收敛于 $\\mu$，即 $\\overline{X} \\stackrel{P}{\\longrightarrow} \\mu$。\n- <span class=\"m-theorem\">(伯努利大数定律)</span> 设 $n_{A}$ 是 $n$ 次独立重复实试验中事件 $A$ 发生的次数，$p$ 是事件 $A$ 在每次试验中发生的概率，则有：当 $n\\to+\\infty$ 时，$\\dfrac{n_{A}}{n} \\stackrel{P}{\\longrightarrow} p$。\n- <span class=\"m-theorem\">(马尔科夫不等式)</span> ==（不考）==设随机变量 $Y$ 的 $k$ 阶矩存在（$k\\geq1$），则对于任意 $\\varepsilon>0$，都有 $\\displaystyle{P\\{ |Y|\\geq \\varepsilon\\}}\\leq \\dfrac{E(|Y|^{k})}{\\varepsilon^{k}}$ 成立。\n  - 等价形式：$\\displaystyle{P\\left\\{\\left|Y\\right|<\\varepsilon\\right\\}\\geq1-\\frac{E(\\left|Y\\right|^k)}{\\varepsilon^k}}$。\n- <span class=\"m-theorem\">(切比雪夫不等式)</span> 设 $X$ 的方差 $D(X)$ 存在，则对于任意 $\\varepsilon>0$ 都有：$P\\{ |X-E(X)| \\geq \\varepsilon \\} \\leq \\dfrac{D(X)}{\\varepsilon^{2}}$。\n  - 等价形式：$P\\{ |X-E(X)| < \\varepsilon \\} \\geq 1 -\\dfrac{D(X)}{\\varepsilon^{2}}$。\n\n> [!note]- 证明马尔科夫不等式\n>\n> 对于任意 $\\varepsilon>0$，令 $\\displaystyle{Z=\\begin{cases}\\varepsilon, & \\text{当 }| Y|\\geq\\varepsilon\\text{ 时;} \\\\0, & \\text{当 }| Y|<\\varepsilon\\text{ 时}. & \\end{cases}}$ 则 $Z\\leq |Y|$，故 $Z^{k}\\leq|Y|^{k}$，故 $E(Z^{k})\\leq E(|Y|^{k})$。\n>\n> 而根据 $Z$ 的定义，知 $E(Z^{k}) = \\varepsilon^{k} P\\{ |Y|\\geq \\varepsilon \\}$，所以 $P\\{ |Y|\\geq \\varepsilon \\}=\\dfrac{E(Z)^{k}}{\\varepsilon^{k}} \\leq \\dfrac{E(|Y|^{k})}{\\varepsilon^{k}}$。\n\n> [!note] 证明切比雪夫大数定律\n>\n> 设 $\\{ X_{n},n\\geq1 \\}$ 相互独立且具有相同的期望 $\\mu$ 和相同的方差 $\\sigma^{2}$，证明：当 $n\\to+\\infty$ 时，$\\displaystyle{\\dfrac{1}{n} \\sum_{i=1}^{n} X_{i} \\stackrel{P}{\\longrightarrow} \\mu}$。\n>\n> > [!quote]- 证明\n> >\n> > ![|440](https://img.memset0.cn/2024/12/06/fz4wv1br.png)\n\n## 2. 中心极限定理\n\n- <span class=\"m-theorem\">(独立同分布的中心极限定理)</span> 设随机序列 $\\{ X_{n},n\\geq1 \\}$ 独立同分布，$E(X_{i})=\\mu$，$D(X_{i})=\\sigma^{2}$，则对任意实数 $x$，$\\displaystyle{\\lim_{ n \\to \\infty } P\\left\\{ \\dfrac{ \\sum_{i=1}^{n} X_{i}-n\\mu }{\\sqrt{n} \\sigma} \\leq x \\right\\} = \\int_{-\\infty}^{x} \\dfrac{1}{\\sqrt{2\\pi}} e^{-t^{2}/2} \\text{d}  t = \\Phi(x) }$。\n  - 因此当 $n$ 充分大时，$\\displaystyle{\\dfrac{1}{n} \\sum_{i=1}^{n} X_{i} \\sim  N\\left( \\mu,  \\dfrac{\\sigma^{2}}{n}\\right)}$。\n  - <span class=\"m-theorem\">(棣莫弗—拉普拉斯中心极限定理)</span> 当 $n$ 充分大时，$B(n,p) \\sim N(np,np(1-p))$。\n","publishedTitle":"「概率论与数理统计」V. 大数定律及中心极限定理"}},{"id":"62b64e4d-33ae-5579-be50-fcd49e7f3cb0","fields":{"slug":"/course/ptms/note/6/","plainText":"\n> 本篇笔记介绍了数理统计中的样本和抽样分布的基本概念。首先讲解了随机样本和简单随机样本的定义，以及样本的常用统计量（如样本均值、样本方差等）。接着详细阐述了三个重要的抽样分布：$\\chi^{2}$ 分布、$t$ 分布和 $F$ 分布，包括它们的定义、性质和上 $\\alpha$ 分位数。最后讨论了正态总体下的抽样分布定理，为下一章节介绍枢轴量做铺垫。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 样本\n\n- <span class=\"m-definition\">(随机样本)</span> 从总体中随机选取 $n$ 个个体，称为一个 **随机样本**。\n- <span class=\"m-definition\">(简单随机样本)</span> 随机样本 $(X_{1},X_{2},\\cdots,X_{n})$ 称为容量是 $n$ 的 **简单随机样本** 当且仅当满足以下条件：① 每个 $X_{i}$ 与 $X$ 同分布；② $X_{1},X_{2},\\cdots,X_{n}$ 是相互独立的随机变量。\n  - 后面提到的样本均指简单随机样本。\n  - 若总体 $X$ 具有概率密度函数 $f(X)$，则样本 $(X_{1},X_2,\\cdots,X_{n})$ 具有联合密度函数：$\\displaystyle{f(X_{1},X_{2},\\cdots,X_{n}) = \\prod_{i=1}^{n} f(X_{i})}$。\n- 样本的常用统计量：\n  - <span class=\"m-definition\">(样本均值)</span> $\\displaystyle{\\overline{X} = \\dfrac{1}{n} \\sum_{i=1}^{n} X_{i}}$\n  - <span class=\"m-definition\">(样本方差)</span> $\\displaystyle{S^{2} ={\\color{red}\\dfrac{1}{n-1}} \\sum_{i=1}^{n} (X_{i}-\\overline{X})^{2}}$\n  - <span class=\"m-definition\">(样本 $k$ 阶矩)</span> $\\displaystyle{A_{k}= \\dfrac{1}{n}\\sum_{i=1}^{n} X_{i}^{k}}$\n  - <span class=\"m-definition\">(样本 $k$ 阶中心矩)</span> $\\displaystyle{B_{k}=\\dfrac{1}{n} \\sum_{i=1}^{n} \\left( X_{i} - \\overline{X} \\right)^{k}}$\n- 对总体方差的估计可以用 $S^{2}$ 也可以用 $B_2$（区别在于前面的系数是 $\\dfrac{1}{n-1}$ 还是 $\\dfrac{1}{n}$）。主要的区别是 $S^{2}$ 作为总体方差是无偏估计，但 $B_{2}$ 作为总体方差的估计是有偏的。\n\n## 2. 抽样分布\n\n> 三个分布的概率密度函数不要求掌握。\n\n- <span class=\"m-definition\">($\\chi^2$ 分布)</span> 设随机变量 $X_{1},X_{2},\\cdots,X_{n}$ 相互独立，$X_{i} \\sim N(0,1)\\ (i=1,2,\\cdots,n)$ 则称 $\\displaystyle{\\chi_{n}^{2}=\\sum_{i=1}^{n} X_{i}^{2}}$ 服从自由度为 $n$ 的 $\\chi^{2}$ 分布，记为 $\\chi^{2} \\sim \\chi^{2}(n)$。\n  <span class=\"m-proposition\"></span> 设 $\\chi^{2} \\sim \\chi^{2}(n)$，则有 $E(\\chi^{2})=n$，$D(\\chi^{2})=2n$。\n  - <span class=\"m-proposition\">($\\chi^2$ 分布的可加性)</span> 设 $Y_{1} \\sim \\chi^{2}(n_{1}),\\ Y_{2} \\sim \\chi^{2}(n_{2})$，且 $Y_{1},Y_{2}$ 相互独立，则有 $Y_{1}+Y_2 \\sim \\chi^{2}(n_{1}+n_{2})$。可以推广到有限个的情形。\n  - 对给定的概率 $\\alpha\\ (0<\\alpha<1)$，称满足条件 $\\displaystyle{\\int_{\\chi^{2}(n)}^{\\infty} f_{n}(y) \\text{d}  y = \\alpha}$ 的点 $\\chi_{\\alpha}^{2}(n)$ 为 $\\chi^{2}(n)$ 分布的 **上 $\\alpha$ 分位数**。\n- <span class=\"m-definition\">($t$ 分布)</span> 设 $X \\sim N(0,1)$，$Y \\sim \\chi^{2}(n)$，并且假设 $X,Y$ 相互独立，则称随机变量 $T=\\dfrac{X}{\\sqrt{Y/n}}$ 服从 **自由度** 为 $n$ 的 $t$ 分布，记为 $T \\sim t(n)$。\n  - 概率密度函数：$f(t,n)=\\dfrac{\\Gamma\\left( \\frac{n+1}2 \\right)}{\\sqrt{n \\pi} \\Gamma\\left( \\frac n2 \\right) }\\left( 1+ \\dfrac{t^{2}}{n}\\right)^{-(n+1)/2},\\ -\\infty<t<+\\infty$。\n  - 对给定的 $\\alpha\\ (0<\\alpha<1)$，称满足条件 $\\displaystyle{\\int_{t_{\\alpha}(n)}^{+\\infty} f(t,n) \\text{d}  t = \\alpha}$ 的点 $t_{\\alpha}(n)$ 为 $t(n)$ 分布的**上 $\\alpha$ 分位数**。\n  - <span class=\"m-proposition\"></span> $t_{\\alpha}(n) = -t_{1-\\alpha}(n)$。\n- <span class=\"m-definition\">($F$ 分布)</span> 设 $X \\sim \\chi^{2}(n_{1}),\\ Y \\sim \\chi^{2}(n_{2})$，且 $X,Y$ 独立，则称随机变量 $F=\\dfrac{X / n_{1}}{Y / n_{2}}$ 服从自由度 $(n_{1},n_{2})$ 的 $F$ 分布，记为 $F \\sim F(n_{1},n_{2})$，其中 $n_{1}$ 称为 **第一自由度**，$n_{2}$ 称为 **第二自由度**。\n  - 概率密度函数：$f\\left(x;n_1,n_2\\right)=\\begin{cases}\\frac{1}{B\\left(n_1/2,n_2/2\\right)}n_1^{\\frac{n_1}{2}}n_2^{\\frac{n_2}{2}}x^{\\frac{n_1}{2}-1}\\left(n_2+n_1x\\right)^{-\\frac{n_1+n_2}{2}} & x>0  \\\\0 & x\\leq0 & \\end{cases}$，其中 $\\displaystyle{B\\left(a,b\\right)=\\int_0^1x^{a-1}\\left(1-x\\right)^{b-1}dx=\\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)}}$。\n  - 对给定的 $\\alpha\\ (0<\\alpha<1)$，称满足条件 $\\displaystyle{\\int_{F_\\alpha(n_1,n_2)}^\\infty f\\left(x;n_1,n_2\\right)\\text{d}  x=\\alpha}$ 的点 $F_{\\alpha}(n_{1},n_{2})$ 为 $F(n,m)$ 分布的 **上 $\\alpha$ 分位数**。\n  - <span class=\"m-proposition\"></span> $F_{\\alpha} (n_{1},n_{2}) = \\dfrac{1}{F_{1-\\alpha} (n_{2},n_{1})}$。\n\n## 3. 正态总体下的抽象分布\n\n> 这些内容其实都是为了引出下一章枢轴量的概念。除了“$\\overline{X}$ 与 $S^{2}$ 相互独立”这一条，别的不需要额外记忆。\n\n- <span class=\"m-theorem\"></span> 设 $X_{1},X_{2},\\cdots,X_{n}$ 为来自正态总体 $N(\\mu,\\sigma^{2})$ 的简单随机样本，$\\overline{X}$ 是样本均值，$S^{2}$ 是样本方差，则有：\n\n  - $\\displaystyle{\\overline{X} \\sim N\\left( \\mu, \\dfrac{\\sigma^{2}}{n} \\right)}$\n  - $\\dfrac{(n-1)S^{2}}{\\sigma^{2}} \\sim \\chi^{2}(n-1)$\n  - $\\overline{X}$ 与 $S^{2}$ ==相互独立== - 概率密度函数：$f_{n}(y)=\\begin{cases}\\dfrac{1}{2 \\Gamma(n/2)} \\left( \\dfrac{y}{2} \\right)^{n/2-1} e^{-y/2},\\quad&y>0\\\\0,\\quad&y\\leq0\\end{cases}$，其中 $\\displaystyle{\\Gamma(\\alpha) = \\int_{0}^{+\\infty} x^{\\alpha-1} e^{-x} \\text{d} x}$。\n  - <span class=\"m-proposition\"></span> ，别的不需要额外记忆。\n\n- <span class=\"m-theorem\"></span> 设 $X_{1},X_{2},\\cdots,X_{n}$ 为来自正态总体 $N(\\mu,\\sigma^{2})$ 的简单随机样本，$\\overline{X}$ 是样本均值，$S^{2}$ 是样本方差，则有：\n  - $\\displaystyle{\\overline{X} \\sim N\\left( \\mu, \\dfrac{\\sigma^{2}}{n} \\right)}$\n  - $\\dfrac{(n-1)S^{2}}{\\sigma^{2}} \\sim \\chi^{2}(n-1)$\n  - $\\overline{X}$ 与 $S^{2}$ ==相互独立==\n  - $\\dfrac{\\overline{X}-\\mu}{S/\\sqrt{n}} \\sim t(n-1)$\n- <span class=\"m-theorem\"></span> 设 $X_{1},X_{2},\\cdots,X_{n_{1}}$，$Y_{1},Y_{2},\\cdots,Y_{n_{2}}$ 分别是来自正态总体 $N(\\mu_{1},\\sigma_{1}^{2})$ 和 $N(\\mu_{2},\\sigma_{2}^{2})$ 的样本，且这两个样本相互独立，设 $\\displaystyle{\\overline{X}=\\dfrac{1}{n_{1}} \\sum_{i=1}^{n_{1}} X_{i}}$，$\\displaystyle{\\overline{Y}=\\dfrac{1}{n_{2}} \\sum_{i=1}^{n_{2}} Y_{i} }$ 分别是两样本的均值，$S_{1}^{2},S_2^{2}$ 分别是两样本的样本方差，则有\n  - $\\dfrac{S_{1}^{2} / \\sigma_{1}^{2}}{S_{2}^{2} / \\sigma_{2}^{2}} \\sim F(n_{1}-1,n_{2}-1)$\n    - $\\displaystyle{\\frac{\\left(\\overline{X}-\\overline{Y}\\right)-\\left(\\mu_1-\\mu_2\\right)}{\\sqrt{\\dfrac{\\sigma_1^2}{n_1}+\\dfrac{\\sigma_2^2}{n_2}}}\\sim N(0,1)}$\n    - 当 $\\sigma_{1}^{2}=\\sigma_{2}^{2}=\\sigma^{2}$ 时，$\\displaystyle{\\frac{\\left(\\overline{X}-\\overline{Y}\\right)-\\left(\\mu_1-\\mu_2\\right)}{S_w\\sqrt{\\dfrac{1}{n_1}+\\dfrac{1}{n_2}}}\\sim t(n_1+n_2-2)}$，其中 $\\displaystyle{S_w^2=\\frac{\\left(n_1-1\\right)S_1^2+\\left(n_2-1\\right)S_2^2}{n_1+n_2-2}}$。\n","publishedTitle":"「概率论与数理统计」VI. 样本及抽样分布"}},{"id":"0bca9516-52f7-56cf-9e70-9ef89d8194dc","fields":{"slug":"/course/ptms/note/7/","plainText":"\n> 本篇笔记介绍了数理统计中参数估计的基本概念和方法。首先讲解了点估计的两种主要方法：矩估计法和极大似然估计法。接着详细阐述了评价估计量优劣的四个准则：无偏性、有效性、均方误差和相合性。最后介绍了区间估计的概念，重点讨论了置信区间和枢轴量，并通过实例说明了如何利用枢轴量构造置信区间。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 参数估计\n\n- <span class=\"m-definition\">(参数)</span> 反应总体某方面特征的量。\n- <span class=\"m-definition\">(参数估计)</span> 当总体的参数未知时，利用样本资料对其给出估计。\n- <span class=\"m-definition\">(点估计)</span> 设总体 $X$ 有未知参数 $\\theta$，$X_{1},\\cdots,X_{n}$ 是 $X$ 的简单随机样本。构造合适的统计量 $\\hat{\\theta} = \\hat{\\theta}(x_{1},\\cdots,x_{n})$ 用来估计未知参数 $\\theta$，称 $\\hat{\\theta}$ 为参数 $\\theta$ 的 **点估计量**，$\\hat{\\theta}(x_{1},\\cdots,x_{n})$ 为参数 $\\theta$ 的 **点估计值**。\n  - <span class=\"m-definition\">(矩估计法)</span>\n    - 统计思想：以样本矩估计总体矩，以样本矩的函数估计总体矩的函数。\n      - 理论依据：辛钦大数定律和依概率收敛的性质。\n    - 步骤：\n      - ① 求总体前 $k$ 阶矩关于 $k$ 个参数的函数：$\\mu_i=E(X^i)=h_i(\\theta_1,\\cdots,\\theta_k)\\ (i=1,\\cdots,k)$\n      - ② 求各参数关于 $k$ 阶矩的反函数：$\\theta_i=g_i(\\mu_1,\\cdots,\\mu_k)\\ (i=1,\\cdots,k)$\n      - ③ 以样本各阶矩 $A_{1},\\cdots,A_{k}$ 代替总体各阶矩 $\\mu_{1},\\cdots,\\mu_{k}$ 得各参数的矩估计 $\\hat{\\theta}_i=g_i(A_1,\\cdots,A_k)\\ (i=1,\\cdots,k)$\n      - 在实际应用时，为求解方便，也可以用中心矩代替原点矩；采用的矩不同，得出的参数估计自然也不同。\n  - <span class=\"m-definition\">(极大似然估计)</span>\n    - 设离散型总体 $X \\sim p(x;\\theta),\\ \\theta \\in \\Theta$，$\\theta$ 未知，从总体 $X$ 中取得样本 $X_{1},X_{2},\\cdots,X_{n}$，其观察值为 $x_{1},x_{2},\\cdots,x_{n}$，则事件 $\\{ X_{1}=x_{1},\\cdots,X_{n}=x_{n} \\}$ 发生的概率为 $L(\\theta) = P\\{ X_{1}=x_{1},\\cdots,X_{n}=x_{n} \\} = p(x_{1}; \\theta) \\cdots p(x_{n}; \\theta) = \\displaystyle{\\prod_{i=1}^{n} p(x_{i}; \\theta)}$。称 $\\hat{\\theta}(x_{1},\\cdots,x_{n})$ 为 $\\theta$ 的 **极大似然估计值**，相应统计量 $\\hat{\\theta}(X_{1},\\cdots,X_n)$ 为 $\\theta$ 的 **极大似然估计量**。\n    - 极大似然原理：$\\displaystyle{L(\\hat{\\theta} (x_{1},x_{2},\\cdots,x_{n})) = \\max_{\\theta \\in \\Theta} L(\\theta)}$。\n    - 说明：\n      - 未知参数可能不止一个，一般设为 $\\theta=(\\theta_{1},\\theta_{2},\\cdots,\\theta_{n})$。\n      - 在求 $L(\\theta)$ 的最大值时，通常转化为求 $\\ln L(\\theta)$ 的最大值，其中 $\\ln L(\\theta)$ 称为 **对数似然函数**。利用 $\\dfrac{\\partial \\ln L(\\theta)}{\\partial \\theta_{i}}=0$ 解得 $\\hat{\\theta_{i}}$。\n      - 若 $L(\\theta)$ 关于某个 $\\theta_{i}$ 是单调增（减）函数，此时 $\\theta_{i}$ 的极大似然估计在其边界取得。\n      - 若 $\\hat{\\theta}$ 是 $\\theta$ 的极大似然估计，则 $g(\\theta)$ 的极大似然估计为 $g(\\hat{\\theta})$。\n\n## 2. 估计量的评选准则\n\n- <span class=\"m-definition\">(无偏性准则)</span> 若参数 $\\theta$ 的估计量 $\\hat{\\theta} = \\hat{\\theta} (X_{1},X_{2},\\cdots,X_{n})$，满足 $E(\\hat{\\theta})=\\theta$，则称 $\\hat{\\theta}$ 是 $\\theta$ 的一个 **无偏估计量**。\n  - 若 $E(\\hat{\\theta})\\neq \\theta$，那么 $\\left| E(\\hat{\\theta}) - \\theta \\right|$ 称为估计量 $\\hat{\\theta}$ 的 **偏差**。\n  - 若 $\\displaystyle{\\lim_{ n \\to \\infty } E(\\hat{\\theta})  = \\theta}$，则称 $\\hat{\\theta}$ 是 $\\theta$ 的 **渐进无偏估计量**。\n  - **纠偏**：若 $E(\\hat{\\theta}) = a \\theta + b,\\ \\theta \\in \\Theta$，其中 $a,b$ 是常数且 $a\\neq0$，则 $\\dfrac{1}{a} (\\hat{\\theta} - b)$ 是 $\\theta$ 的无偏估计。\n- <span class=\"m-definition\">(有效性准则)</span> 设 $\\hat{\\theta}_{1}, \\hat{\\theta}_{2}$ 是 $\\theta$ 的两个==无偏==估计，如果 $D(\\hat{\\theta}_{1}) \\leq D(\\hat{\\theta}_{2})$，对一切 $\\theta \\in \\Theta$ 成立，且不等号至少对某一 $\\theta \\in \\Theta$ 成立，则称 $\\hat{\\theta}_{1}$ 比 $\\hat{\\theta}_2$ **有效**。\n- <span class=\"m-definition\">(均方误差准则)</span> 设 $\\hat{\\theta}$ 是参数 $\\theta$ 的点估计，方差存在，则称 $E\\left(\\left( \\hat{\\theta} - \\theta \\right)^{2}\\right)$ 是估计量的均方误差，记为 $Mse(\\hat{\\theta})$。若 $\\hat{\\theta}$ 是 $\\theta$ 的无偏估计，则有 $Mse(\\hat{\\theta}) = D(\\hat{\\theta})$。\n- <span class=\"m-definition\">(相合性准则)</span> 设 $\\hat{\\theta}(X_{1},X_{2},\\cdots,X_{n})$ 为参数 $\\theta$ 的估计量，若对于任意 $\\theta \\in \\Theta$，当 $n\\to+\\infty$ 时，$\\hat{\\theta}_{n}$ 依概率收敛于 $\\theta$，即 $\\forall \\varepsilon>0$，有 $\\displaystyle{\\lim_{ n \\to \\infty } P\\left\\{ \\hat{\\theta}_{n} - \\theta \\right\\} \\geq \\varepsilon} = 0$ 成立，则称 $\\hat{\\theta}_{n}$ 为 $\\theta$ 的 **相合估计量** 或 **一致估计量**。\n  - 根据依概率收敛的性质，由 $A_{1},\\cdots,A_{k}$ 是 $\\mu_{1},\\cdots,\\mu_{k}$ 的相合估计，若 $g(\\mu_{1},\\cdots,\\mu_{k})$ 是连续函数，则 $g(A_{1},\\cdots,A_{k})$ 是 $g(\\mu_{1},\\cdots,\\mu_{k})$ 的 **相合估计**。\n\n## 3. 区间估计\n\n> 置信区间是可以通过枢轴量推出的，建议掌握这样可以大大减少期末考试时的记忆量。\n\n- <span class=\"m-definition\">(置信区间)</span> 设总体 $X$ 的分布函数 $F(x;\\theta)$ 含有一个未知参数 $\\theta$，$(X_{1},\\cdots,X_{n})$ 是总体 $X$ 的一个样本，对给定的值 $\\alpha\\ (0<\\alpha<1)$，如果有两个统计量 $\\hat{\\theta}_{L} = \\hat{\\theta}_{L} (X_{1},\\cdots,X_{n})$，$\\hat{\\theta}_{U}= \\hat{\\theta}_{U}(X_{1},\\cdots,X_{n})$，使得：$P\\left\\{ \\hat{\\theta}_{L} (X_{1},\\cdots,X_{n}) < \\theta < \\hat{\\theta}_{U}(X_{1},\\cdots,X_{n}) \\right\\} \\geq 1 - \\alpha\\ (\\forall \\theta \\in \\Theta)$。则称随机区间 $\\left( \\hat{\\theta}_{L}, \\hat{\\theta}_{U} \\right)$ 是 $\\theta$ 的 **双侧置信区间**，称 $1-\\alpha$ 为 **置信度**，$\\hat{\\theta}_{L}$ 为 **双侧置信下限**，$\\hat{\\theta}_{U}$ 为 **双侧置信上限**。\n- <span class=\"m-definition\">(枢轴量)</span> 设总体 $X$ 的概率密度函数 $f(x;\\theta)$，其中 $\\theta$ 为待估参数，并设 $X_{1},X_{2},\\cdots,X_{n}$ 是来自总体 $X$ 的样本，如果样本和参数 $\\theta$ 的函数 $G(X_{1},X_{2},\\cdots,X_{n}; \\theta)$ 的分布完全已知，且形式上不依赖于其他未知参数，则称 $G(X_{1},X_{2},\\cdots,X_{n};\\theta)$ 为 **枢轴量**。\n  - 单个正态总体时的假设检验的枢轴量：\n    - 待估 $\\mu$，$\\sigma^{2}$ 已知：$\\displaystyle{Z=\\frac{\\overline{X}-\\mu_0}{\\sigma/\\sqrt{n}}} \\sim N(0,1)$；\n    - 待估 $\\mu$，$\\sigma^{2}$ 未知：$T=\\dfrac{\\overline{X}-\\mu_0}{S/\\sqrt{n}} \\sim t(n-1)$；\n    - 待估 $\\sigma^{2}$，$\\mu$ 未知：$\\displaystyle{\\chi^2=\\frac{(n-1)S^2}{\\sigma^2}\\sim\\chi^2(n-1)}$；\n  - 两个正态总体时的假设检验的枢轴量：\n    - 待估 $\\mu_{1}-\\mu_{2}$，$\\sigma^{2}_{1}$ 和 $\\sigma^{2}_{2}$ 已知：$Z=\\dfrac{(\\overline{X}-\\overline{Y})-(\\mu_1-\\mu_2)}{\\sqrt{\\dfrac{\\sigma_1^2}{n_1}+\\dfrac{\\sigma_2^2}{n_2}}}\\sim N(0,1)$；\n    - 待估 $\\mu_{1}-\\mu_{2}$，$\\sigma^{2}_{1}=\\sigma^{2}_{2}$ 未知：$t=\\dfrac{(\\overline{X}-\\overline{Y})-(\\mu_{1}-\\mu_{2})}{S_{w}\\sqrt{\\dfrac{1}{n_{1}}+\\dfrac{1}{n_{2}}}}\\sim t(n_{1}+n_{2}-2)$，其中 $S_{w}^{2}=\\dfrac{(n_{1}-1)S_{1}^{2}+(n_{2}-1)S_{2}^{2}}{n_{1}+n_{2}-2}$；\n    - 待估 $\\dfrac{\\sigma^{2}_{1}}{\\sigma^{2}_{2}}$，$\\mu_{1},\\mu_{2}$ 未知：$\\displaystyle{F=\\frac{S_{1}^{2}/S_{2}^{2}}{\\sigma_{1}^{2}/\\sigma_{2}^{2}}\\sim F(n_{1}-1,n_{2}-1)}$；\n  - 其余的仅了解即可，考试不考察。\n\n> [!important] 根据枢轴量推出置信区间和单侧置信限（以待估 $\\mu$，$\\sigma^{2}$ 已知的情况为例）\n>\n> - $\\displaystyle{Z=\\frac{\\overline{X}-\\mu_0}{\\sigma/\\sqrt{n}}} \\sim N(0,1)$，故落在 $\\left( z_{\\alpha / 2}, z_{1-\\alpha / 2} \\right)$ 中的概率恰为 $1-\\alpha$；\n> - $\\displaystyle{z_{\\alpha / 2} < \\dfrac{\\overline{X}-\\mu_0}{\\sigma/\\sqrt{n}} < z_{1-\\alpha/2}}$\n> - $\\displaystyle{\\implies \\dfrac{\\sigma}{\\sqrt{n}} z_{\\alpha / 2} < \\overline{X}-\\mu_0 < \\dfrac{\\sigma}{\\sqrt{n}} z_{1-\\alpha/2}}$\n> - $\\displaystyle{\\implies \\overline{X} + \\dfrac{\\sigma}{\\sqrt{n}} z_{1-\\alpha/2} < \\mu_0 < \\overline{X} + \\dfrac{\\sigma}{\\sqrt{n}} z_{\\alpha / 2}}$\n> - 这样就得到了置信区间为：$\\overline{X} + \\dfrac{\\sigma}{\\sqrt{n}} z_{1-\\alpha/2} < \\mu_0 < \\overline{X} + \\dfrac{\\sigma}{\\sqrt{n}} z_{\\alpha / 2}$\n\n![|802](https://img.memset0.cn/2024/12/29/4KXViWIO.png)\n","publishedTitle":"「概率论与数理统计」VII. 参数估计"}},{"id":"957bc106-d6f3-5c1b-8297-60ba5e66954d","fields":{"slug":"/course/ptms/note/8/","plainText":"\n> 本篇笔记介绍了数理统计中假设检验的基本概念和方法。首先讨论了两类错误（第 I 类错误和第 II 类错误）以及 P- 值的定义和应用。然后详细阐述了单个正态总体的假设检验问题，包括双边检验、左边检验和右边检验的拒绝域和 P- 值计算。最后探讨了区间估计与假设检验的关系，说明了它们之间的相互转换，以及单侧置信限与单边假设检验的对应关系。<small style=\"font-style: italic; opacity: 0.5\">（由 claude-3.5-sonnet 生成摘要）</small>\n\n<!-- more -->\n\n## 1. 假设检验\n\n> 后面假设检验的拒绝域和 $P_{-}$ 值都是可以通过检验统计量本身的性质而得到的。故其实第七章和第八章的内容只要背了枢轴量都可以自己推出来。\n\n- 两类错误\n  - <span class=\"m-definition\">(第 I 类错误)</span> 拒绝真实的原假设（弃真）\n    - $\\alpha=P\\{ \\text{第 I 类错误} \\}=P\\{ \\text{拒绝 }H_{0} \\mid H_{0}\\text{ 为真} \\}$\n    - 一般来说都是题目中给出，即问你是否有 $95\\%$ 的把握拒绝原假设，就是问犯第一类错误的概率是否小于 $0.05\\%$。\n  - <span class=\"m-definition\">(第 II 类错误)</span> 接受错误的原假设（取伪）\n    - $\\beta=P\\{ \\text{第 II 类错误} \\}=P \\{ \\text{接受 }H_{0} \\mid H_{0} \\text{ 为假} \\}$\n    - 此类问题需要给出待估参数的真实值，然后根据枢轴量进行计算，具体可参考作业题。\n- <span class=\"m-definition\">($P_-$ 值)</span> 当原假设成立时，检验统计量取比观察到的结果更为极端的数值的概率。\n  - 当 $P_{-} \\leq \\alpha$ 时，拒绝原假设；当 $P_{-} > \\alpha$ 时，接受原假设。\n  - 双边检验问题中的 $P_{-}$ 值可以如下计算：先算出一边的概率 $p$，则 $P_{-} = 2 \\min \\{ p,1-p \\}$。\n- 假设问题与检验（这里以单个正态总体的 $Z$ 检验为例）\n  - 双边假设问题：$H_0:\\mu=\\mu_0,H_1:\\mu\\neq\\mu_0$,其中 $\\mu_0$ 是已知的常数，由前一节讨论知，可取检验统计量为 $Z=\\dfrac{\\bar{X}-\\mu_0}{\\sigma/\\sqrt{n}}$。\n    - 根据 Neyman-Pearson 原则，拒绝域为 $W=\\left\\{|Z|=\\left|\\dfrac{\\overline{X}-\\mu_0}{\\sigma/\\sqrt{n}}\\right|\\geq z_{\\alpha/2}\\right\\}$。\n    - $P_-=P_{H_0}\\left\\{| Z|\\geq| z_0|\\right\\}=2P_{H_0}\\left\\{Z\\geq| z_0|\\right\\}=2(1-\\Phi(| z_0|))$（其中 $z_0 = \\dfrac{\\overline{x}-\\mu_0}{\\sigma / \\sqrt n}$）。\n  - 左边假设问题：$H_0:\\mu\\geq \\mu_0,H_1: \\mu< \\mu_0$,其中 $\\mu_0$ 是已知的常数检验统计量仍取为 $Z=\\dfrac{\\bar{X}-\\mu_0}{\\sigma/\\sqrt{n}}$。拒绝域形式为 $Z=\\dfrac{\\overline{X}-\\mu_0}{\\sigma/\\sqrt{n}}\\leq C$。\n    - 根据 Neyman-Pearson 原则，拒绝域为 $W=\\left\\{Z=\\dfrac{\\overline{X}-\\mu_0}{\\sigma/\\sqrt{n}}\\leq-z_\\alpha\\right\\}$。\n    - $P\\_ = \\Phi(z_0)$。\n  - 右边假设问题：$H_0:\\mu\\leq\\mu_0,H_1:\\mu>\\mu_0$, 其中 $\\mu_0$ 是已知的常数。检验统计量仍取为 $Z=\\dfrac{\\overline{X}-\\mu_0}{\\sigma/\\sqrt{n}}$。\n    - 根据 Neyman-Pearson 原则，拒绝域为 $W=\\left\\{Z=\\dfrac{\\overline{X}-\\mu_0}{\\sigma/\\sqrt{n}}\\geq z_\\alpha\\right\\}$。\n    - $P\\_ = 1-\\Phi(z_0)$。\n\n## 2. 区间估计\n\n- 两者可以互相转换。例如，$\\mu$ 的置信水平为 $1-\\alpha$ 的置信区间为 $\\displaystyle{\\overline{X}-\\frac\\sigma{\\sqrt{n}}z_{\\alpha/2}<\\mu<\\overline{X}+\\frac\\sigma{\\sqrt{n}}z_{\\alpha/2}}$，则假设检验问题 $H_0:\\mu=\\mu_0$，$H_1:\\mu\\neq\\mu_0$ 的接受域为 $\\displaystyle{\\overline{W}=\\left\\{\\overline{X}-\\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2}<\\mu_0<\\overline{X}+\\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2}\\right\\}}$。\n- 一般地，若假设检验问题 $H_0: \\theta = \\theta _0H_1: \\theta \\neq \\theta _0$ 的显著水平为 $\\alpha$ 的接受域能等价地写成 $\\hat{\\theta}_L<\\theta_0<\\hat{\\theta}_U$，那么($\\hat{\\theta}_L,\\hat{\\theta}_U)$ 是参数 $\\theta$ 的置信水平为 $1-\\alpha$ 的置信区间。\n  - 反之，若 ($\\hat{\\theta}_L,\\hat{\\theta}_U$) 是 $\\theta$ 的置信水平为 $1-\\alpha$ 的置信区间，则当 $\\theta_0\\in(\\begin{array}{c}\\hat{\\theta}_L,&\\hat{\\theta}_U\\end{array})$ 时，接受双边检验 $H_0: \\theta = \\theta _0$, $H_1: \\theta \\neq \\theta _0$ 中的原假设 $H_0$, 且检验的拒绝域为 $\\theta _0\\leq \\hat{\\theta } _L$ 或$\\theta_0\\geq\\hat{\\theta}_U$。\n- 单侧置信限与单边假设检验的关系：\n  - 若 $\\hat{\\theta}_L$ 是 $\\theta$ 的置信水平为 $1-\\alpha$ 的单侧置信下限，则当 $\\theta_0\\geq\\hat{\\theta}_L$ 时，接受右边检验 $H_0: \\theta \\leq \\theta _0$, $H_1: \\theta > \\theta _0$ 中的原假设 $H_0$, 反之，拒绝原假设。\n  - 若 $\\hat{\\theta}_U$ 是 $\\theta$ 的置信水平为 $1-\\alpha$ 的单侧置信上限，则当 $\\theta_0\\leq\\hat{\\theta}_U$ 时，接受左边检验 $H_0: \\theta \\geq \\theta _0$, $H_1: \\theta < \\theta _0$ 中的原假设 $H_0$, 反之，拒绝原假设。\n\n![](https://img.memset0.cn/2025/01/13/Q2KcljXM.png)\n\n![](https://img.memset0.cn/2025/01/13/9pFWgfcU.png)\n","publishedTitle":"「概率论与数理统计」VIII. 假设检验"}},{"id":"71062cd2-2a20-59c6-af61-c2f89b9fe017","fields":{"slug":"/oi/solution/opencup/2020/gomel-h/","plainText":"\n> 给出 $n$ 个区间 $[l_i, r_i]$ ，你需要放下**至多** $n$ 个点，使得每个区间里至少包含一个点。并且区间里点个数的最大值要尽可能小。\n> \n> $1 \\le n \\le 10^5, 10^9 \\le l_i < r_i \\le 10^9$ 。\n\n<!-- more -->\n\n## 题解\n\n先按照如下方法贪心：维护一个集合表示当前没有放点的区间，每次选出一个右端点最小的区间，在这个右端点放下一个区间。\n\n若此时的最大值为 $t$ ，则答案要么为 $t$ 要么为 $t-1$ 。\n\n证明：考虑一个被放了 $t$ 个点的区间，只有可能把第一个点的移到区间外，其余的点必定在区间内移动。\n\n怎么判断答案是否为 $t-1$ 呢，定义一个点 $x$ 是合法的当且仅当只考虑 $x$ 和所有被放在 $x$ 右侧的点所有右端点 $r_i\\geq x$ 的区间都能至多放 $t-1$ 个。\n\n从右往左扫描线，定义 $next_x$ 为在 $x$ 右侧，能找到的最远合法点，且区间 $(x, next_x)$ 内不严格包含任意一个区间。令 $y=next^{t-1}_x$ ，如果不存在一个区间同时包含 $x, y$ ，那么 $x$ 就是合法的。\n\n求出所有合法点后，若 $min_{i=1}^n (l_i)$ 是合法的，答案为 $t-1$ ，否则答案为 $t$ 。\n\n![](https://static.memset0.cn/img/v6/2024/02/11/vZ3u4ZK7.png)\n\n（附图：考虑我们是要让每个形如 $x_1$ 的贡献都丢到外面去，但是 $x'_1$ 能取的范围只能在 $[x'_l; x'_r]$ ，否则就不能完整覆盖内部线段）\n\n## 坑\n\n一开始调了半天就是离散化的问题。\n\n实际上区间间留白的部分是有影响的（考虑是否完全包含的时候），把这部分也丢进去离散化就过了，哭哭。\n\n不过别的部分能一遍写对还是挺开心的。\n\n## zimpha 的题解\n\n考虑每个区间至少放一个点的贪心做法。维护一个集合表示当前没有放点的区间，每次选出一个右端点最小的区间，在这个右端点放下一个区间。\n\n如果在上述方案下，最大值为 $t$ ，那么可以证明最优值要么是 $t$ ，要么是 $t-1$ 。\n\n考虑上述方案下，包含点数最多的那个区间 $[l, r]$ 。假设这 $t$ 个点从左往右依次为 $x_1, x_2, \\dots, x_t$ 。那么在最优方案下，这个区间里的点个数肯定要 $\\le t$ 。考虑 $l$ 左边的第一个点为 $x^\\prime_1$ ，那么接下来那个点 $x^\\prime_2$ 一定要不超过 $x_2$ 。因为我们需要用 $x^\\prime_2$ 来覆盖被 $x_1$ 覆盖的区间，如果超过 $x_2$ ，肯定会有区间没有被覆盖。类似的， $x^\\prime_3$ 一定不能超过 $x_3$ 。依次类推， $x^\\prime_t$ 一定不能超过 $x_t$ 。也就是少区间 $[l, r]$ 里至少要有 $t-1$ 个点。\n\n那么接下来只需要判定 $t-1$ 是否可行即可。我们从左往右考虑数轴上每个点 $x$ ，定义 $x$ 是合法的当且仅当如果我们的方案包含了点 $x$ 后，仅考虑加入其它 $\\ge x$ 的点，所有右端点 $r_i \\ge x$ 的区间里面最多只有 $t-1$ 个点。令 $next(x)$ 是 $x$ 右边最远的合法的点，使得没有区间 $[l_i, r_i]$ 严格在区间 $[x, next_x]$ 里。考虑 $y=next^{t-1}(x)$ ，如果存在一个 $[l_i, r_i]$ 同时包含了端点 $x$ 和 $y$ ，那么 $x$ 显然是不合法的，否则 $x$ 是合法的。\n\n最后如果所有点 $\\min(l_i)-1$ 是合法的，那么就存在一个 $t-1$ 的解。\n\n复杂度 $O(n \\log n)$ 。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 6e5 + 9, M = 21;\nint T, n, t, tn, ta[N], maxl[N], maxr[N], mrk[N], nxt[N][M];\nvector<int> pos, ans;\nstruct node {\n  int l, r;\n} a[N];\nstruct segment {\n  int l, r, mid, s;\n} p[N << 2];\ninline bool inside(int l, int r) { return l <= r && maxl[r] >= l; }\ninline bool outside(int l, int r) { return l > r || maxr[l] >= r; }\nvoid build(int u, int l, int r) {\n  p[u].l = l, p[u].r = r, p[u].mid = (l + r) >> 1, p[u].s = 0;\n  if (l == r) return;\n  build(u << 1, l, p[u].mid);\n  build(u << 1 | 1, p[u].mid + 1, r);\n}\nvoid modify(int u, int k, int x) {\n  if (p[u].l == p[u].r) {\n    p[u].s += x;\n    return;\n  }\n  modify(k <= p[u].mid ? u << 1 : u << 1 | 1, k, x);\n  p[u].s = p[u << 1].s + p[u << 1 | 1].s;\n}\nint query(int u, int l, int r) {\n  if (p[u].l == l && p[u].r == r) return p[u].s;\n  if (r <= p[u].mid) return query(u << 1, l, r);\n  if (l > p[u].mid) return query(u << 1 | 1, l, r);\n  return query(u << 1, l, p[u].mid) + query(u << 1 | 1, p[u].mid + 1, r);\n}\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  for (cin >> T; T--;) {\n    t = tn = 0, ans.clear(), pos.clear();\n    cin >> n;\n    ta[++tn] = 1e9 + 10, ta[++tn] = -1e9 - 10;\n    for (int i = 1; i <= n; i++) {\n      cin >> a[i].l, ta[++tn] = a[i].l;\n      cin >> a[i].r, ta[++tn] = a[i].r;\n      ta[++tn] = a[i].l - 1, ta[++tn] = a[i].l + 1;\n      ta[++tn] = a[i].r - 1, ta[++tn] = a[i].r + 1;\n    }\n    sort(ta + 1, ta + tn + 1);\n    tn = unique(ta + 1, ta + tn + 1) - ta - 1;\n    for (int i = 1; i <= n; i++) {\n      a[i].l = lower_bound(ta + 1, ta + tn + 1, a[i].l) - ta;\n      a[i].r = lower_bound(ta + 1, ta + tn + 1, a[i].r) - ta;\n    }\n    memset(maxl + 1, 0, tn << 2);\n    memset(maxr + 1, 0, tn << 2);\n    for (int i = 1; i <= n; i++) {\n      maxl[a[i].r] = max(maxl[a[i].r], a[i].l);\n      maxr[a[i].l] = max(maxr[a[i].l], a[i].r);\n    }\n    for (int i = 1; i <= tn; i++) {\n      maxl[i] = max(maxl[i - 1], maxl[i]);\n      maxr[i] = max(maxr[i - 1], maxr[i]);\n    }\n    sort(a + 1, a + n + 1, [](const node &a, const node &b) { return a.r == b.r ? a.l < b.l : a.r < b.r; });\n    build(1, 1, tn);\n    for (int i = 1; i <= n; i++)\n      if (!query(1, a[i].l, a[i].r)) {\n        modify(1, a[i].r, 1);\n        ans.push_back(a[i].r);\n      }\n    for (int i = 1; i <= n; i++) {\n      t = max(t, query(1, a[i].l, a[i].r));\n    }\n    if (t > 1) {\n      memset(mrk + 1, 0, tn);\n      pos.push_back(tn), mrk[tn] = 1;\n      for (int i = 0; i < M; i++) nxt[tn][i] = tn;\n      for (int i = tn - 1, j, l, r, mid, s, k; i >= 1; i--) {\n        l = 0, r = pos.size() - 1, nxt[i][0] = -1;\n        while (l <= r) {\n          mid = (l + r) >> 1;\n          if (!inside(i + 1, pos[mid] - 1)) {\n            nxt[i][0] = pos[mid];\n            r = mid - 1;\n          } else {\n            l = mid + 1;\n          }\n        }\n        if (!~nxt[i][0]) continue;\n        for (j = nxt[i][0], k = M - 1, s = t - 2; k >= 0; k--) {\n          if ((s >> k) & 1) j = nxt[j][k];\n        }\n        if (outside(i, j)) continue;\n        pos.push_back(i), mrk[i] = 1;\n        for (int j = 1; j < M; j++) {\n          nxt[i][j] = nxt[nxt[i][j - 1]][j - 1];\n        }\n      }\n      int minl = tn;\n      for (int i = 1; i <= n; i++) minl = min(minl, a[i].l);\n      if (mrk[minl - 1]) {\n        --t, ans.clear();\n        int u = minl - 1;\n        while (u != tn) ans.push_back(u), u = nxt[u][0];\n        if (ans.front() == 1) ans.erase(ans.begin());\n      }\n    }\n    cout << t << ' ' << ans.size() << ' ';\n    for (int i = 0; i < ans.size(); i++) {\n      cout << ta[ans[i]] << \" \\n\"[i + 1 == ans.size()];\n    }\n  }\n}\n```","publishedTitle":"「XX Open Cup. GP of Gomel」Hit"}},{"id":"b02cf9cf-5019-5e9f-96f2-3ae8cb3d1668","fields":{"slug":"/oi/solution/opencup/2020/korea-d/","plainText":"\n> 给定两个长度 $n$ 的序列 $s,t$，序列每一位是 $1$ 或 $2$。每次你可以选择一个长度 $\\leq 3$ 的区间进行左右翻转，代价为区间数值和加上给定常数 $c$。问将 $s$ 变换成 $t$ 的最小代价。\n> \n> $n \\leq 500$。\n\n<!-- more -->\n\n## 题解\n\n非常巧妙的一个题。\n\n我们转化为格路问题，$1$ 表示向右走，$2$ 表示向上走。则 $s$ 和 $t$ 对应的两条路线，被他们的交点分割为若干段。\n\n相当于我们需要用 $1 \\times 1, 1 \\times 2, 2 \\times 1$ 三种长方形填充到两条路线包围住的区间里。不妨先设初始解为全用 $1 \\times 1$ 的网格填充，黑白染色后相当于在得到的二分图跑最小费用最大流。\n\n注意到放一个 $2 \\times 1$ 的长方形对应的边权是 $2+c$，$1 \\times 2$ 的长方形对应的边权是 $1+c$。一开始我们可以贪心的填 $2 \\times 1$ 的长方形，这样剩下未被覆盖的格子只有 $O(n)$ 个。在这个残量网络上跑增广，容易证明至多增广 $O(n)$ 次。\n\n求方案可能还需要跑个拓扑排序。\n\n时间复杂度 $O(n^3 \\log n)$，然而听说有牛逼的 $O(n^2)$ DP 做法。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define endl '\\n'\nusing namespace std;\nconst int N = 509, M = 1 << 21;\nint n, c, s, t, l, r, ans, cnt, nod, ind[N * N], q[M], pre[M], dis[M], minA[N], minB[N], id[N][N], num[N][N];\nint tot = 2, hed[M], nxt[M], to[M], val[M], cst[M];\nbool mrk[N][N], inq[M];\nstring a, b;\nvector<int> G[N * N];\nvector<pair<int, int>> seq(1), loc(1);\ninline void add(int u, int v, int w) {\n  nxt[tot] = hed[u], to[tot] = v, val[tot] = 1, cst[tot] = w, hed[u] = tot++;\n  nxt[tot] = hed[v], to[tot] = u, val[tot] = 0, cst[tot] = -w, hed[v] = tot++;\n}\nvoid way(string &a, int *min) {\n  int x = 1, y = 1;\n  for (int i = 1; i <= n; i++)\n    if (a[i] == '1') {\n      min[x] = y;\n      for (int i = y; i < N; i++) mrk[x][i] ^= 1;\n      ++x;\n    } else {\n      ++y;\n    }\n}\nbool spfa() {\n  memset(pre + 1, 0, nod << 2);\n  memset(dis + 1, -63, nod << 2);\n  dis[s] = pre[s] = 0;\n  q[l = r = 1] = s, inq[s] = true;\n  while (l <= r) {\n    int u = q[(l++) % M];\n    inq[u] = false;\n    for (int i = hed[u]; i; i = nxt[i])\n      if (val[i] && dis[to[i]] < dis[u] + cst[i]) {\n        pre[to[i]] = i;\n        dis[to[i]] = dis[u] + cst[i];\n        if (!inq[to[i]]) q[(++r) % M] = to[i], inq[to[i]] = 1;\n      }\n  }\n  return pre[t] && dis[t] > 0;\n}\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n >> c >> a >> b;\n  a.insert(a.begin(), '\\0');\n  b.insert(b.begin(), '\\0');\n  way(a, minA);\n  way(b, minB);\n  for (int i = 0; i < N; i++)\n    for (int j = 0; j < N; j++)\n      if (mrk[i][j]) {\n        id[i][j] = ++nod;\n        loc.push_back({i, j});\n        ans += 3 + c;\n      }\n  s = ++nod, t = ++nod;\n  for (int i = 0; i < N; i++)\n    for (int j = 0; j < N; j++)\n      if (mrk[i][j]) {\n        if ((i + j) & 1) {\n          add(s, id[i][j], 0);\n          for (int d = -1; d <= 1; d += 2) {\n            if (mrk[i + d][j]) add(id[i][j], id[i + d][j], 2 + c);\n            if (mrk[i][j + d]) add(id[i][j], id[i][j + d], 1 + c);\n          }\n        } else {\n          add(id[i][j], t, 0);\n        }\n      }\n  for (int i = 0; i < N; i++)\n    for (int j = 0; j < N; j++)\n      if (mrk[i][j] && mrk[i + 1][j]) {\n        auto connect = [&](int i, int j) {\n          int u = id[i][j];\n          for (int i = hed[u]; i; i = nxt[i]) {\n            if (to[i] == s) return val[i];\n            if (to[i] == t) return val[i ^ 1];\n          }\n          assert(0);\n        };\n        auto play = [&](int u, int v, int k) {\n          for (int i = hed[u]; i; i = nxt[i])\n            if (to[i] == v) {\n              ans -= k * cst[i];\n              val[i] -= k, val[i ^ 1] += k;\n            }\n        };\n        if (!connect(i, j) && !connect(i + 1, j)) {\n          int u = id[i][j], v = id[i + 1][j];\n          if (!((i + j) & 1)) swap(u, v);\n          play(u, s, -1);\n          play(u, v, 1);\n          play(v, t, 1);\n        }\n      }\n  while (spfa()) {\n    int sum = 0;\n    for (int i = pre[t]; i; i = pre[to[i ^ 1]]) {\n      sum += cst[i];\n      val[i]--, val[i ^ 1]++;\n    }\n    ans -= sum;\n  }\n  for (int i = 0; i < N; i++)\n    for (int j = 0; j < N; j++)\n      if (mrk[i][j] && ((i + j) & 1)) {\n        int ii = 0, jj = 0;\n        for (int k = hed[id[i][j]]; k; k = nxt[k])\n          if (to[k] != s && val[k ^ 1]) {\n            ii = loc[to[k]].first;\n            jj = loc[to[k]].second;\n          }\n        if (ii && jj) {\n          int k = min(i + j, ii + jj) - 1;\n          num[i][j] = num[ii][jj] = ++cnt;\n          seq.push_back({k, k + 2});\n        }\n      }\n  for (int i = 0; i < N; i++)\n    for (int j = 0; j < N; j++)\n      if (mrk[i][j] && !num[i][j]) {\n        int k = i + j - 1;\n        num[i][j] = ++cnt;\n        seq.push_back({k, k + 1});\n      }\n  for (int i = 0; i < N; i++)\n    for (int j = 0; j < N; j++)\n      if (mrk[i][j]) {\n        if (minA[i] < minB[i]) {\n          if (mrk[i + 1][j] && num[i][j] != num[i + 1][j]) {\n            G[num[i + 1][j]].push_back(num[i][j]);\n            ++ind[num[i][j]];\n          }\n          if (mrk[i][j - 1] && num[i][j] != num[i][j - 1]) {\n            G[num[i][j - 1]].push_back(num[i][j]);\n            ++ind[num[i][j]];\n          }\n        } else {\n          if (mrk[i - 1][j] && num[i][j] != num[i - 1][j]) {\n            G[num[i - 1][j]].push_back(num[i][j]);\n            ++ind[num[i][j]];\n          }\n          if (mrk[i][j + 1] && num[i][j] != num[i][j + 1]) {\n            G[num[i][j + 1]].push_back(num[i][j]);\n            ++ind[num[i][j]];\n          }\n        }\n      }\n  cout << cnt << endl;\n  l = 1, r = 0;\n  for (int i = 1; i <= cnt; i++)\n    if (!ind[i]) q[++r] = i;\n  while (l <= r) {\n    int u = q[l++];\n    cout << seq[u].first << ' ' << seq[u].second << endl;\n    for (int v : G[u]) {\n      if (!--ind[v]) q[++r] = v;\n    }\n  }\n}\n```","publishedTitle":"「XX Open Cup. GP of Korea」Container"}},{"id":"9fe3ce8e-63e1-5680-b933-ac03e17b4848","fields":{"slug":"/oi/solution/icpc/2020/macau/k/","plainText":"\n> 主办方将在一个二维平面中投放广告。共有 $n$ 个广告可被投放，其中每个广告的都是左上角为 $(x_i,y_i)$ 的 $w\\times h$ 矩形且出现时间为 $[l_i,r_i]$。同一时间内，任意两个被投放的广告不能有重叠面积。此外还有 $m$ 条限制 $(u_i,v_i)$ 表示在广告 $u_i$ 和广告 $v_i$ 中至少选择投放一条。判断是否存在一组合法的投放方案，如果存在的话给出方案。\n>\n> $1\\le n\\le 5\\times 10^4$，$1\\le m\\le 10^5$，$1\\le w,h,x_i,y_i,l_i,r_i \\le 2000$。\n\n<!-- more -->\n\n（本文将介绍一个理论复杂度更优的做法，可惜由于常数问题未能在 QOJ 上通过全部测试集。）\n\n## 题解\n\n考虑用基于 Tarjan 做法的 2-SAT 的解决问题：给定的 $m$ 条限制可以方便的用有向边 $\\lnot u_i\\rightarrow v_i$ 和 $\\lnot v_i \\rightarrow u_i$ 表示。\n\n关于 $n$ 条广告不能重叠的约束，将 $n$ 条广告按照时间右端点 $r_i$ 排序后，做时间的扫描线。某条广告 $i$ 和时间上与他有重叠的广告集合是一段连续的区间。对原序列以 $S$ 为块大小分块，将连续区间基于分块进行处理，\n\n- 零散块部分：直接比较每条广告是否与第 $i$ 条广告在空间（那个二维平面）上有重合。这一部分贡献的时间复杂度共为 $O(n S)$。\n- 整块部分：将 $i$ 这一信息离线到每一整块中，作为一次带关于广告 $i$ 的“询问”。\n\n之后枚举每个块，上面有若干条离线上来的询问。考虑计算矩形 $[x_i,x_i+w-1] \\times [y_i,y_i+h-1]$ 与 $[x_j,x_j+w-1]\\times [y_j,y_j+h-1]$ 是否有交，等价于查询 $(x_i,y_i)$ 是否在矩形 $[x_j-w+2,x_j+w-2]\\times [y_j-h+2,y_j+h-2]$ 内。将块中的所有**询问**插入到 K-D Tree 中，用块中的 $S$ 个**广告**作为查询，考虑基于 K-D Tree 的结构优化建图。\n\n利用插入的节点是 $(x_1,y_1),(x_2,y_2) \\ldots (x_n,y_n)$ 的子集这一性质，通过预先 $O(n\\log n)$ 建树，这样每个块的建树过程只需要在原结构上“开关”若干点即可，可以将复杂度降到单次 $O(n)$ 的，而查询贡献的复杂度为 $O(S\\sqrt{n})$。这一部分总时间复杂度为 $O\\left(\\dfrac{n^2}S + n\\sqrt{n}\\right)$。\n\n取 $S=\\sqrt{n}$，就可以得到时空复杂度均为 $O(n\\sqrt{n})$ 的做法。\n\n## 评价\n\n我们的做法的虽然时空复杂度为 $O(n\\sqrt{n})$，渐进意义上优于官方题解给出的 $O\\left(\\dfrac{n^2}{\\omega}\\right)$ 做法。但由于 K-D Tree、2-SAT 的常数较大，尽管博主进行了很多尝试，均未能在同时满足题目的是时、空约束的条件下通过本题。欢迎正在阅读这篇文章的你提出改进建议。\n\n## 代码\n\n这份代码在本机上可过，但在 QOJ 上会 [TLE on #27](https://qoj.ac/submission/356348)。如果调整块大小则可能 MLE。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define cho(u, x) ((u) << 1 | (x))\n\nconst int N = 5e4 + 9, M = 5e6, S = 370;\nint n, m, w, h, bln[N], tot, tmp[N], now[N];\nbool ans[N], use[N];\nvector<vector<int>> G;\n\nvoid myassert(int x) {\n  if (!x) {\n    cout << \"assertion failed\" << endl;\n    exit(-1);\n  }\n}\n\nint tim, col_tot;\nvector<int> dfn, low, col;\nvector<char> ins;\nint top, stk[M];\nvoid tarjan(int u) {\n  dfn[u] = low[u] = ++tim;\n  ins[u] = true, stk[++top] = u;\n  for (int v : G[u])\n    if (!dfn[v]) {\n      tarjan(v);\n      low[u] = min(low[u], low[v]);\n    } else if (ins[v]) {\n      low[u] = min(low[u], dfn[v]);\n    }\n  if (dfn[u] == low[u]) {\n    ++col_tot;\n    do {\n      col[stk[top]] = col_tot;\n      ins[stk[top]] = false;\n    } while (stk[top--] != u);\n  }\n}\n\nstruct point {\n  int x, y;\n};\n\nstruct atom {\n  int l, r, id;\n  point u;\n  inline bool operator<(const atom &rhs) const { return r == rhs.r ? l < rhs.l : r < rhs.r; }\n} a[N];\n\nint newnode() {\n  ++tot;\n  if (G.size() <= static_cast<size_t>(tot * 2 + 10)) {\n    G.resize(G.size() + N);\n  }\n  return tot;\n}\n\nvoid addedge(int u, int v) {\n  // fprintf(stderr, \">>> add edge %d[%d] %d[%d] \\n\", u >> 1, u & 1, v >> 1, v & 1);\n  G[u].emplace_back(v);\n}\n\nvoid check(int i, int j) {\n  if (a[i].u.x < a[j].u.x) {\n    if (a[i].u.x + w <= a[j].u.x) return;\n  } else {\n    if (a[j].u.x + w <= a[i].u.x) return;\n  }\n  if (a[i].u.y < a[j].u.y) {\n    if (a[i].u.y + h <= a[j].u.y) return;\n  } else {\n    if (a[j].u.y + h <= a[i].u.y) return;\n  }\n  addedge(cho(i, 1), cho(j, 0));\n  addedge(cho(j, 1), cho(i, 0));\n}\n\nint d, rt;\nstruct node {\n  int x[2], l[2], r[2], ch[2], src, nod;\n  bool operator<(const node &rhs) const { return x[d] < rhs.x[d]; }\n} kdt[N];\n\ninline void maintain(int u) {\n  kdt[u].l[0] = kdt[u].x[0];\n  if (kdt[u].ch[0] && kdt[kdt[u].ch[0]].l[0] < kdt[u].l[0]) kdt[u].l[0] = kdt[kdt[u].ch[0]].l[0];\n  if (kdt[u].ch[1] && kdt[kdt[u].ch[1]].l[0] < kdt[u].l[0]) kdt[u].l[0] = kdt[kdt[u].ch[1]].l[0];\n  kdt[u].l[1] = kdt[u].x[1];\n  if (kdt[u].ch[0] && kdt[kdt[u].ch[0]].l[1] < kdt[u].l[1]) kdt[u].l[1] = kdt[kdt[u].ch[0]].l[1];\n  if (kdt[u].ch[1] && kdt[kdt[u].ch[1]].l[1] < kdt[u].l[1]) kdt[u].l[1] = kdt[kdt[u].ch[1]].l[1];\n  kdt[u].r[0] = kdt[u].x[0];\n  if (kdt[u].ch[0] && kdt[kdt[u].ch[0]].r[0] > kdt[u].r[0]) kdt[u].r[0] = kdt[kdt[u].ch[0]].r[0];\n  if (kdt[u].ch[1] && kdt[kdt[u].ch[1]].r[0] > kdt[u].r[0]) kdt[u].r[0] = kdt[kdt[u].ch[1]].r[0];\n  kdt[u].r[1] = kdt[u].x[1];\n  if (kdt[u].ch[0] && kdt[kdt[u].ch[0]].r[1] > kdt[u].r[1]) kdt[u].r[1] = kdt[kdt[u].ch[0]].r[1];\n  if (kdt[u].ch[1] && kdt[kdt[u].ch[1]].r[1] > kdt[u].r[1]) kdt[u].r[1] = kdt[kdt[u].ch[1]].r[1];\n}\n\nint build(int l, int r, int k) {\n  if (l > r) return 0;\n  int mid = (l + r) >> 1;\n  d = k;\n  nth_element(kdt + l, kdt + mid, kdt + r + 1);\n  kdt[mid].ch[0] = build(l, mid - 1, k ^ 1);\n  kdt[mid].ch[1] = build(mid + 1, r, k ^ 1);\n  maintain(mid);\n  // fprintf(stderr, \"build tree u=%d lc=%d rc=%d\\n\", mid, kdt[mid].ch[0], kdt[mid].ch[1]);\n  return mid;\n}\n\nvoid query(int u, const node &cur) {\n  if (cur.l[0] <= kdt[u].l[0] && cur.l[1] <= kdt[u].l[1] && kdt[u].r[0] <= cur.r[0] && kdt[u].r[1] <= cur.r[1]) {\n    if (kdt[u].nod) {\n      addedge(cho(cur.src, 1), cho(kdt[u].nod, 0));\n      addedge(cho(kdt[u].nod, 1), cho(cur.src, 0));\n    }\n    return;\n  }\n  if (cur.l[0] > kdt[u].r[0] || cur.l[1] > kdt[u].r[1] || cur.r[0] < kdt[u].l[0] || cur.r[1] < kdt[u].l[1]) {\n    return;\n  }\n  if (use[kdt[u].src] && cur.l[0] <= kdt[u].x[0] && cur.l[1] <= kdt[u].x[1] && kdt[u].x[0] <= cur.r[0] && kdt[u].x[1] <= cur.r[1]) {\n    addedge(cho(cur.src, 1), cho(kdt[u].src, 0));\n    addedge(cho(kdt[u].src, 1), cho(cur.src, 0));\n  }\n  query(kdt[u].ch[0], cur);\n  query(kdt[u].ch[1], cur);\n}\n\nvoid assign(int u) {\n  if (kdt[u].ch[0]) assign(kdt[u].ch[0]);\n  if (kdt[u].ch[1]) assign(kdt[u].ch[1]);\n  int lc = kdt[u].ch[0], rc = kdt[u].ch[1];\n  if (kdt[lc].nod && kdt[rc].nod) {\n    kdt[u].nod = newnode();\n    addedge(cho(kdt[u].nod, 0), cho(kdt[lc].nod, 0));\n    addedge(cho(kdt[lc].nod, 1), cho(kdt[u].nod, 1));\n    addedge(cho(kdt[u].nod, 0), cho(kdt[rc].nod, 0));\n    addedge(cho(kdt[rc].nod, 1), cho(kdt[u].nod, 1));\n    if (use[kdt[u].src]) {\n      addedge(cho(kdt[u].nod, 0), cho(kdt[u].src, 0));\n      addedge(cho(kdt[u].src, 1), cho(kdt[u].nod, 1));\n    }\n  } else if (kdt[lc].nod) {\n    if (use[kdt[u].src]) {\n      kdt[u].nod = newnode();\n      G[cho(kdt[u].nod, 0)] = {cho(kdt[lc].nod, 0), cho(kdt[u].src, 0)};\n      addedge(cho(kdt[lc].nod, 1), cho(kdt[u].nod, 1));\n      addedge(cho(kdt[u].src, 1), cho(kdt[u].nod, 1));\n    } else {\n      kdt[u].nod = kdt[lc].nod;\n    }\n  } else if (kdt[rc].nod) {\n    if (use[kdt[u].src]) {\n      kdt[u].nod = newnode();\n      G[cho(kdt[u].nod, 0)] = {cho(kdt[rc].nod, 0), cho(kdt[u].src, 0)};\n      addedge(cho(kdt[rc].nod, 1), cho(kdt[u].nod, 1));\n      addedge(cho(kdt[u].src, 1), cho(kdt[u].nod, 1));\n    } else {\n      kdt[u].nod = kdt[rc].nod;\n    }\n  } else {\n    if (use[kdt[u].src]) {\n      kdt[u].nod = kdt[u].src;\n    } else {\n      kdt[u].nod = 0;\n    }\n  }\n  // fprintf(stderr, \"assign %d use=%d src=%d nod=%d\\n\", u, use[kdt[u].src], kdt[u].src, kdt[u].nod);\n}\n\nstruct block {\n  int l, r;\n  vector<int> q;\n  void solve() {\n    // fprintf(stderr, \"solve block %d %d\\n\", l, r);\n    for (int i = 1; i <= n; i++) use[i] = false;\n    for (int x : q) use[x] = true;\n    assign(rt);\n    node cur;\n    for (int i = l; i <= r; i++) {\n      cur.l[0] = a[i].u.x - (w - 1), cur.r[0] = a[i].u.x + (w - 1);\n      cur.l[1] = a[i].u.y - (h - 1), cur.r[1] = a[i].u.y + (h - 1);\n      cur.src = i, cur.nod = -1;\n      query(rt, cur);\n    }\n  }\n} b[N / S + 9];\n\nint main() {\n#ifdef memset0\n  // freopen(\"K.in\", \"r\", stdin);\n  // freopen(\"K-big.txt\", \"r\", stdin);\n  freopen(\"K-data.txt\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  // vector<pair<int, int>> lim;\n  cin >> n >> w >> h;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i].l >> a[i].r >> a[i].u.x >> a[i].u.y;\n    a[i].id = i;\n  }\n  sort(a + 1, a + n + 1);\n  // for (int i = 1; i <= n; i++) fprintf(stderr, \"a[%d] => l=%d r=%d x=%d y=%d id=%d\\n\", i, a[i].l, a[i].r, a[i].u.x, a[i].u.y, a[i].id);\n  for (int i = 1; i <= n; i++) {\n    now[a[i].id] = i;\n  }\n  cin >> m;\n  tot = n;\n  G.resize(tot * 2 + N);\n  for (int u, v, i = 1; i <= m; i++) {\n    cin >> u >> v;\n    // lim.emplace_back(u, v);\n    u = now[u];\n    v = now[v];\n    addedge(cho(u, 0), cho(v, 1));\n    addedge(cho(v, 0), cho(u, 1));\n  }\n\n  for (int i = 1; i <= n; i++) {\n    kdt[i].src = i;\n    kdt[i].x[0] = a[i].u.x;\n    kdt[i].x[1] = a[i].u.y;\n  }\n  rt = build(1, n, 0);\n\n  for (int i = 1; i <= n; i++) {\n    bln[i] = i / S + 1;\n    if (!b[bln[i]].l) b[bln[i]].l = i;\n    b[bln[i]].r = i;\n    // cout << bln[i] << \" \\n\"[i == n];\n  }\n  for (int i = 1; i <= n; i++) tmp[i] = a[i].r;\n  for (int ql, qr, i = 1; i <= n; i++) {\n    ql = lower_bound(tmp + 1, tmp + i, a[i].l) - tmp;\n    qr = i - 1;\n    if (ql <= qr) {\n      // fprintf(stderr, \"solve [ql=%d[%d] qr=%d[%d]] i=%d\\n\", ql, bln[ql], qr, bln[qr], i);\n      if (bln[ql] == bln[qr]) {\n        for (int j = ql; j <= qr; j++) check(j, i);\n      } else {\n        for (int j = ql; j <= b[bln[ql]].r; j++) check(j, i);\n        for (int j = b[bln[qr]].l; j <= qr; j++) check(j, i);\n        for (int k = bln[ql] + 1; k < bln[qr]; k++) {\n          b[k].q.emplace_back(i);\n        }\n      }\n    }\n  }\n  cerr << \"clock = \" << clock() / (double)CLOCKS_PER_SEC << endl;\n  for (int i = 1; i <= bln[n]; i++) {\n    b[i].solve();\n  }\n#ifdef memset0\n  int edg = 0;\n  for (int i = cho(1, 0); i <= cho(tot, 1); i++) edg += G[i].size();\n  cerr << \"tot = \" << tot << \"; edg = \" << edg << endl;\n#endif\n\n  dfn.resize((tot + 1) << 1);\n  low.resize((tot + 1) << 1);\n  col.resize((tot + 1) << 1);\n  ins.resize((tot + 1) << 1);\n  cerr << \"clock = \" << clock() / (double)CLOCKS_PER_SEC << endl;\n  for (int i = cho(1, 0); i <= cho(tot, 1); i++)\n    if (!dfn[i]) {\n      tarjan(i);\n    }\n  cerr << \"clock = \" << clock() / (double)CLOCKS_PER_SEC << endl;\n  for (int i = 1; i <= tot; i++)\n    if (col[cho(i, 0)] == col[cho(i, 1)]) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n  cout << \"Yes\" << endl;\n  for (int i = 1; i <= n; i++) {\n    ans[a[i].id] = col[cho(i, 0)] > col[cho(i, 1)];\n  }\n  // for (int i = 1; i <= n; i++) cerr << col[cho(i, 0)] << \" \\n\"[i == n];\n  // for (int i = 1; i <= n; i++) cerr << col[cho(i, 1)] << \" \\n\"[i == n];\n#ifdef ONLINE_JUDGE\n  for (int i = 1; i <= n; i++) cout << ans[i];\n  cout << endl;\n#endif\n#ifdef memset0\n  cerr << \"clock = \" << clock() / (double)CLOCKS_PER_SEC << endl;\n#endif\n}\n```\n","publishedTitle":"「Macau 20 K」Candy Ads"}},{"id":"c6bd5787-1f01-5463-a2b5-86a512ec27b8","fields":{"slug":"/oi/solution/icpc/2018/worldfinal/g/","plainText":"\n> 给定一个 $n$ 个点的简单多边形（不保证是凸的），你需要确定一个半径 $r$，然后在每个端点画一个半径为 $r$ 的圆，要求能覆盖简单多边形的全部面积。\n> \n> ![center](https://static.memset0.cn/img/v6/2024/02/11/9Mz2vSQn.png)\n> \n> 你需要确定这个 $r$ 最小是多少，精度要求 $10^{-6}$。\n> \n> $3 \\leq n \\leq 2000,\\ -10^4 \\leq x_i,y_i \\leq 10^4$。\n\n<!-- more -->\n\n## 题解\n\n考虑求出端点的 Voronoi 图，答案一定是由 Voronoi 图的端点，或者是 Voronoi 图和多边形的交点贡献的。由于这题数据范围较小，我们可以跑暴力半平面交。\n\n## Hack\n\n正常做法中，我们知道 Voronoi 图实际上是把二维平面按照距离最近的关键点划分为若干部分，所以贡献答案的计算是容易的。\n\n然而我们点开一看博主的代码：[LibreOJ Submission #959701](https://loj.ac/submission/959701)，发现他好像并不清楚 Voronoi 图的性质，而是大力猜想 Voronoi 图和原多边形的交点个数是 $O(n)$ 级别的，然后暴力跑贡献答案。看起来好像非常对，而且实际上跑的还很快。\n\n但这个猜想嘛并不正确，怎么卡呢？我们考虑对交点个数计数：将我们把简单多边形的边提出来染色，若边上的一个区间和端点 $i$ 距离最近，就染成染色 $i$。那么总交点个数即等于每条边的颜色段数和。Hack 程序见后。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e3 + 9;\nconst double inf = 2e4, eps = 0;\nnamespace geometry {\nconst double mathPI = acos(-1);\ntemplate <class T> inline T abs(const T &x) { return x < 0 ? -x : x; }\nstruct point {\n  double x, y;\n  inline bool operator<(const point &rhs) const { return (abs(x - rhs.x) <= eps) ? (y - rhs.y < -eps) : (x - rhs.x < -eps); }\n  inline bool operator==(const point &rhs) const { return abs(x - rhs.x) <= eps && abs(y - rhs.y) <= eps; }\n};\nstruct line {\n  point a, b;\n  inline bool operator<(const line &rhs) const { return a == rhs.a ? b < rhs.b : a < rhs.a; }\n};\ninline double squaredDistance(const point &a, const point &b) { return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y); }\ninline double distance(const point &a, const point &b) { return sqrt(squaredDistance(a, b)); }\ninline double cross(const point &u, const point &a, const point &b) { return (a.x - u.x) * (b.y - u.y) - (b.x - u.x) * (a.y - u.y); }\ninline point intersect(const line &a, const line &b) {\n  double u = ((a.a.y - b.a.y) * (b.a.x - b.b.x) - (a.a.x - b.a.x) * (b.a.y - b.b.y)) / ((a.a.x - a.b.x) * (b.a.y - b.b.y) - (a.a.y - a.b.y) * (b.a.x - b.b.x));\n  return {u * (a.a.x - a.b.x) + a.a.x, u * (a.a.y - a.b.y) + a.a.y};\n}\ninline bool checkSegmentCrossed(const line &a, const line &b) { return ((cross(a.a, a.b, b.a) < eps) ^ (cross(a.a, a.b, b.b) < eps)) && ((cross(b.a, b.b, a.a) < eps) ^ (cross(b.a, b.b, a.b) < eps)); }\ninline bool insideConvex(const point &x, const vector<point> &a) {\n  bool target = cross(a[0], a[1], x) < eps;\n  for (int i = 1; i < a.size(); i++)\n    if (target != (cross(a[i], a[(i + 1) % a.size()], x) < eps)) return false;\n  return true;\n}\ninline bool insidePolygon(const point &x, const vector<point> &a) {\n  vector<double> deg(a.size());\n  for (int i = 0; i < a.size(); i++) {\n    deg[i] = atan2(a[i].y - x.y, a[i].x - x.x);\n  }\n  double sum = 0;\n  for (int i = 0; i < a.size(); i++) {\n    double cur = deg[i] - deg[(i + 1) % a.size()];\n    if (cur >= mathPI) cur -= mathPI;\n    if (cur <= -mathPI) cur += mathPI;\n    sum += cur;\n  }\n  return abs(sum) > .5 * mathPI;\n}\ndeque<point> halfPlane(const vector<line> &source) {\n  vector<pair<line, double>> plane(source.size());\n  for (int i = 0; i < plane.size(); i++) {\n    plane[i] = {source[i], atan2(source[i].b.y - source[i].a.y, source[i].b.x - source[i].a.x)};\n  }\n  sort(plane.begin(), plane.end(), [&](const pair<line, double> &a, const pair<line, double> &b) { return abs(a.second - b.second) > eps ? a.second < b.second : cross(a.first.a, b.first.a, b.first.b) > eps; });\n  deque<point> q;\n  deque<line> ql;\n  for (int i = 0; i < plane.size(); i++) {\n    if (i && abs(plane[i].second - plane[i - 1].second) <= eps) continue;\n    line cur = plane[i].first;\n    while (q.size() && cross(cur.a, cur.b, q.back()) < -eps) q.pop_back(), ql.pop_back();\n    while (q.size() && cross(cur.a, cur.b, q.front()) < -eps) q.pop_front(), ql.pop_front();\n    if (ql.size()) q.push_back(intersect(ql.back(), cur));\n    ql.push_back(cur);\n  }\n  while (q.size() > 1 && cross(ql.front().a, ql.front().b, q.back()) < -eps) q.pop_back(), ql.pop_back();\n  return q;\n}\n} // namespace geometry\nusing namespace geometry;\nint n, satisifyCounter;\nvector<point> a;\ndouble ans;\nset<point> voronoiNode;\nset<line> voronoiEdge;\nvoid satisifyNode(const point &x) {\n  if (isnan(x.x) || isnan(x.y)) return;\n  double cur = numeric_limits<double>::infinity();\n  for (int i = 0; i < n; i++) {\n    cur = min(cur, squaredDistance(x, a[i]));\n  }\n  ++satisifyCounter;\n  ans = max(ans, cur);\n}\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n;\n  a.resize(n);\n  for (int i = 0; i < n; i++) cin >> a[i].x >> a[i].y;\n  for (int i = 0; i < n; i++) satisifyNode({(a[i].x + a[(i + 1) % n].x) / 2, (a[i].y + a[(i + 1) % n].y) / 2});\n  for (int i = 0; i < n; i++) {\n    vector<line> plane = {\n        {{inf, inf}, {-inf, inf}},\n        {{inf, -inf}, {inf, inf}},\n        {{-inf, inf}, {-inf, -inf}},\n        {{-inf, -inf}, {inf, -inf}},\n    };\n    for (int j = 0; j < n; j++)\n      if (i != j) {\n        point mid{(a[i].x + a[j].x) / 2, (a[i].y + a[j].y) / 2};\n        point delta{a[i].x - mid.x, a[i].y - mid.y};\n        plane.push_back({{mid.x - delta.y, mid.y + delta.x}, {mid.x + delta.y, mid.y - delta.x}});\n      }\n    auto convex = halfPlane(plane);\n    for (int i = 0; i < convex.size(); i++) {\n      voronoiNode.insert(convex[i]);\n      line e = {convex[i], convex[(i + 1) % convex.size()]};\n      if (e.a.x < e.b.x) swap(e.a, e.b);\n      voronoiEdge.insert(e);\n    }\n  }\n  for (const point &x : voronoiNode) {\n    if (insidePolygon(x, a)) {\n      satisifyNode(x);\n    }\n  }\n  for (const line &e : voronoiEdge) {\n    for (int i = 0; i < a.size(); i++) {\n      line target{a[i], a[(i + 1) % a.size()]};\n      if (checkSegmentCrossed(e, target)) {\n        satisifyNode(intersect(e, target));\n      }\n    }\n  }\n  cout << fixed << setprecision(12) << sqrt(ans) << endl;\n}\n```\n\n## Hack 程序\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  const int lx = -10000, rx = -9000, ly = -10000, ry = 10000, m = 250;\n  vector<pair<int, int>> node;\n  for (int i = 1; i <= m; i++) {\n    node.push_back({rx, i * 2 - 1});\n    node.push_back({lx, i * 2 - 1});\n    node.push_back({lx, i * 2});\n    node.push_back({rx, i * 2});\n  }\n  for (int i = 1; i <= m; i++) {\n    node.push_back({rx + i * 2 - 1, ry});\n    node.push_back({rx + i * 2 - 1, ly});\n    if (i != m) {\n      node.push_back({rx + i * 2, ly});\n      node.push_back({rx + i * 2, ry});\n    } else {\n      node.push_back({rx + m * 2, ly - 1});\n      node.push_back({rx, ly - 1});\n    }\n  }\n  cout << node.size() << endl;\n  for (auto x : node) cout << x.first << \" \" << x.second << endl;\n  cout << endl;\n}\n```","publishedTitle":"「ICPC World Finals 2018」熊猫保护区"}},{"id":"7e21f105-e993-59a8-a5be-fa53e6556407","fields":{"slug":"/oi/solution/icpc/2021/macau/j/","plainText":"\n> 维护一棵点有颜色的树，一开始只有编号为 $1$ 的节点，其颜色为 $C$，要求支持以下操作 $q$ 次：\n>\n> 1. 给定 $x,c,d$，添加一个编号为 $n+1$ 颜色为 $c$ 的节点，向点 $x$ 连一条长度为 $d$ 的边\n> 2. 给定 $x,c$，将点 $x$ 的颜色变成 $c$。\n>\n> 每次操作后，你都需要在树上选两个颜色不同的点并最大化它们之间最短简单路径的长度，并输出。\n>\n> $1\\le q\\le 5 \\times 10^5$。\n\n<!-- more -->\n\n## 题解\n\n这题并不要求强制在线，添加节点并不会改变树的形状和边的长度，所以我们可以先离线所有操作，将两种操作都转化为对颜色的修改。\n\n如果只要求求一次答案，我们可以考虑点分治，从每一个分治中心出发，搜索得到的信息是一个三元组 $(d,x,y)$，其中 $d$ 是分治中心到目标点的路径长度、$x$ 是目标点的颜色，$y$ 是目标点在 $d$ 的哪个子树里。这样问题就转化为，需要选择两个三元组 $(d_1,x_1,y_1)$ 和 $(d_2,x_2,y_2)$，最大化 $d_1+d_2$ 且满足 $x_1\\neq x_2 \\land y_1 \\neq y_2$。这个问题比较经典，可以考虑类似 2023 年 CCPC Online F 的思路维护。\n\n现在需要在每次修改操作后得到答案，可以把点分治换成点分树，每次修改颜色只需要重做 $O(\\log n)$ 个分治中心的结果。注意到前面提到的问题我们只需要支持单点修改全局查询，且满足线段树信息的性质，可以考虑对于每个分治中心开一个线段树解决。\n\n## 代码\n\n```cpp\n#include <bits/stdc++.h>\n#define endl '\\n'\nusing namespace std;\nconst int N = 5e5 + 9, M = 1 << 21;\nint T, Q, C, n, root, all, fa[N], c[N], siz[N], mxp[N], par[N];\nbool vis[N];\nvector<int> que, op[N];\nvector<pair<int, int>> G[N];\nvector<pair<int, long long>> ins[N];\nstruct operation {\n  int op, x, c, d;\n} q[N];\nvoid findroot(int u) {\n  siz[u] = 1, mxp[u] = 0;\n  for (auto [v, w] : G[u])\n    if (v != fa[u] && !vis[v]) {\n      fa[v] = u;\n      findroot(v);\n      siz[u] += siz[v];\n      if (siz[v] > mxp[u]) mxp[u] = siz[v];\n    }\n  mxp[u] = max(mxp[u], all - siz[u]);\n  if (root == 0 || mxp[u] < mxp[root]) root = u;\n}\nstruct atom {\n  long long w;\n  int x, y;\n  inline bool operator<(const atom &rhs) const { return w > rhs.w; }\n};\nvector<pair<int, atom>> dat;\nstruct atom_list {\n  atom a[4];\n  short len = 0;\n} p[M];\nlong long calc(atom_list &u) {\n  long long ans = 0;\n  for (int i = 0; i < u.len; i++)\n    for (int j = i + 1; j < u.len; j++)\n      if (u.a[i].x != u.a[j].x && u.a[i].y != u.a[j].y && u.a[i].w >= 0 && u.a[j].w >= 0) {\n        if (u.a[i].w + u.a[j].w > ans) ans = u.a[i].w + u.a[j].w;\n      }\n  return ans;\n}\nvoid maintain(atom_list &u, const atom_list &l, const atom_list &r) {\n  int x1 = 0, x2 = 0, y1 = 0, y2 = 0, lstx = 0, lsty = 0;\n  u.len = 0;\n#define doi(_it)                             \\\n  atom it = _it;                             \\\n  if (!x1 && !y1) {                          \\\n    x1 = it.x, y1 = it.y, u.a[u.len++] = it; \\\n  } else {                                   \\\n    if (it.x != x1) {                        \\\n      if (!x2) x2 = it.y;                    \\\n      else if (x2 != it.y)                   \\\n        x2 = -1;                             \\\n    }                                        \\\n    if (it.y != y1) {                        \\\n      if (!y2) y2 = it.x;                    \\\n      else if (y2 != it.x)                   \\\n        y2 = -1;                             \\\n    }                                        \\\n    if (x2 != lstx || y2 != lsty) {          \\\n      u.a[u.len++] = it;                     \\\n    }                                        \\\n    lstx = x2, lsty = y2;                    \\\n    if (x2 == -1 && y2 == -1) break;         \\\n  }\n  int i = 0, j = 0;\n  while (i < l.len && j < r.len) {\n    if (l.a[i].w > r.a[j].w) {\n      doi(l.a[i]);\n      i++;\n    } else {\n      doi(r.a[j]);\n      j++;\n    }\n  }\n  if (x2 != -1 || y2 != -1) {\n    while (i < l.len) {\n      doi(l.a[i]);\n      i++;\n    }\n  }\n  if (x2 != -1 || y2 != -1) {\n    while (j < r.len) {\n      doi(r.a[j]);\n      j++;\n    }\n  }\n}\nvoid build(int u, int l, int r) {\n  p[u].len = 0;\n  if (l == r) {\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(u << 1, l, mid);\n  build(u << 1 | 1, mid + 1, r);\n}\nvoid modify(int u, int k, const atom &x, int l, int r) {\n  if (l == r) {\n    p[u].a[0] = x;\n    p[u].len = 1;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  if (k <= mid) {\n    modify(u << 1, k, x, l, mid);\n  } else {\n    modify(u << 1 | 1, k, x, mid + 1, r);\n  }\n  maintain(p[u], p[u << 1], p[u << 1 | 1]);\n}\nstruct status {\n  int len;\n  long long ans;\n  vector<int> ord;\n  vector<atom> dat;\n} f;\nvoid dfs(int u, int cur) {\n  siz[u] = 1;\n  for (auto [v, w] : G[u])\n    if (v != fa[u] && !vis[v]) {\n      fa[v] = u;\n      dfs(v, cur);\n      siz[u] += siz[v];\n    }\n}\nvoid collect(int u, long long len, int sub, int cur) {\n  dat.push_back({u, {len, -1, sub}});\n  siz[u] = 1;\n  for (auto [v, w] : G[u])\n    if (v != fa[u] && !vis[v]) {\n      fa[v] = u;\n      collect(v, len + w, sub, cur);\n      siz[u] += siz[v];\n    }\n}\nvoid build(int u, int src = 0) {\n  par[u] = src;\n  vis[u] = 1;\n  que.push_back(u);\n  for (auto [v, w] : G[u])\n    if (!vis[v]) {\n      fa[v] = u;\n      dfs(v, u);\n    }\n  for (auto [v, w] : G[u])\n    if (!vis[v]) {\n      all = siz[v], root = 0, findroot(v), build(root, u);\n    }\n}\nvoid solve(int u) {\n  vis[u] = 1;\n  vector<pair<int, atom>>{}.swap(dat);\n  dat.push_back({u, {0, -1, u}});\n  for (auto [v, w] : G[u])\n    if (!vis[v]) {\n      fa[v] = u;\n      collect(v, w, v, u);\n    }\n  sort(dat.begin(), dat.end());\n  f.ord.resize(dat.size());\n  f.dat.resize(dat.size());\n  f.len = dat.size();\n  for (int i = 0; i < dat.size(); i++) {\n    f.ord[i] = dat[i].first;\n    f.dat[i] = dat[i].second;\n  }\n  build(1, 1, f.len);\n  for (int i : op[u]) {\n    int k = lower_bound(f.ord.begin(), f.ord.end(), q[i].x) - f.ord.begin() + 1;\n    f.dat[k - 1].x = q[i].c;\n    modify(1, k, f.dat[k - 1], 1, f.len);\n    ins[i].emplace_back(u, calc(p[1]));\n  }\n  op[u].clear();\n  op[u].shrink_to_fit();\n}\nnamespace pool {\nstruct segment {\n  long long ans;\n} p[M];\nvoid build(int u, int l, int r) {\n  p[u].ans = 0;\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  build(u << 1, l, mid);\n  build(u << 1 | 1, mid + 1, r);\n}\nvoid modify(int u, int k, long long s, int l, int r) {\n  if (l == r) {\n    p[u].ans = s;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  if (k <= mid) {\n    modify(u << 1, k, s, l, mid);\n  } else {\n    modify(u << 1 | 1, k, s, mid + 1, r);\n  }\n  p[u].ans = max(p[u << 1].ans, p[u << 1 | 1].ans);\n}\n} // namespace pool\nint main() {\n#ifdef memset0\n  freopen(\"1.in\", \"r\", stdin);\n#endif\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> T;\n  while (T--) {\n    cin >> Q >> C;\n    n = 1;\n    G[1].clear();\n    for (int i = 1; i <= Q; i++) {\n      cin >> q[i].op >> q[i].x >> q[i].c;\n      if (q[i].op == 0) {\n        cin >> q[i].d;\n        c[++n] = -1;\n        G[n] = {{q[i].x, q[i].d}};\n        G[q[i].x].emplace_back(n, q[i].d);\n        q[i].x = n;\n      }\n    }\n    fill_n(vis + 1, n, false);\n    fa[1] = 0, root = 0, all = n, findroot(1), build(root);\n    q[0].op = 1, q[0].c = C, q[0].x = 1;\n    for (int i = 0; i <= Q; i++) {\n      for (int u = q[i].x; u; u = par[u]) op[u].push_back(i);\n    }\n    fill_n(vis + 1, n, false);\n    for (int u : que) solve(u);\n    que.clear();\n    pool::build(1, 1, n);\n    for (int i = 0; i <= Q; i++) {\n      for (const auto &[k, t] : ins[i]) pool::modify(1, k, t, 1, n);\n      ins[i].clear();\n      ins[i].shrink_to_fit();\n      if (i) cout << pool::p[1].ans << endl;\n    }\n  }\n  return 0;\n}\n```\n","publishedTitle":"「Macau 21 J」Colorful Tree"}}]}}}